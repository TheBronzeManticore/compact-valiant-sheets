/**
 * Log a console message with the "Black Flag" prefix and styling.
 * @param {string} message - Message to display.
 * @param {object} [options={}]
 * @param {string} [options.color="#1874B3"] - Color to use for the log.
 * @param {any[]} [options.extras=[]] - Extra options passed to the logging method.
 * @param {string} [options.level="log"] - Console logging method to call.
 */
function log(message, {color="#1874B3", extras=[], level="log"}={}) {
	console[level](
		`%cBlack Flag | %c${message}`, `color: ${color}; font-variant: small-caps`, `color: ${color}`, ...extras
	);
}

let DragDrop$1 = class DragDrop {
	/**
	 * Data about the ongoing drag event.
	 * @type {{event: DragEvent, data: *, document: Document}|null}
	 */
	static #currentDrag;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tracking rect for the current drag area.
	 * @
	 */
	static #rect;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set the drag data for the current drag operation.
	 * @param {DragEvent} event - Current drag event.
	 * @param {Document|object} data - Data to add to the drag event, or a document that will get `toDragData` called.
	 */
	static beginDragEvent(event, data) {
		let doc;
		if (foundry.utils.getType(data?.toDragData) === "function") {
			doc = data;
			data = doc.toDragData();
		}
		this.#currentDrag = { event, data, document: doc };
		event.dataTransfer.setData("text/plain", JSON.stringify(data));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin tracking a drop area.
	 * @param {DragEvent} event - Event that triggered the enter.
	 * @param {HTMLElement} area - Drop area to be tracked.
	 */
	static enterDragArea(event, area) {
		this.#currentDrag ??= {};
		this.#currentDrag.area = area;
		this.#rect = area.getBoundingClientRect();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Trigger an event if the drag area has been departed. Clear the drag after after calling the callback unless it
	 * returns `false`.
	 * @param {DragEvent} event - Event that triggered the exit.
	 * @param {Function} callback - Method to call if the mouse is outside the area.
	 * @returns {boolean} - Indicate whether the area has been departed.
	 */
	static exitDragArea(event, callback) {
		if (!this.#rect || !this.#currentDrag?.area) return false;
		const departed =
			event.clientY <= this.#rect.top ||
			event.clientY >= this.#rect.bottom ||
			event.clientX <= this.#rect.left ||
			event.clientX >= this.#rect.right;
		if (!departed || callback(this.#currentDrag.area) === false) return false;
		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mark a drag event as complete and clear the stored data.
	 * @param {DragEvent} event - Event that triggered the completion.
	 */
	static finishDragEvent(event) {
		this.#currentDrag = null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {object} DragEventData
	 * @property {any} data - Drag event payload.
	 * @property {Document} [document] - Dragged document if available.
	 */

	/**
	 * Retrieve the drag data for the provided drag operation.
	 * @param {DragEvent} event - Drag event for which to fetch data.
	 * @returns {DragEventPayload}
	 */
	static getDragData(event) {
		const data = TextEditor.getDragEventData(event);
		if (!foundry.utils.isEmpty(data)) return { area: this.#currentDrag?.area, data };
		if (this.#currentDrag?.data)
			return {
				area: this.#currentDrag.area,
				data: this.#currentDrag.data,
				document: this.#currentDrag.document
			};
		return {};
	}
};

const { HandlebarsApplicationMixin } = foundry.applications.api;

/**
 * @typedef {ApplicationContainerParts}
 * @property {object} [container]
 * @property {string} [container.id]         ID of the container. Containers with the same ID will be grouped together.
 * @property {string[]} [container.classes]  Classes to add to the container.
 */

/**
 * Mixin method for ApplicationV2-based applications.
 * @template {ApplicationV2} T
 * @param {typeof T} Base - Application class to extend.
 * @returns {BaseApplication}
 * @mixin
 */
function ApplicationV2Mixin(Base) {
	class BaseApplication extends HandlebarsApplicationMixin(Base) {
		/** @override */
		static DEFAULT_OPTIONS = {
			classes: ["black-flag"],
			dragDropHandlers: {
				dragstart: null,
				dragend: BaseApplication.#onDragEnd,
				dragenter: null,
				dragleave: null,
				dragover: null,
				drop: BaseApplication.#onDragEnd
			},
			dragSelectors: []
		};

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * @type {Record<string, HandlebarsTemplatePart & ApplicationContainerParts>}
		 */
		static PARTS = {};

		/* <><><><> <><><><> <><><><> <><><><> */
		/*           Initialization            */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		_initializeApplicationOptions(options) {
			const applicationOptions = super._initializeApplicationOptions(options);
			// Fix focus bug caused by the use of UUIDs in application IDs
			// TODO: Remove once https://github.com/foundryvtt/foundryvtt/issues/11742 is fixed
			applicationOptions.uniqueId = applicationOptions.uniqueId.replace(/\./g, "-");
			return applicationOptions;
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*              Rendering              */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		async _prepareContext(options) {
			const context = await super._prepareContext(options);
			context.CONFIG = CONFIG.BlackFlag;
			return context;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		async _preparePartContext(partId, context, options) {
			return { ...(await super._preparePartContext(partId, context, options)) };
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Disable form fields that aren't marked with the `interface-only` class.
		 */
		_disableFields() {
			const selector = `.window-content :is(${[
				"INPUT",
				"SELECT",
				"TEXTAREA",
				"BUTTON",
				"BLACKFLAG-MULTISELECT",
				"COLOR-PICKER",
				"DOCUMENT-TAGS",
				"FILE-PICKER",
				"HUE-SLIDER",
				"MULTI-SELECT",
				"PROSE-MIRROR",
				"RANGE-PICKER",
				"STRING-TAGS"
			].join(", ")}):not(.interface-only)`;
			for (const element of this.element.querySelectorAll(selector)) {
				if (element.tagName === "TEXTAREA") element.readOnly = true;
				else element.disabled = true;
			}
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*         Life-Cycle Handlers         */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		_onFirstRender(context, options) {
			super._onFirstRender(context, options);
			const containers = {};
			for (const [part, config] of Object.entries(this.constructor.PARTS)) {
				if (!config.container?.id) continue;
				const element = this.element.querySelector(`[data-application-part="${part}"]`);
				if (!element) continue;
				if (!containers[config.container.id]) {
					const div = document.createElement("div");
					div.dataset.containerId = config.container.id;
					div.classList.add(...(config.container.classes ?? []));
					containers[config.container.id] = div;
					element.replaceWith(div);
				}
				containers[config.container.id].append(element);
			}
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		_onRender(context, options) {
			super._onRender(context, options);

			// Attach draggable
			if (this.options.dragSelectors.length) {
				const drag = this.#onDragEvent.bind(this);
				for (const selector of this.options.dragSelectors) {
					for (const element of this.element.querySelectorAll(selector)) {
						element.setAttribute("draggable", true);
						element.addEventListener("dragstart", drag);
						element.addEventListener("dragend", drag);
					}
				}
			}

			// Allow multi-select tags to be removed when the whole tag is clicked.
			this.element.querySelectorAll("multi-select").forEach(select => {
				if (select.disabled) return;
				select.querySelectorAll(".tag").forEach(tag => {
					tag.classList.add("remove");
					tag.querySelector(":scope > span")?.classList.add("remove");
				});
			});

			// Add special styling for label-top hints.
			this.element.querySelectorAll(":is(.label-top, .label-hinted) > p.hint").forEach(hint => {
				const label = hint.parentElement.querySelector(":scope > label");
				if (!label) return;
				label.classList.add("hinted-label");
				label.dataset.tooltip = hint.innerHTML;
			});
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*            Event Handlers           */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		_attachFrameListeners() {
			super._attachFrameListeners();

			const drag = this.#onDragEvent.bind(this);
			this.element.addEventListener("dragenter", drag);
			this.element.addEventListener("dragleave", drag);
			this.element.addEventListener("dragover", drag);
			this.element.addEventListener("drop", drag);
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*             Drag & Drop             */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Handle a drag event.
		 * @param {Event} event - The originating drag event.
		 */
		#onDragEvent(event) {
			const handler = this.options.dragDropHandlers[event.type];
			if (!handler) return;
			handler.call(this, event, DragDrop$1);
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Finish the drag event.
		 * @this {PseudoDocumentSheet}
		 * @param {Event} event - Triggering event.
		 * @param {DragDrop} dragDrop - The drag event manager.
		 */
		static #onDragEnd(event, dragDrop) {
			dragDrop.finishDragEvent(event);
		}
	}
	return BaseApplication;
}

const { DocumentSheetV2 } = foundry.applications.api;

/**
 * Base application from which all document-based Black Flag applications should be based.
 */
class BFDocumentSheet extends ApplicationV2Mixin(DocumentSheetV2) {}

/**
 * Dialog for choosing ability assignment mode and performing the assignment.
 */
class AbilityAssignmentDialog extends BFDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			buy: AbilityAssignmentDialog.#adjustPointBuy,
			confirm: AbilityAssignmentDialog.#confirmScoring,
			reset: AbilityAssignmentDialog.#resetAssignment,
			roll: AbilityAssignmentDialog.#rollScore,
			selectMethod: AbilityAssignmentDialog.#selectMethod,
			sell: AbilityAssignmentDialog.#adjustPointBuy
		},
		classes: ["ability-assignment-dialog"],
		form: {
			submitOnChange: true
		},
		position: {
			width: 700
		},
		sheetConfig: false
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		dialog: {
			template: "systems/black-flag/templates/actor/ability-assignment-dialog.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get title() {
		return game.i18n.localize("BF.AbilityAssignment.Label");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.system = this.document.system;
		context.source = this.document.system._source;
		context.scoreCount = Object.keys(CONFIG.BlackFlag.abilities).length;
		switch (this.document.system.progression.abilities.method) {
			case "rolling":
				this.getRollingData(context);
				break;
			case "point-buy":
				this.getPointBuyData(context);
				break;
			case "standard-array":
			case "manual":
				this.getStandardArrayManualData(context);
				break;
		}
		context.allowManualAssignment = game.settings.get(game.system.id, "abilitySelectionManual") || game.user.isGM;
		context.allowRerolls = game.settings.get(game.system.id, "abilitySelectionReroll") || game.user.isGM;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare context data for rolling method.
	 * @param {object} context - Context being prepared.
	 */
	getRollingData(context) {
		const progression = this.document.system.progression.abilities;

		context.rolls = Array.fromRange(context.scoreCount).map(idx => {
			const roll = progression.rolls[idx] ?? null;
			const term = roll?.terms[0];
			const results = term?.results.map(r => ({
				result: term.getResultLabel(r),
				classes: term.getResultCSS(r).filterJoin(" ")
			}));
			return { roll, results };
		});
		context.sortedRolls = Array.from(progression.rolls.entries())
			.map(([index, roll]) => ({ index, roll }))
			.sort((lhs, rhs) => (rhs.roll?.total ?? Infinity) - (lhs.roll?.total ?? Infinity));

		context.scores = [];
		let bonusCount = 0;
		for (const [key, c] of Object.entries(CONFIG.BlackFlag.abilities)) {
			const value = progression.assignments[key] ?? null;
			const bonus = progression.bonuses[key] ?? null;
			if (bonus !== null) bonusCount++;
			context.scores.push({
				key,
				label: c.labels.full,
				value,
				bonus,
				maxBonus: CONFIG.BlackFlag.abilityAssignment.rolling.max - (progression.rolls[value]?.total ?? 0)
			});
		}

		const allBonuses = bonusCount >= CONFIG.BlackFlag.abilityAssignment.rolling.bonuses.length;
		context.ready = context.scores.every(s => s.value !== null) && allBonuses;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare context data for point-buy method.
	 * @param {object} context - Context being prepared.
	 */
	getPointBuyData(context) {
		const existingAssignments = this.document.system.progression.abilities.assignments;
		const config = CONFIG.BlackFlag.abilityAssignment.pointBuy;
		const sortedKeys = Object.keys(config.costs)
			.map(k => Number(k))
			.sort((lhs, rhs) => lhs - rhs);
		const minScore = sortedKeys.shift();
		const maxScore = sortedKeys.pop();
		const pluralRules = new Intl.PluralRules(game.i18n.lang);

		context.points = { max: config.points };
		context.points.spent = Object.values(existingAssignments).reduce(
			(spent, assignments) => spent + config.costs[minScore + assignments] ?? 0,
			0
		);
		context.points.remaining = context.points.max - context.points.spent;

		context.pointList = Array.fromRange(context.points.max).map(number => ({
			number: number + 1,
			spent: number >= context.points.remaining
		}));
		context.scores = [];
		for (const [key, c] of Object.entries(CONFIG.BlackFlag.abilities)) {
			const assignments = existingAssignments[key] ?? 0;
			const score = { key, label: c.labels.full, assignments };
			score.value = minScore + assignments;
			score.isMin = score.value === minScore;
			score.isMax = score.value === maxScore;
			score.existingCost = config.costs[score.value] ?? 0;
			score.nextCost = !score.isMax ? config.costs[score.value + 1] - score.existingCost : null;
			score.costDescription = score.isMax
				? "â€”"
				: game.i18n.format(`BF.AbilityAssignment.Method.PointBuy.Cost.Point[${pluralRules.select(score.nextCost)}]`, {
						number: score.nextCost
					});
			score.canAfford = score.nextCost !== null && score.nextCost <= context.points.remaining;
			context.scores.push(score);
		}

		context.ready = context.points.remaining === 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare context data for standard array & manual methods.
	 * @param {object} context - Context being prepared.
	 */
	getStandardArrayManualData(context) {
		context.scores = [];
		for (const [key, c] of Object.entries(CONFIG.BlackFlag.abilities)) {
			const value = this.document.system.progression.abilities.assignments[key] ?? null;
			context.scores.push({ key, label: c.labels.full, value });
		}
		context.ready = context.scores.every(s => s.value !== null);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Life-Cycle Handlers         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);
		for (const element of this.element.querySelectorAll('.scores > fieldset [type="radio"]')) {
			element.addEventListener("change", this._onAssignmentChoice.bind(this));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle assigning a value to an ability score in rolling & standard array methods.
	 * @param {Event} event - Triggering change event.
	 */
	async _onAssignmentChoice(event) {
		event.stopImmediatePropagation();
		const name = event.target.name;
		const key = event.target.closest("[data-key]").dataset.key;
		const value = Number(event.currentTarget.value);
		const updates = { [`system.progression.abilities.${name}.${key}`]: value };

		// Uncheck any other entries in this row
		const existingAssignments = this.document.system.progression.abilities[name];
		const otherChecked = Object.entries(existingAssignments).find(([k, v]) => k !== key && v === value)?.[0];
		if (otherChecked) {
			const value = existingAssignments[key];
			updates[`system.progression.abilities.${name}.${otherChecked}`] = name === "bonuses" ? null : value ?? null;
		}

		// Unset any previously-selected bonus
		if (name === "assignments") {
			updates[`system.progression.abilities.bonuses.${key}`] = null;
			if (otherChecked) updates[`system.progression.abilities.bonuses.${otherChecked}`] = null;
		}

		await this.document.update(updates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle buying & selling scores during point-buy.
	 * @this {AbilityAssignmentDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #adjustPointBuy(event, target) {
		const key = target.closest("[data-key]").dataset.key;
		const current = this.document.system.progression.abilities.assignments[key] ?? 0;
		await this.document.update({
			[`system.progression.abilities.assignments.${key}`]: target.dataset.action === "buy" ? current + 1 : current - 1
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Confirm scoring and set base ability scores.
	 * @this {AbilityAssignmentDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #confirmScoring(event, target) {
		const progression = this.document.system.progression.abilities;
		const updates = {};
		switch (progression.method) {
			case "rolling":
				for (const [key, idx] of Object.entries(progression.assignments)) {
					const bonus = CONFIG.BlackFlag.abilityAssignment.rolling.bonuses[progression.bonuses[key]] ?? 0;
					updates[`system.abilities.${key}.base`] = progression.rolls[idx].total + bonus;
				}
				break;
			case "point-buy":
				const minScore = Object.keys(CONFIG.BlackFlag.abilityAssignment.pointBuy.costs).reduce(
					(m, s) => (Number(s) < m ? Number(s) : m),
					Infinity
				);
				for (const key of Object.keys(CONFIG.BlackFlag.abilities)) {
					const assignments = progression.assignments[key] ?? 0;
					updates[`system.abilities.${key}.base`] = minScore + assignments;
				}
				break;
			case "standard-array":
				for (const [key, idx] of Object.entries(progression.assignments)) {
					updates[`system.abilities.${key}.base`] = CONFIG.BlackFlag.abilityAssignment.standardArray[idx];
				}
				break;
			case "manual":
				for (const [key, value] of Object.entries(progression.assignments)) {
					updates[`system.abilities.${key}.base`] = value;
				}
				break;
		}
		await this.document.update(updates);
		this.close();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle resting back to the start of the process.
	 * @this {AbilityAssignmentDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #resetAssignment(event, target) {
		const updates = { "system.progression.abilities.method": "" };
		Object.keys(this.document.system.progression.abilities.assignments).forEach(
			key => (updates[`system.progression.abilities.assignments.-=${key}`] = null)
		);
		Object.keys(this.document.system.progression.abilities.bonuses).forEach(
			key => (updates[`system.progression.abilities.bonuses.-=${key}`] = null)
		);
		await this.document.update(updates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll for an ability score and store the result.
	 * @this {AbilityAssignmentDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #rollScore(event, target) {
		const idx = target.closest("[data-index]").dataset.index;
		const roll = new Roll(CONFIG.BlackFlag.abilityAssignment.rolling.formula);
		await roll.evaluate();

		// Create chat message with roll results
		const cls = getDocumentClass("ChatMessage");
		const flavor = game.i18n.localize("BF.AbilityAssignment.RolledAbilityScore");
		const messageData = {
			flavor,
			title: `${flavor}: ${this.document.name}`,
			speaker: cls.getSpeaker({ actor: this.document }),
			user: game.user.id,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
			content: "",
			sound: CONFIG.sounds.dice,
			rolls: [roll],
			"flags.blackFlag.type": "abilityScores"
		};
		const message = new cls(messageData);
		await cls.create(message.toObject(), { rollMode: game.settings.get("core", "rollMode") });

		// Save rolls
		const rollCollection = this.document.system.progression.abilities.rolls ?? [];
		while (rollCollection.length < idx) {
			rollCollection.push(null);
		}
		rollCollection[idx] = roll;
		await this.document.update({ "system.progression.abilities.rolls": rollCollection });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle selecting a specific assignment method.
	 * @this {AbilityAssignmentDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #selectMethod(event, target) {
		this.document.update({ "system.progression.abilities.method": target.dataset.method });
	}
}

/**
 * @typedef {StringFieldOptions} FormulaFieldOptions
 * @property {boolean} [deterministic=false] - Is this formula not allowed to have dice values?
 */

/**
 * Special case StringField which represents a formula.
 *
 * @param {FormulaFieldOptions} [options={}] - Options which configure the behavior of the field.
 * @property {boolean} deterministic=false - Is this formula not allowed to have dice values?
 */
class FormulaField extends foundry.data.fields.StringField {
	static get _defaults() {
		return foundry.utils.mergeObject(super._defaults, {
			deterministic: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_validateType(value) {
		if (this.options.deterministic) {
			const roll = new Roll(value);
			if (!roll.isDeterministic) throw new Error("must not contain dice terms");
			Roll.safeEval(roll.formula);
		} else Roll.validate(value);
		super._validateType(value);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*      Active Effect Application      */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_castChangeDelta(delta) {
		return this._cast(delta).trim();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_applyChangeAdd(value, delta, model, change) {
		if (!value) return delta;
		let operator = "+";
		if (delta.startsWith("+")) {
			delta = delta.replace("+", "").trim();
		} else if (delta.startsWith("-")) {
			delta = delta.replace("-", "").trim();
			operator = "-";
		}
		return `${value} ${operator} ${delta}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_applyChangeMultiply(value, delta, model, change) {
		if (!value) return delta;
		const terms = new Roll(value).terms;
		if (terms.length > 1) return `(${value}) * ${delta}`;
		return `${value} * ${delta}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_applyChangeUpgrade(value, delta, model, change) {
		if (!value) return delta;
		const terms = new Roll(value).terms;
		if (terms.length === 1 && terms[0].fn === "max") return value.replace(/\)$/, `, ${delta})`);
		return `max(${value}, ${delta})`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_applyChangeDowngrade(value, delta, model, change) {
		if (!value) return delta;
		const terms = new Roll(value).terms;
		if (terms.length === 1 && terms[0].fn === "min") return value.replace(/\)$/, `, ${delta})`);
		return `min(${value}, ${delta})`;
	}
}

/**
 * @callback MappingFieldInitialValueBuilder
 * @param {string} key - The key within the object where this new value is being generated.
 * @param {*} initial - The generic initial data provided by the contained model.
 * @param {object} existing - Any existing mapping data.
 * @returns {object} - Value to use as default for this key.
 */

/**
 * @typedef {DataFieldOptions} MappingFieldOptions
 * @property {string[]} [initialKeys] - Keys that will be created if no data is provided.
 * @property {MappingFieldInitialValueBuilder} [initialValue] - Function to calculate the initial value for a key.
 * @property {boolean} [prepareKeys=false] - Should the keys in the initialized data be limited to the keys provided
 *                                           by `options.initialKeys`?
 */

/**
 * A subclass of ObjectField that represents a mapping of keys to the provided DataField type.
 *
 * @param {DataField} model - The class of DataField which should be embedded in this field.
 * @param {MappingFieldOptions} [options={}] - Options which configure the behavior of the field.
 * @property {string[]} [initialKeys] - Keys that will be created if no data is provided.
 * @property {MappingFieldInitialValueBuilder} [initialValue] - Function to calculate the initial value for a key.
 * @property {boolean} [prepareKeys=false] - Should the keys in the initialized data be limited to the keys provided
 *                                           by `options.initialKeys`?
 */
class MappingField extends foundry.data.fields.ObjectField {
	constructor(model, options) {
		if (!(model instanceof foundry.data.fields.DataField)) {
			throw new Error("MappingField must have a DataField as its contained element");
		}
		super(options);

		/**
		 * The embedded DataField definition which is contained in this field.
		 * @type {DataField}
		 */
		this.model = model;
		model.parent = this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static get _defaults() {
		return foundry.utils.mergeObject(super._defaults, {
			initialKeys: null,
			initialValue: null,
			prepareKeys: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_cleanType(value, options) {
		Object.entries(value).forEach(([k, v]) => {
			if (k.startsWith("-=")) return;
			value[k] = this.model.clean(v, options);
		});
		return value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Ensure the initial keys are in a usable format.
	 * @returns {string[]|void}
	 */
	_getInitialKeys() {
		const keys = this.initialKeys;
		switch (foundry.utils.getType(keys)) {
			case "Array":
				return keys;
			case "Object":
				return Object.keys(keys);
			case "Set":
				return Array.from(keys);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getInitialValue(data) {
		const keys = this._getInitialKeys();
		const initial = super.getInitialValue(data);
		if (!keys || !foundry.utils.isEmpty(initial)) return initial;
		for (const key of keys) initial[key] = this._getInitialValueForKey(key);
		return initial;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the initial value for the provided key.
	 * @param {string} key - Key within the object being built.
	 * @param {object} [object] - Any existing mapping data.
	 * @returns {*} - Initial value based on provided field type.
	 */
	_getInitialValueForKey(key, object) {
		const initial = this.model.getInitialValue();
		return this.initialValue?.(key, initial, object) ?? initial;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_validateType(value, options = {}) {
		if (foundry.utils.getType(value) !== "Object") throw new Error("must be an Object");
		const errors = this._validateValues(value, options);
		if (!foundry.utils.isEmpty(errors)) {
			const failure = new foundry.data.validation.DataModelValidationFailure();
			failure.elements = Object.entries(errors).map(([id, failure]) => ({ id, failure }));
			throw failure.asError();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Validate each value of the object.
	 * @param {object} value - The object to validate.
	 * @param {object} options - Validation options.
	 * @returns {Record<string, Error>} - An object of value-specific errors by key.
	 */
	_validateValues(value, options) {
		const errors = {};
		for (const [k, v] of Object.entries(value)) {
			if (k.startsWith("-=")) continue;
			const error = this.model.validate(v, options);
			if (error) errors[k] = error;
		}
		return errors;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	initialize(value, model, options = {}) {
		if (!value) return value;
		const obj = {};
		const initialKeys = this._getInitialKeys() ?? [];
		const keys = this.prepareKeys ? initialKeys : Object.keys(value);
		for (const key of keys) {
			const data = value[key] ?? this._getInitialValueForKey(key, value);
			obj[key] = this.model.initialize(data, model, options);
		}
		return obj;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_getField(path) {
		if (path.length === 0) return this;
		else if (path.length === 1) return this.model;
		path.shift();
		return this.model._getField(path);
	}
}

/**
 * Insert a new element into an array in a specific position.
 * @param {Array} array - Array into which to insert.
 * @param {*} toInsert - Element to insert.
 * @param {{after: [*|Function], before: [*|Function]}[]} positions - List of objects that describe where the new
 *                                                                    element should be inserted, if matching elements
 *                                                                    are found, or functions to call to do the same.
 * @returns {number} - Index of the newly inserted element.
 */
function insertBetween(array, toInsert, positions) {
	for ( const position of positions ) {
		let matcher = position.after ?? position.before;
		if ( foundry.utils.getType(matcher) !== "function" ) matcher = e => e === (position.after ?? position.before);
		let insertIdx = array.findIndex(matcher);
		if ( insertIdx === -1 ) continue;
		if ( position.after ) insertIdx += 1;
		array.splice(insertIdx, 0, toInsert);
		return insertIdx;
	}
	array.push(toInsert);
	return array.length - 1;
}

/**
 * Creates an HTML document link for the provided UUID.
 * @param {string} uuid - UUID for which to produce the link.
 * @param {object} [options={}]
 * @param {boolean} [options.element=false] - Should a HTMLElement be returned?
 * @returns {string|HTMLElement|void} - Link to the item or empty string if item wasn't found.
 */
function linkForUUID(uuid, { element=false }={}) {
	let doc = fromUuidSync(uuid);
	if ( !doc ) return;

	if ( uuid.startsWith("Compendium.") && !(doc instanceof foundry.abstract.Document) ) {
		const { collection } = foundry.utils.parseUuid(uuid);
		const cls = collection.documentClass;
		doc = new cls(foundry.utils.deepClone(doc), { pack: collection.metadata.id });
	}

	const result = doc?.toAnchor();
	return element ? result : result.outerHTML;
}

/**
 * Determine which keys are pressed that might trigger the provided keybinding.
 * @param {Event} event - Triggering event.
 * @param {string} action - Keybinding action within the `black-flag` namespace.
 * @returns {boolean} - Should this action be triggered?
 */
function areKeysPressed(event, action) {
	if ( !event ) return false;
	const activeModifiers = {};
	const addModifiers = (key, pressed) => {
		activeModifiers[key] = pressed;
		KeyboardManager.MODIFIER_CODES[key].forEach(n => activeModifiers[n] = pressed);
	};
	addModifiers(KeyboardManager.MODIFIER_KEYS.CONTROL, event.ctrlKey || event.metaKey);
	addModifiers(KeyboardManager.MODIFIER_KEYS.SHIFT, event.shiftKey);
	addModifiers(KeyboardManager.MODIFIER_KEYS.ALT, event.altKey);
	return game.keybindings.get(game.system.id, action).some(b => {
		if ( game.keyboard.downKeys.has(b.key) && b.modifiers.every(m => activeModifiers[m]) ) return true;
		if ( b.modifiers.length ) return false;
		return activeModifiers[b.key];
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Construct roll parts and populate its data object.
 * @param {object} parts - Information on the parts to be constructed.
 * @param {object} [data] - Roll data to use and populate while constructing the parts.
 * @returns {{ parts: string[], data: object }}
 */
function buildRoll(parts, data={}) {
	const finalParts = [];
	for ( let [key, value] of Object.entries(parts) ) {
		if ( !value && (value !== 0) ) continue;
		finalParts.push(`@${key}`);
		foundry.utils.setProperty(data, key, foundry.utils.getType(value) === "string"
			? Roll.replaceFormulaData(value, data) : value);
	}
	return { parts: finalParts, data };
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Step a dice denomination up or down by a certain number of steps, never going beyond the bounds of the allowed dice.
 * If decrease below minimum denomination it will return `null` indicating no dice should be rolled.
 * @param {number} denomination - Starting denomination.
 * @param {number} [step=1] - Number of steps to increase or decrease the denomination.
 * @returns {number|null}
 */
function stepDenomination(denomination, step=1) {
	return CONFIG.BlackFlag.dieSteps[Math.min(
		CONFIG.BlackFlag.dieSteps.indexOf(denomination) + step,
		CONFIG.BlackFlag.dieSteps.length - 1
	)] ?? null;
}

/**
 * A filter description.
 *
 * @typedef {object} FilterDescription
 * @property {string} k - Key on the data object to check.
 * @property {*} v - Value to compare.
 * @property {string} [o=_] - Operator or comparison function to use.
 */

/**
 * Check some data against a filter to determine if it matches.
 * @param {object} data - Data to check.
 * @param {FilterDescription[]} filter - Filter to compare against.
 * @returns {boolean}
 * @throws
 */
function performCheck(data, filter=[]) {
	return AND(data, filter);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Determine the unique keys referenced by a set of filters.
 * @param {FilterDescription[]} filter - Filter to examine.
 * @returns {Set<string>}
 */
function uniqueKeys(filter=[]) {
	const keys = new Set();
	const _uniqueKeys = filters => {
		for ( const f of filters ) {
			const operator = f.o in OPERATOR_FUNCTIONS;
			if ( operator && (foundry.utils.getType(f.v) === "Array") ) _uniqueKeys(f.v);
			else if ( f.o === "NOT" ) _uniqueKeys([f.v]);
			else if ( !operator ) keys.add(f.k);
		}
	};
	_uniqueKeys(filter);
	return keys;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Internal check implementation.
 * @param {object} data - Data to check.
 * @param {string} [keyPath] - Path to individual piece within data to check.
 * @param {*} value - Value to compare against or additional filters.
 * @param {string} [operation="_"] - Checking function to use.
 * @returns {boolean}
 * @internal
 * @throws
 */
function _check(data, keyPath, value, operation="_") {
	const operator = OPERATOR_FUNCTIONS[operation];
	if ( operator ) return operator(data, value);

	const comparison = COMPARISON_FUNCTIONS[operation];
	if ( !comparison ) throw new Error(`Comparison function "${operation}" could not be found.`);
	return comparison(foundry.utils.getProperty(data, keyPath), value);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                   Operator Functions                  */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Operator functions.
 * @enum {Function}
 */
const OPERATOR_FUNCTIONS = {
	AND, NAND, OR, NOR, XOR, NOT
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform an AND check against all filters.
 * @param {object} data - Data to check.
 * @param {FilterDescription[]} filter - Filter to compare against.
 * @returns {boolean}
 */
function AND(data, filter) {
	return filter.every(({k, v, o}) => _check(data, k, v, o));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform an NAND check against all filters.
 * @param {object} data - Data to check.
 * @param {FilterDescription[]} filter - Filter to compare against.
 * @returns {boolean}
 */
function NAND(data, filter) {
	return !filter.every(({k, v, o}) => _check(data, k, v, o));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform an OR check against all filters.
 * @param {object} data - Data to check.
 * @param {FilterDescription[]} filter - Filter to compare against.
 * @returns {boolean}
 */
function OR(data, filter) {
	return filter.some(({k, v, o}) => _check(data, k, v, o));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform an NOR check against all filters.
 * @param {object} data - Data to check.
 * @param {FilterDescription[]} filter - Filter to compare against.
 * @returns {boolean}
 */
function NOR(data, filter) {
	return !filter.some(({k, v, o}) => _check(data, k, v, o));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform an XOR check against all filters.
 * @param {object} data - Data to check.
 * @param {FilterDescription[]} filter - Filter to compare against.
 * @returns {boolean}
 */
function XOR(data, filter) {
	let currentResult = false;
	for ( const { k, v, o } of filter ) {
		if ( _check(data, k, v, o) ) {
			if ( !currentResult ) currentResult = true;
			else return false;
		}
	}
	return currentResult;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Invert the result of a nested check,
 * @param {object} data - Data to check.
 * @param {FilterDescription} filter - Filter to compare against.
 * @returns {boolean}
 */
function NOT(data, filter) {
	const { k, v, o } = filter;
	return !_check(data, k, v, o);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                  Comparison Functions                 */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Currently supported comparison functions.
 * @enum {Function}
 */
const COMPARISON_FUNCTIONS = {
	_: exact, exact, iexact, contains, icontains,
	startswith, istartswith, endswith, iendswith,
	has, hasAny, hasAll, in: in_, gt, gte, lt, lte
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check for an exact match. The default comparison mode if none is provided.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function exact(data, value) {
	return data === value;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Case-insensitive exact match.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function iexact(data, value) {
	return exact(String(data).toLowerCase(), String(value).toLowerCase());
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that data contains value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function contains(data, value) {
	return String(data).includes(String(value));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Case-insensitive check that data contains value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function icontains(data, value) {
	return contains(String(data).toLowerCase(), String(value).toLowerCase());
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that data starts with value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function startswith(data, value) {
	return String(data).startsWith(String(value));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Case-insensitive check that data starts with value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function istartswith(data, value) {
	return startswith(String(data).toLowerCase(), String(value).toLowerCase());
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that data ends with value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function endswith(data, value) {
	return String(data).endsWith(String(value));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Case-insensitive check that data ends with value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function iendswith(data, value) {
	return endswith(String(data).toLowerCase(), String(value).toLowerCase());
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that the data collection has the provided value.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function has(data, value) {
	return in_(value, data);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that the data collection has any of the provided values.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function hasAny(data, value) {
	return Array.from(value).some(v => has(data, v));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that the data collection has all of the provided values.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function hasAll(data, value) {
	return Array.from(value).every(v => has(data, v));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that data matches one of the provided values.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function in_(data, value) {
	switch ( foundry.utils.getType(value) ) {
		case "Array": return value.includes(data);
		case "Set": return value.has(data);
		default: return false;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that value is greater than data.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function gt(data, value) {
	return Number(data) > Number(value);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that value is greater than or equal to data.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function gte(data, value) {
	return Number(data) >= Number(value);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that value is less than data.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function lt(data, value) {
	return Number(data) < Number(value);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Check that value is less than or equal to data.
 * @param {*} data
 * @param {*} value
 * @returns {boolean}
 */
function lte(data, value) {
	return Number(data) <= Number(value);
}

var filter$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AND: AND,
	COMPARISON_FUNCTIONS: COMPARISON_FUNCTIONS,
	NAND: NAND,
	NOR: NOR,
	NOT: NOT,
	OPERATOR_FUNCTIONS: OPERATOR_FUNCTIONS,
	OR: OR,
	XOR: XOR,
	contains: contains,
	endswith: endswith,
	exact: exact,
	gt: gt,
	gte: gte,
	has: has,
	hasAll: hasAll,
	hasAny: hasAny,
	icontains: icontains,
	iendswith: iendswith,
	iexact: iexact,
	in_: in_,
	istartswith: istartswith,
	lt: lt,
	lte: lte,
	performCheck: performCheck,
	startswith: startswith,
	uniqueKeys: uniqueKeys
});

const {
	Coin, DiceTerm, Die, FunctionTerm, NumericTerm, OperatorTerm, ParentheticalTerm, RollTerm
} = foundry.dice.terms;

/**
 * Replace referenced data attributes in the roll formula with values from the provided data.
 * If the attribute is not found in the provided data, adds a warning to the provided messages array.
 * @param {string} formula - The original formula within which to replace.
 * @param {object} data - The data object which provides replacements.
 * @param {object} [error={}]
 * @param {NotificationsCollection} [error.notifications] - Collection to which any errors will be logged.
 * @param {string} [error.key] - Key under which an error will be filed.
 * @param {string} [error.message] - Localization key for the message to display in case of missing errors.
 * @param {object} [error.messageData={}] - Additional data passed to message generation.
 * @returns {string} - Formula with replaced data.
 */
function replaceFormulaData(formula, data, {
	notifications, key, message="BF.Formula.Warning.MissingReference", messageData={}, ...notificationData
}={}) {
	const dataRgx = new RegExp(/@([a-z.0-9_-]+)/gi);
	const missingReferences = new Set();

	formula = String(formula).replace(dataRgx, (match, term) => {
		const value = foundry.utils.getProperty(data, term);
		if ( value == null ) {
			missingReferences.add(match);
			return "0";
		}
		return String(value).trim();
	});

	if ( (missingReferences.size > 0) && notifications ) notifications.set(key, {
		level: "error", ...notificationData, message: game.i18n.format(message, {
			...messageData, references: game.i18n.getListFormatter({ style: "long", type: "conjunction" })
				.format(missingReferences)
		})
	});

	return formula;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Convert a bonus value to a simple integer for displaying on the sheet.
 * @param {number|string|null} bonus - Bonus formula.
 * @param {object} [data={}] - Data to use for replacing @ strings.
 * @returns {number} - Simplified bonus as an integer.
 */
function simplifyBonus(bonus, data={}) {
	if ( !bonus ) return 0;
	if ( Number.isNumeric(bonus) ) return Number(bonus);
	try {
		const roll = new Roll(bonus, data);
		return roll.isDeterministic ? Roll.safeEval(roll.formula) : 0;
	} catch(error) {
		console.error(error);
		// TODO: Report errors using the document notifications system
		return 0;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Reduce a formula to the minimum number of unique terms.
 * @param {string} formula - The original formula.
 * @param {object} [options={}]
 * @param {boolean} [options.deterministic=false] - Strip any non-deterministic terms from the result.
 * @param {boolean} [options.preserveFlavor=false] - Preserve flavor text.
 * @returns {string}
 */
function simplifyFormula(formula, { deterministic=false, preserveFlavor=false }={}) {
	// Create a new roll and verify that the formula is valid before attempting simplification
	let roll;
	try { roll = new Roll(formula); }
	catch(err) { console.warn(`Unable to simplify formula '${formula}': ${err}`); }
	Roll.validate(roll.formula);

	// Optionally strip flavor annotations
	if ( !preserveFlavor ) roll.terms = Roll.parse(roll.formula.replace(RollTerm.FLAVOR_REGEXP, ""));

	// Optionally strip all non-deterministic terms
	if ( deterministic ) roll.terms = _stripDeterministic(roll.terms);

	// Perform arithmetic simplification on the existing roll terms
	roll.terms = _simplifyOperatorTerms(roll.terms);

	// If the formula contains multiplication or division we cannot easily simplify
	if ( /[*/]/.test(roll.formula) ) {
		if ( roll.isDeterministic && !/d\(/.test(roll.formula) && (!/\[/.test(roll.formula) || !preserveFlavor) ) {
			return String(roll.evaluateSync().total);
		}
		else return roll.constructor.getFormula(roll.terms);
	}

	// Flatten the roll formula and eliminate string terms
	roll.terms = _expandParentheticalTerms(roll.terms);
	roll.terms = Roll.simplifyTerms(roll.terms);

	// Group terms by type and perform simplifications on various types of roll term
	let { poolTerms, diceTerms, mathTerms, numericTerms } = _groupTermsByType(roll.terms);
	numericTerms = _simplifyNumericTerms(numericTerms ?? []);
	diceTerms = _simplifyDiceTerms(diceTerms ?? []);

	// Recombine the terms into a single term array and remove an initial + operator if present
	const simplifiedTerms = [diceTerms, poolTerms, mathTerms, numericTerms].flat().filter(Boolean);
	if ( simplifiedTerms[0]?.operator === "+" ) simplifiedTerms.shift();
	return roll.constructor.getFormula(simplifiedTerms);
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function for stripping non-deterministic terms from the result.
 * @param {RollTerm[]} terms - An array of roll terms.
 * @returns {RollTerm[]} - A new array of roll terms with non-deterministic terms removed.
 */
function _stripDeterministic(terms) {
	// Perform arithmetic simplification to simplify parsing through the terms.
	terms = _simplifyOperatorTerms(terms);

	// Remove non-deterministic terms, their preceding operators, and dependent operators/terms.
	const newTerms = [];
	let temp = [];
	let multiplicative = false;
	let determ;
	
	for ( let i = terms.length - 1; i >= 0; ) {
		let paren;
		let term = terms[i];
		if ( term instanceof ParentheticalTerm ) {
			paren = simplifyRollFormula(term.term, { preserveFlavor, deterministic });
		}
		if ( Number.isNumeric(paren) ) {
			const termData = { number: paren };
			if ( preserveFlavor ) termData.options = { flavor: term.flavor };
			term = new NumericTerm(termData);
		}
		determ = term.isDeterministic && (!multiplicative || determ);
		if ( determ ) temp.unshift(term);
		else temp = [];
		term = terms[--i];
		while ( term instanceof OperatorTerm ) {
			if ( determ ) temp.unshift(term);
			if ( (term.operator === "*") || (term.operator === "/") || (term.operator === "%") ) multiplicative = true;
			else {
				multiplicative = false;
				while ( temp.length ) newTerms.unshift(temp.pop());
			}
			term = terms[--i];
		}
	}
	if ( determ ) {
		while ( temp.length ) newTerms.unshift(temp.pop());
	}

	return newTerms;
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function to perform arithmetic simplification and remove redundant operator terms.
 * @param {RollTerm[]} terms - An array of roll terms.
 * @returns {RollTerm[]} - A new array of roll terms with redundant operators removed.
 */
function _simplifyOperatorTerms(terms) {
	return terms.reduce((acc, term) => {
		const prior = acc[acc.length - 1];
		const ops = new Set([prior?.operator, term.operator]);

		// If one of the terms is not an operator, add the current term as is.
		if ( ops.has(undefined) ) acc.push(term);

		// Replace consecutive "+ -" operators with a "-" operator.
		else if ( (ops.has("+")) && (ops.has("-")) ) acc.splice(-1, 1, new OperatorTerm({ operator: "-" }));

		// Replace double "-" operators with a "+" operator.
		else if ( (ops.has("-")) && (ops.size === 1) ) acc.splice(-1, 1, new OperatorTerm({ operator: "+" }));

		// Don't include "+" operators that directly follow "+", "*", or "/". Otherwise, add the term as is.
		else if ( !ops.has("+") ) acc.push(term);

		return acc;
	}, []);
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function for combining unannotated numeric terms in an array into a single numeric term.
 * @param {object[]} terms - An array of roll terms.
 * @returns {object[]} - A new array of terms with unannotated numeric terms combined into one.
 */
function _simplifyNumericTerms(terms) {
	const simplified = [];
	const { annotated, unannotated } = _separateAnnotatedTerms(terms);

	// Combine the unannotated numerical bonuses into a single new NumericTerm.
	if ( unannotated.length ) {
		const staticBonus = Roll.safeEval(Roll.getFormula(unannotated));
		if ( staticBonus === 0 ) return [...annotated];

		// If the staticBonus is greater than 0, add a "+" operator so the formula remains valid.
		if ( staticBonus > 0 ) simplified.push(new OperatorTerm({ operator: "+"}));
		simplified.push(new NumericTerm({ number: staticBonus} ));
	}
	return [...simplified, ...annotated];
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function to group dice of the same size and sign into single dice terms.
 * @param {object[]} terms - An array of DiceTerms and associated OperatorTerms.
 * @returns {object[]} - A new array of simplified dice terms.
 */
function _simplifyDiceTerms(terms) {
	const { annotated, unannotated } = _separateAnnotatedTerms(terms);

	// Split the unannotated terms into different die sizes and signs
	const diceQuantities = unannotated.reduce((obj, curr, i) => {
		if ( curr instanceof OperatorTerm ) return obj;
		const isCoin = curr.constructor?.name === "Coin";
		const face = isCoin ? "c" : curr.faces;
		const modifiers = isCoin ? "" : curr.modifiers.filterJoin("");
		let key = `${unannotated[i - 1].operator}${face}${modifiers}`;
		if ( curr._number.isDeterministic ) curr._number.evaluateSync();
		if ( curr.number ) {
			obj[key] ??= {};
			obj[key].number = (obj[key].number ?? 0) + curr.number;
		} else {
			key = `${key}${curr._number?.formula}`;
			obj[key] ??= {};
			obj[key].number = curr._number;
		}
		if ( !isCoin ) obj[key].modifiers = (obj[key].modifiers ?? []).concat(curr.modifiers);
		return obj;
	}, {});

	// Add new die and operator terms to simplified for each die size and sign
	const simplified = Object.entries(diceQuantities).flatMap(([key, {number, modifiers}]) => ([
		new OperatorTerm({ operator: key.charAt(0) }),
		key.slice(1) === "c"
			? new Coin({ number: number })
			: new Die({ number, faces: parseInt(key.slice(1)), modifiers: [...new Set(modifiers)] })
	]));
	return [...simplified, ...annotated];
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function to extract the contents of parenthetical terms into their own terms.
 * @param {object[]} terms - An array of roll terms.
 * @returns {object[]} - A new array of terms with no parenthetical terms.
 */
function _expandParentheticalTerms(terms) {
	terms = terms.reduce((acc, term) => {
		if ( term instanceof ParentheticalTerm ) {
			if ( term.isDeterministic ) {
				const roll = new Roll(term.term);
				term = new NumericTerm({ number: roll.evaluateSync().total });
			} else {
				const subterms = new Roll(term.term).terms;
				term = _expandParentheticalTerms(subterms);
			}
		}
		acc.push(term);
		return acc;
	}, []);
	return _simplifyOperatorTerms(terms.flat());
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function to group terms into PoolTerms, DiceTerms, MathTerms, and NumericTerms.
 * MathTerms are included as NumericTerms if they are deterministic.
 * @param {RollTerm[]} terms - An array of roll terms.
 * @returns {object} - An object mapping term types to arrays containing roll terms of that type.
 */
function _groupTermsByType(terms) {
	// Add an initial operator so that terms can be rearranged arbitrarily.
	if ( !(terms[0] instanceof OperatorTerm) ) terms.unshift(new OperatorTerm({ operator: "+" }));

	return terms.reduce((obj, term, i) => {
		let type;
		if ( term instanceof DiceTerm ) type = DiceTerm;
		else if ( (term instanceof FunctionTerm) && (term.isDeterministic) ) type = NumericTerm;
		else type = term.constructor;
		const key = `${type.name.charAt(0).toLowerCase()}${type.name.substring(1)}s`;

		// Push the term and the preceding OperatorTerm.
		(obj[key] = obj[key] ?? []).push(terms[i - 1], term);
		return obj;
	}, {});
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper function to separate annotated terms from unannotated terms.
 * @param {object[]} terms - An array of DiceTerms and associated OperatorTerms.
 * @returns {Array | Array[]} - A pair of term arrays, one containing annotated terms.
 */
function _separateAnnotatedTerms(terms) {
	return terms.reduce((obj, curr, i) => {
		if ( curr instanceof OperatorTerm ) return obj;
		obj[curr.flavor ? "annotated" : "unannotated"].push(terms[i - 1], curr);
		return obj;
	}, { annotated: [], unannotated: [] });
}

/**
 * Generate an update object to remove any empty object keys.
 * @param {object} object - Object to be cleaned.
 * @returns {object} - Copy of object with only non false-ish values included and others marked
 *                     using `-=` syntax to be removed by update process.
 */
function cleanedObjectUpdate(object) {
	return Object.entries(object).reduce((obj, [key, value]) => {
		let keep = false;
		if ( foundry.utils.getType(value) === "Object" ) keep = Object.values(value).some(v => v);
		else if ( value ) keep = true;
		if ( keep ) obj[key] = value;
		else obj[`-=${key}`] = null;
		return obj;
	}, {});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Transform an object, returning only the keys which match the provided filter.
 * @param {object} obj - Object to transform.
 * @param {Function} [filter] - Filtering function. If none is provided, it will just check for truthiness.
 * @returns {string[]} - Array of filtered keys.
 */
function filteredKeys(obj, filter) {
	filter ??= e => e;
	return Object.entries(obj).filter(e => filter(e[1])).map(e => e[0]);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Flatten a configuration object with children into a single object. Final output will be ordered depth-first.
 * @param {SelectChoices|NestedTypeConfiguration} object - Nested object to flatten.
 * @param {object} [options={}]
 * @param {boolean|Function(object): boolean} [options.keepCategories=false] - Keep category listings in the final
 *                                                                             object or only entries that don't have
 *                                                                             children of their own.
 * @returns {object}
 */
function flattenChildren(object, { keepCategories=false }={}) {
	const flattened = {};

	const makeFlat = level => {
		for ( const [key, value] of Object.entries(level) ) {
			const entry = foundry.utils.deepClone(value);
			const children = entry.children;
			delete entry.children;

			let keep;
			if ( !children ) keep = true;
			else if ( foundry.utils.getType(keepCategories) === "function" ) keep = keepCategories(entry);
			else keep = keepCategories;
			if ( keep ) flattened[key] = entry;

			if ( children ) makeFlat(children);
		}
	};
	makeFlat(object);

	return flattened;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Sort the provided object by its values or by an inner sortKey.
 * @param {object} obj - The object to sort.
 * @param {object} [options={}]
 * @param {string|Function} [options.sortKey] - An inner key upon which to sort or sorting method.
 * @param {boolean} [options.reverse=false] - Should the sorting be reversed?
 * @returns {object} - A copy of the original object that has been sorted.
 */
function sortObjectEntries(obj, { sortKey, reverse=false }={}) {
	let sorted = Object.entries(obj);
	const sort = (lhs, rhs) => foundry.utils.getType(lhs) === "string" ? lhs.localeCompare(rhs) : lhs - rhs;
	if ( foundry.utils.getType(sortKey) === "function" ) sorted = sorted.sort((lhs, rhs) => sortKey(lhs[1], rhs[1]));
	else if ( sortKey ) sorted = sorted.sort((lhs, rhs) => sort(lhs[1][sortKey], rhs[1][sortKey]));
	else sorted = sorted.sort((lhs, rhs) => sort(lhs[1], rhs[1]));
	return Object.fromEntries(reverse ? sorted.reverse() : sorted);
}

/**
 * Create a formatted list including tags like for languages, sense, and movement.
 * @param {object} config
 * @param {Map<string, string>} [config.entries] - Mapping of keys & localized entries that make up the main list.
 * @param {string[]|Set<string>} [config.extras=[]] - Additional pre-localized values that will be added to the end.
 * @param {string[]|Set<string>} [config.tags=[]] - Tags that modify the list.
 * @param {TraitTagConfiguration} config.tagDefinitions - Configuration information for provided tags.
 * @param {string} [config.listType="unit"] - Type of list to use for entries.
 * @returns {string}
 */
function formatTaggedList({ entries=new Map(), extras=[], tags=[], tagDefinitions, listType="unit" }) {
	const formatters = [];
	const appendedTags = [];
	const associatedTags = {};
	const inlineTags = [];
	for ( const tag of tags ) {
		const config = tagDefinitions[tag];
		const localized = game.i18n.localize(config?.display ?? tag);
		switch ( config?.type ) {
			case "appendedTags":
				appendedTags.push(localized);
			case "associated":
				if ( entries.has(config.association) ) {
					associatedTags[config.association] ??= [];
					associatedTags[config.association].push(localized);
				} else {
					appendedTags.push(localized);
				}
				break;
			case "formatter":
				formatters.push(config.display ?? tag);
				break;
			case "inline":
			default:
				inlineTags.push(localized);
		}
	}

	// Iterate over values in entries, added associated tags as necessary
	entries = Array.from(entries.entries()).map(([key, value]) => {
		if ( !associatedTags[key] ) return value;
		return `${value} (${game.i18n.getListFormatter({ style: "short" }).format(associatedTags[key])})`;
	});
	entries.push(...inlineTags);

	let label = game.i18n.getListFormatter({ style: "short", type: listType }).format(entries);
	if ( appendedTags.length ) label += ` (${game.i18n.getListFormatter({ style: "short" }).format(appendedTags)})`;

	formatters.forEach(f => label = game.i18n.format(f, { entries: label }));
	return game.i18n.getListFormatter({ type: "unit" }).format([label, ...extras].filter(l => l));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Cached options for attributes.
 * @type {Map<string, FormSelectOptions>}
 */
const _attributeOptionCache = {
	activity: new Map(),
	actor: new Map(),
	item: new Map()
};

/**
 * Create a human readable label for the provided attribute key, if possible.
 * @param {string} attribute - Attribute key path to localize.
 * @param {object} [options={}]
 * @param {BlackFlagActor} [options.actor] - Optional actor to assist with lookups.
 * @param {BlackFlagItem} [options.item] - Optional item to assist with lookups.
 * @returns {FormSelectOption}
 */
function getAttributeOption(attribute, { actor, item }={}) {
	if ( attribute.startsWith("system.") ) attribute = attribute.slice(7);

	let type = "actor";
	if ( item ) type = attribute.startsWith("activities.") ? "activity" : "item";
	else if ( _attributeOptionCache.actor.has(attribute) ) return _attributeOptionCache.actor.get(attribute);

	const getSchemaLabel = (attr, type, doc) => {
		if ( doc ) return doc.system.schema.getField(attr)?.label;
		for ( const model of Object.values(CONFIG[type].dataModels) ) {
			const field = model.schema.getField(attr);
			if ( field ) return field.label;
		}
	};

	let name;
	let group;
	let label;
	let option;

	// Activity Labels
	if ( type === "activity" ) {
		let [, activityId, ...keyPath] = attribute.split(".");
		const activity = item.system.activities?.get(activityId);
		if ( !activity ) return { value: attribute, label: attribute };
		attribute = keyPath.join(".");
		name = `${item.name}: ${activity.name}`;
		if ( _attributeOptionCache.activity.has(attribute) ) option = _attributeOptionCache.activity.get(attribute);
		else if ( attribute === "uses.spent" ) label = "BF.Uses.Short";
	}

	// Item Labels
	else if ( type === "item" ) {
		name = item.name;
		if ( _attributeOptionCache.item.has(attribute) ) option = _attributeOptionCache.item.get(attribute);
		else if ( attribute === "uses.spent" ) label = "BF.Uses.Short";
		else label = getSchemaLabel(attribute, "Item", item);
	}

	// Abilities
	else if ( attribute.startsWith("abilities.") ) {
		label = CONFIG.BlackFlag.abilities.localized[attribute];
		group = "BF.Ability.Score.Label[other]";
	}

	// Hit Dice
	else if ( attribute.startsWith("attributes.hd.d.") ) {
		const denom = attribute.replace("attributes.hd.d.", "").replace(".spent", "");
		label = game.i18n.format("BF.HitDie.LabelSpecific", { denom });
		group = "BF.HitDie.Label[other]";
	}

	// Skills
	else if ( attribute.startsWith("proficiencies.skills.") ) {
		const key = attribute.replace("proficiencies.skills.", "").replace(".passive", "");
		label = CONFIG.BlackFlag.skills.localized[key];
		group = "BF.Skill.Passive.Label";
	}

	// Spell Slots
	else if ( attribute.startsWith("spellcasting.slots.") ) {
		if ( attribute.startsWith("spellcasting.slots.pact") ) {
			label = "BF.Spellcasting.Type.Pact.Slots";
		} else {
			const circle = attribute.match(/spellcasting\.slots\.circle-(\d+)(?:\.|$)/)?.[1];
			if ( circle ) label = CONFIG.BlackFlag.spellCircles()[Number(circle)];
		}
		if ( !label && actor ) label = foundry.utils.getProperty(actor.system, attribute)?.label;
		group = "BF.CONSUMPTION.Type.SpellSlots.Label";
	}

	// Movement
	else if ( attribute.startsWith("traits.movement.types.") ) {
		label = CONFIG.BlackFlag.movementTypes.localized[attribute.replace("traits.movement.types.", "")];
		group = "BF.Speed.Label";
	}

	// Senses
	else if ( attribute.startsWith("traits.senses.types.") ) {
		label = CONFIG.BlackFlag.senses.localized[attribute.replace("traits.senses.types.", "")];
		group = "BF.SENSES.Label[other]";
	}

	else {
		switch (attribute) {
			case "attributes.ac.flat":
			case "attributes.ac.value":
				label = "BF.ArmorClass.Label";
				break;
			case "attributes.cr":
				label = "BF.ChallengeRating.Label";
				break;
			case "attributes.death.failure":
				label = "BF.Death.Failure.Label";
				break;
			case "attributes.death.success":
				label = "BF.Death.Success.Label";
				break;
			case "attributes.exhaustion":
				label = "BF.Condition.Exhaustion.Level";
				break;
			case "attributes.hp.temp":
				label = "BF.HitPoint.Temp.LabelLong";
				break;
			case "attributes.hp":
			case "attributes.hp.value":
				label = "BF.HitPoint.Label[other]";
				break;
			case "initiative":
			case "attributes.initiative.mod":
				label = "BF.Initiative.Label";
				break;
			case "attributes.legendary.spent":
			case "attributes.legendary.value":
				label = "BF.ACTIVATION.Type.Legendary[other]";
				break;
			case "attributes.luck.value":
				label = "BF.Luck.Label";
				break;
			case "attributes.perception":
				label = "BF.Skill.Perception.Label";
				break;
			case "attributes.stealth":
				label = "BF.Skill.Stealth.Label";
				break;
			case "progression.xp":
			case "progression.xp.value":
				label = "BF.ExperiencePoints.Label";
				break;
			case "spellcasting.dc":
				label = "BF.Spellcasting.DC.Label";
				break;
			default:
				label = getSchemaLabel(attribute, "Actor", actor);
				break;
		} 
	}

	if ( !option ) option = {
		value: attribute,
		label: label ? game.i18n.localize(label) : attribute,
		group: group ? game.i18n.localize(group) : undefined
	};
	if ( label ) _attributeOptionCache[type].set(attribute, option);
	option = foundry.utils.deepClone(option);
	if ( name ) option.label = `${name} ${option.label}`;
	return option;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Cached store of Intl.PluralRules instances.
 * @type {Record<string, Intl.PluralRules>}
 */
const _pluralRules = {};

/**
 * Get a PluralRules object, fetching from cache if possible.
 * @param {object} [options={}]
 * @param {string} [options.type=cardinal]
 * @returns {Intl.PluralRules}
 */
function getPluralRules({ type="cardinal" }={}) {
	_pluralRules[type] ??= new Intl.PluralRules(game.i18n.lang, { type });
	return _pluralRules[type];
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Attach a "localized" property to an object that returns a localized & sorted version.
 * @param {object} config - Configuration object to modify.
 * @param {object} [options={}] - Options to pass through to the makeLabels function.
 * @param {string} [options.propertyName] - Name where the localized string is stored.
 */
function localizeConfig(config, { propertyName="localized", ...options }={}) {
	Object.defineProperty(config, propertyName, {
		get() {
			return makeLabels(config, options);
		},
		enumerable: false
	});
	Object.defineProperty(config, `${propertyName}Options`, {
		get() {
			return Object.entries(this[propertyName]).map(([value, label]) => ({ value, label }));
		},
		enumerable: false
	});
}

/* <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform pre-localization on the contents of a SchemaField. Necessary because the `localizeSchema` method
 * on `Localization` is private.
 * @param {SchemaField} schema
 * @param {string[]} prefixes
 */
function localizeSchema(schema, prefixes) {
	Localization.localizeDataModel({ schema }, { prefixes });
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create labels for the provided object using either a "localization" value with the provided
 * plural role or a "label" value.
 * @param {object} object
 * @param {object} [options={}]
 * @param {boolean} [options.sort=true] - Should the localized results be sorted?
 * @param {string} [options.pluralRule="one"] - Pluralization rule to use with localization value.
 * @param {string} [options.labelKeyPath="label"] - Path to the standard label.
 * @param {string} [options.localizationKeyPath="label"] - Path to the pluralizable label.
 * @param {boolean} [options.flatten=false] - For nested configs with children, flatten them to one level.
 * @param {boolean|Function(object): boolean} [options.keepCategories=true] - Passed to `flattenChildren`.
 * @param {boolean} [options.objectOutput=false] - Output values as objects with label property.
 * @returns {object}
 */
function makeLabels(object, {
	sort=true, pluralRule="one", labelKeyPath="label", localizationKeyPath="localization",
	flatten=false, keepCategories=true, objectOutput=false
}={}) {
	if ( flatten ) object = flattenChildren(object, { keepCategories });
	const localized = Object.entries(object).map(([k, d]) => {
		const label = makeLabel(d, { pluralRule, labelKeyPath, localizationKeyPath });
		return [k, objectOutput ? { ...d, [labelKeyPath]: label } : label];
	});
	if ( sort && objectOutput ) sortObjectEntries(localized, { sortKey: labelKeyPath });
	else if ( sort ) localized.sort((lhs, rhs) => lhs[1].localeCompare(rhs[1]));
	return Object.fromEntries(localized);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a label for the provided object using either a "localization" value with the provided
 * plural role or a "label" value.
 * @param {object|string} input
 * @param {object} [options={}]
 * @param {string} [options.pluralRule="one"] - Pluralization rule to use with localization value.
 * @param {string} [options.labelKeyPath="label"] - Path to the standard label.
 * @param {string} [options.localizationKeyPath="label"] - Path to the pluralizable label.
 * @returns {string}
 */
function makeLabel(input, { pluralRule="one", labelKeyPath="label", localizationKeyPath="localization" }={}) {
	return game.i18n.localize(
		foundry.utils.getType(input) === "string" ? input
			: foundry.utils.getProperty(input, labelKeyPath)
      ?? `${foundry.utils.getProperty(input, localizationKeyPath)}[${pluralRule}]`
	);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Produce a human-formatted system version.
 * @returns {string}
 */
function systemVersion() {
	const parts = game.system.version.split(".");
	const build = Number(parts.pop());
	const version = parts.join(".");
	const type = `BF.Version.${(game.system.flags.version?.type ?? "stable").capitalize()}`;

	return game.i18n.format("BF.Version.Label", {
		version, build, type: game.i18n.localize(type)
	});
}

/**
 * Recreate all documents in the compendium to commit any migrations and clean any deprecated data.
 * @param {CompendiumCollection} pack - Pack to refresh.
 */
async function refreshCompendium(pack) {
	if ( !pack?.documentName ) return;
	const DocumentClass = CONFIG[pack.documentName].documentClass;
	const wasLocked = pack.locked;
	await pack.configure({ locked: false });
	await pack.migrate();

	ui.notifications.info(`Beginning to refresh Compendium ${pack.collection}`);
	const documents = await pack.getDocuments();
	for ( const doc of documents ) {
		const data = doc.toObject();
		await doc.delete();
		await DocumentClass.create(data, { keepId: true, keepEmbeddedIds: true, pack: pack.collection });
	}
	await pack.configure({ locked: wasLocked });
	ui.notifications.info(`Refreshed all documents from Compendium ${pack.collection}`);
}

var migration = /*#__PURE__*/Object.freeze({
	__proto__: null,
	refreshCompendium: refreshCompendium
});

/**
 * Ensure the provided string contains only the characters allowed in identifiers.
 * @param {string} identifier - Identifier to verify.
 * @returns {boolean}
 */
function isValidIdentifier(identifier) {
	return /^([a-z0-9_-]+)$/i.test(identifier);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Determine whether the provided unit is usable within `Intl.NumberFormat`.
 * @param {string} unit
 * @returns {boolean}
 */
function isValidUnit(unit) {
	if ( foundry.utils.getType(unit) === "Object" ) unit = unit.formattingUnit;
	if ( unit?.includes("-per-") ) return unit.split("-per-").every(u => isValidUnit(u));
	return Intl.supportedValuesOf("unit").includes(unit);
}

var validation = /*#__PURE__*/Object.freeze({
	__proto__: null,
	isValidIdentifier: isValidIdentifier,
	isValidUnit: isValidUnit
});

/**
 * Convert the provided weight to another unit.
 * @param {number} value - The weight value to convert.
 * @param {string} from - The initial units.
 * @param {string} to - The final units.
 * @returns {number}
 */
function convertWeight(value, from, to) {
	if ( from === to ) return value;
	const message = unit => `Weight unit ${unit} not defined in CONFIG.BlackFlag.weightUnits`;
	if ( !CONFIG.BlackFlag.weightUnits[from] ) throw new Error(message(from));
	if ( !CONFIG.BlackFlag.weightUnits[to] ) throw new Error(message(to));
	return value
		* CONFIG.BlackFlag.weightUnits[from].conversion
		/ CONFIG.BlackFlag.weightUnits[to].conversion;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Cached store of Intl.NumberFormat instances.
 * @type {{[key: string]: Intl.PluralRules}}
 */
const _numberFormatters = {};

/**
 * Get a PluralRules object, fetching from cache if possible.
 * @param {object} [options={}]
 * @returns {Intl.PluralRules}
 */
function getNumberFormatter(options={}) {
	const key = JSON.stringify(options);
	_numberFormatters[key] ??= new Intl.NumberFormat(game.i18n.lang, options);
	return _numberFormatters[key];
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Format a challenge rating into a fraction if less than one.
 * @param {number|null} value
 * @param {object} [options={}]
 * @param {boolean} [options.narrow=true] - Use narrow fractions (e.g. â…›) rather than wide ones (e.g. 1/8).
 * @returns {string}
 */
function formatCR(value, { narrow=true }={}) {
	if ( value === null ) return "â€”";
	const fractions = narrow ? { 0.125: "â…›", 0.25: "Â¼", 0.5: "Â½" } : { 0.125: "1/8", 0.25: "1/4", 0.5: "1/2" };
	return fractions[value] ?? numberFormat(value);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Form a number using the provided distance unit.
 * @param {number} value - The distance to format.
 * @param {string} unit - Distance unit as defined in `CONFIG.BlackFlag.distanceUnits`.
 * @param {Partial<NumberFormattingOptions>} [options={}] - Formatting options passed to `formatNumber`.
 * @returns {string}
 */
function formatDistance(value, unit, options={}) {
	return _formatSystemUnits(value, unit, CONFIG.BlackFlag.distanceUnits[unit], options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {NumberFormattingOptions}
 * @param {number} decimals - Number of decimal digits to display.
 * @param {number} digits - Number of digits before the decimal point to display.
 * @param {boolean} ordinal - Produce an ordinal version of the number.
 * @param {boolean} sign - Should the sign always be displayed?
 * @param {string} [signDisplay] - Override more specific sign display option.
 * @param {boolean} spelledOut - Should small numbers be spelled out?
 * @param {string} unit - What unit should be displayed?
 * @param {string} unitDisplay - Unit display style.
 */

/**
 * Take number formatting options and convert them into a format usable by `Intl.NumberFormat`.
 * @param {NumberFormattingOptions} options
 * @returns {object}
 */
function _prepareFormattingOptions(options) {
	const formatterOptions = {};
	if ( options.signDisplay ) formatterOptions.signDisplay = options.signDisplay;
	else if ( options.sign ) formatterOptions.signDisplay = "always";
	if ( options.decimals !== undefined ) {
		formatterOptions.minimumFractionDigits = options.decimals;
		formatterOptions.maximumFractionDigits = options.decimals;
	}
	if ( options.digits !== undefined ) {
		formatterOptions.minimumIntegerDigits = options.digits;
		formatterOptions.maximumIntegerDigits = options.digits;
	}
	if ( options.unit && isValidUnit(options.unit) ) {
		formatterOptions.style = "unit";
		formatterOptions.unit = options.unit.formattingUnit ?? options.unit;
		formatterOptions.unitDisplay = options.unitDisplay;
		options.unitFallback = false;
	}
	return formatterOptions;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Format a number based on the current locale.
 * @param {number} value - A number for format.
 * @param {NumberFormattingOptions} [options] - Additional formatting options.
 * @returns {string}
 */
function numberFormat(value, options={}) {
	value = Number(value);

	if ( !Number.isFinite(value) ) {
		value = "âˆž";
		if ( !options.spelledOut ) return value;
	}
	if ( options.spelledOut ) {
		const key = `BF.Number[${value}]`;
		if ( game.i18n.has(key) ) return game.i18n.localize(key);
	}

	let formatted = getNumberFormatter(_prepareFormattingOptions(options)).format(value);

	if ( options.ordinal ) {
		const rule = getPluralRules({ type: "ordinal" }).select(value);
		const key = `BF.Number.Ordinal[${rule}]`;
		if ( game.i18n.has(key) ) formatted = game.i18n.format(key, { number: formatted });
	}

	if ( options.unit?.localization && (options.unitFallback !== false) ) {
		const key = `${options.unit.localization}[${getPluralRules().select(value)}]`;
		formatted += ` ${game.i18n.localize(key).toLowerCase()}`;
	}

	return formatted;
}

/**
 * Format a number based on the current locale.
 * @param {number} value - A number for format.
 * @param {NumberFormattingOptions} [options] - Additional formatting options.
 * @returns {string}
 */
function formatNumber(value, options) {
	return numberFormat(value, options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Form a number using the provided pace unit.
 * @param {number} value - The time to format.
 * @param {string} unit - Time unit as defined in `CONFIG.BlackFlag.timeUnits.time.children`.
 * @param {Partial<NumberFormattingOptions>} [options={}] - Formatting options passed to `formatNumber`.
 * @param {string} [options.period="hour"] - Time period formatting unit (e.g. hour or day).
 * @returns {string}
 */
function formatPace(value, unit, { period="hour", ...options }={}) {
	const unitConfig = CONFIG.BlackFlag.paceUnits[unit];
	options.unit ??= `${unitConfig?.formattingUnit ?? unit}-per-${period}`;
	return _formatSystemUnits(value, unit, unitConfig, options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Produce a number with the parts wrapped in their own spans.
 * @param {number} value - A number for format.
 * @param {NumberFormattingOptions} [options] - Additional formatting options.
 * @returns {string}
 */
function numberParts(value, options) {
	const parts = getNumberFormatter(_prepareFormattingOptions(options)).formatToParts(value);
	return parts.reduce((str, { type, value }) => `${str}<span class="${type}">${value}</span>`, "");
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Form a number using the provided time unit.
 * @param {number} value - The time to format.
 * @param {string} unit - Time unit as defined in `CONFIG.BlackFlag.timeUnits`.
 * @param {Partial<NumberFormattingOptions>} [options={}] - Formatting options passed to `formatNumber`.
 * @returns {string}
 */
function formatTime(value, unit, options={}) {
	const unitConfig = CONFIG.BlackFlag.timeUnits.time.children[unit] ?? CONFIG.BlackFlag.timeUnits.combat.children[unit];
	return _formatSystemUnits(value, unit, unitConfig, options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Form a number using the provided volume unit.
 * @param {number} value - The volume to format.
 * @param {string} unit - Volume unit as defined in `CONFIG.BlackFlag.volumeUnits`.
 * @param {Partial<NumberFormattingOptions>} [options={}] - Formatting options passed to `formatNumber`.
 * @returns {string}
 */
function formatVolume(value, unit, options={}) {
	return _formatSystemUnits(value, unit, CONFIG.BlackFlag.volumeUnits[unit], options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Form a number using the provided weight unit.
 * @param {number} value - The weight to format.
 * @param {string} unit - Weight unit as defined in `CONFIG.BlackFlag.weightUnits`.
 * @param {Partial<NumberFormattingOptions>} [options={}] - Formatting options passed to `formatNumber`.
 * @returns {string}
 */
function formatWeight(value, unit, options={}) {
	return _formatSystemUnits(value, unit, CONFIG.BlackFlag.weightUnits[unit], options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Format a number using one of core's built-in unit types.
 * @param {number} value - Value to display.
 * @param {string} unit - Name of the unit to use.
 * @param {UnitConfiguration} config - Configuration data for the unit.
 * @param {Partial<NumberFormattingOptions>} [options={}] - Formatting options passed to `formatNumber`.
 * @returns {string}
 */
function _formatSystemUnits(value, unit, config, options={}) {
	options.unitDisplay ??= "long";
	if ( config?.counted ) {
		const localizationKey = `${config.counted}.${options.unitDisplay}.${getPluralRules().select(value)}`;
		return game.i18n.format(localizationKey, { number: formatNumber(value, options) });
	}
	return formatNumber(value, { unit: config?.formattingUnit ?? unit, ...options });
}

/**
 * Slugify the provided string with additional improvements to handle works separated by slashes
 * (e.g. `this/that` becomes `this-that` rather than `thisthat`).
 * @param {string} text - Text to slugify.
 * @param {object} options - Options passed to the core slugify function.
 * @returns {string}
 */
function slugify$1(text, options) {
	text = text.replaceAll(/(\w+)([\\|/])(\w+)/g, "$1-$3");
	return text.slugify(options);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create an ID from the input truncating or padding the value to make it reach 16 characters.
 * @param {string} id
 * @returns {string}
 */
function staticID(id) {
	if ( id.length >= 16 ) return id.substring(0, 16);
	return id.padEnd(16, "0");
}

/**
 * Search compendiums for documents that match the given options.
 * @param {typeof Document} documentClass - Class of document should be searched (e.g. Actor or Item).
 * @param {object} [options={}]
 * @param {boolean} [options.deduplicate=true] - Perform identifier-based de-duplication on the result.
 * @param {FilterDescription} [options.filters] - Additional filtering to apply.
 * @param {boolean} [options.index=true] - Should indexes be returned, or the full documents.
 * @param {Set<string>} [options.indexFields] - Key paths of fields to index.
 * @param {boolean|string} [options.sort] - Should the contents be sorted or what keyPath should they be sorted on?
 * @param {string} [options.type] - Individual document subtype to find (e.g. "talent" or "spell").
 * @param {Set<string>} [options.types] - Set of document subtypes to find.
 * @returns {Document[]}
 */
async function compendiums(documentClass, {
	deduplicate=true, filters=[], index=true, indexFields=new Set(), sort=true, type, types=new Set()
}={}) {
	// Nothing within containers should be shown
	filters.push({ k: "system.container", o: "in", v: [null, undefined] });

	// If de-duplicating, the identifier must be fetched
	if ( deduplicate ) indexFields.add("system.identifier.value");

	// If type is provided, stick it into the types set
	if ( type ) types.add(type);

	// If filters are provided, merge their keys with any other fields needing to be indexed
	if ( filters?.length ) indexFields = indexFields.union(uniqueKeys(filters));

	// Iterate over all packs
	let documents = game.packs

		// Skip Packs that have the wrong document class
		.filter(p => p.metadata.type === documentClass.metadata.name

			// Do not show entries inside compendia that are not visible to current user
			&& p.visible

			// And if types are set and specified in the compendium flag, only include those that include the correct types
			&& (!types.size || !(p.metadata.flags[game.system.id]?.types || p.metadata.flags.types) ||
				new Set(p.metadata.flags[game.system.id]?.types ?? p.metadata.flags.types).intersects(types)))

		// Generate an index based on the needed fields
		.map(async p => await Promise.all((await p.getIndex({ fields: Array.from(indexFields) }))

			// Ensure all values have identifier if required
			.map(i => {
				if ( deduplicate && !i.system?.identifier?.value ) {
					foundry.utils.setProperty(i, "system.identifier.value", slugify$1(i.name, { strict: true }));
				}
				return i;
			})

			// Remove any documents that don't match the specified types or the provided filters
			.filter(i => types.has(i.type) && (!filters?.length || performCheck(i, filters)))

			// If full documents are required, retrieve those, otherwise stick with the indices
			.map(async i => index ? i : await fromUuid(i.uuid))
		));

	// Wait for everything to finish loading and flatten the arrays
	documents = (await Promise.all(documents)).flat();

	// De-duplicate results based on identifiers
	if ( deduplicate ) documents = Array.from(
		documents.reduce((map, d) => {
			const key = `${d.type}-${d.system.identifier.value}`;
			if ( !map.has(key) ) map.set(key, []);
			map.get(key).push(d);
			return map;
		}, new Map()).values()
	).map(a => a.pop());

	// Sort final results
	if ( sort === true ) sort = "name";
	if ( sort ) documents.sort((lhs, rhs) =>
		foundry.utils.getProperty(lhs, sort).localeCompare(foundry.utils.getProperty(rhs, sort))
	);

	return documents;
}

var search = /*#__PURE__*/Object.freeze({
	__proto__: null,
	compendiums: compendiums
});

/**
 * Get currently selected tokens in the scene or user's character's tokens.
 * @returns {Token5e[]}
 */
function getSelectedTokens() {
	let targets = canvas.tokens.controlled.filter(t => t.actor);
	if ( !targets.length && game.user.character ) targets = game.user.character.getActiveTokens();
	return targets;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Important information on a targeted token.
 *
 * @typedef {object} TargetDescriptor
 * @property {string} uuid - The UUID of the target.
 * @property {string} img - The target's image.
 * @property {string} name - The target's name.
 * @property {number} [ac] - The target's armor class, if applicable.
 */

/**
 * Grab the targeted tokens and return relevant information on them.
 * @returns {TargetDescriptor[]}
 */
function getTargetDescriptors() {
	const targets = new Map();
	for (const token of game.user.targets) {
		const { name } = token;
		const { img, system, uuid } = token.actor ?? {};
		if (uuid) targets.set(uuid, { name, img, uuid, ac: system?.attributes?.ac?.value });
	}
	return Array.from(targets.values());
}

const { ApplicationV2 } = foundry.applications.api;

/**
 * Base application from which all Black Flag applications should be based.
 */
class BFApplication extends ApplicationV2Mixin(ApplicationV2) {}

/**
 * Tooltip that displays notifications on a sheet.
 */
class NotificationTooltip extends BFApplication {
	constructor(doc, notificationKeys, options = {}) {
		super(options);
		this.document = doc;
		this.notificationKeys = notificationKeys;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		window: {
			frame: false,
			positioned: false
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		tooltip: {
			template: "systems/black-flag/templates/notification-tooltip.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Document for which the notifications should be displayed.
	 * @param {Document}
	 */
	document;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Notifications that should be displayed in the tooltip.
	 * @param {string[]}
	 */
	notificationKeys;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_insertElement(element) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.notifications = this.notificationKeys
			.reduce((arr, k) => {
				let doc = this.document;
				let notification = this.document.notifications.get(k);
				if (!notification) {
					const [first, ...rest] = k.split(".");
					if (rest?.length) doc = this.document.items.get(first);
					k = rest.join(".") ?? split[0];
					notification = doc?.notifications?.get(k);
				}
				if (!notification) return arr;
				notification = foundry.utils.deepClone(notification);
				notification.badge = this.constructor.generateBadge([notification], doc.uuid, { displayOrder: true });
				arr.push(notification);
				return arr;
			}, [])
			.sort((lhs, rhs) => lhs.order - rhs.order);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activate global tooltip listeners on the page.
	 */
	static activateListeners() {
		document.body.addEventListener(
			"pointerenter",
			event => {
				const element = event.target;
				if (!element.classList.contains("notification-badge")) return;
				this.renderTooltip(element);
			},
			true
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a badge for the provided set of notifications.
	 * @param {object[]} notifications - Notifications for which to generate the badge.
	 * @param {string} uuid - UUID of the document to which these notifications belong.
	 * @param {object} [options={}]
	 * @param {boolean} [options.displayOrder=false] - Should a number be displayed for the order?
	 * @returns {string}
	 */
	static generateBadge(notifications, uuid, { displayOrder = false } = {}) {
		let level = "info";
		let order = Infinity;
		for (const notification of notifications) {
			if (notification.level && notification.level !== level) {
				if (notification.level === "error") level = "error";
				else if (notification.level === "warn" && level !== "error") level = "warn";
			}
			if (notification.order && notification.order < order) order = notification.order;
		}

		let center;
		if (Number.isFinite(order) && displayOrder) {
			center = `<span class="order">${order}</span>`;
		} else {
			center = `<i class="${CONFIG.BlackFlag.notificationLevels[level]?.symbol ?? ""}"></i>`;
		}

		const keys = notifications.map(n => n.key).join(";");
		return `<div class="notification-badge" data-uuid="${uuid}" data-notification-level="${level}" data-notification-keys="${keys}">${center}</div>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Render this app to a tooltip.
	 * @param {HTMLElement} element - The element to which the tooltip should be attached.
	 */
	static async renderTooltip(element) {
		const keys = element.dataset.notificationKeys?.split(";");
		const uuid = element.dataset.uuid;
		if (!keys || !uuid) return;
		const doc = await fromUuid(uuid);
		const tooltip = new NotificationTooltip(doc, keys);
		await tooltip.render({ force: true });
		game.tooltip.activate(element, { content: tooltip.element, cssClass: "notification-tooltip" });
	}
}

/**
 * Object representing a nested set of choices to be displayed in a grouped select list or a trait selector.
 *
 * @typedef {object} SelectChoicesEntry
 * @property {string} label - Label, either pre- or post-localized.
 * @property {boolean} [chosen] - Has this choice been selected?
 * @property {boolean} [sorting=true] - Should this value be sorted? If there are a mixture of this value at
 *                                      a level, unsorted values are listed first followed by sorted values.
 * @property {SelectChoices} [children] - Nested choices.
 */

/**
 * Object with a number of methods for performing actions on a nested set of choices.
 *
 * @param {Record<string, SelectChoicesEntry>} [choices={}] - Initial choices for the object.
 * @param {Set<string>} [chosen=null] - Keys of entries that should be marked chosen by default.
 */
class SelectChoices {
	constructor(choices = {}, chosen = null) {
		const clone = foundry.utils.deepClone(choices);
		for (const [key, value] of Object.entries(clone)) {
			if (chosen) value.chosen = chosen.has(key);
			if (!value.children || value.children instanceof SelectChoices) continue;
			value.category = true;
			value.children = new this.constructor(value.children, chosen);
		}
		Object.assign(this, clone);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a set of available choice keys.
	 * @type {Set<string>}
	 */
	get set() {
		const set = new Set();
		for (const [key, choice] of Object.entries(this)) {
			if (!choice.children) set.add(key);
			else {
				if (choice.selectableCategory) set.add(`${key}!`);
				choice.children.set.forEach(k => set.add(k));
			}
		}
		return set;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve a value for the specific key.
	 * @param {string} key
	 * @returns {object}
	 */
	get(key) {
		const search = (data, key) => {
			for (const [k, v] of Object.entries(data)) {
				if (k === key) return v;
				if (v.children) {
					const result = search(v.children, key);
					if (result) return result;
				}
			}
		};
		return search(this, key);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a clone of this object.
	 * @returns {SelectChoices}
	 */
	clone() {
		const newData = {};
		for (const [key, value] of Object.entries(this)) {
			newData[key] = foundry.utils.deepClone(value);
			if (value.children) newData[key].children = value.children.clone();
		}
		const clone = new this.constructor(newData);
		return clone;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Find key and value for the provided key or key suffix.
	 * @param {string} key - Full prefixed key (e.g. `tool:art:alchemist`) or just the suffix (e.g. `alchemist`).
	 * @returns {[string, SelectChoicesEntry]|null} - An tuple with the first value being the matched key,
	 *                                                and the second being the value.
	 */
	find(key) {
		for (const [k, v] of Object.entries(this)) {
			if (k === key || k.endsWith(`:${key}`)) {
				return [k, v];
			} else if (v.children) {
				const result = v.children.find(key);
				if (result) return result;
			}
		}
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * This object represented as a flat list of form options.
	 * @param {object} [options={}]
	 * @param {boolean} [options.allOptions=false] - When a selectable category is found, also display all children.
	 * @param {string} [options.parentLabel] - Category label prefix.
	 * @param {string} [options.selected] - Entry to mark as selected.
	 * @returns {FormSelectOption[]}
	 */
	formOptions({ allOptions = false, parentLabel, selected } = {}) {
		const options = [];
		for (const [value, data] of Object.entries(this)) {
			const label = makeLabel(data);
			const option = {
				value,
				label,
				group: parentLabel,
				selected: selected !== undefined ? value === selected : data.chosen,
				disabled: data.disabled ?? false
			};
			if (!data.children || (data.selectableCategory && !allOptions)) options.push(option);
			else {
				const newParentLabel = parentLabel ? `${parentLabel} - ${label}` : label;
				if (data.selectableCategory)
					options.push({
						...option,
						label: game.i18n.format("BF.Trait.All", { category: label }),
						group: newParentLabel
					});
				if (data.children) options.push(...data.children.formOptions({ parentLabel: newParentLabel, selected }));
			}
		}
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Localize all the entries using either a localization key or label.
	 * @param {object} [options={}]
	 * @param {string} [options.pluralRule="one"] - Pluralization rule to use for all entries.
	 * @param {string} [options.categoryPluralRule] - Pluralization rule to use for categories, if different than default.
	 * @param {string} [options.labelKeyPath="label"] - Path to the standard label.
	 * @param {string} [options.localizationKeyPath="localization"] - Path to the pluralizable label.
	 * @returns {SelectOptions}
	 */
	localize({
		pluralRule = "one",
		categoryPluralRule,
		labelKeyPath = "label",
		localizationKeyPath = "localization"
	} = {}) {
		for (const v of Object.values(this)) {
			const pr = v.category && categoryPluralRule ? categoryPluralRule : pluralRule;
			v[labelKeyPath] = makeLabel(v, { pluralRule: pr, labelKeyPath, localizationKeyPath });
			if (v.children) v.children.localize({ pluralRule, categoryPluralRule, labelKeyPath, localizationKeyPath });
		}
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Localize all the entries using either a localization key or label, returning a new SelectOptions object.
	 * @param {object} [options]
	 * @returns {SelectOptions}
	 */
	toLocalized(options) {
		return this.clone().localize(options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Merge another SelectOptions object into this one.
	 * @param {SelectOptions} other
	 * @returns {SelectOptions}
	 */
	merge(other) {
		return foundry.utils.mergeObject(this, other);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Merge another SelectOptions object into this one, returning a new SelectOptions object.
	 * @param {SelectOptions} other
	 * @returns {SelectOptions}
	 */
	merged(other) {
		return this.clone().merge(other);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Internal sorting method.
	 * @param {object} lhs
	 * @param {object} rhs
	 * @returns {number}
	 */
	_sort(lhs, rhs) {
		if (lhs.sorting === false && rhs.sorting === false) return 0;
		if (lhs.sorting === false) return -1;
		if (rhs.sorting === false) return 1;
		return lhs.label.localeCompare(rhs.label);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sort the entries using the label.
	 * @returns {SelectOptions}
	 */
	sort() {
		const sorted = new SelectChoices(sortObjectEntries(this, { sortKey: this._sort }));
		for (const key of Object.keys(this)) delete this[key];
		this.merge(sorted);
		for (const entry of Object.values(this)) {
			if (entry.children) entry.children.sort();
		}
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sort the entries using the label, returning a new SelectOptions object.
	 * @returns {SelectOptions}
	 */
	sorted() {
		const sorted = new SelectChoices(sortObjectEntries(this, { sortKey: this._sort }));
		for (const entry of Object.values(sorted)) {
			if (entry.children) entry.children = entry.children.sorted();
		}
		return sorted;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Filters choices in place to only include the provided keys.
	 * @param {Set<string>|SelectChoices} filter - Keys of traits to retain or another SelectOptions object.
	 * @returns {SelectChoices} - This SelectChoices with filter applied.
	 */
	filter(filter) {
		if (filter instanceof SelectChoices) filter = filter.set;

		for (const [key, trait] of Object.entries(this)) {
			// Simple filter ("languages:standard:common") - Include this entry
			// Category filter ("tools:artisan") - Include category but not children
			const wildcardKey = key.replace(/(:|^)([\w]+)$/, "$1*");
			const forcedCategoryKey = `${key}!`;
			if (filter.has(key) && !filter.has(wildcardKey)) {
				if (trait.children) {
					if (filter.has(forcedCategoryKey)) {
						trait.children.filter(filter);
						if (foundry.utils.isEmpty(trait.children)) delete trait.children;
					} else delete trait.children;
				}
			}

			// Check children, remove entry if no children match filter
			else if (!filter.has(wildcardKey) && !filter.has(`${key}:*`)) {
				if (trait.children) trait.children.filter(filter);
				if (foundry.utils.isEmpty(trait.children ?? {})) delete this[key];
			}

			// Top-level wildcard ("languages:*") - Include all entries & children
			// Category wildcard ("tools:artisan:*") - Include category and all children
		}

		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Filters choices to only include the provided keys, returning a new SelectChoices object.
	 * @param {Set<string>|SelectChoices} filter - Keys of traits to retain or another SelectOptions object.
	 * @returns {SelectChoices} - Clone of SelectChoices with filter applied.
	 */
	filtered(filter) {
		return this.clone().filter(filter);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Removes in place any traits or categories the keys of which are included in the exclusion set.
	 * @param {Set<string>} keys - Set of keys to remove from the choices.
	 * @returns {SelectChoices} - This SelectChoices with excluded keys removed.
	 */
	exclude(keys) {
		for (const [key, trait] of Object.entries(this)) {
			// TODO: Handle wildcard keys
			if (keys.has(key)) delete this[key];
			else if (trait.children) trait.children = trait.children.exclude(keys);
		}
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Removes any traits or categories the keys of which are included in the exclusion set, returning a copy.
	 * @param {Set<string>} keys - Set of keys to remove from the choices.
	 * @returns {SelectChoices} - Clone of SelectChoices with excluded keys removed.
	 */
	excluded(keys) {
		return this.clone().exclude(keys);
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                   Handlebars Helpers                  */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper that converts the provided object into a series of `data-` entries.
 * @param {object} context - Current evaluation context.
 * @param {object} options - Handlebars options.
 * @returns {string}
 */
function dataset(context, options) {
	const entries = [];
	for ( let [key, value] of Object.entries(context ?? {}) ) {
		key = key.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (a, b) => (b ? "-" : "") + a.toLowerCase());
		entries.push(`data-${key}="${value}"`);
	}
	return new Handlebars.SafeString(entries.join(" "));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper to create a set of <option> elements in a <select> block grouped together
 * in <optgroup> based on the provided categories.
 *
 * @param {SelectChoices} choices - Choices to format.
 * @param {object} options
 * @param {string} [options.blank] - Name for the empty option, if one should be added.
 * @param {boolean} [options.rule] - Insert a <hr> after the empty option.
 * @returns {Handlebars.SafeString} - Formatted option list.
 */
function groupedSelectOptions(choices, options) {
	if ( !(choices instanceof SelectChoices) ) choices = new SelectChoices(choices);
	const formOptions = choices.formOptions({ ...options });
	if ( options.blank !== undefined ) {
		formOptions.unshift({ value: "", label: options.blank ?? "" });
		if ( options.rule ) formOptions.unshift({ rule: true });
	}
	return HandlebarsHelpers.selectOptions(formOptions, { hash: {} });
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper that fetch the appropriate item context from root and adds it to the first block parameter.
 * @param {object} context - Current evaluation context.
 * @param {object} options - Handlebars options.
 * @returns {string}
 */
function itemContext(context, options) {
	if ( arguments.length !== 2 ) throw new Error("#blackFlag-itemContext requires exactly one argument");
	if ( foundry.utils.getType(context) === "function" ) context = context.call(this);

	const contextObject = options.hash.context ?? options.data.root.itemContext;
	const ctx = contextObject?.[context.id];
	if ( !ctx ) {
		const inverse = options.inverse(this);
		if ( inverse ) return options.inverse(this);
	}

	return options.fn(context, { data: options.data, blockParams: [ctx] });
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * A helper to mark one or more `<option>` elements as selected.
 * Escape the string as handlebars would, then escape any regexp characters in it.
 * @param {string[]|Set<string>} selected - The value of the option.
 * @param {object} options - Handlebars options.
 * @returns {Handlebars.SafeString}
 */
function multiSelect(selected, options) {
	let html = options.fn(this);
	for ( const value of selected ) {
		const escapedValue = RegExp.escape(Handlebars.escapeExpression(value));
		const rgx = new RegExp(` value=["']${escapedValue}["']`);
		html = html.replace(rgx, "$& selected");
	}
	return html;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Display a notification badge if necessary.
 * @param {Document} document - Document from which the notifications should be gathered.
 * @param {object} options
 * @param {object} options.hash
 * @param {string} [options.hash.key] - Display if a notification of this key is set.
 * @param {Document|string} [options.hash.document] - Display if any notifications for this document are set.
 * @param {string} [options.hash.category] - Display if any notifications in this category are set.
 * @param {string} [options.hash.section] - Display if any notifications in this section are set.
 * @param {boolean} [options.hash.displayOrder] - Should a number be displayed for the order?
 * @returns {Handlebars.SafeString|void}
 */
function notificationBadge(document, options={}) {
	let { key, document: item, category, section, ...generationOptions } = options.hash;
	if ( !document.notifications ) return;
	if ( foundry.utils.getType(key) === "Object" ) key = key.string;
	if ( foundry.utils.getType(category) === "Object" ) category = category.string;
	if ( foundry.utils.getType(section) === "Object" ) section = section.string;

	let id = item;
	if ( foundry.utils.getType(item) === "Object" ) id = null;
	else item = null;

	// TODO: If section is set to "auto" and a document ID is provided, determine section using sheet sections

	const getNotifications = (document, key, id, category, section, child=false) => {
		let notifications = [];
		if ( key ) {
			if ( key.endsWith("*") ) {
				notifications = document.notifications.filter(notification =>
					notification.key.startsWith(key.replace("*", ""))
				);
			} else {
				const notification = document.notifications.get(key);
				if ( notification ) notifications.push(notification);
			}
		} else if ( id || category || section ) {
			notifications = document.notifications.filter(notification => {
				if ( id && (id !== notification.document) ) return false;
				if ( category && (category !== notification.category) ) return false;
				if ( section && (section !== notification.section) ) return false;
				return true;
			});
		} else if ( child ) {
			notifications = document.notifications.contents;
		}
		if ( child ) {
			notifications = foundry.utils.deepClone(notifications);
			notifications.forEach(n => n.key = `${document.id}.${n.key}`);
		}
		return notifications;
	};

	let notifications = getNotifications(document, key, id, category, section);
	if ( item ) notifications = notifications.concat(getNotifications(item, key, id, category, section, true));

	if ( !notifications.length ) return;

	return new Handlebars.SafeString(NotificationTooltip.generateBadge(notifications, document.uuid, generationOptions));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register custom Handlebars helpers for use by the system.
 */
function registerHandlebarsHelpers() {
	Handlebars.registerHelper({
		"blackFlag-dataset": dataset,
		"blackFlag-groupedSelectOptions": (choices, options) => groupedSelectOptions(choices, options.hash),
		"blackFlag-itemContext": itemContext,
		"blackFlag-linkForUUID": (uuid, options) => new Handlebars.SafeString(linkForUUID(uuid, options.hash)),
		"blackFlag-multiSelect": multiSelect,
		"blackFlag-notificationBadge": notificationBadge,
		"blackFlag-number": (number, options) => numberFormat(number, options.hash),
		"blackFlag-numberParts": (number, options) =>
			new Handlebars.SafeString(numberParts(number, options.hash)),
		"blackFlag-signedNumber": (number, options) =>
			new Handlebars.SafeString(numberParts(number, { sign: true, ...options.hash }))
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                  Handlebars Partials                  */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register & pre-load handlebars partial templates.
 * @returns {Promise}
 */
async function registerHandlebarsPartials() {
	const partials = [
		"active-effect/active-effect-change.hbs",
		"activity/parts/activity-activation-notes.hbs",
		"activity/parts/activity-inventory-row.hbs",
		"actor/config/modifier-list.hbs",
		"actor/pc-actions.hbs",
		"actor/embeds/statblock-actions-embed.hbs",
		"actor/parts/actor-active-effects.hbs",
		"actor/parts/modifier-list-v2.hbs",
		"actor/parts/statblock-abilities.hbs",
		"actor/parts/statblock-actions.hbs",
		"actor/parts/statblock-hit-points.hbs",
		"actor/parts/statblock-resistances.hbs",
		"actor/tabs/npc-biography.hbs",
		"actor/tabs/npc-features.hbs",
		"actor/tabs/npc-main.hbs",
		"actor/tabs/pc-biography.hbs",
		"actor/tabs/pc-features.hbs",
		"actor/tabs/pc-inventory.hbs",
		"actor/tabs/pc-main.hbs",
		"actor/tabs/pc-progression.hbs",
		"actor/tabs/pc-spellcasting.hbs",
		"actor/tabs/siege-main.hbs",
		"actor/tabs/vehicle-main.hbs",
		"advancement/parts/advancement-controls.hbs",
		"advancement/parts/advancement-name.hbs",
		"advancement/parts/advancement-spell-configuration.hbs",
		"chat/parts/card-activities.hbs",
		"chat/parts/card-deltas.hbs",
		"item/concept-summary.hbs",
		"item/parts/equipment-attunement.hbs",
		"item/parts/equipment-categories.hbs",
		"item/parts/equipment-description.hbs",
		"item/parts/item-active-effects.hbs",
		"item/parts/item-active-effects-section.hbs",
		"item/parts/item-activities.hbs",
		"item/parts/item-advancement.hbs",
		"item/parts/item-description.hbs",
		"journal/journal-table.hbs",
		"shared/currency.hbs",
		"shared/inventory.hbs",
		"shared/trait-list.hbs",
		"shared/uses-config.hbs",
		"shared/parts/activity-affects.hbs",
		"shared/parts/activity-range.hbs",
		"shared/parts/activity-template.hbs",
		"shared/parts/document-source.hbs",
		"shared/parts/fieldlist.hbs",
		"shared/parts/inventory-collapsible.hbs",
		"shared/parts/inventory-controls.hbs",
		"shared/parts/inventory-summary.hbs"
	];

	const paths = {};
	for ( let path of partials ) {
		path = `systems/${game.system.id}/templates/${path}`;
		paths[`blackFlag.${path.split("/").pop().replace(".hbs", "")}`] = path;
	}

	return loadTemplates(paths);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                      Application                      */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Get the key path to the specified trait on an actor.
 * @param {string} trait - Trait as defined in `CONFIG.BlackFlag.traits`.
 * @returns {string} - Key path to this trait's object within an actor's data.
 */
function actorKeyPath(trait) {
	const traitConfig = CONFIG.BlackFlag.traits[trait];
	if ( !traitConfig ) return "";
	if ( traitConfig.actorKeyPath ) return traitConfig.actorKeyPath;
	const prefix = traitConfig.type === "proficiency" ? "proficiencies" : "traits";
	return `system.${prefix}.${trait}`;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Get the current trait values for the provided actor.
 * @param {BlackFlagActor} actor
 * @param {string} trait - Trait as defined in `CONFIG.BlackFlag.traits`.
 * @returns {Record<string, number>}
 */
function actorValues(actor, trait) {
	const keyPath = actorKeyPath(trait);
	const data = foundry.utils.getProperty(actor, keyPath);
	if ( !data ) return {};
	const traitChoices = choices(trait, { prefixed: true });
	const values = {};

	const field = actor.system.schema.getField(keyPath.replace("system.", ""));
	if ( field instanceof MappingField ) {
		Object.entries(data).forEach(([k, d]) => {
			const key = traitChoices.find(k)?.[0];
			if ( !key ) return;
			values[key] = foundry.utils.getProperty(d, `${trait === "saves" ? "save." : ""}proficiency.multiplier`);
		});
	} else {
		data.value.forEach(v => {
			const key = traitChoices.find(v)?.[0];
			if ( key ) values[key] = 1;
		});
	}

	return values;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Calculate the change key path for a provided trait key.
 * @param {string} key - Key for a trait to set.
 * @param {string} [trait] - Trait as defined in `CONFIG.BlackFlag.traits`, only needed if key isn't prefixed.
 * @returns {string|void}
 */
function changeKeyPath(key, trait) {
	const split = key.split(":");
	if ( !trait ) trait = split.shift();

	const traitConfig = CONFIG.BlackFlag.traits[trait];
	if ( !traitConfig ) return;

	let keyPath = actorKeyPath(trait);

	if ( trait === "saves" ) {
		return `${keyPath}.${split.pop()}.save.proficiency.multiplier`;
	} else if ( traitConfig.format === "complex" ) {
		return `${keyPath}.${split.pop()}.proficiency.multiplier`;
	} else {
		return `${keyPath}.value`;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Find the configuration object for the provided trait key.
 * @param {string} key - Key for which the configuration should be found.
 * @param {object} [options={}]
 * @param {string} [options.trait] - Explicitly set trait type if non-prefixed key is provided.
 * @returns {object|void}
 */
function configForKey(key, { trait }={}) {
	const parts = key.split(":");
	if ( !trait && (parts.length < 2) ) return;
	else trait ??= parts.shift();

	const traitConfig = CONFIG.BlackFlag.traits[trait];
	const traitData = CONFIG.BlackFlag[traitConfig.configKey ?? trait];

	// Top-level trait or non-prefixed key
	if ( parts.length === 1 ) {
		const searchCategory = (data, key) => {
			for ( const [k, v] of Object.entries(data) ) {
				if ( k === key ) return v;
				if ( v.children ) {
					const result = searchCategory(v.children, key);
					if ( result ) return result;
				}
			}
		};
		return searchCategory(traitData, parts.shift());
	}

	// Prefixed key
	else {
		const searchCategory = (data, parts) => {
			key = parts.shift();
			if ( parts.length ) return searchCategory(data[key]?.children ?? {}, parts);
			else return data[key];
		};
		return searchCategory(traitData, parts);
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                         Lists                         */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Fetch the categories object for the specified trait type.
 * @param {string} trait - Trait as defined in `CONFIG.BlackFlag.traits`.
 * @returns {object} - Trait categories defined within `CONFIG.BlackFlag`.
 */
function categories(trait) {
	return CONFIG.BlackFlag[CONFIG.BlackFlag.traits[trait]?.configKey ?? trait] ?? {};
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Get a list of choices for a specific trait.
 * @param {string} trait - Trait as defined in `CONFIG.BlackFlag.traits`.
 * @param {object} [options={}]
 * @param {Set<string>} [options.chosen=[]] - Optional list of keys to be marked as chosen.
 * @param {boolean} [options.prefixed=false] - Prefix keys with the trait type.
 * @param {boolean} [options.any=false] - Should an "Any" option be added to each category?
 * @param {boolean} [options.category=false] - Should the category be selectable in addition to its children?
 * @returns {SelectChoices} - Object mapping proficiency ids to choice objects.
 */
function choices(trait, { chosen=new Set(), prefixed=false, any=false, category=false }={}) {
	const traitConfig = CONFIG.BlackFlag.traits[trait];
	if ( !traitConfig ) return new SelectChoices();
	if ( foundry.utils.getType(chosen) === "Array" ) chosen = new Set(chosen);

	let result = {};
	if ( prefixed && any ) {
		const key = `${trait}:*`;
		result[key] = { label: keyLabel(key).titleCase(), chosen: chosen.has(key), sorting: false, wildcard: true };
	}

	const prepareCategory = (key, data, result, prefix) => {
		let label = foundry.utils.getType(data) === "Object"
			? foundry.utils.getProperty(data, traitConfig.labelKeyPath ?? "label") : data;
		if ( !label ) {
			const localization = foundry.utils.getProperty(data, "localization");
			if ( localization ) label = `${localization}[other]`;
			else label = key;
		}
		if ( prefixed ) key = `${prefix}:${key}`;
		result[key] = {
			label: game.i18n.localize(label),
			chosen: chosen.has(key),
			sorting: traitConfig.sortCategories !== false
		};
		if ( data.children ) {
			result[key].selectableCategory = data?.selectableCategory ?? false;
			const children = result[key].children = {};
			if ( category && data?.selectableCategory !== false ) {
				children[key] = { label: result[key].label, chosen: chosen.has(key), sorting: false };
			}
			if ( any ) {
				const anyKey = `${key}:*`;
				children[anyKey] = {
					label: keyLabel(anyKey, { trait }).titleCase(), chosen: chosen.has(anyKey), sorting: false, wildcard: true
				};
			}
			Object.entries(data.children).forEach(([k, v]) => prepareCategory(k, v, children, key));
		}
	};

	Object.entries(categories(trait)).forEach(([k, v]) => prepareCategory(k, v, result, trait));

	return new SelectChoices(result).sorted();
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Prepare an object with all possible choices from a set of keys. These choices will be grouped by
 * trait type if more than one type is present.
 * @param {Set<string>} keys - Prefixed trait keys.
 * @returns {SelectChoices}
 */
function mixedChoices(keys) {
	if ( !keys.size ) return new SelectChoices();
	const types = {};
	for ( const key of keys ) {
		const split = key.split(":");
		const trait = split.shift();
		const selectChoices = choices(trait, { prefixed: true }).filtered(new Set([key]));
		types[trait] ??= { label: traitLabel(trait), children: new SelectChoices() };
		types[trait].children.merge(selectChoices);
	}
	if ( Object.keys(types).length > 1 ) return new SelectChoices(types);
	return Object.values(types)[0].children;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                     Localization                      */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Get the localized label for a specific trait type.
 * @param {string} trait - Trait as defined in `CONFIG.BlackFlag.traits`.
 * @param {number} [count] - Count used to determine pluralization. If no count is provided, will default to
 *                           the 'other' pluralization.
 * @returns {string}
 */
function traitLabel(trait, count) {
	const traitConfig = CONFIG.BlackFlag.traits[trait];
	const pluralRule = ( count !== undefined ) ? new Intl.PluralRules(game.i18n.lang).select(count) : "other";
	if ( !traitConfig ) return game.i18n.localize(`BF.Trait.Label[${pluralRule}]`);
	return game.i18n.localize(`${traitConfig.labels.localization}[${pluralRule}]`);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Retrieve the proper display label for the provided key.
 * @param {string} key - Key for which to generate the label.
 * @param {object} [config={}]
 * @param {number} [config.count] - Number to display, only if a wildcard is used as final part of key.
 * @param {string} [config.trait] - Trait as defined in `CONFIG.BlackFlag.traits` if not using a prefixed key.
 * @param {boolean} [config.final] - Is this the final in a list?
 * @param {"label"|"localization"} [config.priority] - If both a label and a localization string are found, which one
 *                                                     should be preferred?
 * @returns {string}
 */
function keyLabel(key, { count, trait, final, priority }={}) {
	let parts = key.split(":");
	const localizedCount = count ? numberFormat(count, { spelledOut: true }) : null;
	priority ??= count ? "localization" : "label";

	if ( !trait || trait === parts[0] ) trait = parts.shift();
	const traitConfig = CONFIG.BlackFlag.traits[trait];
	if ( !traitConfig ) return key;
	const pluralRule = getPluralRules().select(count ?? 1);
	const type = game.i18n.localize(`${traitConfig.labels.localization}[${pluralRule}]`).toLowerCase();

	const searchTrait = (parts, traits, type) => {
		const firstKey = parts.shift();

		if ( firstKey === "*" ) {
			const key = `BF.Advancement.Trait.Choice.${final ? "Other" : `Any${count ? "Counted" : "Uncounted"}`}`;
			return game.i18n.format(key, { count: localizedCount, type });
		}

		let category = traits[firstKey];
		if ( !category && !parts.length ) category = configForKey(firstKey, { trait });
		if ( !category ) return key;
		let label = foundry.utils.getProperty(category, traitConfig.labelKeyPath ?? "label");
		const localization = foundry.utils.getProperty(category, "localization");
		const categoryPluralRule = count ? pluralRule : "other";
		if ( foundry.utils.getType(category) !== "Object" ) label = category;
		else if ( priority === "label" ) label ??= `${localization}[${categoryPluralRule}]`;
		else if ( localization ) label = `${localization}[${categoryPluralRule}]`;

		if ( !parts.length ) {
			if ( !label ) return key;
			return game.i18n.localize(label);
		}

		if ( !category.children ) return key;

		if ( localization ) type = game.i18n.localize(`${localization}[${getPluralRules().select(count ?? 1)}]`);
		else type = label;

		return searchTrait(parts, category.children, type);
	};

	return searchTrait(parts, categories(trait), type);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a human readable description of the provided choice.
 * @param {TraitChoice} choice - Data for a specific choice.
 * @param {object} [options={}]
 * @param {boolean} [options.only=false] - Is this choice on its own, or part of a larger list?
 * @param {boolean} [options.final=false] - If this choice is part of a list of other grants or choices,
 *                                          is it in the final position?
 * @param {string} [options.trait] - Explicitly set trait type if non-prefixed keys are provided.
 * @returns {string}
 */
function choiceLabel(choice, { only=false, final=false, trait }={}) {
	if ( !choice.pool.size ) return "";
	const count = numberFormat(choice.count, { spelledOut: true });

	// Single entry in pool
	// { count: 3, pool: ["skills:*"] } -> any three skills
	// { count: 3, pool: ["skills:*"] } (final) -> three other skills
	if ( (choice.pool.size === 1) ) {
		return keyLabel(choice.pool.first(), {
			count: (choice.count > 1 || !only) ? choice.count : null, final: final && !only, trait
		});
	}

	const listFormatter = new Intl.ListFormat(game.i18n.lang, { type: "disjunction" });

	// Singular count
	// { count: 1, pool: ["skills:*"] } -> any skill
	// { count: 1, pool: ["thief", "skills:*"] } -> Thieves Tools or any skill
	// { count: 1, pool: ["thief", "tools:artisan:*"] } -> Thieves' Tools or any artisan tool
	if ( (choice.count === 1) && only ) {
		return listFormatter.format(choice.pool.map(p => keyLabel(p, { trait })));
	}

	// Select from a list of options
	// { count: 2, pool: ["thief", "skills:*"] } -> Choose two from thieves tools or any skill
	const choices = choice.pool.map(key => keyLabel(key, { trait }));
	return game.i18n.format("BF.Advancement.Trait.Choice.List", {
		count: count,
		list: listFormatter.format(choices)
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a human readable description of trait grants & choices.
 * @param {Set<string>} grants - Guaranteed trait grants.
 * @param {TraitChoice[]} [choices=[]] - Trait choices.
 * @param {object} [options={}]
 * @param {string} [options.choiceMode="inclusive"] - Choice mode.
 * @param {string} [options.style="long"] - List style type used (see Intl.ListFormat).
 * @param {string} [options.trait] - Explicitly set trait type if non-prefixed keys are provided.
 * @returns {string}
 */
function localizedList(grants, choices=[], { choiceMode="inclusive", style="long", trait }={}) {
	const choiceSections = [];

	for ( const [index, choice] of choices.entries() ) {
		const final = choiceMode === "exclusive" ? false : index === choices.length - 1;
		choiceSections.push(choiceLabel(choice, { final, only: !grants.size && choices.length === 1 }));
	}

	let sections = Array.from(grants).map(g => keyLabel(g, { trait }));
	if ( choiceMode === "inclusive" ) {
		sections = sections.concat(choiceSections);
	} else {
		const choiceListFormatter = new Intl.ListFormat(game.i18n.lang, { style, type: "disjunction" });
		sections.push(choiceListFormatter.format(choiceSections));
	}

	const listFormatter = new Intl.ListFormat(game.i18n.lang, { style, type: "conjunction" });
	if ( !sections.length || grants.size ) return listFormatter.format(sections);
	return game.i18n.format("BF.Advancement.Trait.Choice.Wrapper", {
		choices: listFormatter.format(sections)
	});
}

var trait = /*#__PURE__*/Object.freeze({
	__proto__: null,
	actorKeyPath: actorKeyPath,
	actorValues: actorValues,
	categories: categories,
	changeKeyPath: changeKeyPath,
	choiceLabel: choiceLabel,
	choices: choices,
	configForKey: configForKey,
	keyLabel: keyLabel,
	localizedList: localizedList,
	mixedChoices: mixedChoices,
	traitLabel: traitLabel
});

/**
 * Version of Map that includes a default value that will be used whenever retrieving a value if its key doesn't exist.
 */
class DefaultMap extends Map {
	constructor(iterable, makeDefault) {
		super(iterable);
		this.#makeDefault = makeDefault;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Function used to create the default value for this map.
	 * @type {Function<DefaultMap: Any>}
	 */
	#makeDefault;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get(key) {
		if ( !this.has(key) ) this.set(key, this.#makeDefault(this));
		return super.get(key);
	}
}

var utils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DefaultMap: DefaultMap,
	Search: search,
	Trait: trait,
	areKeysPressed: areKeysPressed,
	buildRoll: buildRoll,
	cleanedObjectUpdate: cleanedObjectUpdate,
	convertWeight: convertWeight,
	filter: filter$1,
	filteredKeys: filteredKeys,
	flattenChildren: flattenChildren,
	formatCR: formatCR,
	formatDistance: formatDistance,
	formatNumber: formatNumber,
	formatPace: formatPace,
	formatTaggedList: formatTaggedList,
	formatTime: formatTime,
	formatVolume: formatVolume,
	formatWeight: formatWeight,
	getAttributeOption: getAttributeOption,
	getNumberFormatter: getNumberFormatter,
	getPluralRules: getPluralRules,
	getSelectedTokens: getSelectedTokens,
	getTargetDescriptors: getTargetDescriptors,
	insertBetween: insertBetween,
	linkForUUID: linkForUUID,
	localizeConfig: localizeConfig,
	localizeSchema: localizeSchema,
	log: log,
	makeLabel: makeLabel,
	makeLabels: makeLabels,
	migration: migration,
	numberFormat: numberFormat,
	numberParts: numberParts,
	registerHandlebarsHelpers: registerHandlebarsHelpers,
	registerHandlebarsPartials: registerHandlebarsPartials,
	replaceFormulaData: replaceFormulaData,
	simplifyBonus: simplifyBonus,
	simplifyFormula: simplifyFormula,
	slugify: slugify$1,
	sortObjectEntries: sortObjectEntries,
	staticID: staticID,
	stepDenomination: stepDenomination,
	systemVersion: systemVersion,
	validators: validation
});

const { ObjectField: ObjectField$5, SchemaField: SchemaField$12, SetField: SetField$u, StringField: StringField$15 } = foundry.data.fields;

/**
 * Extend the base ActiveEffect class to implement system-specific logic.
 */
class BlackFlagActiveEffect extends ActiveEffect {
	/**
	 * Status effect for the various conditions.
	 * @type {Record<string, string>}
	 */
	static ID = {
		ENCUMBERED: staticID("bfencumbered"),
		EXHAUSTION: staticID("bfexhaustion")
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Additional key paths to properties added during base data preparation that should be treated as formula fields.
	 * @type {Set<string>}
	 */
	static FORMULA_FIELDS = new Set([
		"system.attributes.encumbrance.bonuses.encumbered",
		"system.attributes.encumbrance.bonuses.heavilyEncumbered",
		"system.attributes.encumbrance.bonuses.maximum",
		"system.attributes.encumbrance.bonuses.overall",
		"system.attributes.encumbrance.multipliers.encumbered",
		"system.attributes.encumbrance.multipliers.heavilyEncumbered",
		"system.attributes.encumbrance.multipliers.maximum",
		"system.attributes.encumbrance.multipliers.overall",
		"system.traits.movement.multiplier"
	]);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static async _fromStatusEffect(statusId, { reference, ...effectData }, options) {
		if (!("description" in effectData) && reference) effectData.description = `@Embed[${reference} inline]`;
		return super._fromStatusEffect(statusId, effectData, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get isSuppressed() {
		if (!this.parent?.isEmbedded || this.type === "enchantment") return false;
		return this.suppressionReasons.length > 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * One or more reasons why this effect is suppressed.
	 * @type {string[]}
	 */
	get suppressionReasons() {
		const reasons = [];
		if (this.parent.parent?.type !== "pc") return reasons;
		if (this.parent.getFlag(game.system.id, "relationship.enabled") === false) {
			reasons.push("BF.EFFECT.SuppressionReason.Disabled");
		}
		if (this.parent.system.equippable && !this.parent.system.equipped) {
			reasons.push("BF.EFFECT.SuppressionReason.NotEquipped");
		}
		if (this.parent.system.attunement?.value === "required" && !this.parent.system.attuned) {
			reasons.push("BF.EFFECT.SuppressionReason.NotAttuned");
		}
		return reasons;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		if (this.id !== this.constructor.ID.EXHAUSTION) return;

		// Change name and icon to match exhaustion level
		let level = this.getFlag("black-flag", "level");
		if (!Number.isFinite(level)) level = 1;
		this.img = `systems/black-flag/artwork/statuses/exhaustion-${level}.svg`;
		this.name = game.i18n.format("BF.Condition.Exhaustion.Numbered", { level: numberFormat(level) });
		if (level >= 6) this.statuses.add("dead");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Effect Application          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	apply(doc, change) {
		// Handle special actor flags
		if (change.key.startsWith("flags.black-flag.")) {
			const config = CONFIG.BlackFlag.actorFlags[change.key.replace("flags.black-flag.", "")];
			if (config?.actorTypes.has(doc.type)) return this.constructor.applyField(doc, change, config.field);
		}

		// Properly handle formulas that don't exist as part of the data model
		if (this.constructor.FORMULA_FIELDS.has(change.key)) {
			const value = foundry.utils.getProperty(doc, change.key) ?? null;
			const field = new FormulaField({ deterministic: true });
			const update = field.applyChange(value, null, change);
			foundry.utils.setProperty(doc, change.key, update);
			return { [change.key]: update };
		}

		// Handle activity-targeted changes
		if ((change.key.startsWith("activities[") || change.key.startsWith("system.activities.")) && doc instanceof Item) {
			return this.applyActivity(doc, change);
		}

		return super.apply(doc, change);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply a change to activities on this item.
	 * @param {BlackFlagItem} item - The Item to whom this change should be applied.
	 * @param {EffectChangeData} change - The change data being applied.
	 * @returns {Record<string, *>} - An object of property paths and their updated values.
	 */
	applyActivity(item, change) {
		const changes = {};
		const apply = (activity, key) => {
			const c = this.apply(activity, { ...change, key });
			Object.entries(c).forEach(([k, v]) => (changes[`system.activities.${activity.id}.${k}`] = v));
		};
		if (change.key.startsWith("system.activities.")) {
			const [, , id, ...keyPath] = change.key.split(".");
			const activity = item.system.activities?.get(id);
			if (activity) apply(activity, keyPath.join("."));
		} else {
			const { type, key } = change.key.match(/activities\[(?<type>[^\]]+)]\.(?<key>.+)/)?.groups ?? {};
			item.system.activities?.byType(type)?.forEach(activity => apply(activity, key));
		}
		return changes;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static applyField(model, change, field) {
		field ??= model.schema.getField(change.key);
		change = foundry.utils.deepClone(change);
		const current = foundry.utils.getProperty(model, change.key);
		const modes = CONST.ACTIVE_EFFECT_MODES;

		// Replace value when using string interpolation syntax
		if (field instanceof StringField$15 && change.mode === modes.OVERRIDE && change.value.includes("{}")) {
			change.value = change.value.replace("{}", current ?? "");
		}

		// If current value is `null`, UPGRADE & DOWNGRADE should always just set the value
		if (current === null && [modes.UPGRADE, modes.DOWNGRADE].includes(change.mode)) change.mode = modes.OVERRIDE;

		// Handle removing entries from sets
		if (field instanceof SetField$u && change.mode === modes.ADD && foundry.utils.getType(current) === "Set") {
			for (const value of field._castChangeDelta(change.value)) {
				const neg = value.replace(/^\s*-\s*/, "");
				if (neg !== value) current.delete(neg);
				else current.add(value);
			}
			return current;
		}

		// If attempting to apply active effect to empty MappingField entry, create it
		if (current === undefined && change.key.startsWith("system.")) {
			let keyPath = change.key;
			let mappingField = field;
			while (!(mappingField instanceof MappingField) && mappingField) {
				if (mappingField.name) keyPath = keyPath.substring(0, keyPath.length - mappingField.name.length - 1);
				mappingField = mappingField.parent;
			}
			if (mappingField && foundry.utils.getProperty(model, keyPath) === undefined) {
				const created = mappingField.model.initialize(mappingField.model.getInitialValue(), mappingField);
				foundry.utils.setProperty(model, keyPath, created);
			}
		}

		// Parse any JSON provided when targeting an object
		if (field instanceof ObjectField$5 || field instanceof SchemaField$12) {
			change = { ...change, value: this.prototype._parseOrString(change.value) };
		}

		return super.applyField(model, change, field);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_applyUpgrade(actor, change, current, delta, changes) {
		if (current === null) return this._applyOverride(actor, change, current, delta, changes);
		// TODO: Apply fix for this core issue: https://github.com/foundryvtt/foundryvtt/issues/11527
		// Can be removed and replaced with super._applyUpgrade(actor, change, current, delta, changes);
		// when the system goes V13-only
		let update;
		const ct = foundry.utils.getType(current);
		switch (ct) {
			case "boolean":
			case "number":
				if (change.mode === CONST.ACTIVE_EFFECT_MODES.UPGRADE && delta > current) update = delta;
				else if (change.mode === CONST.ACTIVE_EFFECT_MODES.DOWNGRADE && delta < current) update = delta;
				break;
		}
		if (update !== undefined) changes[change.key] = update;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create conditions that are applied alongside initial effect.
	 * @returns {Promise<BlackFlagActiveEffect[]>} - Created effects.
	 */
	async createRiderConditions() {
		const riders = new Set(
			this.statuses.reduce((arr, status) => {
				const r = CONFIG.statusEffects.find(e => e.id === status)?.riders ?? [];
				return arr.concat(r);
			}, [])
		);

		const created = [];
		for (const rider of riders) {
			const effect = await this.parent.toggleStatusEffect(rider, { active: true });
			if (effect instanceof BlackFlagActiveEffect) created.push(effect);
		}

		return created;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onCreate(data, options, userId) {
		await super._onCreate(data, options, userId);
		if (userId === game.userId) {
			if (this.active && this.parent instanceof Actor) await this.createRiderConditions();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onUpdate(data, options, userId) {
		super._onUpdate(data, options, userId);
		const originalLevel = foundry.utils.getProperty(options, `${game.system.id}.originalExhaustion`);
		const newLevel = foundry.utils.getProperty(data, `flags.${game.system.id}.level`);
		const originalEncumbrance = foundry.utils.getProperty(options, `${game.system.id}.originalEncumbrance`);
		const newEncumbrance = data.statuses?.[0];
		const name = this.name;

		// Display proper scrolling status effects for exhaustion
		if (this.id === this.constructor.ID.EXHAUSTION && Number.isFinite(newLevel) && Number.isFinite(originalLevel)) {
			if (newLevel === originalLevel) return;
			if (newLevel < originalLevel)
				this.name = game.i18n.format("BF.Condition.Exhaustion.Numbered", {
					level: numberFormat(originalLevel)
				});
			this._displayScrollingStatus(newLevel > originalLevel);
			this.name = name;
		}

		// Display proper scrolling status effects for encumbrance
		else if (this.id === this.constructor.ID.ENCUMBERED && originalEncumbrance && newEncumbrance) {
			if (newEncumbrance === originalEncumbrance) return;
			const increase =
				!originalEncumbrance ||
				(originalEncumbrance === "encumbered" && newEncumbrance) ||
				newEncumbrance === "exceedingCarryingCapacity";
			if (!increase) this.name = CONFIG.BlackFlag.encumbrance.effects[originalEncumbrance].name;
			this._displayScrollingStatus(increase);
			this.name = name;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Levels Handling           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Register listeners for custom exhaustion handling in the TokenHUD.
	 */
	static registerHUDListeners() {
		Hooks.on("renderTokenHUD", this._onTokenHUDRender);
		document.addEventListener("click", this._onClickTokenHUD.bind(this), { capture: true });
		document.addEventListener("contextmenu", this._onClickTokenHUD.bind(this), { capture: true });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Adjust exhaustion icon display to match current level.
	 * @param {Application} app - The TokenHUD application.
	 * @param {jQuery} html - The TokenHUD HTML.
	 * @protected
	 */
	static _onTokenHUDRender(app, html) {
		const actor = app.object.actor;
		const level = foundry.utils.getProperty(actor, "system.attributes.exhaustion");
		if (Number.isFinite(level) && level > 0) {
			html.find('[data-status-id="exhaustion"]').css({
				objectPosition: "-100px",
				background: `url('systems/black-flag/artwork/statuses/exhaustion-${level}.svg') no-repeat center / contain`
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Implement custom exhaustion cycling when interacting with the Token HUD.
	 * @param {PointerEvent} event - The triggering event.
	 * @protected
	 */
	static _onClickTokenHUD(event) {
		const { target } = event;
		if (!target.classList?.contains("effect-control") || target.dataset?.statusId !== "exhaustion") return;
		const actor = canvas.hud.token.object?.actor;
		let level = foundry.utils.getProperty(actor ?? {}, "system.attributes.exhaustion");
		if (!Number.isFinite(level)) return;
		event.preventDefault();
		event.stopPropagation();
		if (event.button === 0) level++;
		else level--;
		actor.update({ "system.attributes.exhaustion": Math.clamp(level, 0, 6) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create an ActiveEffect instance from some status effect data.
	 * @param {string|object} effectData - The status effect ID or its data.
	 * @param {DocumentModificationContext} [options] - Additional options to pass to ActiveEffect instantiation.
	 * @returns {BlackFlagActiveEffect|void}
	 */
	static fromStatusEffect(effectData, options = {}) {
		if (typeof effectData === "string") effectData = CONFIG.statusEffects.find(e => e.id === effectData);
		if (foundry.utils.getType(effectData) !== "Object") return;
		const createData = {
			...foundry.utils.deepClone(effectData),
			_id: staticID(`bf${effectData.id}`),
			name: game.i18n.localize(effectData.name),
			statuses: [effectData.id, ...(effectData.statuses ?? [])]
		};
		this.migrateDataSafe(createData);
		this.cleanData(createData);
		return new this(createData, { keepId: true, ...options });
	}
}

/**
 * Specialized ContextMenu class for displaying at mouse position.
 */
class BlackFlagContextMenu extends (foundry.applications?.ui?.ContextMenu ?? ContextMenu) {
	/** @override */
	_setPosition(html, target, options) {
		if (game.release.generation > 12) {
			html.classList.add("black-flag");
			return this._setFixedPosition(html, target, options);
		}

		html = html[0];
		target = target[0];

		document.body.appendChild(html);
		const { clientWidth, clientHeight } = document.documentElement;
		const { width, height } = html.getBoundingClientRect();

		const { clientX, clientY } = window.event;
		const left = Math.min(clientX, clientWidth - width);
		this._expandUp = clientY + height > clientHeight;
		html.classList.add("black-flag");
		html.classList.toggle("expand-up", this._expandUp);
		html.classList.toggle("expand-down", !this._expandUp);
		html.style.visibility = "";
		html.style.insetInlineStart = `${left}px`;
		if (this._expandUp) html.style.insetBlockEnd = `${clientHeight - clientY}px`;
		else html.style.insetBlockStart = `${clientY}px`;
		target.classList.add("context");
	}
}

/**
 * Abstract custom element that connects with a Foundry application.
 */
class AppAssociatedElement extends HTMLElement {
	connectedCallback() {
		this.#app =
			ui.windows[this.closest(".app")?.dataset.appid] ??
			foundry.applications.instances.get(this.closest(".application")?.id);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Reference to the application that contains this component.
	 * @type {Application}
	 */
	#app;

	get app() {
		return this.#app;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can the contents of the associated app be edited?
	 * @type {boolean}
	 */
	get isEditable() {
		return this.app.isEditable ?? true;
	}
}

class DocumentSheetAssociatedElement extends AppAssociatedElement {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Document containing this inventory.
	 * @type {Document}
	 */
	get document() {
		return this.app.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does the user have permission to edit the document?
	 * @type {boolean}
	 */
	get isEditable() {
		return this.app.isEditable;
	}
}

/**
 * Custom element for displaying the active effects on actor or item sheets.
 */
class EffectsElement extends DocumentSheetAssociatedElement {
	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		const { signal } = this.#controller;

		this.addEventListener("drop", this._onDrop.bind(this), { signal });

		for (const element of this.querySelectorAll("[data-effect-id]")) {
			element.setAttribute("draggable", true);
			element.ondragstart = this._onDragStart.bind(this);
		}

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener("click", event => {
				event.stopImmediatePropagation();
				this._onAction(event.currentTarget, event.currentTarget.dataset.action);
			});
		}

		for (const control of this.querySelectorAll("[data-context-menu]")) {
			control.addEventListener(
				"click",
				event => {
					event.stopPropagation();
					event.currentTarget.closest("[data-effect-id]").dispatchEvent(
						new PointerEvent("contextmenu", {
							view: window,
							bubbles: true,
							cancelable: true,
							clientX: event.clientX,
							clientY: event.clientY
						})
					);
				},
				{ signal }
			);
		}

		new BlackFlagContextMenu(this, "[data-effect-id]", [], { jQuery: true, onOpen: this._onContextMenu.bind(this) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the provided effects collection for display on an actor sheet.
	 * @param {Collection<BlackFlagActiveEffect>} effects
	 * @returns {object}
	 */
	static prepareActorContext(effects) {
		const context = {
			temporary: { label: "BF.EFFECT.Category.Temporary", effects: [] },
			passive: { label: "BF.EFFECT.Category.Passive", effects: [] },
			inactive: { label: "BF.EFFECT.Category.Inactive", effects: [] },
			suppressed: { label: "BF.EFFECT.Category.Suppressed", effects: [] }
		};

		for (const effect of effects) {
			const data = {
				...effect,
				id: effect.id,
				sourceName: effect.sourceName,
				parentId: effect.target === effect.parent ? null : effect.parent.id
			};
			if (effect.isSuppressed) {
				data.suppressionReason = game.i18n.format("BF.EFFECT.SuppressionReason.Description", {
					item: effect.parent.name,
					reasons: game.i18n
						.getListFormatter({ style: "short" })
						.format(effect.suppressionReasons.map(r => game.i18n.localize(r)))
				});
				context.suppressed.effects.push(data);
			} else if (effect.disabled) context.inactive.effects.push(data);
			else if (effect.isTemporary) context.temporary.effects.push(data);
			else context.passive.effects.push(data);
		}
		if (!context.suppressed.effects.length) delete context.suppressed;

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the provided effects collection for display on an item sheet.
	 * @param {Collection<BlackFlagActiveEffect>} effects
	 * @returns {object}
	 */
	static prepareItemContext(effects) {
		const context = {
			base: {
				id: "base",
				label: "BF.EFFECT.Label[other]",
				effects: [],
				show: { duration: true, source: false, transfer: true }
			},
			enchantment: {
				id: "enchantment",
				label: "BF.EFFECT.Type.Enchantment[other]",
				effects: [],
				show: { duration: false, source: true, transfer: false }
			}
		};

		for (const effect of effects) {
			const data = {
				...effect,
				id: effect.id
			};
			if (effect.type === "enchantment") context.enchantment.effects.push(data);
			else context.base.effects.push(data);
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the set of ContextMenu options which should be applied for activity entries.
	 * @param {BlackFlagActiveEffect} effect - The effect for which the context menu is being activated.
	 * @returns {ContextMenuEntry[]} - Context menu entries.
	 * @protected
	 */
	_getContextMenuOptions(effect) {
		return [
			{
				name: "BF.EFFECT.Action.View",
				icon: "<i class='fa-solid fa-eye fa-fw'></i>",
				condition: li => !this.isEditable,
				callback: li => this._onAction(li[0], "view")
			},
			{
				name: "BF.EFFECT.Action.Edit",
				icon: "<i class='fa-solid fa-edit fa-fw'></i>",
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "edit")
			},
			{
				name: "BF.EFFECT.Action.Duplicate",
				icon: "<i class='fa-solid fa-copy fa-fw'></i>",
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "duplicate")
			},
			{
				name: "BF.EFFECT.Action.Delete",
				icon: "<i class='fa-solid fa-trash fa-fw'></i>",
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "delete"),
				group: "destructive"
			},
			{
				name: `BF.EFFECT.Action.${effect.disabled ? "Enable" : "Disable"}`,
				icon: `<i class='fa-solid fa-${effect.disabled ? "check" : "times"} fa-fw'></i>`,
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "toggle"),
				group: "state"
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {Element} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @returns {Promise|void}
	 * @protected
	 */
	_onAction(target, action) {
		const event = new CustomEvent("bf-effect", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (target.dispatchEvent(event) === false) return;

		const effect = this.getEffect(target.closest("[data-effect-id]")?.dataset);
		if (action !== "add" && !effect) return;

		switch (action) {
			case "add":
				return this._onAddEffect(target);
			case "edit":
			case "view":
				return effect.sheet.render(true);
			case "delete":
				return effect.deleteDialog();
			case "duplicate":
				const data = effect.toObject();
				delete data._id;
				return this.document.createEmbeddedDocuments("ActiveEffect", [data]);
			case "toggle":
				return effect.update({ disabled: !effect.disabled });
			case "transfer":
				return effect.update({ transfer: !effect.transfer });
			default:
				return log(`Invalid effect action type clicked ${action}.`, { level: "warn" });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle creating a new effect within a certain section.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 * @protected
	 */
	_onAddEffect(target) {
		const section = event.target.closest("[data-section-id]")?.dataset.sectionId;
		const isEnchantment = section === "enchantment";
		const isItem = this.document instanceof Item;
		this.document.createEmbeddedDocuments("ActiveEffect", [
			{
				type: isEnchantment ? "enchantment" : "base",
				name: isItem ? this.document.name : game.i18n.localize("BF.EFFECT.New"),
				icon: isItem ? this.document.img : "icons/svg/aura.svg",
				origin: isEnchantment ? undefined : this.document.uuid,
				duration: {
					rounds: section === "temporary" ? 1 : undefined
				},
				disabled: section === "inactive"
			}
		]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle opening the context menu.
	 * @param {HTMLElement} element - The element the context menu was triggered on.
	 * @protected
	 */
	_onContextMenu(element) {
		const effect = this.getEffect(element.closest("[data-effect-id]")?.dataset);
		ui.context.menuItems = this._getContextMenuOptions(effect);
		/**
		 * A hook event that fires when the context menu for an effects list is constructed.
		 * @function blackFlag.getEffectsContext
		 * @memberof hookEvents
		 * @param {InventoryElement} html - The HTML element to which the context options are attached.
		 * @param {BlackFlagActiveEffect} effect - The effect for which the context options are being prepared.
		 * @param {ContextMenuEntry[]} entryOptions - The context menu entries.
		 */
		Hooks.call("blackFlag.getEffectsContext", this, effect, ui.context.menuItems);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin dragging an entry.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragStart(event) {
		const effect = this.getEffect(event.currentTarget.dataset);
		DragDrop$1.beginDragEvent(event, effect);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry is dropped onto the element.
	 * @param {DragEvent} event - Triggering drop event.
	 * @returns {Promise}
	 */
	async _onDrop(event) {
		event.preventDefault();
		event.stopImmediatePropagation();

		if (!this.isEditable) return false;

		const { data } = DragDrop$1.getDragData(event);
		if (!this._validateDrop(data)) return this.app._onDrop?.(event);

		try {
			const effect = (await fromUuid(data.uuid)).toObject() ?? data.data;
			if (!effect) return false;
			return this.constructor.dropEffects(event, this.document, [effect]);
		} finally {
			DragDrop$1.finishDragEvent(event);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can the dragged document be dropped?
	 * @param {object} data
	 * @returns {boolean}
	 */
	_validateDrop(data) {
		if (data.type !== "ActiveEffect") return false;
		if (!data.uuid) return true;
		return !data.uuid.startsWith(this.document.uuid);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an effect dropped onto the sheet.
	 * @param {DragEvent} event - Triggering drop event.
	 * @param {BlackFlagItem} target - Document to which the advancement was dropped.
	 * @param {BlackFlagActiveEffect[]} effectData - One or more effects dropped.
	 * @returns {Promise}
	 */
	static async dropEffects(event, target, effectData) {
		target.createEmbeddedDocuments("ActiveEffect", effectData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve an effect with the specified ID.
	 * @param {object} [data]
	 * @param {string} [data.effectId] - ID of the effect to fetch.
	 * @param {string} [data.parentId] - ID of the parent item that contains this effect, if a grandchild effect.
	 * @returns {BlackFlagActiveEffect}
	 */
	getEffect({ effectId, parentId } = {}) {
		if (!parentId) return this.document.effects.get(effectId);
		return this.document.items.get(parentId).effects.get(effectId);
	}
}

/**
 * Dialog for selecting which activity to activate for an item.
 */
class ActivityChoiceDialog extends BFApplication {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["activity-choice"],
		actions: {
			choose: ActivityChoiceDialog.#onChooseActivity
		},
		item: null,
		position: {
			width: 350
		},
		window: {
			minimizable: false
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		activities: {
			template: "systems/black-flag/templates/activity/activity-choices.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The chosen activity.
	 * @type {Activity|null}
	 */
	#activity;

	get activity() {
		return this.#activity;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The Item for which to select the activity.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.options.item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return this.item.name;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.activities = this.item.system.activities.map(activity => activity.listContext);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle choosing the specific activity.
	 * @this ActivityChoiceDialog
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #onChooseActivity(event, target) {
		const { activityId } = target.dataset;
		this.#activity = this.item.system.activities.get(activityId);
		this.close();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the choice dialog for an item.
	 * @param {BlackFlagItem} item
	 * @param {Partial<ApplicationConfiguration>} [options={}]
	 * @returns {Promise<Activity|null>}
	 */
	static create(item, options = {}) {
		return new Promise(resolve => {
			const dialog = new this({ ...options, item });
			dialog.addEventListener("close", () => resolve(dialog.activity), { once: true });
			dialog.render({ force: true });
		});
	}
}

/**
 * Base activity data model shared by activity system data.
 */
class ActivityDataModel extends foundry.abstract.DataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform the pre-localization of this data model.
	 */
	static localize() {
		Localization.localizeDataModel(this);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The primary ability for this activity that will be available as `@mod` in roll data.
	 * @type {string|null}
	 */
	get ability() {
		return this.isSpell ? this.spellcastingAbility : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The current activity.
	 * @type {Activity}
	 */
	get activity() {
		return this.parent;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The containing actor, if embedded.
	 * @type {BlackFlagActor|void}
	 */
	get actor() {
		return this.activity.actor;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Effects that can be applied from this activity.
	 * @type {BlackFlagActiveEffect[]|null}
	 */
	get applicableEffects() {
		return this.effects?.map(e => e.effect).filter(e => e) ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this activity on a spell item, or something else?
	 * @type {boolean}
	 */
	get isSpell() {
		return this.item.type === "spell";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The containing item.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.activity.item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The spellcasting ability to use based on the item settings if embedded in a spell.
	 * @type {string|null}
	 */
	get spellcastingAbility() {
		if (this.isSpell) ;
		const abilities = Object.values(this.actor?.system.spellcasting?.origins ?? {}).reduce((set, o) => {
			set.add(o.ability);
			return set;
		}, new Set());
		return this.actor?.system.selectBestAbility?.(abilities) ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply transformations or derivations to the values of the source data object.
	 */
	prepareData() {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Final data preparation steps performed on Activity after parent actor has been fully prepared.
	 */
	prepareFinalData() {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve the roll data for this activity.
	 * @param {object} [options={}]
	 * @returns {object}
	 */
	getRollData(options = {}) {
		return this.activity.getRollData(options);
	}
}

const { BooleanField: BooleanField$r, DocumentUUIDField: DocumentUUIDField$9, NumberField: NumberField$I, SchemaField: SchemaField$11, SetField: SetField$t, StringField: StringField$14 } = foundry.data.fields;

/**
 * Configuration data for the save activity.
 *
 * @property {object} spell
 * @property {string} spell.ability - Override the default casting ability of the spell.
 * @property {object} spell.challenge
 * @property {number} spell.challenge.attack - Flat to hit bonus in place of the spell's normal attack bonus.
 * @property {number} spell.challenge.save - Flat DC to use in place of the spell's normal save DC.
 * @property {boolean} spell.challenge.override - Use custom attack bonus & DC rather than creature's.
 * @property {number} spell.circle - Base circle at which to cast the spell.
 * @property {Set<string>} spell.properties - Spell components & tags to ignore while casting.
 * @property {boolean} spell.spellbook - Should this spell be listed in the character's spellbook?
 * @property {string} spell.uuid - UUID of the spell to cast.
 */
class CastData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.CAST"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			spell: new SchemaField$11({
				ability: new StringField$14(),
				challenge: new SchemaField$11({
					attack: new NumberField$I(),
					save: new NumberField$I(),
					override: new BooleanField$r()
				}),
				circle: new NumberField$I(),
				properties: new SetField$t(new StringField$14(), { initial: ["verbal", "somatic", "material"] }),
				spellbook: new BooleanField$r({ initial: true }),
				uuid: new DocumentUUIDField$9()
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return a string describing the result if the default ability is selected for this activity.
	 * @type {string|null}
	 */
	get defaultAbility() {
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		const spell = fromUuidSync(this.spell.uuid, { strict: false });
		if (spell) {
			if (!this.parent._source.name) this.parent.name = spell.name;
			if (!this.parent._source.img) this.parent.img = spell.img;
		}
		super.prepareData();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();

		for (const field of ["activation", "duration", "range", "target"]) {
			Object.defineProperty(this.parent[field], "canOverride", {
				value: true,
				configurable: true,
				enumerable: false
			});
		}
	}
}

/**
 * Special form application that acts like a dialog.
 */
class BFFormDialog extends BFApplication {
	/** @override */
	static DEFAULT_OPTIONS = {
		tag: "dialog",
		window: {
			contentTag: "form",
			contentClasses: ["standard-form"],
			minimizable: false
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		content: {
			template: ""
		},
		footer: {
			template: "templates/generic/form-footer.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Form element within the dialog.
	 * @type {HTMLFormElement|void}
	 */
	get form() {
		return this.options.tag === "form" ? this.element : this.element.querySelector("form");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		if (partId === "content") return this._prepareContentContext(context, options);
		if (partId === "footer") return this._prepareFooterContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the content section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareContentContext(context, options) {
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the footer.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareFooterContext(context, options) {
		context.buttons = this.options.buttons?.map(button => ({
			...button,
			cssClass: button.class
		}));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_attachFrameListeners() {
		super._attachFrameListeners();

		// Add event listeners to the form manually (see https://github.com/foundryvtt/foundryvtt/issues/11621)
		if (this.options.tag !== "form") {
			this.form?.addEventListener("submit", this._onSubmitForm.bind(this, this.options.form));
			this.form?.addEventListener("change", this._onChangeForm.bind(this, this.options.form));
		}
	}
}

const { BooleanField: BooleanField$q, NumberField: NumberField$H, StringField: StringField$13 } = foundry.data.fields;

/**
 * Application to handled configuring the activation of an activity.
 */
class ActivityActivationDialog extends BFFormDialog {
	constructor(options = {}) {
		super(options);

		this.#activityId = options.activity.id;
		this.#item = options.activity.item;
		this.#config = options.config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["activity-activation"],
		actions: {
			use: ActivityActivationDialog.#onUse
		},
		activity: null,
		button: {
			icon: null,
			label: null
		},
		config: null,
		display: {
			all: true
		},
		form: {
			handler: ActivityActivationDialog.#onSubmitForm,
			submitOnChange: true
		},
		position: {
			width: 460
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		scaling: {
			template: "systems/black-flag/templates/activity/activity-activation-scaling.hbs"
		},
		consumption: {
			template: "systems/black-flag/templates/activity/activity-activation-consumption.hbs"
		},
		creation: {
			template: "systems/black-flag/templates/activity/activity-activation-creation.hbs"
		},
		footer: {
			template: "templates/generic/form-footer.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * ID of the activity being activated.
	 * @type {Activity}
	 */
	#activityId;

	/**
	 * Activity being activated.
	 * @type {Activity}
	 */
	get activity() {
		return this.item.system.activities.get(this.#activityId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor using this activity.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.item.actor;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activity activation configuration data.
	 * @type {ActivityActivationConfiguration}
	 */
	#config;

	get config() {
		return this.#config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item that contains the activity.
	 * @type {BlackFlagItem}
	 */
	#item;

	get item() {
		return this.#item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return `${this.item.name}: ${this.activity.name}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Was the use button clicked?
	 * @type {boolean}
	 */
	#used = false;

	get used() {
		return this.#used;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		if ("scaling" in this.config) this.#item = this.#item.clone({ "flags.black-flag.scaling": this.config.scaling });
		return {
			...(await super._prepareContext(options)),
			activity: this.activity,
			linkedActivity: this.config.cause ? this.activity.getLinkedActivity(this.config.cause.activity) : null
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "consumption":
				return this._prepareConsumptionContext(context, options);
			case "creation":
				return this._prepareCreationContext(context, options);
			case "footer":
				return this._prepareFooterContext(context, options);
			case "scaling":
				return this._prepareScalingContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the consumption section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareConsumptionContext(context, options) {
		context.fields = [];
		context.notes = [];

		if (this.activity.spellSlotConsumption && this._shouldDisplay("consume.spellSlot") && !this.config.cause)
			context.fields.push({
				field: new BooleanField$q({ label: game.i18n.localize("BF.CONSUMPTION.Type.SpellSlots.PromptDecrease") }),
				name: "consume.spellSlot",
				value: this.config.consume?.spellSlot
			});

		if (this.activity.activation.type === "legendary" && this._shouldDisplay("consume.action"))
			context.fields.push({
				field: new BooleanField$q({
					label: game.i18n.format("BF.CONSUMPTION.Type.PromptGeneric", { type: this.activity.activation.label })
					// TODO: Display legendary action count as hint
				}),
				name: "consume.action",
				value: this.config.consume?.action
			});

		if (this._shouldDisplay("consume.resources")) {
			const addResources = (targets, keyPath) => {
				const consume = foundry.utils.getProperty(this.config, keyPath);
				const isArray = foundry.utils.getType(consume) === "Array";
				for (const [index, target] of targets.entries()) {
					const value =
						(isArray && consume.includes(index)) || (!isArray && consume !== false && this.config.consume !== false);
					const { label, hint, notes, warn } = target.getConsumptionLabels(this.config, value);
					if (notes?.length) context.notes.push(...notes);
					context.fields.push({
						field: new BooleanField$q({ label, hint }),
						name: `${keyPath}.${index}`,
						value,
						warn: value ? warn : false
					});
				}
			};
			addResources(this.activity.consumption.targets, "consume.resources");
			if (context.linkedActivity) addResources(context.linkedActivity.consumption.targets, "cause.resources");
		}

		context.hasConsumption = context.fields.length;

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the creation section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareCreationContext(context, options) {
		context.hasCreation = false;
		if (this.activity.target?.template?.type && this._shouldDisplay("create.measuredTemplate")) {
			context.hasCreation = true;
			context.template = {
				field: new BooleanField$q({ label: game.i18n.localize("BF.TARGET.Action.PlaceTemplate") }),
				name: "create.measuredTemplate",
				value: this.config.create?.measuredTemplate
			};
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the footer.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareFooterContext(context, options) {
		context.buttons = [
			{
				action: "use",
				cssClass: "heavy-button",
				icon: this.options.button.icon ?? `fa-solid fa-${this.activity.isSpell ? "magic" : "fist-raised"}`,
				label: this.options.button.label ?? this.activity.activationLabel,
				type: "button"
			}
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the scaling section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareScalingContext(context, options) {
		context.hasScaling = true;
		context.notes = [];
		if (!this._shouldDisplay("scaling")) {
			context.hasScaling = false;
			return context;
		}

		const scale = (context.linkedActivity ?? this.activity).consumption.scale;
		const rollData = (context.linkedActivity ?? this.activity).getRollData({ deterministic: true });

		if (this.activity.spellSlotScaling && context.linkedActivity && this.config.scaling !== false) {
			const max = simplifyBonus(scale.max, rollData);
			const minimumCircle = context.linkedActivity.system.spell?.circle ?? this.item.system.circle.base ?? 1;
			const maximumCircle = scale.allowed ? (scale.max ? minimumCircle + max - 1 : Infinity) : minimumCircle;
			const spellSlotOptions = Object.entries(CONFIG.BlackFlag.spellCircles())
				.map(([circle, label]) => {
					if (Number(circle) < minimumCircle || Number(circle) > maximumCircle) return null;
					return { value: `circle-${circle}`, label };
				})
				.filter(_ => _);
			context.spellSlots = {
				field: new StringField$13({ label: game.i18n.localize("BF.Spell.Circle.Label") }),
				name: "spell.slot",
				value: this.config.spell?.slot,
				options: spellSlotOptions
			};
		} else if (this.activity.spellSlotScaling && this.config.scaling !== false) {
			const spellcasting = this.actor.system.spellcasting;
			const minimumCircle = this.item.system.circle.base ?? 1;
			const maximumCircle = spellcasting.maxCircle;

			const consumeSlot = this.config.consume === true || this.config.consume?.spellSlot;
			let spellSlotValue =
				spellcasting.slots[this.config.spell?.slot]?.value || !consumeSlot ? this.config.spell.slot : null;
			if (!consumeSlot) spellSlotValue = this.config.spell?.slot;
			const spellSlotOptions = Object.entries(spellcasting.slots)
				.map(([value, slot]) => {
					if (
						slot.circle < minimumCircle ||
						(!slot.max && slot.type !== "leveled") ||
						(slot.type === "leveled" && slot.circle > maximumCircle)
					)
						return null;
					const label = game.i18n.format("BF.CONSUMPTION.Type.SpellSlots.Available", {
						slot: slot.label,
						available: numberFormat(slot.value)
					});
					const disabled = slot.value === 0 && consumeSlot;
					if (!disabled && !spellSlotValue) spellSlotValue = value;
					return { value, label, disabled, selected: spellSlotValue === value };
				})
				.filter(_ => _);

			context.spellSlots = {
				field: new StringField$13({ label: game.i18n.localize("BF.Spell.Circle.Label") }),
				name: "spell.slot",
				value: spellSlotValue,
				options: spellSlotOptions
			};

			if (!spellSlotOptions.some(o => !o.disabled))
				context.notes.push({
					type: "warn",
					message: game.i18n.format("BF.ACTIVATION.Warning.NoSlotsLeft", {
						name: this.item.name
					})
				});
		} else if (scale.allowed && this.config.scaling !== false) {
			const max = scale.max ? simplifyBonus(scale.max, rollData) : Infinity;
			context.scaling = {
				field: new NumberField$H({
					min: 1,
					max: Math.max(1, max),
					label: game.i18n.localize("BF.Consumption.Scaling.Value")
				}),
				name: "scalingValue",
				// Config stores the scaling increase, but scaling value (increase + 1) is easier to understand in the UI
				value: Math.clamp((this.config.scaling ?? 0) + 1, 1, max),
				max,
				showRange: max <= 20
			};
		} else {
			context.hasScaling = false;
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine whether a particular element should be displayed based on the `display` options.
	 * @param {string} section - Key path describing the section to be displayed.
	 * @returns {boolean}
	 */
	_shouldDisplay(section) {
		const display = this.options.display;
		if (foundry.utils.hasProperty(display, section)) return foundry.utils.getProperty(display, section);
		const [group] = section.split(".");
		if (group !== section && group in display) return display[group];
		return this.options.display.all ?? true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle form submission.
	 * @this {ActivityActivationDialog}
	 * @param {SubmitEvent} event - Triggering submit event.
	 * @param {HTMLFormElement} form - The form that was submitted.
	 * @param {FormDataExtended} formData - Data from the submitted form.
	 */
	static async #onSubmitForm(event, form, formData) {
		const submitData = this._prepareSubmitData(event, formData);
		await this._processSubmitData(event, submitData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking the use button.
	 * @this {ActivityActivationDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #onUse(event, target) {
		const formData = new FormDataExtended(this.element.querySelector("form"));
		const submitData = this._prepareSubmitData(event, formData);
		foundry.utils.mergeObject(this.#config, submitData);
		this.#used = true;
		this.close();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any pre-processing of the form data to prepare it for updating.
	 * @param {SubmitEvent} event - Triggering submit event.
	 * @param {FormDataExtended} formData - Data from the submitted form.
	 * @returns {object}
	 */
	_prepareSubmitData(event, formData) {
		const submitData = foundry.utils.expandObject(formData.object);
		if (foundry.utils.hasProperty(submitData, "spell.slot")) {
			const circle = this.actor.system.spellcasting?.slots?.[submitData.spell.slot]?.circle ?? 0;
			submitData.scaling = Math.max(0, circle - this.item.system.circle.base);
		} else if ("scalingValue" in submitData) {
			submitData.scaling = submitData.scalingValue - 1;
			delete submitData.scalingValue;
		}
		for (const key of ["consume", "cause"]) {
			if (foundry.utils.getType(submitData[key]?.resources) === "Object") {
				submitData[key].resources = filteredKeys(submitData[key].resources).map(i => Number(i));
			}
		}
		return submitData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle updating the usage configuration based on processed submit data.
	 * @param {SubmitEvent} event - Triggering submit event.
	 * @param {object} submitData - Prepared object for updating.
	 */
	async _processSubmitData(event, submitData) {
		foundry.utils.mergeObject(this.#config, submitData);
		this.render();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the activity activation dialog.
	 * @param {Activity} activity - Activity to activate.
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activation.
	 * @param {object} options - Additional options for the application.
	 * @returns {Promise<ActivityActivationConfiguration>} - Final configuration object if activated.
	 * @throws error if activity couldn't be activated.
	 */
	static async create(activity, config, options) {
		if (!activity.item.isOwned) throw new Error("Cannot activate an activity that is not owned.");

		return new Promise((resolve, reject) => {
			const dialog = new this({ activity, config, ...options });
			dialog.addEventListener("close", event => {
				if (dialog.used) resolve(dialog.config);
				else reject();
			});
			dialog.render({ force: true });
		});
	}
}

/**
 * Custom measured template class with helpers to handle placing templates from activities.
 */
class AbilityTemplate extends (foundry.canvas?.placeables?.MeasuredTemplate ?? MeasuredTemplate) {
	/**
	 * Track the timestamp when the last mouse move event was captured.
	 * @type {number}
	 */
	#moveTime = 0;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Current token that is highlighted when using adjusted size template.
	 * @type {BlackFlagToken}
	 */
	#hoveredToken;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The initially active CanvasLayer to re-activate after the workflow is complete.
	 * @type {CanvasLayer}
	 */
	#initialLayer;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Track the bound event handlers so they can be properly canceled later.
	 * @type {object}
	 */
	#events;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A factory method to create an AbilityTemplate instance using provided data from an Activity instance.
	 * @param {Activity} activity - The Activity for which to construct the template.
	 * @param {object} [options={}] - Options to modify the created template.
	 * @returns {AbilityTemplate[]|null} - The template objects, or null if the item does not produce a template.
	 */
	static fromActivity(activity, options = {}) {
		const target = activity.target?.template ?? {};
		const templateShape = CONFIG.BlackFlag.areaOfEffectTypes[target.type]?.template;
		if (!templateShape) return null;

		// Prepare template data
		const templateData = foundry.utils.mergeObject(
			{
				t: templateShape,
				user: game.user.id,
				distance: target.size,
				direction: 0,
				x: 0,
				y: 0,
				fillColor: game.user.color,
				flags: {
					[game.system.id]: {
						dimensions: {
							size: target.size,
							width: target.width,
							height: target.height,
							adjustedSize: target.type === "radius",
							rotatable: target.type === "square"
						},
						origin: activity.uuid
					}
				}
			},
			options
		);

		// Additional type-specific data
		switch (templateShape) {
			case "cone":
				templateData.angle = CONFIG.MeasuredTemplate.defaults.angle;
				break;
			case "rect":
				templateData.width = target.size;
				templateData.distance = Math.hypot(target.size, target.size);
				templateData.direction = 45;
				break;
			case "ray":
				templateData.width = target.type === "cube" ? target.size : target.width ?? canvas.dimensions.distance;
				break;
		}

		/**
		 * A hook event that fires before a template is created for an Activity.
		 * @function blackFlag.preCreateActivityTemplate
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity for which the template is being placed.
		 * @param {object} templateData - Data used to create the new template.
		 * @returns {boolean} - Explicitly return `false` to prevent the template from being placed.
		 */
		if (Hooks.call("blackFlag.preCreateActivityTemplate", activity, templateData) === false) return null;

		// Construct the templates from activity data
		const cls = CONFIG.MeasuredTemplate.documentClass;
		const created = Array.fromRange(target.count || 1).map(() => {
			const template = new cls(foundry.utils.deepClone(templateData), { parent: canvas.scene });
			const object = new this(template);
			object.activity = activity;
			object.item = activity.item;
			return object;
		});

		/**
		 * A hook event that fires after a template are created for an Activity.
		 * @function blackFlag.createActivityTemplate
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity for which the template is being placed.
		 * @param {AbilityTemplate[]} templates - The templates being placed.
		 */
		Hooks.callAll("blackFlag.createActivityTemplate", activity, created);

		return created;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Creates a preview of the spell template.
	 * @returns {Promise}  A promise that resolves with the final measured template if created.
	 */
	drawPreview() {
		const initialLayer = canvas.activeLayer;

		// Draw the template and switch to the template layer
		this.draw();
		this.layer.activate();
		this.layer.preview.addChild(this);

		// Activate interactivity
		return this.activatePreviewListeners(initialLayer);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activate listeners for the template preview
	 * @param {CanvasLayer} initialLayer - The initially active CanvasLayer to re-activate after the workflow is complete
	 * @returns {Promise} - A promise that resolves with the final measured template if created.
	 */
	activatePreviewListeners(initialLayer) {
		return new Promise((resolve, reject) => {
			this.#initialLayer = initialLayer;
			this.#events = {
				cancel: this._onCancelPlacement.bind(this),
				confirm: this._onConfirmPlacement.bind(this),
				move: this._onMovePlacement.bind(this),
				resolve,
				reject,
				rotate: this._onRotatePlacement.bind(this)
			};

			// Activate listeners
			canvas.stage.on("mousemove", this.#events.move);
			canvas.stage.on("mousedown", this.#events.confirm);
			canvas.app.view.oncontextmenu = this.#events.cancel;
			canvas.app.view.onwheel = this.#events.rotate;
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Shared code for when template placement ends by being confirmed or canceled.
	 * @param {Event} event - Triggering event that ended the placement.
	 */
	async _finishPlacement(event) {
		this.layer._onDragLeftCancel(event);
		canvas.stage.off("mousemove", this.#events.move);
		canvas.stage.off("mousedown", this.#events.confirm);
		canvas.app.view.oncontextmenu = null;
		canvas.app.view.onwheel = null;
		if (this.#hoveredToken) {
			this.#hoveredToken._onHoverOut(event);
			this.#hoveredToken = null;
		}
		this.#initialLayer.activate();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Move the template preview when the mouse moves.
	 * @param {Event} event - Triggering mouse event.
	 */
	_onMovePlacement(event) {
		event.stopPropagation();
		const now = Date.now(); // Apply a 20ms throttle
		if (now - this.#moveTime <= 20) return;
		const center = event.data.getLocalPosition(this.layer);
		const updates = canvas.templates.getSnappedPoint(center);

		// Adjust template size to take hovered token into account if `adjustedSize` is set
		const baseDistance = this.document.flags[game.system.id]?.dimensions?.size;
		if (this.document.flags[game.system.id]?.dimensions?.adjustedSize && baseDistance) {
			const rectangle = new PIXI.Rectangle(center.x, center.y, 1, 1);
			const hoveredToken = canvas.tokens.quadtree
				.getObjects(rectangle, {
					collisionTest: ({ t }) => t.visible && !t.document.isSecret
				})
				.first();
			if (hoveredToken && hoveredToken !== this.#hoveredToken) {
				this.#hoveredToken = hoveredToken;
				this.#hoveredToken._onHoverIn(event);
				const size = Math.max(hoveredToken.document.width, hoveredToken.document.height);
				updates.distance = baseDistance + (size * canvas.grid.distance) / 2;
			} else if (!hoveredToken && this.#hoveredToken) {
				this.#hoveredToken._onHoverOut(event);
				this.#hoveredToken = null;
				updates.distance = baseDistance;
			}
		}

		this.document.updateSource(updates);
		this.refresh();
		this.#moveTime = now;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Rotate the template preview by 3Ëš increments when the mouse wheel is rotated.
	 * @param {Event} event - Triggering mouse event.
	 */
	_onRotatePlacement(event) {
		if (event.ctrlKey) event.preventDefault(); // Avoid zooming the browser window
		event.stopPropagation();
		const delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;
		const snap = event.shiftKey ? delta : 5;
		const update = { direction: this.document.direction + snap * Math.sign(event.deltaY) };
		this.document.updateSource(update);
		this.refresh();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Confirm placement when the left mouse button is clicked.
	 * @param {Event} event - Triggering mouse event.
	 */
	async _onConfirmPlacement(event) {
		await this._finishPlacement(event);
		const destination = canvas.templates.getSnappedPoint({ x: this.document.x, y: this.document.y });
		this.document.updateSource(destination);
		this.#events.resolve(canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.document.toObject()]));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Cancel placement when the right mouse button is clicked.
	 * @param {Event} event - Triggering mouse event.
	 */
	async _onCancelPlacement(event) {
		await this._finishPlacement(event);
		this.#events.reject();
	}
}

const { NumberField: NumberField$G, SchemaField: SchemaField$10, StringField: StringField$12 } = foundry.data.fields;

/**
 * Field for storing information about a spell's casting time or activity's activation.
 *
 * @property {string} value - Activation value.
 * @property {string} units - Units used to measure the activation.
 * @property {string} condition - Condition required to trigger activation.
 *
 * @param {object} [fields={}] - Additional fields to add or, if value is `false`, default fields to remove.
 * @param {object} [options={}] - Additional options in addition to the default label.
 */
class ActivationField extends SchemaField$10 {
	constructor(fields = {}, options = {}) {
		fields = {
			value: new NumberField$G({ min: 0, integer: true }),
			type: new StringField$12(),
			condition: new StringField$12(),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	initialize(value, model, options = {}) {
		const obj = super.initialize(value, model, options);

		Object.defineProperty(obj, "category", {
			get() {
				if (this.type in CONFIG.BlackFlag.actionTypes.standard.children) {
					return "standard";
				} else if (this.type in CONFIG.BlackFlag.actionTypes.monster.children) {
					return "monster";
				} else if (this.type in CONFIG.BlackFlag.timeUnits.time.children) {
					return "time";
				}
				return null;
			},
			enumerable: false
		});

		Object.defineProperty(obj, "label", {
			get() {
				return ActivationField.label(obj);
			},
			enumerable: false
		});
		Object.defineProperty(obj, "embedLabel", {
			get() {
				return ActivationField.label(obj, { style: "long" });
			},
			enumerable: false
		});

		return obj;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Labels                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a label describing the activation.
	 * @param {TargetField} data - Data from the activation field.
	 * @param {object} [options={}]
	 * @param {string} [options.style="combined"] - Long or combined.
	 * @returns {string}
	 */
	static label(data, { style = "combined" } = {}) {
		let label;
		if (data.type in CONFIG.BlackFlag.timeUnits.time.children) {
			label = formatTime(data.value, data.type);
		} else {
			const type = CONFIG.BlackFlag.activationOptions({
				pluralRule: getPluralRules().select(data.value ?? 1)
			}).get(data.type);
			if (!type) return "";

			label = game.i18n.format("BF.ACTIVATION.Formatted.Scalar", {
				number: numberFormat(data.value ?? 1),
				type: type.label,
				typeLowercase: type.label.toLowerCase()
			});
		}

		if (style === "combined") {
			return `<span${data.condition ? ` data-tooltip="${data.condition.capitalize()}"` : ""}>${label}</span>`;
		} else if (data.condition) {
			return game.i18n.format("BF.ACTIVATION.Formatted.Condition", {
				activation: label,
				condition: data.condition
			});
		}

		return label;
	}
}

const { SchemaField: SchemaField$$, StringField: StringField$11 } = foundry.data.fields;

/**
 * Field for storing information about a item or activity's duration.
 *
 * @property {string} value - Duration value.
 * @property {string} units - Units used to measure the duration.
 * @property {string} special - Description of the duration if units is `special`.
 *
 * @param {object} [fields={}] - Additional fields to add or, if value is `false`, default fields to remove.
 * @param {object} [options={}] - Additional options in addition to the default label.
 */
class DurationField extends SchemaField$$ {
	constructor(fields = {}, options = {}) {
		fields = {
			value: new FormulaField({ deterministic: true }),
			units: new StringField$11({ initial: "instantaneous" }),
			special: new StringField$11(),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	initialize(value, model, options = {}) {
		const obj = super.initialize(value, model, options);
		const isSpell = model.isSpell || model.parent?.type === "spell";

		Object.defineProperty(obj, "scalar", {
			get() {
				return this.units ? !!CONFIG.BlackFlag.durationOptions({ isSpell }).get(this.units)?.scalar : false;
			},
			configurable: true,
			enumerable: false
		});

		Object.defineProperty(obj, "label", {
			get() {
				if (this.units in CONFIG.BlackFlag.timeUnits.localized) {
					return formatTime(this.value, this.units);
				} else {
					const unit = CONFIG.BlackFlag.durationOptions({
						pluralRule: getPluralRules().select(this.value),
						isSpell
					}).get(this.units);
					if (unit?.scalar) {
						if (!this.value) return null;
						return numberFormat(this.value, { unit });
					}
					return unit?.label ?? "";
				}
			},
			configurable: true,
			enumerable: false
		});

		return obj;
	}
}

const { SchemaField: SchemaField$_, StringField: StringField$10 } = foundry.data.fields;

/**
 * Field for storing information about an item or activity's range.
 *
 * @property {string} value - Standard range.
 * @property {string} units - Units used to measure the range.
 * @property {string} special - Description of the range if units is `special`.
 *
 * @param {object} [fields={}] - Additional fields to add or, if value is `false`, default fields to remove.
 * @param {object} [options={}] - Additional options in addition to the default label.
 */
class RangeField extends SchemaField$_ {
	constructor(fields = {}, options = {}) {
		fields = {
			value: new FormulaField({ deterministic: true, label: "BF.RANGE.Value.Label" }),
			units: new StringField$10({ label: "BF.RANGE.Unit.Label" }),
			special: new StringField$10({ label: "BF.RANGE.Special.Label" }),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, { label: "BF.RANGE.Label", ...options });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	initialize(value, model, options = {}) {
		const obj = super.initialize(value, model, options);

		Object.defineProperty(obj, "scalar", {
			get() {
				return this.units in CONFIG.BlackFlag.distanceUnits;
			},
			enumerable: false
		});

		Object.defineProperty(obj, "label", {
			get() {
				if (this.scalar) return this.value ? formatDistance(this.value, this.units) : null;
				else {
					const type = CONFIG.BlackFlag.rangeTypes[this.units];
					if (!type) return "";
					let label = game.i18n.localize(type.label);
					if (this.units === "special" && this.special) {
						label = `<span data-tooltip="${this.special}">${label}*</span>`;
					}
					return label;
				}
			},
			enumerable: false
		});

		return obj;
	}
}

const { BooleanField: BooleanField$p, SchemaField: SchemaField$Z, StringField: StringField$$ } = foundry.data.fields;

/**
 * Field for storing information about an item or activity's targeting.
 *
 * @property {object} template
 * @property {string} template.count - Number of templates to create.
 * @property {boolean} template.connected - Must all created areas be connected to one another?
 * @property {string} template.type - Type of template (e.g. sphere, cone, line)
 * @property {string} template.size - Primary template size.
 * @property {string} template.width - Width of the template if relevant.
 * @property {string} template.height - Height of the template if relevant.
 * @property {string} template.units - Units used to measure the template.
 * @property {object} affects
 * @property {string} affects.formula - Number of targets affected.
 * @property {string} affects.type - Type of targets affected (e.g. creatures, objects, allies, enemies)
 * @property {boolean} affects.choice - Can the caster select which targets are affected?
 * @property {string} affects.special - Description of the targets if type is `special`.
 *
 * @param {object} [fields={}] - Additional fields to add or, if value is `false`, default fields to remove.
 * @param {object} [options={}] - Additional options in addition to the default label.
 */
class TargetField extends SchemaField$Z {
	constructor(fields = {}, options = {}) {
		fields = {
			template: new SchemaField$Z({
				count: new FormulaField({ deterministic: true }),
				contiguous: new BooleanField$p(),
				type: new StringField$$(),
				size: new FormulaField({ deterministic: true }),
				width: new FormulaField({ deterministic: true }),
				height: new FormulaField({ deterministic: true }),
				units: new StringField$$({ initial: "foot" })
			}),
			affects: new SchemaField$Z({
				count: new FormulaField({ deterministic: true }),
				type: new StringField$$(),
				choice: new BooleanField$p(),
				special: new StringField$$()
			}),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, { label: "BF.Targeting.Label", ...options });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	initialize(value, model, options = {}) {
		const obj = super.initialize(value, model, options);

		Object.defineProperty(obj, "aoeSizes", {
			get() {
				const sizes = CONFIG.BlackFlag.areaOfEffectTypes[this.template.type]?.sizes;
				if (!sizes) return null;
				const aoeSizes = {
					size: "BF.AreaOfEffect.Size.Label",
					width: sizes.includes("width") && (sizes.includes("length") || sizes.includes("radius")),
					height: sizes.includes("height")
				};
				if (sizes.includes("radius")) aoeSizes.size = "BF.AreaOfEffect.Size.Radius";
				else if (sizes.includes("length")) aoeSizes.size = "BF.AreaOfEffect.Size.Length";
				else if (sizes.includes("width")) aoeSizes.size = "BF.AreaOfEffect.Size.Width";
				if (sizes.includes("thickness")) aoeSizes.width = "BF.AreaOfEffect.Size.Thickness";
				else if (aoeSizes.width) aoeSizes.width = "BF.AreaOfEffect.Size.Width";
				if (aoeSizes.height) aoeSizes.height = "BF.AreaOfEffect.Size.Height";
				return aoeSizes;
			},
			enumerable: false
		});

		Object.defineProperty(obj.affects, "scalar", {
			get() {
				return this.type && this.type !== "special";
			},
			enumerable: false
		});

		Object.defineProperty(obj, "label", {
			get() {
				const templateShort = TargetField.templateLabel(obj, { style: "short" });
				if (!templateShort) return TargetField.affectsLabel(obj, { style: "combined" });
				const templateLong = TargetField.templateLabel(obj, { style: "long" });
				const affectsLong = TargetField.affectsLabel(obj, { style: "long" });
				const tooltip = affectsLong ? `${templateLong}, ${affectsLong.toLowerCase()}` : templateLong;
				return `<span class="template-label" aria-label="${tooltip}" data-tooltip="${tooltip}">${templateShort}</span>`;
			},
			enumerable: false
		});

		Object.defineProperty(obj.affects, "label", {
			get() {
				return TargetField.affectsLabel(obj);
			},
			enumerable: false
		});

		Object.defineProperty(obj.template, "label", {
			get() {
				return TargetField.templateLabel(obj);
			},
			enumerable: false
		});

		Object.defineProperty(obj.affects, "placeholder", {
			get() {
				return obj.template.type
					? game.i18n.localize("BF.TARGET.Count.EveryGeneric")
					: game.i18n.localize("BF.TARGET.Count.AnyGeneric");
			},
			enumerable: false
		});

		return obj;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Labels                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a label describing the affected targets.
	 * @param {TargetField} data - Data from the targeting field.
	 * @param {object} [options={}]
	 * @param {string} [options.style="combined"] - Short, long, or combined.
	 * @returns {string}
	 */
	static affectsLabel(data, { style = "combined" } = {}) {
		const { affects, template } = data;
		const type = CONFIG.BlackFlag.targetTypes[affects.type];
		if (!type) return "";

		let short;
		let long;

		if (affects.type === "special") {
			short = game.i18n.localize(type.label);
		} else if (!affects.count) {
			const key = template.type in CONFIG.BlackFlag.areaOfEffectTypes ? "Every" : "Any";
			const pluralRule = template.type in CONFIG.BlackFlag.areaOfEffectTypes ? "one" : "other";
			short = long = game.i18n.format(`BF.TARGET.Count.${key}Specific`, {
				type: game.i18n.localize(`${type.localization}[${pluralRule}]`),
				typeLowercase: game.i18n.localize(`${type.localization}[${pluralRule}]`).toLowerCase()
			});
		} else {
			const number = formatNumber(affects.count ?? 1);
			short = `${number} ${game.i18n
				.localize(`BF.TARGET.Label[${getPluralRules().select(affects.count ?? 1)}]`)
				.toLowerCase()}`;
			long = `${number} ${game.i18n
				.localize(type.label ?? `${type.localization}[${getPluralRules().select(affects.count ?? 1)}]`)
				.toLowerCase()}`;
		}

		if (affects.choice) {
			long = game.i18n.format("BF.TARGET.Choice", { number: long ?? short });
		}

		const tooltip = long ? (affects.special ? `${long} (${affects.special})` : long) : affects.special?.capitalize();

		return style === "short"
			? short
			: style === "long"
				? tooltip ?? short
				: `<span${tooltip ? ` data-tooltip="${tooltip}"` : ""}>${short}</span>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a label describing the created template.
	 * @param {TargetField} data - Data from the targeting field.
	 * @param {object} [options={}]
	 * @param {string} [options.style="combined"] - Short, long, or combined.
	 * @returns {string}
	 */
	static templateLabel(data, { style = "combined" } = {}) {
		const { template } = data;
		const type = CONFIG.BlackFlag.areaOfEffectTypes[template.type];
		if (!type || !template.size) return "";

		let short;
		let long;

		const pluralRule = getPluralRules().select(template.count);
		const shape = type.localization
			? game.i18n.localize(`${type.localization}[${pluralRule}]`)
			: game.i18n.localize(type.label) ?? "";

		if (type.icon) {
			let size = formatDistance(template.size, template.units, { unitDisplay: "narrow" });
			const image = `<img class="area-icon" src="${type.icon}" alt="${shape}"></img>`;
			short = game.i18n.format("BF.AreaOfEffect.Described", {
				size: style === "combined" ? `<span class="number">${size}</span>` : size,
				shape: image,
				shapeLowercase: image
			});
			if (template.count > 1) {
				short = `${formatNumber(template.count)} x ${short}`;
			}
		}

		if (style !== "short" && short) {
			long = game.i18n.format("BF.AreaOfEffect.Described", {
				size: formatDistance(template.size, template.units),
				shape,
				shapeLowercase: shape.toLowerCase()
			});
			if (template.count > 1) {
				long = game.i18n.format("BF.AreaOfEffect.Counted", {
					count: formatNumber(template.count, { spelledOut: true }).capitalize(),
					sizedShape: long
				});
			}
		}

		return style === "short"
			? short ?? long
			: style === "long" || !short
				? long
				: `<span class="template-label" aria-label="${long}" data-tooltip="${long}">${short ?? long}</span>`;
	}
}

/**
 * @typedef {DataFieldOptions} TypeFieldOptions
 * @property {TypeFieldTypeGetter} [determineType] - Function used to determine the type.
 * @property {TypeFieldModelGetter|object} [modelLookup] - Function or object that loads the model based on type.
 */

/**
 * Data field that selects the appropriate data model if available, otherwise defaults to generic
 * `ObjectField` to prevent issues with custom types that aren't currently loaded.
 *
 * @param {TypeFieldOptions} [options={}]
 * @property {TypeFieldTypeGetter} [determineType] - Function used to determine the type.
 * @property {TypeFieldModelGetter|object} [modelLookup] - Function or object that loads the model based on type.
 */
class TypeField extends foundry.data.fields.ObjectField {
	/** @inheritDoc */
	static get _defaults() {
		return foundry.utils.mergeObject(super._defaults, {
			determineType: null,
			modelLookup: null
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static recursive = true;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the DataModel definition for the specified type.
	 * @param {object} value - Data being prepared for this field.
	 * @param {DataField} parent - Parent field for which this is being prepared.
	 * @returns {typeof DataModel|null} - Data model to use while initializing the field.
	 */
	getModel(value, parent) {
		const type = this.determineType?.(value, parent) ?? null;
		if (foundry.utils.getType(this.modelLookup) === "function") return this.modelLookup(type) ?? null;
		return this.modelLookup?.[type] ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_cleanType(value, options) {
		if (!(typeof value === "object")) value = {};

		const cls = this.getModel(value);
		if (cls) return cls.cleanData(value, options);
		return value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	initialize(value, model, options = {}) {
		const cls = this.getModel(value, model);
		if (cls) {
			const created = cls.fromSource(value, { parent: model, ...options });
			if (created.schema) created.schema.name = this.name;
			return created;
		}
		return foundry.utils.deepClone(value);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate this field's candidate source data.
	 * @param {object} sourceData - Candidate source data of the root model.
	 * @param {any} fieldData - The value of this field within the source data.
	 */
	migrateSource(sourceData, fieldData) {
		const cls = this.getModel(fieldData, sourceData);
		if (cls) cls.migrateDataSafe(fieldData);
	}
}

const { ArrayField: ArrayField$q, BooleanField: BooleanField$o, EmbeddedDataField: EmbeddedDataField$5, NumberField: NumberField$F, SchemaField: SchemaField$Y, StringField: StringField$_ } = foundry.data.fields;

/**
 * Field for storing uses data.
 */
class UsesField extends EmbeddedDataField$5 {
	constructor(options = {}) {
		super(UsesData, foundry.utils.mergeObject({ label: "BF.Uses.Label" }, options));
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Data for a recovery profile for an activity's uses.
 *
 * @typedef {object} UsesRecoveryData
 * @property {string} period   Period at which this profile is activated.
 * @property {string} type     Whether uses are reset to full, reset to zero, or recover a certain number of uses.
 * @property {string} formula  Formula used to determine recovery if type is not reset.
 */

/**
 * Data for uses on an item or activity.
 *
 * @property {number} spent                 Number of uses that have been spent.
 * @property {string} max                   Formula for the maximum number of uses.
 * @property {boolean} consumeQuantity      For items with quantity, should the quantity be reduced if all uses spent?
 * @property {UsesRecoveryData[]} recovery  Recovery profiles for this activity's uses.
 */
class UsesData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			spent: new NumberField$F({ initial: 0, integer: true, label: "BF.Uses.Spent.Label" }),
			max: new FormulaField({ deterministic: true, label: "BF.Uses.Maximum.Label" }),
			consumeQuantity: new BooleanField$o({
				label: "BF.Uses.ConsumeQuantity.Label",
				hint: "BF.Uses.ConsumeQuantity.Hint"
			}),
			recovery: new ArrayField$q(
				new SchemaField$Y({
					period: new StringField$_({ initial: "longRest", label: "BF.Recovery.Period.Label" }),
					type: new StringField$_({ initial: "recoverAll", label: "BF.Recovery.Type.Label" }),
					formula: new FormulaField({ label: "BF.Recovery.Formula.Label" })
				}),
				{ label: "BF.Recovery.Label" }
			)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is there a range of possible uses defined?
	 * @type {boolean}
	 */
	get hasUses() {
		return !!this._source.max || !!this.max;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can an item's quantity be consumed as part of the usage consumption?
	 * @type {boolean}
	 */
	get supportsConsumeQuantity() {
		return this.options.consumeQuantity !== false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare uses data.
	 * @param {object} rollData
	 */
	prepareData(rollData) {
		const existingPeriods = new Set(this.recovery.map(r => r.period));
		for (const recovery of this.recovery) {
			if (recovery.period === "recharge") recovery.type = "recoverAll";
			Object.defineProperty(recovery, "validPeriods", {
				get() {
					return Object.entries(CONFIG.BlackFlag.recoveryPeriods).map(([value, config]) => ({
						disabled: existingPeriods.has(value) && this.period !== value,
						group: game.i18n.localize(config.group),
						label: game.i18n.localize(config.label),
						value
					}));
				},
				configurable: true,
				enumerable: false
			});
			Object.defineProperty(recovery, "periodOptions", {
				get() {
					return [
						...this.validPeriods,
						{ rule: true },
						{
							value: "recharge",
							label: game.i18n.localize("BF.Recovery.Recharge.Label"),
							disabled: this.recharge.disabled
						},
						{ value: "@scale.", label: game.i18n.localize("BF.Advancement.ScaleValue.Title") }
					];
				},
				configurable: true,
				enumerable: false
			});
			Object.defineProperty(recovery, "recharge", {
				get() {
					return {
						disabled: existingPeriods.has("recharge") && this.period !== "recharge",
						options: [
							...Array.fromRange(4, 2).map(min => ({
								key: min,
								label: game.i18n.format("BF.Recovery.Recharge.Range", { min })
							})),
							{ key: 6, label: game.i18n.localize("BF.Recovery.Recharge.Single") }
						].reverse()
					};
				},
				configurable: true,
				enumerable: false
			});

			Object.defineProperty(recovery, "isScaleValue", {
				value: recovery.period.startsWith("@scale"),
				configurable: true,
				enumerable: false
			});
			if (recovery.isScaleValue) {
				const scaleValue = foundry.utils.getProperty(rollData, recovery.period.replace("@", ""));
				if (scaleValue?.per) recovery.period = scaleValue.per;
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine usage recovery for this usage.
	 * @param {string[]} periods - Recovery periods to apply. Will execute the first one found in recovery configurations.
	 * @param {object} rollData - Roll data to use when evaluating recovery formulas.
	 * @returns {{updates: object, rolls: []}|false}
	 */
	async recoverUses(periods, rollData) {
		if (!this.recovery.length) return false;
		if (periods.includes("roundStart")) periods.unshift("recharge");
		const matchingPeriod = periods.find(p => this.recovery.find(r => r.period === p));
		const recoveryProfile = this.recovery.find(r => r.period === matchingPeriod);
		if (!recoveryProfile) return false;

		const updates = {};
		const rolls = [];

		// If recharge period, then roll to see if it actually recovers
		if (matchingPeriod === "recharge") {
			if (this.spent === 0) return false;
			rolls.push(await this.rollRecharge(Number(recoveryProfile.formula)));
			if (!rolls[0]) return false;
		}

		if (recoveryProfile.type === "recoverAll") updates.spent = 0;
		else if (recoveryProfile.type === "loseAll") updates.spent = this.max ? this.max : 0;
		else if (recoveryProfile.formula) {
			const delta =
				this.parent instanceof BlackFlag.documents.activity.Activity
					? { item: this.parent.item.id, keyPath: `system.activities.${this.parent.id}.uses.spent` }
					: { item: this.parent.parent.id, keyPath: "system.uses.spent" };
			const roll = new CONFIG.Dice.BasicRoll(recoveryProfile.formula, rollData, { delta });
			await roll.evaluate();
			const newSpent = Math.clamp(this.spent - roll.total, 0, this.max);
			if (newSpent !== this.spent) {
				updates.spent = newSpent;
				if (!roll.isDeterministic) rolls.push(roll);
			}
		}

		return { updates, rolls };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Make a recharge roll to see if uses are recovered.
	 * @param {number} target - Target value necessary to success.
	 * @returns {BasicRoll|false}
	 */
	async rollRecharge(target) {
		const rollConfig = {
			rolls: [
				{
					parts: ["1d6"],
					options: {
						delta:
							this.parent.parent instanceof Item
								? { item: this.parent.parent.id, keyPath: "system.uses.spent" }
								: { item: this.parent.item.id, keyPath: `system.activities.${this.parent.id}.uses.spent` },
						target
					}
				}
			],
			origin: this.parent
		};

		const type = game.i18n.localize("BF.Recovery.Recharge.Label");
		const dialogConfig = {
			configure: false,
			options: {
				title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
			}
		};

		const flavor = game.i18n.format("BF.Roll.Type.Label", { type });
		const messageConfig = {
			data: {
				flavor,
				"flags.black-flag.roll": {
					type: "recharge"
				}
			}
		};

		/**
		 * A hook event that fires before recharge is rolled.
		 * @function blackFlag.preRollRecharge
		 * @memberof hookEvents
		 * @param {BlackFlagItem|Activity} source - Item or activity for which uses are being recovered.
		 * @param {HitDieRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {BasicRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollRecharge", this.parent, rollConfig, dialogConfig, messageConfig) === false) {
			return false;
		}

		const rolls = await CONFIG.Dice.BasicRoll.build(rollConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires after a recharge roll has been performed.
		 * @function blackFlag.rollRecharge
		 * @memberof hookEvents
		 * @param {BlackFlagItem|Activity} source - Item or activity for which uses are being recovered.
		 * @param {BasicRoll[]} rolls - The resulting rolls.
		 */
		Hooks.callAll("blackFlag.rollRecharge", this.parent, rolls);

		return rolls[0]?.isSuccess ? rolls[0] : false;
	}
}

const { ArrayField: ArrayField$p, EmbeddedDataField: EmbeddedDataField$4, SchemaField: SchemaField$X, StringField: StringField$Z } = foundry.data.fields;

/**
 * Field for holding one or more consumption targets.
 */
class ConsumptionTargetsField extends ArrayField$p {
	constructor(options = {}) {
		super(new EmbeddedDataField$4(ConsumptionTargetData), options);
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Data model for consumption targets.
 *
 * @property {string} type             Type of consumption (e.g. activity uses, item uses, hit die, spell slot).
 * @property {string} target           Target of the consumption depending on the selected type (e.g. item's ID, hit
 *                                     die denomination, spell slot circle).
 * @property {string} value            Formula that determines amount consumed or recovered.
 * @property {object} scaling
 * @property {string} scaling.mode     Scaling mode (e.g. no scaling, scale target amount, scale spell circle).
 * @property {string} scaling.formula  Specific scaling formula if not automatically calculated from target's value.
 */
class ConsumptionTargetData extends foundry.abstract.DataModel {
	static defineSchema() {
		return {
			type: new StringField$Z({ label: "BF.CONSUMPTION.Type.Label" }),
			target: new StringField$Z({ label: "BF.Consumption.Target.Label" }),
			value: new FormulaField({ initial: "1", label: "BF.Consumption.Amount.Label" }),
			scaling: new SchemaField$X({
				mode: new StringField$Z({ label: "BF.DAMAGE.Scaling.Mode.Label" }),
				formula: new FormulaField()
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activity to which this consumption target belongs.
	 * @type {Activity}
	 */
	get activity() {
		return this.parent;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor containing this consumption target, if embedded.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.activity.actor;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item to which this consumption target's activity belongs.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.activity.item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Placeholder for the target field.
	 * @type {string|null}
	 */
	get placeholder() {
		if (this.type !== "item") return null;
		return game.i18n.localize("BF.CONSUMPTION.Type.ItemUses.ThisItem");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Method of scaling this consumption.
	 * @type {FormSelectOption[]|null}
	 */
	get scalingModes() {
		if (CONFIG.BlackFlag.consumptionTypes[this.type]?.scalingModes === false) return null;
		return [
			{ value: "", label: game.i18n.localize("BF.Consumption.Scaling.Mode.None") },
			{ value: "amount", label: game.i18n.localize("BF.Consumption.Scaling.Mode.Amount") },
			...Object.entries(CONFIG.BlackFlag.consumptionTypes[this.type].scalingModes ?? {}).map(([value, config]) => ({
				value,
				label: game.i18n.localize(config.label)
			}))
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should the target section be shown?
	 * @type {boolean}
	 */
	get showTargets() {
		return "validTargets" in CONFIG.BlackFlag.consumptionTypes[this.type];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * List of valid targets within the current context.
	 * @type {FormSelectOption[]|null}
	 */
	get validTargets() {
		return this.constructor.getValidTargets(this.type, this.parent);
	}

	/**
	 * List of valid targets for a specific type.
	 * @param {string} type - Consumption type.
	 * @param {Activity} activity - Activity that contains the target.
	 * @returns {FormSelectOption[]|null}
	 */
	static getValidTargets(type, activity) {
		const config = CONFIG.BlackFlag.consumptionTypes[type];
		if (!config?.validTargets || (!activity.item?.isEmbedded && config.targetRequiresEmbedded === true)) return null;
		return config.validTargets.call(activity);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Consumption              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform consumption according to the target type.
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivationUpdates} updates - Updates to be performed.
	 * @throws ConsumptionError
	 */
	async consume(config, updates) {
		const typeConfig = CONFIG.BlackFlag.consumptionTypes[this.type];
		if (!typeConfig?.consume) throw new Error(`Consumption type ${this.type} does not have a consume method defined.`);
		await typeConfig.consume.call(this, config, updates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare updates for activity uses consumption.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivationUpdates} updates - Updates to be performed.
	 */
	static async consumeActivityUses(config, updates) {
		const result = await this._usesConsumption(config, {
			uses: this.activity.uses,
			type: game.i18n.format("BF.CONSUMPTION.Type.ActivityUses.Warning", {
				itemName: this.item.name,
				activityName: this.activity.name
			}),
			rolls: updates.rolls
		});
		if (result) foundry.utils.mergeObject(updates.activity, { "uses.spent": result.spent });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare updates for attribute consumption.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivationUpdates} updates - Updates to be performed.
	 */
	static async consumeAttribute(config, updates) {
		const cost = (await this.resolveCost({ config, rolls: updates.rolls })).total;
		const keyPath = `system.${this.target}`;
		const attribute = getAttributeOption(this.target)?.label ?? this.target;

		if (!foundry.utils.hasProperty(this.actor, keyPath))
			throw new ConsumptionError(
				game.i18n.format("BF.CONSUMPTION.Warning.MissingAttribute", {
					activity: this.activity.name,
					attribute,
					item: this.item.name
				})
			);
		const current = foundry.utils.getProperty(this.actor, keyPath);

		let warningMessage;
		if (cost > 0 && !current) warningMessage = "BF.CONSUMPTION.Warning.None";
		else if (current < cost) warningMessage = "BF.CONSUMPTION.Warning.NotEnough";
		if (warningMessage)
			throw new ConsumptionError(
				game.i18n.format(warningMessage, {
					available: numberFormat(current),
					cost: numberFormat(cost),
					type: game.i18n.format("BF.CONSUMPTION.Type.Attribute.Warning", { attribute })
				})
			);

		updates.actor[keyPath] = current - cost;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare updates for hit dice consumption.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivationUpdates} updates - Updates to be performed.
	 */
	static async consumeHitDice(config, updates) {
		const cost = (await this.resolveCost({ config, rolls: updates.rolls })).total;

		if (!this.actor.system.attributes?.hd)
			throw new ConsumptionError(game.i18n.format("BF.CONSUMPTION.Warning.MissingHitDice", { denomination: "" }));

		const availableDenominations = Object.entries(this.actor.system.attributes.hd.d);
		if (this.target === "smallest") availableDenominations.sort((lhs, rhs) => lhs[0] - rhs[0]);
		else if (this.target === "largest") availableDenominations.sort((lhs, rhs) => rhs[0] - lhs[0]);
		else {
			const denom = this.actor.system.attributes.hd.d[this.target];

			let warningMessage;
			if (!denom) warningMessage = "BF.CONSUMPTION.Warning.MissingHitDice";
			else if (denom.available === 0 && cost > 0) warningMessage = "BF.CONSUMPTION.Warning.None";
			else if (denom.available < cost) warningMessage = "BF.CONSUMPTION.Warning.NotEnough";
			if (warningMessage) {
				const denomination = `d${this.target}`;
				throw new ConsumptionError(
					game.i18n.format(warningMessage, {
						type: game.i18n.format("BF.CONSUMPTION.Type.HitDice.Warning", { denomination }),
						denomination,
						cost: numberFormat(cost, { spelledOut: true }),
						available: numberFormat(denom?.value, { spelledOut: true })
					})
				);
			}

			if (cost < 0 && !denom.spent) return;
			updates.actor[`system.attributes.hd.d.${this.target}.spent`] = Math.clamp(denom.spent + cost, 0, denom.max);
			return;
		}

		// Loop over available denominations, subtracting or adding cost until it is all spent
		let remaining = cost;
		for (const [d, denom] of availableDenominations) {
			const delta = remaining > 0 ? Math.min(remaining, denom.available) : Math.max(remaining, -denom.spent);
			if (delta !== 0) {
				updates.actor[`system.attributes.hd.d.${d}.spent`] = denom.spent + delta;
				remaining -= delta;
			}
			if (remaining === 0) return;
		}
		if (remaining > 0) {
			const available = Object.values(this.actor.system.attributes.hd.d).reduce((sum, d) => sum + d.available, 0);
			const warningMessage = `BF.CONSUMPTION.Warning.${available > 0 ? "NotEnough" : "None"}`;
			throw new ConsumptionError(
				game.i18n.format(warningMessage, {
					type: game.i18n.localize("BF.HitDie.Label[other]").toLowerCase(),
					cost: numberFormat(cost, { spelledOut: true }),
					available: numberFormat(available, { spelledOut: true })
				})
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare updates for item uses consumption.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivationUpdates} updates - Updates to be performed.
	 */
	static async consumeItemUses(config, updates) {
		const item = this.target ? this.actor.items.get(this.target) : this.item;
		if (!item)
			throw new ConsumptionError(
				game.i18n.format("BF.CONSUMPTION.Warning.MissingItem", {
					activity: this.activity.name,
					item: this.item.name
				})
			);

		const result = await this._usesConsumption(config, {
			uses: item.system.uses,
			quantity: item.system.quantity ?? 1,
			type: game.i18n.format("BF.CONSUMPTION.Type.ItemUses.Warning", { name: item.name }),
			rolls: updates.rolls
		});
		if (!result) return;

		const update = { "system.uses.spent": result.spent };
		if (item.system.uses.consumeQuantity) update["system.quantity"] = result.quantity;

		const itemIndex = updates.item.findIndex(i => i._id === item.id);
		if (itemIndex === -1) updates.item.push({ _id: item.id, ...update });
		else foundry.utils.mergeObject(updates.item[itemIndex], update);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare updates for spell slot consumption.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivationUpdates} updates - Updates to be performed.
	 */
	static async consumeSpellSlots(config, updates) {
		const cost = (await this.resolveCost({ config, rolls: updates.rolls })).total;
		const circleNumber = Math.clamp(
			this.resolveCircle({ config, rolls: updates.rolls }),
			1,
			CONFIG.BlackFlag.maxSpellCircle
		);

		// Check to see if enough slots are available at specified circle
		const circleData = this.actor.system.spellcasting?.slots?.[`circle-${circleNumber}`];
		const newSpent = (circleData?.spent ?? 0) + cost;
		let warningMessage;
		if (!circleData?.max) warningMessage = "BF.CONSUMPTION.Warning.MissingSpellCircle";
		else if (cost > 0 && !circleData.value) warningMessage = "BF.CONSUMPTION.Warning.None";
		else if (newSpent > circleData.max) warningMessage = "BF.CONSUMPTION.Warning.NotEnough";
		if (warningMessage) {
			const circle = CONFIG.BlackFlag.spellCircles()[circleNumber].toLowerCase();
			const type = game.i18n.format("BF.CONSUMPTION.Type.SpellSlots.Warning", { circle });
			throw new ConsumptionError(
				game.i18n.format(warningMessage, {
					type,
					circle,
					cost: numberFormat(cost, { spelledOut: true }),
					available: numberFormat(circleData?.value, { spelledOut: true })
				})
			);
		}

		if (cost < 0 && !circleData.spent) return;
		updates.actor[`system.spellcasting.slots.circle-${circleNumber}.spent`] = Math.clamp(newSpent, 0, circleData.max);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate uses updates.
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {object} options
	 * @param {object} options.uses - Uses object on an Item or Activity.
	 * @param {string} options.type - Type property that will be provided to warning messages.
	 * @param {Roll[]} options.rolls - Rolls performed as part of the activation.
	 * @param {number} [options.quantity] - Item quantity, for when `consumeQuantity` is `true`.
	 * @returns {{spent: number, quantity: number}|null} - New spent uses & quantity values, or `null` for no change.
	 * @internal
	 */
	async _usesConsumption(config, { uses, type, rolls, quantity }) {
		const cost = (await this.resolveCost({ config, rolls })).total;

		let availableUses = uses.value;
		const maxUses = uses.max || 1;
		const canConsumeQuantity = uses.consumeQuantity && quantity && cost > 0;
		if (canConsumeQuantity) availableUses += quantity * maxUses;

		let warningMessage;
		if (cost > 0 && !availableUses) warningMessage = "BF.CONSUMPTION.Warning.None";
		else if (cost > availableUses) warningMessage = "BF.CONSUMPTION.Warning.NotEnough";
		if (warningMessage)
			throw new ConsumptionError(
				game.i18n.format(warningMessage, {
					type,
					cost: numberFormat(cost, { spelledOut: true }),
					available: numberFormat(availableUses, { spelledOut: true })
				})
			);

		// No need to adjust quantity
		if (!canConsumeQuantity || cost < uses.value) return { spent: uses.spent + cost, quantity };

		let remainingCost = cost - uses.value;
		let deltaQuantity = 1;
		while (remainingCost > maxUses) {
			remainingCost -= maxUses;
			deltaQuantity += 1;
		}
		return { spent: remainingCost, quantity: quantity - deltaQuantity };
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Consumption Labels         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create label and hint text indicating how much of this resource will be consumed/recovered.
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @param {boolean} consumed - Is this consumption currently set to be consumed?
	 * @returns {ConsumptionLabels}
	 */
	getConsumptionLabels(config, consumed) {
		const typeConfig = CONFIG.BlackFlag.consumptionTypes[this.type];
		if (!typeConfig?.consumptionLabels) return "";
		return typeConfig.consumptionLabels.call(this, config, consumed);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create hint text indicating how much of this resource will be consumed/recovered.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @param {boolean} consumed - Is this consumption currently set to be consumed?
	 * @returns {ConsumptionLabels}
	 */
	static consumptionLabelsActivityUses(config, consumed) {
		const { cost, simplifiedCost, increaseKey, pluralRule } = this._resolveHintCost(config);
		const uses = this.activity.uses;
		const usesPluralRule = getPluralRules().select(uses.value);
		return {
			label: game.i18n.localize(`BF.CONSUMPTION.Type.ActivityUses.Prompt${increaseKey}`),
			hint: game.i18n.format(`BF.CONSUMPTION.Type.ActivityUses.PromptHint${increaseKey}`, {
				cost,
				use: game.i18n.localize(`BF.CONSUMPTION.Type.Use.${pluralRule}`),
				available: numberFormat(uses.value),
				availableUse: game.i18n.localize(`BF.CONSUMPTION.Type.Use.${usesPluralRule}`)
			}),
			warn: simplifiedCost > uses.value
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create hint text indicating how much of this resource will be consumed/recovered.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @param {boolean} consumed - Is this consumption currently set to be consumed?
	 * @returns {ConsumptionLabels}
	 */
	static consumptionLabelsAttribute(config, consumed) {
		const { cost, simplifiedCost, increaseKey } = this._resolveHintCost(config);
		const current = foundry.utils.getProperty(this.actor.system, this.target);
		return {
			label: game.i18n.localize(`BF.CONSUMPTION.Type.Attribute.Prompt${increaseKey}`),
			hint: game.i18n.format(`BF.CONSUMPTION.Type.Attribute.PromptHint${increaseKey}`, {
				cost,
				attribute: getAttributeOption(this.target)?.label ?? this.target,
				current: numberFormat(current)
			}),
			warn: simplifiedCost > current
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create hint text indicating how much of this resource will be consumed/recovered.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @param {boolean} consumed - Is this consumption currently set to be consumed?
	 * @returns {ConsumptionLabels}
	 */
	static consumptionLabelsHitDice(config, consumed) {
		const { cost, simplifiedCost, increaseKey, pluralRule } = this._resolveHintCost(config);
		let denomination;
		if (this.target === "smallest") denomination = game.i18n.localize("BF.CONSUMPTION.Type.HitDice.Smallest");
		else if (this.target === "largest") denomination = game.i18n.localize("BF.CONSUMPTION.Type.HitDice.Largest");
		else denomination = `d${this.target}`;
		const available =
			(["smallest", "largest"].includes(this.target)
				? this.actor.system.attributes?.hd?.available
				: this.actor.system.attributes?.hd?.d[this.target]?.available) ?? 0;
		return {
			label: game.i18n.localize(`BF.CONSUMPTION.Type.HitDice.Prompt${increaseKey}`),
			hint: game.i18n.format(`BF.CONSUMPTION.Type.HitDice.PromptHint${increaseKey}`, {
				cost,
				denomination: denomination.toLowerCase(),
				die: game.i18n.localize(`BF.CONSUMPTION.Type.HitDie.${pluralRule}`),
				available: numberFormat(available)
			}),
			warn: simplifiedCost > available
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create hint text indicating how much of this resource will be consumed/recovered.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @param {boolean} consumed - Is this consumption currently set to be consumed?
	 * @returns {ConsumptionLabels}
	 */
	static consumptionLabelsItemUses(config, consumed) {
		const { cost, simplifiedCost, increaseKey, pluralRule } = this._resolveHintCost(config);
		const item = this.actor.items.get(this.target);
		const itemName = item ? item.name : game.i18n.localize("BF.CONSUMPTION.Type.ItemUses.ThisItem").toLowerCase();
		const uses = (item ?? this.item).system.uses;
		const usesPluralRule = getPluralRules().select(uses.value);

		let totalUses = uses.value;
		if (uses.consumeQuantity) {
			let quantity = (item ?? this.item).system.quantity ?? 1;
			if (uses.value) quantity -= 1;
			totalUses += quantity * (uses.max || 1);
		}

		return {
			label: game.i18n.localize(`BF.CONSUMPTION.Type.ItemUses.Prompt${increaseKey}`),
			hint: game.i18n.format(`BF.CONSUMPTION.Type.ItemUses.PromptHint${increaseKey}`, {
				cost,
				use: game.i18n.localize(`BF.CONSUMPTION.Type.Use.${pluralRule}`),
				available: numberFormat(totalUses),
				availableUse: game.i18n.localize(`BF.CONSUMPTION.Type.Use.${usesPluralRule}`),
				item: item ? `<em>${itemName}</em>` : itemName
			}),
			warn: simplifiedCost > totalUses
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create hint text indicating how much of this resource will be consumed/recovered.
	 * @this {ConsumptionTargetData}
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @param {boolean} consumed - Is this consumption currently set to be consumed?
	 * @returns {ConsumptionLabels}
	 */
	static consumptionLabelsSpellSlots(config, consumed) {
		const { cost, simplifiedCost, increaseKey, pluralRule } = this._resolveHintCost(config);
		const number = Math.clamp(this.resolveCircle({ config }), 1, CONFIG.BlackFlag.maxSpellCircle);
		const level = CONFIG.BlackFlag.spellCircles()[number].toLowerCase();
		const available = this.actor.system.spellcasting?.slots?.[`circle-${number}`]?.value ?? 0;
		return {
			label: game.i18n.localize(`BF.CONSUMPTION.Type.SpellSlots.Prompt${increaseKey}`),
			hint: game.i18n.format(`BF.CONSUMPTION.Type.SpellSlots.PromptHint${increaseKey}`, {
				cost,
				slot: game.i18n.format(`BF.CONSUMPTION.Type.SpellSlot.${pluralRule}`, { level }),
				available: numberFormat(available)
			}),
			warn: simplifiedCost > available
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve the cost for the consumption hint.
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activity usage.
	 * @returns {{ cost: string, simplifiedCost: number, increaseKey: string, pluralRule: string }}
	 * @internal
	 */
	_resolveHintCost(config) {
		const costRoll = this.resolveCost({ config, evaluate: false });
		let cost = costRoll.isDeterministic ? String(costRoll.evaluateSync().total) : simplifyFormula(costRoll.formula);
		const simplifiedCost = simplifyBonus(cost);
		const isNegative = cost.startsWith("-");
		if (isNegative) cost = cost.replace("-", "");
		let pluralRule;
		if (costRoll.isDeterministic) pluralRule = new Intl.PluralRules(game.i18n.lang).select(Number(cost));
		else pluralRule = "other";
		return { cost, simplifiedCost, increaseKey: isNegative ? "Increase" : "Decrease", pluralRule };
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Valid Targets            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a list of targets for the "Attribute" consumption type.
	 * @this {ConsumptionTargetData}
	 * @returns {FormSelectOption[]}
	 */
	static validAttributeTargets() {
		if (!this.actor) return [];
		return (CONFIG.BlackFlag.consumableResources[this.actor.type] ?? [])
			.map(a => getAttributeOption(a))
			.sort((lhs, rhs) => {
				if (lhs.group === rhs.group) return lhs.label.localeCompare(rhs.label, game.i18n.lang);
				const lhsKey = lhs.group || lhs.label;
				const rhsKey = rhs.group || rhs.label;
				return lhsKey.localeCompare(rhsKey, game.i18n.lang);
			});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a list of targets for the "Hit Dice" consumption type.
	 * @this {ConsumptionTargetData}
	 * @returns {FormSelectOption[]}
	 */
	static validHitDiceTargets() {
		return [
			{ value: "smallest", label: game.i18n.localize("BF.CONSUMPTION.Type.HitDice.Smallest") },
			...CONFIG.BlackFlag.hitDieSizes.map(d => ({ value: d, label: `d${d}` })),
			{ value: "largest", label: game.i18n.localize("BF.CONSUMPTION.Type.HitDice.Largest") }
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a list of targets for the "Item Uses" consumption type.
	 * @this {ConsumptionTargetData}
	 * @returns {FormSelectOption[]}
	 */
	static validItemUsesTargets() {
		const makeLabel = (name, item) => {
			let label;
			const uses = item.system.uses;
			if (
				uses.max &&
				uses.recovery?.length === 1 &&
				uses.recovery[0].type === "recoverAll" &&
				uses.recovery[0].period !== "recharge"
			) {
				const period = CONFIG.BlackFlag.recoveryPeriods.localizedAbbreviations[uses.recovery[0].period];
				label = game.i18n.format("BF.CONSUMPTION.Uses.Available.Period", { value: numberFormat(uses.max), period });
			} else {
				const type = game.i18n.localize(
					`BF.CONSUMPTION.Uses.Available.Charges[${getPluralRules().select(uses.value)}]`
				);
				label = game.i18n.format("BF.CONSUMPTION.Uses.Available.Limited", { value: numberFormat(uses.value), type });
			}
			return `${name} (${label})`;
		};
		const options = [
			{ value: "", label: makeLabel(game.i18n.localize("BF.CONSUMPTION.Type.ItemUses.ThisItem"), this.item) }
		];
		const items = (this.actor?.items ?? []).filter(i => i.system.uses?.max && i !== this.item);
		if (items.length) options.push({ rule: true }, ...items.map(i => ({ value: i.id, label: makeLabel(i.name, i) })));
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a list of targets for the "Spell Slots" consumption type.
	 * @this {ConsumptionTargetData}
	 * @returns {FormSelectOption[]}
	 */
	static validSpellSlotsTargets() {
		return Object.entries(CONFIG.BlackFlag.spellCircles()).reduce((arr, [value, label]) => {
			if (value !== "0") arr.push({ value, label });
			return arr;
		}, []);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve the spell circle to consume, taking scaling into account.
	 * @param {object} [options={}]
	 * @param {ActivityActivationConfiguration} [options.config={}] - Configuration info for the activation.
	 * @param {BasicRoll[]} [options.rolls] - Rolls performed as part of the activation.
	 * @returns {number}
	 */
	resolveCircle({ config = {}, ...options } = {}) {
		const roll = this._resolveScaledRoll(this.target, this.scaling.mode === "circle" ? config.scaling ?? 0 : 0, {
			...options,
			evaluate: false
		});
		roll.evaluateSync();
		return roll.total;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve the provided cost formula as a dice roll.
	 * @param {object} [options={}]
	 * @param {ActivityActivationConfiguration} [options.config={}] - Configuration info for the activation.
	 * @param {boolean} [options.evaluate=true] - Should the cost roll be evaluated?
	 * @param {BasicRoll[]} [options.rolls] - Rolls performed as part of the activation.
	 * @returns {Promise<BasicRoll>|BasicRoll}
	 */
	resolveCost({ config = {}, ...options } = {}) {
		return this._resolveScaledRoll(this.value, this.scaling.mode === "amount" ? config.scaling ?? 0 : 0, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve a scaling consumption value.
	 * @param {string} formula - Formula for the initial value.
	 * @param {number} scaling - Amount to scale the formula.
	 * @param {object} [options={}]
	 * @param {boolean} [options.evaluate=true] - Should the roll be evaluated?
	 * @param {BasicRoll[]} [options.rolls] - Rolls performed as part of the activation.
	 * @returns {Promise<BasicRoll>|BasicRoll}
	 * @internal
	 */
	_resolveScaledRoll(formula, scaling, { evaluate = true, rolls } = {}) {
		const rollData = this.parent.item.getRollData();
		const roll = new CONFIG.Dice.BasicRoll(formula, rollData);

		if (scaling) {
			// If a scaling formula is provided, multiply it and add to the end of the initial formula
			if (this.scaling.formula) {
				const scalingRoll = new Roll(this.scaling.formula, rollData);
				scalingRoll.alter(scaling, undefined, { multiplyNumeric: true });
				roll.terms.push(new foundry.dice.terms.OperatorTerm({ operator: "+" }), ...scalingRoll.terms);
			}

			// Otherwise increase the number of dice and the numeric term for each scaling step
			else {
				roll.terms = roll.terms.map(term => {
					if (term instanceof foundry.dice.terms.DiceTerm) return term.alter(undefined, scaling);
					else if (term instanceof foundry.dice.terms.NumericTerm) term.number += term.number >= 0 ? scaling : -scaling;
					return term;
				});
			}

			roll.resetFormula();
		}

		if (evaluate)
			return roll.evaluate().then(roll => {
				if (rolls && !roll.isDeterministic) rolls.push(roll);
				return roll;
			});
		if (rolls && !roll.isDeterministic) rolls.push(roll);
		return roll;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Error to throw when consumption cannot be achieved.
 */
class ConsumptionError extends Error {
	constructor(...args) {
		super(...args);
		this.name = "ConsumptionError";
	}
}

const {
	BooleanField: BooleanField$n,
	DocumentIdField: DocumentIdField$a,
	FilePathField: FilePathField$1,
	HTMLField: HTMLField$a,
	IntegerSortField: IntegerSortField$1,
	ObjectField: ObjectField$4,
	SchemaField: SchemaField$W,
	StringField: StringField$Y
} = foundry.data.fields;

/**
 * Data model for activities.
 *
 * @property {string} _id - Unique ID for the activity on an item.
 * @property {string} type - Type name of the activity used to build a specific activity class.
 * @property {string} name - Name for this activity.
 * @property {string} img - Image that represents this activity.
 * @property {string} description - Activity's description.
 * @property {Record<string, object>} flags - Flag data.
 * @property {number} sort - Sorting order for the activity.
 * @property {*} system - Type-specific data.
 * @property {ActivationField} activation
 * @property {boolean} activation.override - Should the item's activation be overridden?
 * @property {number} activation.primary - Is this the primary activation for this item? Mainly used to indicate what
 *                                         activity corresponds with casting a spell.
 * @property {object} consumption
 * @property {ConsumptionTargetData[]} consumption.targets - Collection of consumption targets.
 * @property {object} consumption.scale
 * @property {boolean} consumption.scale.allowed - Can this non-spell activity be activated at higher levels?
 * @property {string} consumption.scale.max - Maximum number of scaling levels for this item.
 * @property {DurationField} duration
 * @property {boolean} duration.concentration - Does this activity require concentration?
 * @property {boolean} duration.override - Should the item's duration be overridden?
 * @property {RangeField} range
 * @property {boolean} range.override - Should the item's range be overridden?
 * @property {boolean} magical - Is this considered a magical effect?
 * @property {TargetField} target
 * @property {boolean} target.prompt - Should template placement be checked by default?
 * @property {boolean} target.override - Should the item's targeting data be overridden?
 * @property {UsesField} uses
 */
class BaseActivity extends foundry.abstract.DataModel {
	/**
	 * Base type information for an activity.
	 *
	 * @typedef {PseudoDocumentsMetadata} BaseActivityMetadata
	 * @property {string} type - Type of the activity.
	 */

	/**
	 * @type {BaseActivityMetadata}
	 */
	static metadata = Object.freeze({
		name: "Activity",
		collection: "activities",
		label: "BF.ACTIVITY.Label[one]",
		type: "base"
	});

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Name of this activity type that will be stored in config and used for lookups.
	 * @type {string}
	 * @protected
	 */
	static get typeName() {
		return this.metadata.type ?? this.name.replace(/Activity$/, "");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = [
		"BF.ACTIVITY",
		"BF.ACTIVATION",
		"BF.CONSUMPTION",
		"BF.DURATION",
		"BF.RANGE",
		"BF.TARGET",
		"BF.USES"
	];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static defineSchema() {
		return {
			_id: new DocumentIdField$a({ initial: () => foundry.utils.randomID() }),
			type: new StringField$Y({
				required: true,
				readOnly: true,
				initial: this.typeName,
				validate: v => v === this.typeName,
				validationError: `must be the same as the Activity type name ${this.typeName}`
			}),
			name: new StringField$Y({ initial: undefined }),
			img: new FilePathField$1({ blank: true, initial: undefined, categories: ["IMAGE"], base64: false }),
			description: new HTMLField$a(),
			flags: new MappingField(new ObjectField$4()),
			sort: new IntegerSortField$1(),
			system: new TypeField({ modelLookup: type => this.metadata.dataModel ?? null }),
			activation: new ActivationField({
				override: new BooleanField$n(),
				primary: new BooleanField$n({ required: false, initial: true })
			}),
			consumption: new SchemaField$W({
				targets: new ConsumptionTargetsField(),
				scale: new SchemaField$W({
					allowed: new BooleanField$n(),
					max: new FormulaField()
				})
			}),
			duration: new DurationField({
				concentration: new BooleanField$n(),
				override: new BooleanField$n()
			}),
			range: new RangeField({
				override: new BooleanField$n()
			}),
			magical: new BooleanField$n(),
			target: new TargetField({
				prompt: new BooleanField$n({ initial: true }),
				override: new BooleanField$n()
			}),
			uses: new UsesField({ consumeQuantity: false })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should the magical status of this activity be inherited from its containing item?
	 * @type {boolean}
	 */
	get inheritMagical() {
		return this.isSpell || "magical" in (this.item.system.validProperties ?? {});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate custom damage formulas to object.
	 * Added in 0.9.035
	 * @param {DamageField} source - Candidate source data for a damage entry to migrate.
	 */
	static _migrateCustomDamageFormula(source) {
		if (foundry.utils.getType(source.custom) === "string") {
			source.custom = { enabled: source.custom !== "", formula: source.custom };
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareFinalData() {
		const rollData = this.item.getRollData();
		this.uses.prepareData(rollData);

		const prepareFinalValue = (keyPath, label) =>
			foundry.utils.setProperty(
				this,
				keyPath,
				simplifyBonus(
					replaceFormulaData(foundry.utils.getProperty(this, keyPath) ?? "", rollData, {
						notifications: this.item.notifications,
						key: `activity-${this.id}-invalid-target-${keyPath.replaceAll(".", "-")}`,
						section: "auto",
						messageData: {
							name: `${this.item.name} (${this.name})`,
							property: game.i18n.localize(label)
						}
					})
				)
			);

		this.setProperty("activation.value", "system.casting.value");
		this.setProperty("activation.type", "system.casting.type");
		this.setProperty("activation.condition", "system.casting.condition");

		this._setOverride("activation", "casting");
		this._setOverride("duration");
		this._setOverride("range");
		this._setOverride("target");

		Object.defineProperty(this, "_inferredSource", {
			value: this.toObject(false),
			configurable: false,
			enumerable: false,
			writable: false
		});

		prepareFinalValue("duration.value", "BF.DURATION.Label");
		prepareFinalValue("target.affects.count", "BF.TARGET.Label[other]");
		prepareFinalValue("target.template.count", "BF.TARGET.FIELDS.template.count.label");
		prepareFinalValue("target.template.size", "BF.AreaOfEffect.Size.Label");
		prepareFinalValue("target.template.width", "BF.AreaOfEffect.Size.Width");
		prepareFinalValue("target.template.height", "BF.AreaOfEffect.Size.Height");
		prepareFinalValue("uses.max", "BF.Uses.Maximum.DebugName");

		this.activation.type ??= "action";
		this.activation.primary ??= true;

		// TODO: Add ability to have uses increase without clamping to max
		this.uses.value = Math.clamp(this.uses.max - this.uses.spent, 0, this.uses.max);
		Object.defineProperty(this.uses, "label", {
			get() {
				if (this.max) return `${numberFormat(this.value)} / ${numberFormat(this.max)}`;
				return "";
			},
			configurable: true,
			enumerable: false
		});

		// Re-link UUIDs in consumption fields to explicit items
		if (this.item.isEmbedded) {
			for (const target of this.consumption.targets) {
				if (target.target && target.type === "item") {
					if (target.target?.includes(".")) {
						const item = this.item.actor.sourcedItems?.get(target.target)?.first();
						if (item) target.target = item.id;
					}
					if (!this.item.actor.items.get(target.target))
						this.item.notifications.set(`activity-${this.id}-missing-consumption-${target.target}`, {
							level: "error",
							section: "auto",
							message: game.i18n.format("BF.CONSUMPTION.Warning.MissingItem", { activity: this.name })
						});
				}
			}
		}

		if (this.inheritMagical) this.magical = this.isSpell || this.item.system.properties.has("magical");

		this.system.prepareFinalData?.();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add an `canOverride` property to the provided object and, if `override` is `false`, replace the data on the
	 * activity with data from the item.
	 * @param {string} activityKeyPath - Path of the property to set on the activity.
	 * @param {string} [itemKeyPath] - Optional item key path, if different than actor key path.
	 * @internal
	 */
	_setOverride(activityKeyPath, itemKeyPath) {
		const obj = foundry.utils.getProperty(this, activityKeyPath);
		Object.defineProperty(obj, "canOverride", {
			value: foundry.utils.hasProperty(this.item.system, itemKeyPath ?? activityKeyPath),
			configurable: true,
			enumerable: false
		});
		if (obj.canOverride && !obj.override) {
			foundry.utils.mergeObject(obj, foundry.utils.getProperty(this.item.system, itemKeyPath ?? activityKeyPath));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set a property on the activity with a value from the item so long as it is currently blank and the item's
	 * property isn't blank.
	 * @param {string} activityKeyPath - Path of the property to set on the activity.
	 * @param {string} itemKeyPath - Path of the property to get from the item.
	 */
	setProperty(activityKeyPath, itemKeyPath) {
		const activityProperty = foundry.utils.getProperty(this, activityKeyPath);
		const itemProperty = foundry.utils.getProperty(this.item, itemKeyPath);
		if (!activityProperty && itemProperty) foundry.utils.setProperty(this, activityKeyPath, itemProperty);
	}
}

const { ArrayField: ArrayField$o, NumberField: NumberField$E, SchemaField: SchemaField$V, StringField: StringField$X } = foundry.data.fields;

/**
 * @typedef ActorDeltasData
 * @property {IndividualDeltaData[]} actor - Changes for the actor.
 * @property {Record<string, IndividualDeltaData[]>} item - Changes for each item grouped by ID.
 */

/**
 * @typedef DeltaDisplayContext
 * @property {string} type - Type of document to which the delta applies.
 * @property {string} delta - The formatted numeric change.
 * @property {BlackFlagActor|BlackFlagItem} document - The document to which the delta applies.
 * @property {string} label - The formatted label for the attribute.
 * @property {Roll[]} [rolls] - Any rolls associated with the delta.
 */

/**
 * A field for storing deltas made to an actor or embedded items.
 */
class ActorDeltasField extends SchemaField$V {
	constructor(fields = {}, options = {}) {
		super(
			{
				actor: new ArrayField$o(new IndividualDeltaField()),
				item: new MappingField(new ArrayField$o(new IndividualDeltaField())),
				...fields
			},
			options
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate delta information for an actor document from the given updates.
	 * @param {BlackFlagActor} actor - Actor for which to calculate the deltas.
	 * @param {{ actor: object, item: object[] }} updates - Updates to apply to the actor and contained items.
	 * @returns {ActorDeltasData}
	 */
	static getDeltas(actor, updates) {
		return {
			actor: IndividualDeltaField.getDeltas(actor, updates.actor),
			item: updates.item.reduce((obj, { _id, ...changes }) => {
				const deltas = IndividualDeltaField.getDeltas(actor.items.get(_id), changes);
				if (deltas.length) obj[_id] = deltas;
				return obj;
			}, {})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare deltas for display in a chat message.
	 * @this {ActorDeltasData}
	 * @param {BlackFlagActor} actor - Actor to which this delta applies.
	 * @param {Roll[]} [rolls] - Rolls that may be associated with a delta.
	 * @returns {DeltaDisplayContext[]}
	 */
	static processDeltas(actor, rolls = []) {
		return [
			...this.actor.map(d =>
				IndividualDeltaField.processDelta.call(
					d,
					actor,
					rolls.filter(r => !r.options.delta?.item && r.options.delta?.keyPath === d.keyPath)
				)
			),
			...Object.entries(this.item).flatMap(([id, deltas]) =>
				deltas.map(d =>
					IndividualDeltaField.processDelta.call(
						d,
						actor.items.get(id),
						rolls.filter(r => r.options.delta?.item === id && r.options.delta?.keyPath === d.keyPath)
					)
				)
			)
		];
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef IndividualDeltaData
 * @property {number} delta    The change in the specified field.
 * @property {string} keyPath  Path to the changed field on the document.
 */

/**
 * A field that stores a delta for an individual property on an actor or item.
 */
class IndividualDeltaField extends SchemaField$V {
	constructor() {
		super({ delta: new NumberField$E(), keyPath: new StringField$X() });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate delta information for a document from the given updates.
	 * @param {DataModel} dataModel - Document for which to calculate the deltas.
	 * @param {object} updates - Updates that are to be applied.
	 * @returns {IndividualDeltaData[]}
	 */
	static getDeltas(dataModel, updates) {
		updates = foundry.utils.flattenObject(updates);
		const deltas = [];
		for (const [keyPath, value] of Object.entries(updates)) {
			let currentValue;
			if (keyPath.startsWith("system.activities")) {
				const [id, ...kp] = keyPath.slice(18).split(".");
				currentValue = foundry.utils.getProperty(dataModel.system.activities?.get(id) ?? {}, kp.join("."));
			} else currentValue = foundry.utils.getProperty(dataModel, keyPath);

			const delta = value - currentValue;
			if (delta && !Number.isNaN(delta)) deltas.push({ keyPath, delta });
		}
		return deltas;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare a delta for display in a chat message.
	 * @this {IndividualDeltaData}
	 * @param {BlackFlagActor|BlackFlagItem} doc - Actor or item to which this delta applies.
	 * @param {Roll[]} [rolls] - Rolls that may be associated with a delta.
	 * @returns {DeltaDisplayContext}
	 */
	static processDelta(doc, rolls = []) {
		const type = doc instanceof Actor ? "actor" : "item";
		const value = this.keyPath.endsWith(".spent") ? -this.delta : this.delta;
		return {
			type,
			delta: formatNumber(value, { signDisplay: "always" }),
			document: doc,
			label: getAttributeOption(this.keyPath, { [type]: doc }).label,
			rolls: rolls.map(roll => ({ roll, anchor: roll.toAnchor().outerHTML.replace(`${roll.total}</a>`, "</a>") }))
		};
	}
}

/**
 * Mixin used to share backported embed logic between Documents and PseudoDocuments.
 * Backported from V12, can be removed when V11 support is dropped.
 * @type {function(Class): Class}
 * @mixin
 */
var EmbedMixin = Base => {
	let created = class extends Base {};

	for (const method of ["toEmbed", "_buildEmbedHTML", "_createFigureEmbed", "_createInlineEmbed"]) {
		created.prototype[method] ??= Actor.prototype[method];
	}

	created = class extends created {
		/** @inheritDoc */
		async _createInlineEmbed(content, config, options) {
			const section = await super._createInlineEmbed(content, config, options);
			if (config.label && section.children[0]) {
				const inlineCaption = document.createElement("strong");
				inlineCaption.classList.add("inline-caption");
				inlineCaption.innerText = config.label;
				section.children[0].insertAdjacentElement("afterbegin", inlineCaption);
			}
			return section;
		}
	};

	return created;
};

/**
 * A mixin which extends a DataModel to provide a CRUD-layer similar to normal Documents.
 * @param {typeof DataModel} Base - The base DataModel to be mixed.
 * @returns {typeof PseudoDocument}
 * @mixin
 */
var PseudoDocumentMixin = Base =>
	class extends EmbedMixin(Base) {
		constructor(data, { parent = null, ...options } = {}) {
			if (parent instanceof Item) parent = parent.system;
			super(data, { parent, ...options });
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Mapping of PseudoDocument UUID to the apps they should re-render.
		 * @type {Map<string, Set<string>>}
		 * @internal
		 */
		static _apps = new Map();

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Existing sheets of a specific type for a specific document.
		 * @type {Map<[PseudoDocument, typeof Application], Application>}
		 */
		static _sheets = new Map();

		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		_initialize(options) {
			super._initialize(options);
			if (!game._documentsReady) return;
			return this.prepareData();
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*         Model Configuration         */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Configuration information for PseudoDocuments.
		 *
		 * @typedef {object} PseudoDocumentsMetadata
		 * @property {string} name - Base type name of this PseudoDocument (e.g. "Activity", "Advancement").
		 * @property {string} collection - Location of the collection of pseudo documents within system data.
		 * @property {string} type - Sub-type of PseudoDocument.
		 * @property {string} label - Localized name for this PseudoDocument type.
		 */

		/**
		 * Configuration information for PseudoDocuments.
		 * @type {PseudoDocumentsMetadata}
		 */
		get metadata() {
			return this.constructor.metadata;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * The named collection to which this PseudoDocument belongs.
		 * @type {string}
		 */
		static get collectionName() {
			return this.metadata.collection;
		}

		/**
		 * The named collection to which this PseudoDocument belongs.
		 * @type {string}
		 */
		get collectionName() {
			return this.constructor.collectionName;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * The canonical name of this PseudoDocument type, for example "Actor".
		 * @type {string}
		 */
		static get documentName() {
			return this.metadata.name;
		}

		/**
		 * The canonical name of this PseudoDocument type, for example "Actor".
		 * @type {string}
		 */
		get documentName() {
			return this.constructor.documentName;
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*         Instance Properties         */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Unique identifier for this PseudoDocument within its item.
		 * @type {string}
		 */
		get id() {
			return this._id;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Unique ID for this PseudoDocument on an actor.
		 * @type {string}
		 */
		get relativeID() {
			return `${this.item.id}.${this.id}`;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Globally unique identifier for this PseudoDocument.
		 * @type {string}
		 */
		get uuid() {
			return `${this.item.uuid}.${this.documentName}.${this.id}`;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Item to which this PseudoDocument belongs.
		 * @type {BlackFlagItem}
		 */
		get item() {
			return this.parent.parent;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Actor to which this PseudoDocument's item belongs, if the item is embedded.
		 * @type {BlackFlagActor|null}
		 */
		get actor() {
			return this.item.parent ?? null;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Lazily obtain a FormApplication instance used to configure this PseudoDocument, or null if no sheet is available.
		 * @type {FormApplication|null}
		 */
		get sheet() {
			const cfg = CONFIG[this.documentName].types;
			const cls = cfg[this.type]?.sheetClasses?.config ?? cfg[CONST.BASE_DOCUMENT_TYPE].sheetClasses.config;
			if (!cls) return null;
			const def = `${this.uuid}!${cls.name}`;
			if (!this.constructor._sheets.has(def)) {
				this.constructor._sheets.set(def, new cls(this, { editable: this.item.isOwner }));
			}
			return this.constructor._sheets.get(def);
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Prepare a data object which defines the data schema used by dice roll commands against this Activity.
		 * @param {object} [options]
		 * @param {boolean} [options.deterministic] - Whether to force deterministic values for data properties that could
		 *                                            be either a die term or a flat term.
		 * @returns {object}
		 */
		getRollData(options) {
			return this.item.getRollData(options);
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*         Preparation Methods         */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Prepare data for the PseudoDocument.
		 */
		prepareData() {}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Perform preliminary operations before an Advancement is created.
		 * @param {object} data - The initial data object provided to the document creation request.
		 * @returns {boolean|void} - A return value of false indicates the creation operation should be cancelled.
		 * @protected
		 */
		_preCreate(data) {}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*           Display Methods           */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Render all of the Application instances which are connected to this PseudoDocument.
		 * @param {boolean} [force=false] - Force rendering
		 * @param {object} [context={}] - Optional context
		 */
		render(force = false, context = {}) {
			for (const app of this.constructor._apps.get(this.uuid) ?? []) app.render(force, context);
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Register an application to respond to updates to a certain document.
		 * @param {PseudoDocument} doc - Pseudo document to watch.
		 * @param {Application} app - Application to update.
		 * @internal
		 */
		static _registerApp(doc, app) {
			if (!this._apps.has(doc.uuid)) this._apps.set(doc.uuid, new Set());
			this._apps.get(doc.uuid).add(app);
		}

		/**
		 * Remove an application from the render registry.
		 * @param {PseudoDocument} doc - Pseudo document being watched.
		 * @param {Application} app - Application to stop watching.
		 */
		static _unregisterApp(doc, app) {
			this._apps.get(doc?.uuid)?.delete(app);
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		async _buildEmbedHTML(config, options = {}) {
			return this.toEmbedContents?.(config, options) ?? null;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Convert this Document to some HTML display for embedding purposes.
		 * @param {DocumentHTMLEmbedConfig} config - Configuration for embedding behavior.
		 * @param {EnrichmentOptions} [options] - The original enrichment options for cases where the Document embed content
		 *                                        also contains text that must be enriched.
		 * @returns {Promise<HTMLElement|HTMLCollection|null>}
		 */
		async toEmbedContents(config, options) {
			return null;
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*           Editing Methods           */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Remove unnecessary keys from the context before passing it through to the update.
		 * @param {DocumentModificationContext} context
		 * @returns {DocumentModificationContext}
		 * @internal
		 */
		static _clearedDocumentModificationContext(context) {
			context = foundry.utils.deepClone(context);
			delete context.parent;
			delete context.pack;
			delete context.keepId;
			delete context.keepEmbeddedIds;
			delete context.renderSheet;
			return context;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Validate that a PseudoDocument can be created.
		 * @param {object} data - Data for creating a single PseudoDocument.
		 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the creation workflow.
		 * @throws
		 */
		static _validateDocumentCreation(data, context) {}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Create multiple PseudoDocuments using provided input data.
		 * Data is provided as an array of objects where each individual object becomes one new PseudoDocument.
		 * See Foundry's Document#createDocuments documentation for more information.
		 *
		 * @param {object[]} data - An array of data objects used to create multiple PseudoDocuments.
		 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the creation workflow.
		 * @returns {Promise<PseudoDocument[]>} - An array of created PseudoDocuments instances.
		 */
		static async createDocuments(data = [], context = {}) {
			if (!context.parent) throw new Error("Cannot create pseudo documents without a parent.");
			const updates = data.reduce((updates, data) => {
				if (!context.keepId || !data._id) data._id = foundry.utils.randomID();
				const c = CONFIG[this.documentName].types[data.type];
				const createData = foundry.utils.deepClone(data);
				const created = new c.documentClass(data, { parent: context.parent });
				if (created._preCreate(createData) !== false) {
					updates[data._id] = created.toObject();
					this._validateDocumentCreation(data, context);
				}
				return updates;
			}, {});
			await context.parent.update(
				{ [`system.${this.collectionName}`]: updates },
				this._clearedDocumentModificationContext(context)
			);
			const documents = Object.keys(updates).map(id => context.parent.getEmbeddedDocument(this.documentName, id));
			if (context.renderSheet) documents.forEach(d => d.sheet.render(true));
			return documents;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Update multiple PseudoDocuments instances using provided differential data.
		 * Data is provided as an array of objects where each individual object updates one existing PseudoDocuments.
		 * See Foundry's Document#updateDocuments documentation for more information.
		 *
		 * @param {object[]} updates - An array of differential data objects, each used to update a single PseudoDocuments.
		 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the update workflow.
		 * @returns {Promise<PseudoDocument[]>} - An array of updated PseudoDocuments instances.
		 */
		static async updateDocuments(updates = [], context = {}) {
			if (!context.parent) throw new Error("Cannot update pseudo documents without a parent.");
			updates = updates.reduce((updates, data) => {
				if (!data._id) throw new Error("ID must be provided when updating an pseudo document");
				const c =
					CONFIG[this.documentName].types[
						data.type ?? context.parent.getEmbeddedDocument(this.documentName, data._id)?.type
					];
				const removals = Object.entries(foundry.utils.flattenObject(data)).reduce((obj, [k, v]) => {
					if (k.includes("-=")) obj[k] = v;
					return obj;
				}, {});
				updates[data._id] = foundry.utils.mergeObject(
					c?.documentClass.cleanData(foundry.utils.expandObject(data), { partial: true }) ?? data,
					removals
				);
				return updates;
			}, {});
			await context.parent.update(
				{ [`system.${this.collectionName}`]: updates },
				this._clearedDocumentModificationContext(context)
			);
			return Object.keys(updates).map(id => context.parent.getEmbeddedDocument(this.documentName, id));
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Delete one or multiple existing Documents using an array of provided ids.
		 * Data is provided as an array of string ids for the PseudoDocuments to delete.
		 * See Foundry's Document#deleteDocuments documentation for more information.
		 *
		 * @param {string[]} ids - An array of string ids for the PseudoDocuments to be deleted.
		 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the deletion workflow.
		 * @returns {Promise<PseudoDocument[]>} - An array of deleted PseudoDocument instances.
		 */
		static async deleteDocuments(ids, context = {}) {
			if (!context.parent) throw new Error("Cannot delete pseudo documents without a parent.");
			const closing = [];
			const { updates, documents } = ids.reduce(
				({ updates, documents }, id) => {
					const doc = context.parent.getEmbeddedDocument(this.documentName, id);
					closing.push(Promise.allSettled(doc.constructor._apps.get(doc.uuid)?.map(a => a.close()) ?? []));
					documents.push(doc);
					updates[`system.${this.collectionName}.-=${id}`] = null;
					return { updates, documents };
				},
				{ updates: {}, documents: [] }
			);
			await Promise.allSettled(closing);
			await context.parent.update(updates, this._clearedDocumentModificationContext(context));
			return documents;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Update this PseudoDocument.
		 * @param {object} [data={}] - Updates to apply to this PseudoDocument.
		 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the update workflow.
		 * @returns {Promise<PseudoDocument>} - This PseudoDocument after updates have been applied.
		 */
		async update(data = {}, context = {}) {
			await this.item.updateEmbeddedDocuments(this.documentName, [{ ...data, _id: this.id }], context);
			if (context.render !== false) this.render();
			return this;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Update this PseudoDocument's data on the item without performing a database commit.
		 * @param {object} updates - Updates to apply to this PseudoDocument.
		 * @returns {PseudoDocument} - This PseudoDocument after updates have been applied.
		 */
		updateSource(updates) {
			super.updateSource(updates);
			return this;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Delete this PseudoDocument, removing it from the database.
		 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the deletion workflow.
		 * @returns {Promise<PseudoDocument>} - The deleted PseudoDocument instance.
		 */
		async delete(context = {}) {
			const deleted = await this.item.deleteEmbeddedDocuments(this.documentName, [this.id], context);
			return deleted.shift();
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Present a Dialog form to confirm deletion of this PseudoDocument.
		 * @param {object} [options] - Positioning and sizing options for the resulting dialog.
		 * @returns {Promise<PseudoDocument>} - A Promise which resolves to the deleted PseudoDocument.
		 */
		async deleteDialog(options = {}) {
			const type = game.i18n.localize(this.metadata.title);
			return Dialog.confirm({
				title: `${game.i18n.format("DOCUMENT.Delete", { type })}: ${this.name || this.title}`,
				content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.format("SIDEBAR.DeleteWarning", {
					type
				})}</p>`,
				yes: this.delete.bind(this),
				options: options
			});
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Serialize salient information for this PseudoDocument when dragging it.
		 * @returns {object} - An object of drag data.
		 */
		toDragData() {
			const dragData = { type: this.documentName, data: this.toObject() };
			if (this.id) dragData.uuid = this.uuid;
			return dragData;
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*           Flag Operations           */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Get the value of a flag for this PseudoDocument.
		 * @param {string} scope - The flag scope which namespaces the key.
		 * @param {string} key - The flag key.
		 * @returns {*} - The flag value.
		 */
		getFlag(scope, key) {
			const scopes = Item.database.getFlagScopes();
			if (!scopes.includes(scope)) throw new Error(`Flag scope "${scope}" is not valid or not currently active.`);
			return foundry.utils.getProperty(this.flags?.[scope], key);
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Assign a flag to this PseudoDocument.
		 * @param {string} scope - The flag scope which namespaces the key.
		 * @param {string} key - The flag key.
		 * @param {*} value - The flag value.
		 * @returns {Promise<PseudoDocument>} - A Promise resolving to the updated PseudoDocument.
		 */
		async setFlag(scope, key, value) {
			const scopes = Item.database.getFlagScopes();
			if (!scopes.includes(scope)) throw new Error(`Flag scope "${scope}" is not valid or not currently active.`);
			return this.update({ flags: { [scope]: { [key]: value } } });
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Remove a flag assigned to the PseudoDocument.
		 * @param {string} scope - The flag scope which namespaces the key.
		 * @param {string} key - The flag key.
		 * @returns {Promise<Document>} - The updated document instance.
		 */
		async unsetFlag(scope, key) {
			const scopes = Item.database.getFlagScopes();
			if (!scopes.includes(scope)) throw new Error(`Flag scope "${scope}" is not valid or not currently active.`);
			const head = key.split(".");
			const tail = `-=${head.pop()}`;
			return this.update({ [["flags", scope, ...head, tail].join(".")]: null });
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*       Importing and Exporting       */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Create a content link for this PseudoDocument.
		 * @param {object} [options] - Additional options to configure how the link is constructed.
		 * @param {Record<string>} [options.attrs] -  Attributes to set on the link.
		 * @param {Record<string>} [options.dataset] - Custom data- attributes to set on the link.
		 * @param {string[]} [options.classes] - Additional classes to add to the link. The `content-link` class is added
		 *                                       by default.
		 * @param {string} [options.name] - A name to use for the Document, if different from the Document's name.
		 * @param {string} [options.icon] - A font-awesome icon class to use as the icon, if different to the
		 *                                  Document's configured sidebarIcon.
		 * @returns {HTMLAnchorElement}
		 */
		toAnchor({ attrs = {}, dataset = {}, classes = [], name, icon } = {}) {
			// Build dataset
			const documentConfig = CONFIG[this.documentName];
			const documentName = game.i18n.localize(`DOCUMENT.BF.${this.documentName}`);
			let anchorIcon = icon ?? documentConfig.sidebarIcon ?? "fas fa-suitcase";
			dataset = foundry.utils.mergeObject(
				{
					uuid: this.uuid,
					id: this.id,
					type: this.documentName,
					pack: this.item.pack,
					tooltip: documentName
				},
				dataset
			);

			// If this is a typed document, add the type to the dataset
			if (this.type) {
				const typeLabel = documentConfig.typeLabels?.[this.type];
				const typeName = game.i18n.has(typeLabel) ? `${game.i18n.localize(typeLabel)}` : "";
				dataset.tooltip = typeName
					? game.i18n.format("DOCUMENT.TypePageFormat", { type: typeName, page: documentName })
					: documentName;
				anchorIcon = icon ?? documentConfig.typeIcons?.[this.type] ?? documentConfig.sidebarIcon ?? anchorIcon;
			}

			// Construct Link
			const a = document.createElement("a");
			a.classList.add("content-link", ...classes);
			Object.entries(attrs).forEach(([k, v]) => a.setAttribute(k, v));
			for (const [k, v] of Object.entries(dataset)) {
				if (v !== null) a.dataset[k] = v;
			}
			a.innerHTML = `<i class="${anchorIcon}"></i>`;
			a.append(name ?? this.name ?? this.title);
			return a;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Handle clicking on a content link for this document.
		 * @param {MouseEvent} event - The triggering click event.
		 * @returns {any}
		 * @protected
		 */
		_onClickDocumentLink(event) {
			return this.sheet.render(true);
		}
	};

/**
 * @import { ActivityDeltasData } from "../../data/chat-message/activation-message-data.mjs";
 */

/**
 * Abstract base class which various activity types can subclass.
 * @param {object} [data={}] - Raw data stored in the activity object.
 * @param {object} [options={}] - Options which affect DataModel construction.
 * @abstract
 */
class Activity extends PseudoDocumentMixin(BaseActivity) {
	/**
	 * Information on how an advancement type is configured.
	 *
	 * @typedef {BaseActivityMetadata} ActivityMetadata
	 * @property {typeof DataModel} [dataModel] - Data model for custom system data.
	 * @property {string} icon - Icon used if no user icon is specified.
	 * @property {string} title - Title to be displayed if no user title is specified.
	 * @property {string} hint - Description of this type shown in the activity selection dialog.
	 * @property {object} usage
	 * @property {Record<string, Function>} usage.actions - Actions that can be triggered from the chat card.
	 * @property {string} usage.chatCard - Template used to render chat cards.
	 * @property {typeof ActivityActivationDialog} usage.dialog - Application used for the activation dialog by default.
	 */

	/**
	 * Configuration information for this activity type.
	 * @type {ActivityMetadata}
	 */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				icon: "",
				title: "BF.ACTIVITY.Label[one]",
				hint: "",
				usage: {
					actions: {
						placeTemplate: Activity.#placeTemplate
					},
					chatCard: "systems/black-flag/templates/activity/chat/activation-card.hbs",
					dialog: ActivityActivationDialog
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform the pre-localization of this data model.
	 */
	static localize() {
		Localization.localizeDataModel(this);
		if (this.metadata.dataModel) this.metadata.dataModel.localize();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform pre-localization on the contents of a SchemaField. Necessary because the `localizeSchema` method
	 * on `Localization` is private.
	 * @param {SchemaField} schema
	 * @param {string[]} prefixes
	 * @internal
	 */
	static _localizeSchema(schema, prefixes) {
		localizeSchema(schema, prefixes);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The primary ability for this activity that will be available as `@mod` in roll data.
	 * @type {string|null}
	 */
	get ability() {
		return this.system.ability ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The action type that is used to activate this activity.
	 * @type {string}
	 */
	get actionType() {
		return this.activation.type;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The label used for activation buttons.
	 * @type {string}
	 */
	get activationLabel() {
		return `BF.ACTIVITY.Core.Action.${this.isSpell ? "Cast" : "Use"}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is scaling possible with this activity?
	 * @type {boolean}
	 */
	get canScale() {
		return (
			this.consumption.scale.allowed ||
			(this.isSpell &&
				this.item.system.circle.base > 0 &&
				(CONFIG.BlackFlag.spellPreparationModes[this.item.getFlag(game.system.id, "relationship.mode")]?.scalable ??
					true))
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can damage be scaled for this activity? Requires either "Allow Scaling" to be checked or to be on a spell.
	 * @type {boolean}
	 */
	get canScaleDamage() {
		return this.consumption.scale.allowed || this.isSpell;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contents of the challenge column in the action table.
	 * @type {string}
	 */
	get challengeColumn() {
		return "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tags that should be displayed in chat.
	 * @type {Map<string, string>}
	 */
	get chatTags() {
		const tags = this.item.system.chatTags ?? this.item.chatTags;
		tags.set("activation", this.activation.label);
		tags.set("duration", this.duration.label);
		if (this.range.units) tags.set("range", this.range.label);
		if (this.target.affects.type) tags.set("affects", this.target.affects.label);
		if (this.target.template.units) tags.set("template", this.target.template.label);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Description used in chat message flavor for messages created with `rollDamage`.
	 * @type {string}
	 */
	get damageFlavor() {
		return game.i18n.localize("BF.DAMAGE.Label");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Damage modifier with any adjustments applied.
	 * @type {number}
	 */
	get damageModifier() {
		const ability = this.actor?.system.abilities?.[this.ability];
		if (!ability) return 0;
		return ability?.adjustedMod ?? ability?.mod;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should this activity be displayed as an action on the character sheet?
	 * @type {boolean}
	 */
	get displayAction() {
		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contents of the effect column in the action table.
	 * @type {string}
	 */
	get effectColumn() {
		if (!this.hasDamage) return "";
		const layout = document.createElement("div");
		layout.classList.add("layout");
		const rollConfig = this.getDamageConfig();
		for (const roll of rollConfig.rolls) {
			let formula = roll.parts.join(" + ");
			formula = Roll.defaultImplementation.replaceFormulaData(formula, roll.data);
			formula = simplifyFormula(formula);
			if (formula) {
				const damageType = CONFIG.BlackFlag.damageTypes[roll.options.damageType];
				layout.innerHTML += `<span class="damage">${formula} ${game.i18n.localize(damageType?.label ?? "")}</span>`;
			}
		}
		return layout.outerHTML;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Are any damage parts actually configured for this activity?
	 * @type {boolean}
	 */
	get hasDamage() {
		return this.system.damage?.parts?.length > 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this activity on a spell item, or something else?
	 * @type {boolean}
	 */
	get isSpell() {
		return this.system.isSpell;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Data used to display the activity in the inventory or activity selection lists.
	 * @type {object}
	 */
	get listContext() {
		// TODO: Uses / Activation / Range / Target / Traits (for spells)
		// TODO: Uses / Traits (for inventory)
		// TODO: Uses (for features)
		return { id: this.id, name: this.name, img: this.img, svgImg: this.img.endsWith(".svg") };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create the data added to messages flags.
	 * @type {object}
	 */
	get messageFlags() {
		return {
			activity: { type: this.type, id: this.id, uuid: this.uuid },
			item: { type: this.item.type, id: this.item.id, uuid: this.item.uuid },
			targets: getTargetDescriptors()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Data used when fetching modifiers associated with this activity.
	 * @type {object}
	 */
	get modifierData() {
		return {
			activity: this.system,
			actor: this.actor?.getRollData(),
			class: this.item.system.associatedClass?.identifier,
			item: this.item.getRollData()?.item
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Relative UUID for this activity on an actor.
	 * @type {string}
	 */
	get relativeUUID() {
		return `.Item.${this.item.id}.Activity.${this.id}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does activating this activity consume a spell slot?
	 * @type {boolean}
	 */
	get spellSlotConsumption() {
		return this.spellSlotScaling && this.item.system.requiresSpellSlot && this.activation.primary;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can a spell slot be selected when activating this activity?
	 * @type {boolean}
	 */
	get spellSlotScaling() {
		if (!this.isSpell || !this.actor?.system.spellcasting?.slots) return false;
		return this.canScale;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contents of the uses column in action table.
	 * @type {string}
	 */
	get usesColumn() {
		const uses = document.createElement("div");
		uses.classList.add("layout");
		if (this.consumption.targets.find(t => t.type === "item")) {
			const itemUses = this.item.system.uses;
			if (itemUses.max) {
				uses.innerHTML += `<span>${numberFormat(itemUses.value)} / ${numberFormat(itemUses.max)}</span>`;
			} else if (itemUses.consumeQuantity && this.item.system.isPhysical) {
				uses.innerHTML += `<span>${numberFormat(this.item.system.quantity)}</span>`;
			}
		}
		if (this.consumption.targets.find(t => t.type === "activity")) {
			uses.innerHTML += `<span>${numberFormat(this.uses.value)} / ${numberFormat(this.uses.max)}</span>`;
		}
		return uses.outerHTML;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Consumption targets that can be use for this activity.
	 * @type {Set<string>}
	 */
	get validConsumptionTypes() {
		const types = new Set(Object.keys(CONFIG.BlackFlag.consumptionTypes));
		if (this.isSpell) types.delete("spellSlots");
		return types;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareData() {
		this.name = this.name || game.i18n.localize(this.constructor.metadata.title);
		this.img = this.img || this.constructor.metadata.icon;
		this.system.prepareData?.();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbedContents(config, options) {
		const div = document.createElement("div");
		div.innerHTML = await TextEditor.enrichHTML(this.description, {
			relativeTo: this,
			secrets: false,
			rollData: this.item.getRollData()
		});
		return div.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _createInlineEmbed(content, config, options) {
		if (!config.values?.includes("activate") || !this.item.isEmbedded) {
			return super._createInlineEmbed(content, config, options);
		}

		const section = document.createElement("section");
		if (content instanceof HTMLCollection) section.append(...content);
		else section.append(content);

		let insert = section.children[0];
		if (!insert) {
			insert = document.createElement("p");
			section.append(insert);
		}

		const control = document.createElement("button");
		control.type = "button";
		control.classList.add("inline-caption", "link-button");
		control.dataset.action = "activate";
		control.dataset.activityUuid = this.uuid;
		control.innerText = config.label ?? this.name;
		section.children[0].insertAdjacentElement("afterbegin", control);

		return section;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration data for an activity's activation.
	 *
	 * @typedef {object} ActivityActivationConfiguration
	 * @property {object} [cause]
	 * @property {string} [cause.activity] - Relative UUID to the activity that caused this one to be activated.
	 *                                       Activity must be on the same actor as this one.
	 * @property {boolean|number[]} [cause.resources] - Control resource consumption on linked activity.
	 * @property {object|false} create
	 * @property {boolean} create.measuredTemplate - Should measured templates defined by activity be created?
	 * @property {boolean|object} consume - Consumption configuration, set to `false` to prevent all consumption.
	 * @property {boolean} consume.action - Control whether a part of the action economy is used during activation.
	 * @property {boolean|BlackFlagItem} consume.ammunition - Control whether ammunition is consumed by a weapon or
	 *                                                        provide an ammunition item to consume.
	 * @property {boolean|number[]} consume.resources - Set to `true` or `false` to enable or disable all resource
	 *                                                  consumption or provide a list of consumption indexes to only
	 *                                                  enable those types.
	 * @property {boolean} consume.spellSlot - Control whether spell consumes a spell slot.
	 * @property {Event} [event] - Triggering event.
	 * @property {boolean|number} scaling - Number of steps above baseline to scale this activation, or `false` if scaling
	 *                                      is not allowed.
	 * @property {object} [spell]
	 * @property {number} [spell.circle] - Spell circle to consume. Replaces `scaling` on property for spells.
	 * @property {boolean} [subsequentActions=true] - Trigger subsequent actions defined by this activity.
	 * @property {TargetDescriptor[]} targets - Tokens targeted during activation.
	 */

	/**
	 * Data for the activity activation configuration dialog.
	 *
	 * @typedef {object} ActivityDialogConfiguration
	 * @property {boolean} [configure=true] - Should the activation configuration dialog be displayed?
	 * @property {typeof ActivityActivationDialog} [applicationClass] - Alternate activation dialog to use.
	 * @property {object} [options] - Options passed through to the dialog.
	 */

	/**
	 * Message configuration data used when creating messages.
	 *
	 * @typedef {object} ActivityMessageConfiguration
	 * @property {boolean} [create=true] - Should a message be created when this roll is complete?
	 * @property {object} [data={}] - Additional data used when creating the message.
	 * @property {boolean} [hasConsumption] - Was consumption available during activation?
	 * @property {string} [template] - Template to use for rendering the chat card.
	 */

	/**
	 * Details of final changes performed by the activation.
	 *
	 * @typedef {object} ActivityActivationResults
	 * @property {BlackFlagChatMessage|ActivityMessageConfiguration} message - The chat message created for the
	 *                                                                         activation, or the message data if create
	 *                                                                         was `false`.
	 * @property {MeasuredTemplateDocument[]} templates - Created measured templates.
	 * @property {ActivationUpdates} updates - Updates to the actor & items.
	 */

	/**
	 * Activate this activity.
	 * @param {Partial<ActivityActivationConfiguration>} config - Configuration info for the activation.
	 * @param {Partial<ActivityDialogConfiguration>} dialog - Configuration info for the configuration dialog.
	 * @param {Partial<ActivityMessageConfiguration>} message - Configuration info for the chat message created.
	 * @returns {ActivityActivationResults}
	 */
	async activate(config = {}, dialog = {}, message = {}) {
		if (!this.item.isEmbedded || !this.item.isOwner || this.item.pack) return;

		let item = this.item.clone({}, { keepId: true });
		let activity = item.system.activities.get(this.id);

		const activationConfig = activity._prepareActivationConfig(config);

		const dialogConfig = foundry.utils.mergeObject(
			{
				applicationClass: this.metadata.usage.dialog
			},
			dialog
		);

		const messageConfig = foundry.utils.mergeObject(
			{
				create: true,
				data: {
					flags: {
						[game.system.id]: this.messageFlags
					},
					system: {
						effects: this.system.applicableEffects?.map(e => e.id)
					}
				},
				hasConsumption: activationConfig.hasConsumption,
				template: this.metadata.usage.chatCard
			},
			message
		);

		this._applyKeybindings(activationConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires before an activity activation is configured.
		 * @function blackFlag.preActivateActivity
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity being activated.
		 * @param {ActivityActivationConfiguration} activationConfig - Configuration data for the activation.
		 * @param {ActivityDialogConfiguration} dialogConfig - Configuration data for the activity activation dialog.
		 * @param {ActivityMessageConfiguration} messageConfig - Configuration data for the activity message to be created.
		 * @returns {boolean} - Explicitly return `false` to prevent activity from being activated.
		 */
		if (Hooks.call("blackFlag.preActivateActivity", activity, activationConfig, dialogConfig, messageConfig) === false)
			return;

		// Display configuration window if necessary, wait for result
		if (dialogConfig.configure && activity._requiresConfigurationDialog(activationConfig)) {
			try {
				await dialogConfig.applicationClass.create(activity, activationConfig, dialogConfig.options);
			} catch (err) {
				return;
			}
		}

		// Handle scaling
		this._prepareActivationScaling(activationConfig, messageConfig, item);
		activity = item.system.activities.get(this.id);

		// Handle consumption
		const updates = await activity.consume(activationConfig, messageConfig);
		if (updates === false) return;
		const results = { templates: [], updates };

		// TODO: Create activated effect/track concentration

		// Display the card in chat
		messageConfig.data.rolls = (messageConfig.data.rolls ?? []).concat(updates.rolls);
		if (config.targets?.length) {
			foundry.utils.setProperty(messageConfig, `data.flags.${game.system.id}.targets`, config.targets);
		}
		results.message = await activity.createActivationMessage(messageConfig);

		// Finalize the activation
		await activity._finalizeActivation(activationConfig, results);

		/**
		 * A hook event that fires when an activity is activated.
		 * @function blackFlag.postActivateActivity
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity being activated.
		 * @param {ActivityActivationConfiguration} activationConfig - Configuration data for the activation.
		 * @param {ActivityActivationResults} results - Results of the activation.
		 */
		if (Hooks.call("blackFlag.postActivateActivity", activity, activationConfig, results) === false) return;

		// Trigger any primary action provided by this activity
		if (activationConfig.subsequentActions !== false) activity._triggerSubsequentActions(activationConfig, results);

		return results;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Consume this activity's usage.
	 * @param {ActivityActivationConfiguration} activationConfig - Any configuration data provided manually.
	 * @param {ActivityMessageConfiguration} messageConfig - Configuration data for the chat message.
	 * @returns {ActivationUpdates|false}
	 */
	async consume(activationConfig, messageConfig) {
		/**
		 * A hook event that fires before an item's resource consumption is calculated.
		 * @function blackFlag.preActivityConsumption
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity being activated.
		 * @param {ActivityActivationConfiguration} activationConfig - Configuration data for the activation.
		 * @param {ActivityMessageConfiguration} messageConfig - Configuration data for the activity message to be created.
		 * @returns {boolean} - Explicitly return `false` to prevent activity from being activated.
		 */
		if (Hooks.call("blackFlag.preActivityConsumption", this, activationConfig, messageConfig) === false) return false;

		// Calculate what resources should be consumed
		const updates = await this._prepareActivationUpdates(activationConfig);
		if (updates === false) return false;

		/**
		 * A hook event that fires after an item's resource consumption is calculated, but before an updates are performed.
		 * @function blackFlag.activityConsumption
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity being activated.
		 * @param {ActivityActivationConfiguration} activationConfig - Configuration data for the activation.
		 * @param {ActivityMessageConfiguration} messageConfig - Configuration data for the activity message to be created.
		 * @param {ActivationUpdates} updates - Updates that will be applied to the actor and other documents.
		 * @returns {boolean} - Explicitly return `false` to prevent activity from being activated.
		 */
		if (Hooks.call("blackFlag.activityConsumption", this, activationConfig, messageConfig, updates) === false) {
			return false;
		}

		// Merge activity changes into the item updates
		if (!foundry.utils.isEmpty(updates.activity)) {
			const itemIndex = updates.item.findIndex(i => i._id === this.item.id);
			const keyPath = `system.activities.${this.id}`;
			const activityUpdates = foundry.utils.expandObject(updates.activity);
			if (itemIndex === -1) updates.item.push({ _id: this.item.id, [keyPath]: activityUpdates });
			else updates.item[itemIndex][keyPath] = activityUpdates;
		}

		const consumed = await this.#applyActivationUpdates(updates);
		if (!foundry.utils.isEmpty(consumed)) foundry.utils.setProperty(messageConfig, "data.system.deltas", consumed);
		if (activationConfig.cause?.activity)
			foundry.utils.setProperty(messageConfig, "data.system.cause", activationConfig.cause.activity);

		/**
		 * A hook event that fires after an item's resource consumption is calculated and applied.
		 * @function blackFlag.postActivityConsumption
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity being activated.
		 * @param {ActivityActivationConfiguration} activationConfig - Configuration data for the activation.
		 * @param {ActivityMessageConfiguration} messageConfig - Configuration data for the activity message to be created.
		 * @param {ActivationUpdates} updates - Updates that have been applied to the actor and other documents.
		 * @returns {boolean} - Explicitly return `false` to prevent activity from being activated.
		 */
		if (Hooks.call("blackFlag.postActivityConsumption", this, activationConfig, messageConfig, updates) === false) {
			return false;
		}

		return updates;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply any keybindings that might affect activation process.
	 * @param {ActivityActivationConfiguration} config - Configuration info for the activation.
	 * @param {ActivityDialogConfiguration} dialog - Configuration info for the configuration dialog.
	 * @param {ActivityMessageConfiguration} message - Configuration info for the chat message created.
	 * @protected
	 */
	_applyKeybindings(config, dialog, message) {
		dialog.configure ??=
			!areKeysPressed(config.event, "skipDialogNormal") &&
			!areKeysPressed(config.event, "skipDialogAdvantage") &&
			!areKeysPressed(config.event, "skipDialogDisadvantage");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Merge activity updates into the appropriate item updates and apply.
	 * @param {ActivationUpdates} updates
	 * @returns {ActivityDeltasData} - Information on consumption performed to store in message flag.
	 */
	async #applyActivationUpdates(updates) {
		this._mergeActivityUpdates(updates);

		// Ensure no existing items are created again & no non-existent items try to be deleted
		updates.create = updates.create?.filter(i => !this.actor.items.has(i));
		updates.delete = updates.delete?.filter(i => this.actor.items.has(i));

		const consumed = ActorDeltasField.getDeltas(this.actor, updates);
		if (foundry.utils.isEmpty(consumed.actor)) delete consumed.actor;
		if (foundry.utils.isEmpty(consumed.item)) delete consumed.item;
		if (updates.create?.length) consumed.created = updates.create;
		if (updates.delete?.length) consumed.deleted = updates.delete.map(i => this.actor.items.get(i).toObject());

		// Update documents with consumption
		if (!foundry.utils.isEmpty(updates.actor)) await this.actor.update(updates.actor);
		if (!foundry.utils.isEmpty(updates.create)) {
			await this.actor.createEmbeddedDocuments("Item", updates.create, { keepId: true });
		}
		if (!foundry.utils.isEmpty(updates.delete)) await this.actor.deleteEmbeddedDocuments("Item", updates.delete);
		if (!foundry.utils.isEmpty(updates.item)) await this.actor.updateEmbeddedDocuments("Item", updates.item);

		return consumed;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare activation configuration object with the necessary defaults based on the activity and item.
	 * @param {ActivityActivationConfiguration} [config={}] - Any configuration data provided manually.
	 * @returns {ActivityActivationConfiguration}
	 * @protected
	 */
	_prepareActivationConfig(config = {}) {
		config = foundry.utils.deepClone(config);
		const linked = this.getLinkedActivity(config.cause?.activity);

		if (config.create !== false) {
			config.create ??= {};
			config.create.measuredTemplate ??= this.target.template.type && this.target.prompt;
		}

		if (config.consume !== false) {
			const hasActionConsumption = this.activation.type === "legendary";
			const hasResourceConsumption = this.consumption.targets.length > 0;
			const hasLinkedConsumption = linked?.consumption.targets.length > 0;
			const hasSpellSlotConsumption = this.spellSlotConsumption;
			config.consume ??= {};
			config.consume.action ??= hasActionConsumption;
			config.consume.resources ??= hasResourceConsumption;
			config.consume.spellSlot ??= !linked && hasSpellSlotConsumption;
			config.hasConsumption =
				hasActionConsumption || hasResourceConsumption || hasLinkedConsumption || (!linked && hasSpellSlotConsumption);
		}

		const canScale = linked ? linked.consumption.scale.allowed : this.canScale;
		const linkedDelta = (linked?.system.spell?.circle ?? Infinity) - (this.item.system.circle?.base ?? Infinity);
		if (!canScale) config.scaling = false;
		else if (Number.isFinite(linkedDelta)) config.scaling ??= linkedDelta;

		if (this.spellSlotScaling) {
			const mode = this.item.getFlag(game.system.id, "relationship.mode");
			config.spell ??= {};
			config.spell.slot ??= linked?.system.spell?.circle
				? `circle-${linked.system.spell.circle}`
				: mode in this.actor.system.spellcasting.slots
					? mode
					: `circle-${this.item.system.circle.base}`;
			const scaling =
				(this.actor.system.spellcasting.slots[config.spell.slot]?.circle ?? 0) -
				(this.item.system.circle?.base ?? -Infinity);
			if (scaling > 0) config.scaling ??= scaling;
		}

		config.scaling ??= 0;
		config.targets ??= getTargetDescriptors();

		// TODO: Begin concentration

		if (linked) {
			config.cause ??= {};
			config.cause.activity ??= linked.relativeUUID;
			config.cause.resources ??= linked.consumption.targets.length > 0;
		}

		return config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine scaling values and update item clone if necessary.
	 * @param {ActivityActivationConfiguration} activationConfig - Configuration data for the activation.
	 * @param {ActivityMessageConfiguration} messageConfig - Configuration data for the chat message.
	 * @param {BlackFlagItem} item - Clone of the item upon which the activation is occurring.
	 * @protected
	 */
	_prepareActivationScaling(activationConfig, messageConfig, item) {
		const scaleUpdate = {};

		if (item.type === "spell") {
			const circle = item.system.tags.has("ritual")
				? this.actor.system.spellcasting?.maxCircle
				: this.actor.system.spellcasting?.slots?.[activationConfig.spell?.slot]?.circle;
			if (circle) {
				foundry.utils.setProperty(
					messageConfig.data,
					`flags.${game.system.id}.spellSlot`,
					activationConfig.spell?.slot
				);
				if (circle !== item.system.circle.base) {
					scaleUpdate["system.circle.value"] = circle;
					activationConfig.scaling = circle - item.system.circle.base;
				}
			}
		}

		if (activationConfig.scaling !== undefined) {
			scaleUpdate[`flags.${game.system.id}.scaling`] = activationConfig.scaling;
			foundry.utils.setProperty(messageConfig.data, `flags.${game.system.id}.scaling`, activationConfig.scaling);
			item.actor._embeddedPreparation = true;
			item.updateSource(scaleUpdate);
			item.actor._embeddedPreparation = false;
			item.system.prepareFinalData?.();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Update data produced by activity activation.
	 *
	 * @typedef {object} ActivationUpdates
	 * @property {object} activity - Updates applied to activity that performed the activation.
	 * @property {object} actor - Updates applied to the actor that performed the activation.
	 * @property {object[]} create - Full data for Items to create (with IDs maintained).
	 * @property {string[]} delete - IDs of items to be deleted from the actor.
	 * @property {object[]} item - Updates applied to items on the actor that performed the activation.
	 * @property {Roll[]} rolls - Any rolls performed as part of the activation.
	 */

	/**
	 * Calculate changes to actor, items, & this activity based on resource consumption.
	 * @param {ActivityActivationConfiguration} config - Activation configuration.
	 * @param {object} [options={}]
	 * @param {boolean} [options.returnErrors=false] - Return array of errors, rather than displaying them.
	 * @returns {ActivationUpdates|ConsumptionError[]|false}
	 * @protected
	 */
	async _prepareActivationUpdates(config, { returnErrors = false } = {}) {
		const updates = { activity: {}, actor: {}, create: [], delete: [], item: [], rolls: [] };
		if (!config.consume) return updates;
		const errors = [];

		// Handle action economy
		if ((config.consume === true || config.consume.action) && this.activation.type === "legendary") {
			const count = this.activation.value ?? 1;
			const legendary = this.actor.system.attributes?.legendary;
			if (legendary) {
				let errMessage;
				if (legendary.value === 0) errMessage = "BF.ACTIVATION.Warning.NoActions";
				else if (count > legendary.value) errMessage = "BF.ACTIVATION.Warning.NotEnoughActions";
				if (!errMessage) {
					updates.actor["system.attributes.legendary.spent"] = legendary.spent + count;
				} else {
					const err = new ConsumptionError(
						game.i18n.format(errMessage, {
							type: CONFIG.BlackFlag.actionTypes.localized[this.activation.type],
							required: numberFormat(count),
							available: numberFormat(legendary.value)
						})
					);
					errors.push(err);
				}
			}
		}

		// Handle consumption targets
		if (config.consume === true || config.consume.resources) {
			const indexes =
				config.consume === true || config.consume.resources === true
					? this.consumption.targets.keys()
					: config.consume.resources;
			for (const index of indexes) {
				const target = this.consumption.targets[index];
				try {
					await target.consume(config, updates);
				} catch (err) {
					if (err instanceof ConsumptionError) errors.push(err);
					else throw err;
				}
			}
		}

		// Handle consumption on a linked activity
		if (config.cause) {
			const linkedActivity = this.getLinkedActivity(config.cause.activity);
			if (linkedActivity) {
				const consume = {
					resources:
						config.consume === true || config.cause?.resources === true
							? linkedActivity.consumption.targets.keys()
							: config.cause?.resources,
					spellSlot: false
				};
				const activationConfig = foundry.utils.mergeObject(config, { consume, cause: false }, { inplace: false });
				const results = await linkedActivity._prepareActivationUpdates(activationConfig, { returnErrors: true });
				if (foundry.utils.getType(results) === "Object") {
					linkedActivity._mergeActivityUpdates(results);
					foundry.utils.mergeObject(updates.actor, results.actor);
					updates.create.push(...results.create);
					updates.delete.push(...results.delete);
					updates.item.push(...results.item);
					updates.rolls.push(...results.rolls);
					// Mark this item for deletion if it is linked to a cast activity that will be deleted
					if (
						updates.delete.includes(linkedActivity.item.id) &&
						this.item.getFlag(game.system.id, "cachedFor") === linkedActivity.relativeUUID
					) {
						updates.delete.push(this.item.id);
					}
				} else if (results?.length) {
					errors.push(...results);
				}
			}
		}

		// Handle spell slot consumption
		else if ((config.consume === true || config.consume.spellSlot) && this.isSpell) {
			const slot = config.spell?.slot ?? `circle-${this.item.system.circle?.value ?? this.item.system.circle?.base}`;
			const slotData = this.actor.system.spellcasting?.slots[slot];
			if (slotData?.value) {
				updates.actor[`system.spellcasting.slots.${slot}.spent`] = slotData.spent + 1;
			} else {
				const err = new ConsumptionError(
					game.i18n.format("BF.Spellcasting.Warning.NoLeveledSlot", {
						circle: slotData.label,
						circleLowercase: slotData.label?.toLowerCase()
					})
				);
				errors.push(err);
				ui.notifications.error(err.message, { console: false });
			}
		}

		// TODO: Validate concentration

		if (!returnErrors) errors.forEach(err => ui.notifications.error(err.message, { console: false }));
		return errors.length ? (returnErrors ? errors : false) : updates;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine if the configuration dialog is required based on the configuration options. Does not guarantee a dialog
	 * is shown if the dialog is suppressed in the activation dialog configuration.
	 * @param {ActivityActivationConfiguration} config
	 * @returns {boolean}
	 * @protected
	 */
	_requiresConfigurationDialog(config) {
		const checkObject = obj => foundry.utils.getType(obj) === "Object" && Object.values(obj).some(v => v);
		return (
			checkObject(config.create) ||
			((checkObject(config.consume) || config.cause?.resources === true) && config.hasConsumption) ||
			config.scaling !== false
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the context for item activation.
	 * @returns {object}
	 * @protected
	 */
	async _activationChatContext() {
		const buttons = this._activationChatButtons();
		return {
			activity: this,
			item: this.item,
			actor: this.item.actor,
			token: this.item.actor?.token,
			buttons: buttons.length ? buttons : null,
			subtitle: this.name,
			tags: Array.from(this.chatTags.entries())
				.map(([key, label]) => ({ key, label }))
				.filter(t => t.label),
			description: await TextEditor.enrichHTML(this.description || this.item.system.description.value, {
				relativeTo: this.description ? this : this.item,
				rollData: this.item.getRollData(),
				secrets: false,
				async: true
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {object} ActivityActivationChatButton
	 * @property {string} label    Label to display on the button.
	 * @property {string} icon     Icon to display on the button.
	 * @property {string} classes  Classes for the button.
	 * @property {object} dataset  Data attributes attached to the button.
	 */

	/**
	 * Create the buttons that will be displayed in chat.
	 * @returns {ActivityActivationChatButton[]}
	 * @protected
	 */
	_activationChatButtons() {
		const buttons = [];

		if (this.target?.template?.type)
			buttons.push({
				label: game.i18n.localize("BF.TARGET.Action.PlaceTemplate"),
				icon: '<i class="fa-solid fa-bullseye" inert></i>',
				dataset: {
					action: "placeTemplate"
				}
			});

		return buttons;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine whether the provided button in a chat message should be visible.
	 * @param {HTMLButtonElement} button - The button to check.
	 * @param {BlackFlagChatMessage} message - Chat message containing the button.
	 * @returns {boolean}
	 */
	shouldHideChatButton(button, message) {
		switch (button.dataset.action) {
			case "placeTemplate":
				return !game.user.can("TEMPLATE_CREATE") || !game.canvas.scene;
		}
		return false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display an activation chat message for this activity.
	 * @param {ActivityMessageConfiguration} message - Configuration info for the created message.
	 * @returns {Promise<BlackFlagChatMessage|ActivityMessageConfiguration>}
	 */
	async createActivationMessage(message = {}) {
		const context = await this._activationChatContext();
		await this.item.system.prepareActivationChatContext?.(context);

		/**
		 * A hook event that fires before an activity activation card contents is rendered.
		 * @function blackFlag.preCreateActivationMessage
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity for which the card will be created.
		 * @param {ActivityMessageConfiguration} message - Configuration info for the created message.
		 * @param {object} context - Context that will be used to render the message.
		 */
		if (Hooks.call("blackFlag.preCreateActivationMessage", this, message, context) === false) return message;

		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					content: await renderTemplate(message.template ?? this.metadata.usage.chatCard, context),
					flags: {
						core: { canPopout: true }
					},
					speaker: ChatMessage.implementation.getSpeaker({ actor: this.item.actor }),
					type: "activation"
				},
				rollMode: game.settings.get("core", "rollMode")
			},
			message
		);
		ChatMessage.applyRollMode(messageConfig.data, messageConfig.rollMode);

		/**
		 * A hook event that fires before an activity activation card is created.
		 * @function blackFlag.createActivationMessage
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity for which the card will be created.
		 * @param {ActivityMessageConfiguration} message - Configuration info for the created message.
		 */
		if (Hooks.call("blackFlag.createActivationMessage", this, messageConfig) === false) return message;

		const card = messageConfig.create !== false ? await ChatMessage.create(messageConfig.data) : messageConfig;

		/**
		 * A hook event that fires after an activity activation card is created.
		 * @function blackFlag.postCreateActivationMessage
		 * @memberof hookEvents
		 * @param {Activity} activity - Activity for which the card was created.
		 * @param {BlackFlagChatMessage} message - Created chat message.
		 */
		if (messageConfig.create !== false) Hooks.callAll("blackFlag.postCreateActivationMessage", this, messageConfig);

		return card;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply any activity-type specific modifications to the rendered chat card.
	 * @param {BlackFlagChatMessage} message - Associated chat message.
	 * @param {HTMLElement} element - Element in the chat log.
	 * @abstract
	 */
	onRenderChatCard(message, element) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any final steps of the activation including creating measured templates.
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activation.
	 * @param {ActivityActivationResults} results - Final details on the activation.
	 * @protected
	 */
	async _finalizeActivation(config, results) {
		results.templates = config.create?.measuredTemplate ? await Activity.#placeTemplate.call(this) : [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Trigger a primary activation action defined by the activity (such as opening the attack dialog for attack rolls).
	 * @param {ActivityActivationConfiguration} config - Configuration data for the activation.
	 * @param {ActivityActivationResults} results - Final details on the activation.
	 * @protected
	 */
	async _triggerSubsequentActions(config, results) {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Rolls                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform a damage roll.
	 * @param {Partial<DamageRollProcessConfiguration>} [config] - Configuration information for the roll.
	 * @param {Partial<BasicRollDialogConfiguration>} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {Partial<BasicRollMessageConfiguration>} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<DamageRoll[]|void>}
	 */
	async rollDamage(config = {}, dialog = {}, message = {}) {
		if (!this.item.isEmbedded || this.item.pack) return;

		const rollConfig = this.getDamageConfig(config);
		rollConfig.subject = this;

		const allModifiers = rollConfig.rolls?.map(c => c.modifierData) ?? [];
		const dialogConfig = foundry.utils.mergeObject({
			options: {
				rollNotes: this.actor?.system.getModifiers?.(allModifiers, "note"),
				title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type: this.name })
			}
		});

		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					flags: {
						[game.system.id]: {
							...this.messageFlags,
							messageType: "roll",
							roll: { type: "damage" }
						}
					},
					flavor: `${this.name} - ${this.damageFlavor}`,
					speaker: ChatMessage.getSpeaker({ actor: this.item.actor })
				}
			},
			message
		);

		/**
		 * A hook event that fires before damage is rolled.
		 * @function blackFlag.preRollDamage
		 * @memberof hookEvents
		 * @param {DamageRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {BasicRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return false to prevent the roll from being performed.
		 */
		if (Hooks.call("blackFlag.preRollDamage", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.DamageRoll.build(rollConfig, dialogConfig, messageConfig);
		if (!rolls) return;

		const lastDamageTypes = rolls.reduce((obj, roll, index) => {
			obj[index] = roll.options.damageType;
			return obj;
		}, {});
		if (!foundry.utils.isEmpty(lastDamageTypes) && this.actor.items.has(this.item.id)) {
			await this.item.setFlag(game.system.id, `relationship.last.${this.id}.damageType`, lastDamageTypes);
		}

		/**
		 * A hook event that fires after damage has been rolled.
		 * @function blackFlag.postRollDamage
		 * @memberof hookEvents
		 * @param {DamageRoll[]} rolls - The resulting rolls.
		 * @param {object} [data]
		 * @param {Activity} [data.subject] - Activity for which the roll was performed.
		 */
		Hooks.callAll("blackFlag.postRollDamage", rolls, { subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activate listeners on a chat message.
	 * @param {ChatMessage} message - Associated chat message.
	 * @param {HTMLElement} html - Element in the chat log.
	 */
	activateChatListeners(message, html) {
		html.addEventListener("click", event => {
			const target = event.target.closest("[data-action]");
			if (target) this.#onChatAction(event, target, message);
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an action activated from an activity's chat message.
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	async #onChatAction(event, target, message) {
		const scaling = message.getFlag(game.system.id, "scaling") ?? 0;
		let item = this.item;
		if (scaling) {
			const updates = { [`flags.${game.system.id}.scaling`]: scaling };
			if (item.type === "spell") {
				updates["system.circle.value"] = (item.system.circle.value ?? item.system.circle.base) + scaling;
			}
			item = item.clone(updates, { keepId: true });
		}
		const activity = item.system.activities.get(this.id);

		const action = target.dataset.action;
		const handler = this.metadata.usage?.actions?.[action];
		target.disabled = true;
		try {
			if (handler) await handler.call(activity, event, target, message);
			else await activity._onChatAction(event, target, message);
		} catch (err) {
			Hooks.onError("Activity#onChatAction", err, { log: "error", notify: "error" });
		} finally {
			target.disabled = false;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an action activated from an activity's chat message. Action handlers in metadata are called first.
	 * This method is only called for actions which have no defined handler.
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 * @protected
	 */
	async _onChatAction(event, target, message) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle placing measured templates into the scene.
	 * @this {Activity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 * @returns {Promise<MeasuredTemplateDocument[]>}
	 */
	static async #placeTemplate(event, target, message) {
		const templates = [];
		const minimized = !this.actor?.sheet._minimized;
		await this.actor?.sheet?.minimize();

		try {
			for (const template of AbilityTemplate.fromActivity(this)) {
				const result = await template.drawPreview();
				if (result) templates.push(result);
			}
		} catch (err) {
			Hooks.onError("Activity#placeTemplate", err, {
				msg: game.i18n.localize("BF.TARGET.Warning.PlaceTemplate"),
				log: "error",
				notify: "error"
			});
		} finally {
			if (minimized) this.actor?.sheet?.maximize();
		}
		return templates;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve a list of targets based on selected tokens.
	 * @returns {BlackFlagActor[]}
	 */
	getActionTargets() {
		let targets = canvas.tokens.controlled.filter(t => t.actor);
		if (!targets.length && game.user.character) targets = game.user.character.getActiveTokens();
		if (!targets.length) ui.notifications.warn("BF.ACTIVITY.Core.Warning.NoTargets", { localize: true });
		// TODO: Alternatively fetch targeted tokens
		return targets;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the roll parts used to create the damage rolls.
	 * @param {Partial<DamageRollProcessConfiguration>} [config={}]
	 * @returns {DamageRollProcessConfiguration}
	 */
	getDamageConfig(config = {}) {
		if (!this.system.damage?.parts) return foundry.utils.mergeObject({ rolls: [] }, config);

		const rollConfig = foundry.utils.deepClone(config);
		const rollData = this.getRollData();
		rollConfig.rolls = this.system.damage.parts
			.map((d, index) => this._processDamagePart(d, rollConfig, rollData, { index }))
			.filter(d => d.parts.length)
			.concat(config.rolls ?? []);

		return rollConfig;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Damage formulas and activity.
	 * @param {object} [options={}] - Additional options that might affect fetched data.
	 * @returns {{ activity: Activity, rolls: DamageRollConfiguration[] }|null}
	 */
	getDamageDetails(options = {}) {
		return {
			activity: this,
			rolls: this.getDamageConfig({ attackMode: options.attackMode ?? (options.versatile ? "versatile" : null) }).rolls
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Process a single damage part into a roll configuration.
	 * @param {DamageData} damage - Damage to prepare for the roll.
	 * @param {Partial<DamageRollProcessConfiguration>} rollConfig - Roll configuration being built.
	 * @param {object} rollData - Roll data to populate with damage data.
	 * @param {object} [config={}]
	 * @param {object} [config.modifierData={}] - Extra data to be included in the modifier data.
	 * @param {number} [config.index=0] - Index of the damage part being prepared.
	 * @returns {DamageRollConfiguration}
	 * @protected
	 */
	_processDamagePart(damage, rollConfig, rollData, { modifierData = {}, index = 0 } = {}) {
		modifierData = foundry.utils.mergeObject({ ...this.modifierData, type: "damage", damage }, modifierData);
		const { parts, data } = buildRoll(
			{
				bonus: this.actor?.system.buildBonus?.(this.actor?.system.getModifiers?.(modifierData), { rollData })
			},
			rollData
		);
		const scaledFormula = damage.scaledFormula(rollConfig.scaling ?? rollData.scaling);
		if (scaledFormula) parts.unshift(scaledFormula);

		if (index === 0 && this.item.system.damage?.bonus) {
			parts.push(String(this.item.system.damage.bonus));
		}

		return {
			data,
			modifierData,
			parts,
			options: {
				damageType:
					damage.type === "variable"
						? this.item.getFlag(game.system.id, `relationship.last.${this.id}.damageType.${index}`) ??
							damage.additionalTypes?.first()
						: damage.type,
				damageTypes: damage.type === "variable" ? damage.additionalTypes : undefined,
				magical: this.magical,
				minimum: this.actor?.system.buildMinimum?.(this.actor?.system.getModifiers?.(modifierData, "min"), { rollData })
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve a linked activity based on the provided relative UUID, or the stored `cachedFor` value.
	 * @param {string} relativeUUID - Relative UUID for an activity on this actor.
	 * @returns {Activity|null}
	 */
	getLinkedActivity(relativeUUID) {
		if (!this.actor) return null;
		relativeUUID ??= this.item.getFlag(game.system.id, "cachedFor");
		return fromUuidSync(relativeUUID, { relative: this.actor, strict: false });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve the roll data for this activity.
	 * @param {object} [options={}]
	 * @returns {object}
	 */
	getRollData(options = {}) {
		const rollData = this.item.getRollData(options);
		const ability = this.actor?.system.abilities?.[this.ability] ?? {};
		rollData.activity = { ...this };
		rollData.mod = ability.adjustedMod ?? ability.mod ?? 0;
		return rollData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Merge the activity updates into this activity's item updates.
	 * @param {ActivationUpdates} updates
	 * @internal
	 */
	_mergeActivityUpdates(updates) {
		if (foundry.utils.isEmpty(updates.activity)) return;
		const itemIndex = updates.item.findIndex(i => i._id === this.item.id);
		const keyPath = `system.activities.${this.id}`;
		const activityUpdates = foundry.utils.expandObject(updates.activity);
		if (itemIndex === -1) updates.item.push({ _id: this.item.id, [keyPath]: activityUpdates });
		else updates.item[itemIndex][keyPath] = activityUpdates;
	}
}

/**
 * Activity for casting spells.
 */
class CastActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Static ID used for the enchantment that modifies spell data.
	 */
	static ENCHANTMENT_ID = staticID("bfspellchanges");

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "cast",
				dataModel: CastData,
				icon: "systems/black-flag/artwork/activities/cast.svg",
				title: "BF.CAST.Title",
				hint: "BF.CAST.Hint"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Cached copy of the associated spell stored on the actor.
	 * @type {BlackFlagItem|void}
	 */
	get cachedSpell() {
		return this.actor?.sourcedItems
			.get(this.system.spell.uuid)
			?.find(i => i.getFlag(game.system.id, "cachedFor") === this.relativeUUID);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should this spell be listed in the actor's spellbook?
	 * @type {boolean}
	 */
	get displayInSpellbook() {
		return this.item.system.magicAvailable !== false && this.system.spell.spellbook;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async activate(config = {}, dialog = {}, message = {}) {
		if (!this.item.isEmbedded || !this.item.isOwner || this.item.pack) return;

		/**
		 * A hook event that fires before a linked spell is used by a Cast activity.
		 * @function blackFlag.preUseLinkedSpell
		 * @memberof hookEvents
		 * @param {CastActivity} activity - Cast activity being used.
		 * @param {Partial<ActivityActivationConfiguration>} activationConfig - Configuration info for the activation.
		 * @param {Partial<ActivityDialogConfiguration>} dialogConfig - Configuration info for the usage dialog.
		 * @param {Partial<ActivityMessageConfiguration>} messageConfig - Configuration info for the created chat message.
		 * @returns {boolean}  Explicitly return `false` to prevent activity from being used.
		 */
		if (Hooks.call("blackFlag.preUseLinkedSpell", this, config, dialog, message) === false) return;

		let spell = this.cachedSpell;
		if (!spell) {
			[spell] = await this.actor.createEmbeddedDocuments("Item", [await this.getCachedSpellData()]);
		}

		const results = await spell.activate(config, dialog, message);

		/**
		 * A hook event that fires after a linked spell is used by a Cast activity.
		 * @function blackFlag.postUseLinkedSpell
		 * @memberof hookEvents
		 * @param {CastActivity} activity - Activity being activated.
		 * @param {Partial<ActivityUseConfiguration>} activationConfig - Configuration data for the activation.
		 * @param {ActivityUsageResults} results - Final details on the activation.
		 */
		if (results) Hooks.callAll("blackFlag.postUseLinkedSpell", this, config, results);

		return results;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the data for the cached spell to store on the actor.
	 * @returns {Promise<object|void>}
	 */
	async getCachedSpellData() {
		const originalSpell = await fromUuid(this.system.spell.uuid);
		if (!originalSpell) return;
		return originalSpell
			.clone({
				effects: [
					...originalSpell.effects.map(e => e.toObject()),
					{
						_id: this.constructor.ENCHANTMENT_ID,
						type: "enchantment",
						name: game.i18n.localize("BF.CAST.Enchantment.Name"),
						img: "systems/black-flag/artwork/activities/cast.svg",
						origin: this.uuid,
						changes: this.getSpellChanges()
					}
				],
				flags: {
					[game.system.id]: {
						cachedFor: this.relativeUUID
					}
				},
				_stats: { compendiumSource: this.system.spell.uuid }
			})
			.toObject();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create spell changes based on the activity's configuration.
	 * @returns {object[]}
	 */
	getSpellChanges() {
		const changes = [];
		const source = this.toObject();

		// Override spell details
		for (const type of ["activation", "duration", "range", "target"]) {
			if (!this[type].override) continue;
			const data = source[type];
			delete data.override;
			changes.push({
				key: `system.${type === "activation" ? "casting" : type}`,
				mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
				value: JSON.stringify(data)
			});
		}

		// Set ability override
		if (this.system.spell.ability)
			changes.push({
				key: "flags.black-flag.relationship.origin.ability",
				mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
				value: this.system.spell.ability
			});

		// Remove ignored properties
		for (const property of this.system.spell.properties) {
			changes.push({
				key: `system.${property in CONFIG.BlackFlag.spellComponents ? "components.required" : "tags"}`,
				mode: CONST.ACTIVE_EFFECT_MODES.ADD,
				value: `-${property}`
			});
		}

		// Set challenge overrides
		const challenge = this.system.spell.challenge;
		if (challenge.override && challenge.attack)
			changes.push(
				{
					key: "activities[attack].system.attack.bonus",
					mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					value: challenge.attack
				},
				{
					key: "activities[attack].system.attack.flat",
					mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					value: true
				}
			);
		if (challenge.override && challenge.save)
			changes.push(
				{
					key: "activities[save].system.save.dc.ability",
					mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					value: "custom"
				},
				{
					key: "activities[save].system.save.dc.formula",
					mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					value: challenge.save
				}
			);

		return changes;
	}
}

/**
 * Field that automatically prepares activities in an {@link ActivityCollection}.
 */
class ActivityField extends MappingField {
	constructor(options) {
		super(
			new TypeField({
				determineType: value => value?.type,
				modelLookup: type => CONFIG.Activity.types[type]?.documentClass ?? null
			}),
			options
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static hierarchical = true;
	// TODO: Rework this to be more like EmbeddedCollection

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	initialize(value, model, options) {
		return new ActivityCollection(model, super.initialize(value, model, options));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	migrateSource(sourceData, fieldData) {
		for (const value of Object.values(fieldData ?? {})) {
			this.model.migrateSource(sourceData, value);
		}
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Specialized collection type for retrieving activity PseudoDocuments.
 * @param {DataModel} model - The parent DataModel to which this ActivityCollection belongs.
 * @param {Activity[]} entries - Initialized advancement PseudoDocuments.
 */
class ActivityCollection extends Collection {
	constructor(model, entries) {
		super();
		this.#model = model;
		const activities = Object.entries(entries).sort(
			(lhs, rhs) => (lhs[1].sort ?? Infinity) - (rhs[1].sort ?? Infinity)
		);
		for (const [id, entry] of activities) {
			if (!(entry instanceof BaseActivity)) continue;
			this.set(id, entry);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The parent DataModel to which this ActivityCollection instance belongs.
	 * @type {DataModel}
	 */
	#model;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Pre-filtered arrays of activities per-type.
	 * @type {Map<string, Set<string>>}
	 */
	#types = new Map();

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Methods               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return array of activities filtered by the provided type.
	 * @param {string} type
	 * @returns {Activity[]}
	 * @deprecated
	 */
	byType(type) {
		return this.getByType(type);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return array of activities filtered by the provided type.
	 * @param {string} type
	 * @returns {Activity[]}
	 */
	getByType(type) {
		return Array.from(this.#types.get(type) ?? []).map(key => this.get(key));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generator that yields activities for each of the provided types.
	 * @param {string[]} types - Types to fetch.
	 * @yields {Activity}
	 */
	*getByTypes(...types) {
		for (const type of types) {
			for (const activity of this.getByType(type)) yield activity;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	set(key, value) {
		if (!this.#types.has(value.type)) this.#types.set(value.type, new Set());
		this.#types.get(value.type).add(key);
		return super.set(key, value);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	delete(key) {
		this.#types.get(this.get(key)?.type)?.delete(key);
		return super.delete(key);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Test the given predicate against every entry in the Collection.
	 * @param {function(*, number, ActivityCollection): boolean} predicate - The predicate.
	 * @returns {boolean}
	 */
	every(predicate) {
		return this.reduce((pass, v, i) => pass && predicate(v, i, this), true);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Convert the ActivityCollection to an array of simple objects.
	 * @param {boolean} [source=true] - Draw data for contained Documents from the underlying data source?
	 * @returns {object[]} - The extracted array of primitive objects.
	 */
	toObject(source = true) {
		return this.map(doc => doc.toObject(source));
	}
}

/**
 * Data definition template for items with activities.
 *
 * @property {ActivityField} activities - Activities contained in this item.
 * @property {UsesField} uses - Uses and recovery details.
 */
class ActivitiesTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			activities: new ActivityField(),
			uses: new UsesField()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should this item's actions be displayed on the actor sheet?
	 * @type {boolean}
	 */
	get displayActions() {
		return this.parent.enabled && (this.quantity !== 0);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate the "override" checkbox on spells.
	 * Added in 0.10.049
	 * @param {object} source - Candidate source data to migrate.
	 */
	static _migrateActivityActivationOverride(source) {
		if ( (source.type !== "spell") || foundry.utils.isEmpty(source.system?.activities)
			|| !source.system.casting?.type ) return;
		for ( const activity of Object.values(source.system.activities) ) {
			if ( !activity.activation || ("override" in activity.activation) ) continue;
			if ( activity.activation.type !== source.system.casting.type
				|| activity.activation.value !== source.system.casting.value
				|| activity.activation.condition !== source.system.casting.condition ) activity.activation.override = true;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare activities & uses formulas.
	 * Should be called during the `prepareFinalData` stage.
	 * @param {object} rollData
	 */
	prepareFinalActivities(rollData) {
		this.uses.prepareData(rollData);

		this.uses.max = simplifyBonus(replaceFormulaData(this.uses.max ?? "", rollData, {
			notifications: this.parent.notifications, key: "invalid-max-uses-formula", section: "auto",
			messageData: { name: this.parent.name, property: game.i18n.localize("BF.Uses.Maximum.DebugName") }
		}));
		// TODO: Add ability to have uses increase without clamping to max
		this.uses.value = Math.clamp(this.uses.max - this.uses.spent, 0, this.uses.max);

		Object.defineProperty(this.uses, "label", {
			get() {
				if ( this.max ) return `${numberFormat(this.value)} / ${numberFormat(this.max)}`;
				return "";
			},
			configurable: true,
			enumerable: false
		});

		for ( const activity of this.activities ) {
			activity.prepareFinalData();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any necessary actions when an item with activities is created.
	 * @param {object} data - The initial data object provided to the document creation request.
	 * @param {object} options - Additional options which modify the update request.
	 * @param {string} userId - The id of the User requesting the document update.
	 */
	async onCreateActivities(data, options, userId) {
		if ( (userId !== game.user.id) || !this.parent.isEmbedded ) return;

		// If item has any Cast activities, create locally cached copies of the spells
		const spells = (await Promise.all(
			this.activities.byType("cast").map(a => !a.cachedSpell && a.getCachedSpellData())
		)).filter(_ => _);
		if ( spells.length ) this.parent.actor.createEmbeddedDocuments("Item", spells);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare any item or actor changes based on activity changes.
	 * @param {object} changed - The differential data that is changed relative to the document's prior values.
	 * @param {object} options - Additional options which modify the update request.
	 * @param {User} user - The User requesting the document update.
	 */
	async preUpdateActivities(changed, options, user) {
		if ( !foundry.utils.hasProperty(changed, "system.activities") || !this.parent.isEmbedded ) return;

		// Track changes to cached spells on cast activities
		const removed = Object.entries(changed.system?.activities ?? {}).map(([key, data]) => {
			if ( key.startsWith("-=") ) {
				const id = key.replace("-=", "");
				return this.activities.get(id).cachedSpell?.id;
			} else if ( foundry.utils.hasProperty(data, "system.spell.uuid") ) {
				return this.activities.get(key)?.cachedSpell?.id;
			}
			return null;
		}).filter(_ => _);
		if ( removed.length ) foundry.utils.setProperty(options, "blackFlag.removedCachedItems", removed);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any additional updates when an item with activities is updated.
	 * @param {object} changed - The differential data that is changed relative to the document's prior values.
	 * @param {object} options - Additional options which modify the update request.
	 * @param {string} userId - The id of the User requesting the document update.
	 */
	async onUpdateActivities(changed, options, userId) {
		if ( (userId !== game.user.id) || !this.parent.isEmbedded
			|| !foundry.utils.hasProperty(changed, "system.activities") ) return;

		// If any Cast activities were removed, or their spells changed, remove old cached spells
		if ( options.blackFlag?.removedCachedItems ) {
			await this.parent.actor.deleteEmbeddedDocuments("Item", options.blackFlag.removedCachedItems);
		}

		// Create any new cached spells & update existing ones as necessary
		const cachedInserts = [];
		for ( const id of Object.keys(changed.system.activities) ) {
			const activity = this.activities.get(id);
			if ( !(activity instanceof CastActivity) ) continue;
			const existingSpell = activity.cachedSpell;
			if ( existingSpell ) {
				const enchantment = existingSpell.effects.get(CastActivity.ENCHANTMENT_ID);
				await enchantment.update({ changes: activity.getSpellChanges() });
			} else cachedInserts.push(await activity.getCachedSpellData());
		}
		if ( cachedInserts.length ) await this.parent.actor.createEmbeddedDocuments("Item", cachedInserts);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any necessary cleanup when an item with activities is deleted.
	 * @param {object} options - Additional options which modify the deletion request.
	 * @param {string} userId - The id of the User requesting the document update.
	 */
	onDeleteActivities(options, userId) {
		if ( (userId !== game.user.id) || !this.parent.isEmbedded ) return;

		// If item has any Cast activities, clean up any cached spells
		const spellIds = this.activities.byType("cast").map(a => a.cachedSpell?.id).filter(_ => _);
		if ( spellIds.length ) this.parent.actor.deleteEmbeddedDocuments("Item", spellIds);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get any actions provided by activities on this item.
	 * @yields {object}
	 */
	*actions() {
		for ( const activity of this.activities ) {
			yield activity;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any item & activity uses recovery for a certain period.
	 * @param {string[]} periods - Recovery periods to check.
	 * @param {object} rollData - Roll data to use when evaluating recovery formulas.
	 * @returns {Promise<{ updates: object, rolls: BasicRoll[] }>}
	 */
	async recoverUses(periods, rollData) {
		const updates = {};
		const rolls = [];

		if ( this.uses.hasUses ) {
			const result = await this.uses.recoverUses(periods, rollData);
			if ( result ) {
				foundry.utils.mergeObject(updates, { "system.uses": result.updates });
				rolls.push(...result.rolls);
			}
		}

		for ( const activity of this.activities ) {
			if ( !activity.uses.hasUses ) continue;
			const result = await activity.uses.recoverUses(periods, rollData);
			if ( result ) {
				foundry.utils.mergeObject(updates, { [`system.activities.${activity.id}.uses`]: result.updates });
				rolls.push(...result.rolls);
			}
		}

		return { updates, rolls };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Adjust consumption types allowed in activities on this item.
	 * @param {{key: string, label: string, disabled: boolean}[]} types - All types available to activities.
	 * @returns {{key: string, label: string, disabled: boolean}[]}} - Adjusted types.
	 * @protected
	 */
	_validConsumptionTypes(types) {
		return types;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create one or more activity documents when this item is created.
	 * @param {object[]} data - Initial data for activity documents. Must include "type".
	 * @internal
	 */
	_createInitialActivities(data) {
		const activities = {};
		for ( const initialData of data ) {
			const ActivityClass = CONFIG.Activity.types[initialData.type].documentClass;
			if ( !initialData._id ) initialData._id = foundry.utils.randomID();
			activities[initialData._id] = new ActivityClass(initialData, { parent: this.parent }).toObject();
		}
		this.parent.updateSource({"system.activities": activities});
	}
}

const { ForeignDocumentField, NumberField: NumberField$D, SchemaField: SchemaField$U, StringField: StringField$W } = foundry.data.fields;

/**
 * Data definition template for Physical items.
 *
 * @property {object} attunement
 * @property {string} attunement.requirement - Other conditions of attunement.
 * @property {string} attunement.value - Type of attunement (none, required, optional).
 * @property {string} container - Container within which this item resides.
 * @property {object} price
 * @property {number} price.value - Base price for this item.
 * @property {string} price.denomination - Currency denomination used for the price.
 * @property {number} quantity - Number of this item in a stack.
 * @property {string} rarity - Rarity level of a magic item, blank for mundane items.
 * @property {object} weight
 * @property {number} weight.value - Item's weight.
 * @property {string} weight.units - Units used to measure item's weight.
 */
class PhysicalTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			attunement: new SchemaField$U({
				requirement: new StringField$W({ label: "BF.Attunement.Requirement.Label" }),
				value: new StringField$W({ label: "BF.Attunement.Type.Label" })
			}, {label: "BF.Attunement.Label"}),
			container: new ForeignDocumentField(foundry.documents.BaseItem, {
				idOnly: true, label: "BF.Item.Type.Container[one]"
			}),
			price: new SchemaField$U({
				value: new NumberField$D({
					nullable: false, initial: 0, min: 0, step: 0.01, label: "BF.Price.Label"
				}),
				denomination: new StringField$W({
					blank: false, initial: "gp", label: "BF.Currency.Denomination.Label"
				})
			}, {label: "BF.Price.Label"}),
			quantity: new NumberField$D({
				nullable: false, initial: 1, min: 0, integer: true, label: "BF.Quantity.Label"
			}),
			rarity: new StringField$W({label: "BF.Rarity.Label"}),
			weight: new SchemaField$U({
				value: new NumberField$D({
					nullable: false, initial: 0, min: 0, step: 0.01, label: "BF.Weight.Label"
				}),
				units: new StringField$W({initial: "pound"})
			}, {label: "BF.Weight.Label"})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Maximum depth items can be nested in containers.
	 * @type {number}
	 */
	static MAX_DEPTH = 5;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can this item be attuned?
	 * @type {boolean}
	 */
	get attunable() {
		return !!this.attunement.value;
	}

	/**
	 * Is this item attuned?
	 * @type {boolean}
	 */
	get attuned() {
		if ( !this.attunable || (this.parent.actor?.type !== "pc") ) return false;
		return this.parent.getFlag("black-flag", "relationship.attuned") === true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	get displayActions() {
		return this.equipped;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can this item be equipped?
	 * @type {boolean}
	 */
	get equippable() {
		return true;
	}

	/**
	 * Is this item equipped?
	 * @type {boolean}
	 */
	get equipped() {
		if ( !this.parent.actor ) return false;
		if ( !this.equippable || this.parent.actor?.type !== "pc" ) return true;
		return this.parent.getFlag(game.system.id, "relationship.equipped") === true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this a physical item?
	 * @type {boolean}
	 */
	get isPhysical() {
		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Are the magical properties of this item currently available?
	 * @type {boolean}
	 */
	get magicAvailable() {
		const attunement = this.attunement.value !== "required" || this.parent.actor?.type !== "pc"
			|| this.parent.getFlag(game.system.id, "relationship.attuned") === true;
		const property = !this.properties || ("magical" in this.validProperties && this.properties.has("magical"));
		return attunement && property;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The price of all of the items in an item stack.
	 * @type {number}
	 */
	get totalPrice() {
		return this.quantity * this.price.value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The weight of all of the items in an item stack.
	 * @type {number}
	 */
	get totalWeight() {
		return this.quantity * this.weight.value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare labels for physical items.
	 * Should be called during the `prepareDerivedData` stage.
	 */
	preparePhysicalLabels() {
		const system = this;
		if ( this.price ) Object.defineProperty(this.price, "label", {
			get() {
				if ( !system.totalPrice ) return "â€”";
				const denominationConfig = CONFIG.BlackFlag.currencies[this.denomination];
				return game.i18n.format("BF.Currency.Display", {
					value: formatNumber(system.totalPrice), denomination: game.i18n.localize(denominationConfig.abbreviation)
				});
				// TODO: Adjust total displayed to use smallest logical units (so 5 cp x 20 = 100 cp => 1 gp)
			},
			configurable: true,
			enumerable: false
		});
		Object.defineProperty(this.weight, "label", {
			get() {
				const totalWeight = system.totalWeight;
				if ( totalWeight instanceof Promise || !totalWeight ) return "â€”";
				return formatWeight(system.totalWeight.toNearest(0.1), this.units, { unitDisplay: "short" });
				// TODO: Reduce to units in current system that result in the smallest value
			},
			configurable: true,
			enumerable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Trigger a render on all sheets for items within which this item is contained.
	 * @param {object} [options={}]
	 * @param {string} [options.formerContainer] - UUID of the former container if this item was moved.
	 * @param {object} [options.rendering] - Additional rendering options.
	 * @protected
	 */
	async _renderContainers({ formerContainer, ...rendering }={}) {
		// Render this item's container & any containers it is within
		const parentContainers = await this.allContainers();
		parentContainers.forEach(c => c.sheet?.render(false, rendering));

		// Render the actor sheet, compendium, or sidebar
		if ( this.parent.isEmbedded ) this.parent.actor.sheet?.render(false, rendering);
		else if ( this.parent.pack ) game.packs.get(this.parent.pack).apps.forEach(a => a.render(false, rendering));
		else ui.sidebar.tabs.items.render(false, rendering);

		// Render former container if it was moved between containers
		if ( formerContainer ) {
			const former = await fromUuid(formerContainer);
			former.render(false, rendering);
			former.system._renderContainers(rendering);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _preUpdate(changed, options, user) {
		if ( foundry.utils.hasProperty(changed, "system.container") ) {
			options.formerContainer = (await this.parent.container)?.uuid;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_onCreatePhysicalItem(data, options, userId) {
		this._renderContainers();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_onUpdatePhysicalItem(changed, options, userId) {
		this._renderContainers({ formerContainer: options.formerContainer });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_onDeletePhysicalItem(options, userId) {
		this._renderContainers();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * All of the containers this item is within up to the parent actor or collection.
	 * @returns {Promise<BlackFlagItem[]>}
	 */
	async allContainers() {
		let item = this.parent;
		let container;
		let depth = 0;
		const containers = [];
		while ( (container = await item.container) && (depth < PhysicalTemplate.MAX_DEPTH) ) {
			containers.push(container);
			item = container;
			depth++;
		}
		return containers;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set the equipped and attuned chat tags.
	 * @param {Map<string, string>} tags - Tags map to set.
	 */
	setPhysicalChatTags(tags) {
		if ( this.attuned ) tags.set("attuned", game.i18n.localize("BF.Attunement.Attuned"));
		else if ( this.attunement.value === "required" ) {
			tags.set("attuned", game.i18n.localize("BF.Attunement.Type.Required"));
		}
		if ( this.equipped ) tags.set("equipped", game.i18n.localize("BF.Item.Equipped"));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate the total weight and return it in specific units.
	 * @param {string} units - Units in which the weight should be returned.
	 * @returns {number|Promise<number>}
	 */
	totalWeightIn(units) {
		const weight = this.totalWeight;
		if ( weight instanceof Promise ) return weight.then(w => convertWeight(w, this.weight.units, units));
		return convertWeight(weight, this.weight.units, units);
	}
}

/**
 * Mixin used to share some logic between Actor & Item documents.
 * @type {function(Class): Class}
 * @mixin
 */
var DocumentMixin = Base =>
	class extends EmbedMixin(Base) {
		/* <><><><> <><><><> <><><><> <><><><> */
		/*               Helpers               */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		static getDefaultArtwork(data = {}) {
			const dataModel = CONFIG[this.metadata.name]?.dataModels[data.type];
			const { img, texture } = super.getDefaultArtwork(data);
			return {
				img: dataModel?.metadata.img ?? img,
				texture: {
					src: dataModel?.metadata.img ?? texture?.src ?? img
				}
			};
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Description for a single part of a property attribution.
		 * @typedef {object} AttributionDescription
		 * @property {BlackFlagActiveEffect} document - Active effect document.
		 * @property {string} label - Descriptive label that will be displayed. If the label is in the form
		 *                            of an @ property, the system will try to turn it into a human-readable label.
		 * @property {number} mode - Application mode for this step as defined in
		 *                           [CONST.ACTIVE_EFFECT_MODES](https://foundryvtt.com/api/module-constants.html#.ACTIVE_EFFECT_MODES).
		 * @property {number} value - Value of this step.
		 */

		/**
		 * Break down all of the Active Effects affecting a given target property.
		 * @param {string} keyPath - The data property being targeted.
		 * @returns {AttributionDescription[]} - Any active effects that modify that property.
		 * @protected
		 */
		activeEffectAttributions(keyPath) {
			const rollData = this.getRollData({ deterministic: true });
			const attributions = [];
			for (const e of this.allApplicableEffects()) {
				let source = e.sourceName;
				if (!e.origin || e.origin === this.uuid) source = e.name;
				if (!source || e.disabled || e.isSuppressed) continue;
				const value = e.changes.reduce((n, change) => {
					if (change.key !== keyPath) return n;
					if (change.mode !== CONST.ACTIVE_EFFECT_MODES.ADD) return n;
					return n + simplifyBonus(change.value, rollData);
				}, 0);
				if (value) attributions.push({ document: e, value, label: source, mode: CONST.ACTIVE_EFFECT_MODES.ADD });
			}
			return attributions;
		}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*       Importing and Exporting       */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @override */
		static async createDialog(data = {}, { parent = null, pack = null, types = null, ...options } = {}) {
			const documentName = this.metadata.name;
			types ??= foundry.utils.deepClone(game.documentTypes[documentName].filter(t => t !== CONST.BASE_DOCUMENT_TYPE));
			const extraTypes = new Set(types);
			if (!types.length) return null;
			const collection = parent ? null : pack ? game.packs.get(pack) : game.collections.get(this.documentName);
			const folders = collection?._formatFolderSelectOptions() ?? [];
			const label = game.i18n.localize(this.metadata.label);
			const title = game.i18n.format("DOCUMENT.Create", { type: label });

			const lastCreated = game.user.getFlag(game.system.id, "lastCreatedTypes") ?? {};
			const selectedType = data.type ?? lastCreated[documentName] ?? CONFIG[documentName]?.defaultType ?? types[0];

			let categories;
			if (!foundry.utils.isEmpty(CONFIG[documentName]?.categories)) {
				categories = {};
				for (const [key, value] of Object.entries(CONFIG[documentName]?.categories)) {
					const category = { label: game.i18n.localize(value.label), children: {} };
					for (const type of value.types) {
						if (!types.includes(type.metadata?.type)) continue;
						extraTypes.delete(type.metadata?.type);
						const name = type.fullType;
						category.children[name] = {
							label: game.i18n.localize(CONFIG[documentName]?.typeLabels?.[name] ?? name),
							chosen: name === selectedType
						};
					}
					if (!foundry.utils.isEmpty(category.children)) categories[key] = category;
				}
			}

			// Render the document creation form
			const html = await renderTemplate("systems/black-flag/templates/shared/document-create.hbs", {
				folders: folders
					? [{ value: "", label: "" }, ...folders.map(({ id, name }) => ({ value: id, label: name }))]
					: null,
				name: data.name || game.i18n.format("DOCUMENT.New", { type: label }),
				folder: data.folder,
				hasFolders: folders.length >= 1,
				type: selectedType,
				categories,
				types: extraTypes.reduce((obj, t) => {
					const label = CONFIG[documentName]?.typeLabels?.[t] ?? t;
					obj[t] = game.i18n.localize(label);
					return obj;
				}, {})
			});

			// Render the confirmation dialog window
			return Dialog.prompt({
				title: title,
				content: html,
				label: title,
				callback: async html => {
					const form = html[0].querySelector("form");
					const fd = new FormDataExtended(form);
					foundry.utils.mergeObject(data, fd.object, { inplace: true });
					if (!data.folder) delete data.folder;
					if (types.length === 1) data.type = types[0];
					if (!data.name?.trim()) data.name = this.defaultName();
					lastCreated[documentName] = data.type;
					await game.user.setFlag(game.system.id, "lastCreatedTypes", lastCreated);
					return this.create(data, { parent, pack, renderSheet: true });
				},
				rejectClose: false,
				options
			});
		}
	};

/**
 * Data structure to represent a document notification.
 *
 * @typedef {object} NotificationData
 * @property {string} key - Unique key for this notification.
 * @property {string} [document] - ID of a document that is causing this notification.
 * @property {string} [category] - Type of data to which this notification applies (e.g. abilities, lineage).
 * @property {string} [section] - Sheet section that should display a notice about this
 *                                notification (e.g. progression, inventory).
 * @property {string} level - Level of notification severity (e.g. info, warn, error).
 * @property {number} [order] - Order in which the player should handle this notification.
 */

/**
 * Custom collection for storing messages, warnings, or errors during document preparation.
 */
class NotificationsCollection extends Collection {
	set(key, value) {
		value.key = key;
		super.set(key, value);
	}
}

/**
 * Object describing the scaling of a specific activation.
 *
 * @param {number} increase - Scaling level above baseline.
 */
class Scaling {
	constructor(increase) {
		this.#increase = increase;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Scaling level above baseline.
	 * @type {number}
	 */
	#increase;

	get increase() {
		return this.#increase;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Value of the scaling starting 1.
	 * @type {string}
	 */
	get value() {
		return this.#increase + 1;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	toString() {
		return this.value;
	}
}

class BlackFlagItem extends DocumentMixin(Item) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Accent color used for certain parts of the UI.
	 * @type {string}
	 */
	get accentColor() {
		if (this.system.color) return this.system.color;
		return this.system.metadata?.accentColor ?? "var(--bf-blue)";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Base Map used to ensure tags are always displayed in order.
	 * @type {Map<string, string>}
	 */
	static get baseTags() {
		return new Map(
			[
				"type",
				"details",
				"activity",
				"activation",
				"range",
				"affects",
				"template",
				"duration",
				"equipped",
				"attuned",
				"proficient"
			].map(l => [l, null])
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tags that should be displayed in chat.
	 * @type {Map<string, string>}
	 */
	get chatTags() {
		const tags = this.constructor.baseTags;
		tags.set("type", game.i18n.localize(CONFIG.Item.typeLabels[this.type]));
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The item that contains this item, if it is in a container. Returns a promise if the item is located
	 * in a compendium pack.
	 * @type {BlackFlagItem|Promise<BlackFlagItem>|void}
	 */
	get container() {
		if (!this.system.container) return;
		if (this.isEmbedded) return this.actor.items.get(this.system.container);
		if (this.pack) return game.packs.get(this.pack).getDocument(this.system.container);
		return game.items.get(this.system.container);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this item currently enabled? Non-enabled items won't display in the actions list.
	 * @type {boolean}
	 */
	get enabled() {
		return this.flags["black-flag"]?.relationship?.enabled !== false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get identifier() {
		if (this.system.identifier?.value) return this.system.identifier.value;
		return slugify$1(identifier, { strict: true });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Collection of notifications that should be displayed on the actor sheet.
	 */
	notifications = this.notifications;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get pseudoDocumentHierarchy() {
		const hierarchy = {};
		for (const [fieldName, field] of this.system.schema.entries()) {
			if (field.constructor.hierarchical) hierarchy[fieldName] = field;
		}
		Object.defineProperty(this, "pseudoDocumentHierarchy", { value: Object.freeze(hierarchy), writable: false });
		return this.pseudoDocumentHierarchy;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Scaling increase for this item based on flag or item-type specific details.
	 * @type {number}
	 */
	get scaling() {
		return this.system?.scaling ?? this.getFlag(game.system.id, "scaling") ?? 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Data Initialization         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	clone(data = {}, options = {}) {
		if (options.save) return super.clone(data, options);
		if (this.parent) this.parent._embeddedPreparation = true;
		const item = super.clone(data, options);
		if (item.parent) {
			item.parent._embeddedPreparation = false;
			item.system.prepareFinalData?.();
		}
		return item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_initializeSource(data, options = {}) {
		if (data instanceof foundry.abstract.DataModel) data = data.toObject();

		const activities = foundry.utils.getProperty(data, "system.activities");
		if (activities)
			Object.values(activities).forEach(data => {
				if (data.type === "healing") data.type = "heal";
				else if (data.type === "savingThrow") data.type = "save";
			});
		if (!data.system?.identifier?.value) {
			foundry.utils.setProperty(data, "system.identifier.value", slugify$1(data.name, { strict: true }));
		}
		return super._initializeSource(data, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static migrateData(source) {
		source = super.migrateData(source);
		ActivitiesTemplate._migrateActivityActivationOverride?.(source);
		return source;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		this.notifications = new NotificationsCollection();
		super.prepareData();
		if (this.system.shouldPrepareFinalData) this.system.prepareFinalData();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareEmbeddedDocuments() {
		super.prepareEmbeddedDocuments();
		for (const collectionName of Object.keys(this.pseudoDocumentHierarchy ?? {})) {
			for (const e of this.getEmbeddedCollection(collectionName)) {
				e.prepareData();
			}
		}
		if (!this.actor || this.actor._embeddedPreparation) this.applyActiveEffects();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get all ActiveEffects that may apply to this Item.
	 * @yields {BlackFlagActiveEffect}
	 * @returns {Generator<BlackFlagActiveEffect, void, void>}
	 */
	*allApplicableEffects() {
		for (const effect of this.effects) {
			if (effect.type === "enchantment") yield effect;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply any transformation to the Item data which are caused by enchantment Effects.
	 */
	applyActiveEffects() {
		const overrides = {};

		// Organize non-disabled effects by their application priority
		const changes = [];
		for (const effect of this.allApplicableEffects()) {
			if (!effect.active) continue;
			changes.push(
				...effect.changes.map(change => {
					const c = foundry.utils.deepClone(change);
					c.effect = effect;
					c.priority ??= c.mode * 10;
					return c;
				})
			);
		}
		changes.sort((a, b) => a.priority - b.priority);

		// Apply all changes
		for (const change of changes) {
			if (!change.key) continue;
			const changes = change.effect.apply(this, change);
			Object.assign(overrides, changes);
		}

		// Expand the set of final overrides
		this.overrides = foundry.utils.expandObject(overrides);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Methods               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activate this item, posting to chat if no activities are set, triggering the only activity if only one is present,
	 * and displaying an activity choice dialog if more than one is available.
	 * @param {Partial<ActivityActivationConfiguration>} [config={}] - Configuration info for the activation.
	 * @param {Partial<ActivityDialogConfiguration>} [dialog={}] - Configuration info for the configuration dialog.
	 * @param {Partial<ActivityMessageConfiguration>} [message={}] - Configuration info for the chat message created.
	 */
	async activate(config = {}, dialog = {}, message = {}) {
		if (this.system.activities?.size && !this.pack) {
			let activity = this.system.activities.contents[0];
			// TODO: Handle proper skip-dialog keybindings
			if (this.system.activities.size > 1 && !config.event?.shiftKey) {
				activity = await ActivityChoiceDialog.create(this);
			}
			activity?.activate(config, dialog, message);
		} else if (this.actor) {
			this.postToChat(message);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get advancement for this item.
	 * @param {number|AdvancementLevels} levels - Level for which to get the advancement.
	 * @yields {Advancement}
	 */
	*advancementForLevel(levels = 0) {
		if (foundry.utils.getType(levels) === "number") {
			for (const advancement of this.system.advancement?.byLevel(levels) ?? []) {
				yield advancement;
			}
		} else {
			for (const advancement of this.system.advancement ?? []) {
				const level = advancement.relavantLevel(levels);
				if (advancement.levels.includes(level)) yield advancement;
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async deleteDialog(options = {}) {
		// Display custom delete dialog when deleting a container with contents
		const count = await this.system.contentsCount;
		if (count) {
			return Dialog.confirm({
				title: `${game.i18n.format("DOCUMENT.Delete", {
					type: game.i18n.localize("BF.Item.Type.Container[one]")
				})}: ${this.name}`,
				content: `<h4>${game.i18n.localize("AreYouSure")}</h4>
					<p>${game.i18n.format("BF.Container.Delete.Message", { count })}</p>
					<label>
						<input type="checkbox" name="deleteContents">
						${game.i18n.localize("BF.Container.Delete.Contents")}
					</label>`,
				yes: html => {
					const deleteContents = html.querySelector('[name="deleteContents"]').checked;
					this.delete({ deleteContents });
				},
				options: { ...options, jQuery: false }
			});
		}

		return super.deleteDialog(options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Attack formula and activity for the default attack this item might have.
	 * @param {object} [options={}] - Additional options that might affect fetched data.
	 * @returns {{parts: string[], data: object, formula: string, activity: Activity}|null}
	 */
	getAttackDetails(options = {}) {
		for (const activity of this.system.activities ?? []) {
			const details = activity.getAttackDetails?.(options);
			if (details) return details;
		}
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Damage formulas and activity for the default attack this item might have.
	 * @param {object} [options={}] - Additional options that might affect fetched data.
	 * @returns {{rolls: DamageRollConfiguration[], activity: Activity}|null}
	 */
	getDamageDetails(options = {}) {
		for (const activity of this.system.activities ?? []) {
			const details = activity.getDamageDetails?.(options);
			if (details) return details;
		}
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getRollData(options = {}) {
		let rollData;
		if (this.system.getRollData) rollData = this.system.getRollData(options);
		else {
			rollData = { ...(this.actor.getRollData(options) ?? {}), item: { ...this.system } };
		}

		if (rollData.item) {
			rollData.item.flags = { ...this.flags };
			rollData.item.name = this.name;
		}

		const abilityKey = this.system.ability;
		if (abilityKey && "abilities" in rollData) {
			rollData.mod = rollData.abilities[abilityKey]?.mod ?? 0;
		}

		rollData.scaling = new Scaling(this.scaling);

		return rollData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Save ability, dc, and activity for the default save this item might have.
	 * @param {object} [options={}] - Additional options that might affect fetched data.
	 * @returns {{ability: string, dc: string, activity: Activity}|null}
	 */
	getSaveDetails(options = {}) {
		for (const activity of this.system.activities ?? []) {
			const details = activity.getSaveDetails?.(options);
			if (details) return details;
		}
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the data used to present an expanded summary for this item.
	 * @param {object} [enrichmentOptions={}] - Options passed to `TextEditor.enrichHTML`.
	 * @returns {object} - Context passed to the template for rendering the summary.
	 */
	async getSummaryContext(enrichmentOptions = {}) {
		const context = {
			enriched: {
				description: await TextEditor.enrichHTML(this.system.description.value, {
					async: true,
					relativeTo: this,
					rollData: this.getRollData(),
					...enrichmentOptions
				})
			},
			item: this,
			system: this.system
		};
		await this.system.getSummaryContext?.(context, enrichmentOptions);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Post this item's description to chat.
	 * @param {Partial<ActivityMessageConfiguration>} [message={}] - Configuration info for the chat message created.
	 * @returns {Promise<ChatMessage>}
	 */
	async postToChat(message = {}) {
		const baseContext = {
			item: this,
			actor: this.actor,
			token: this.actor?.token,
			buttons: {},
			tags: Array.from((this.system.chatTags ?? this.chatTags).entries())
				.map(([key, label]) => ({ key, label }))
				.filter(t => t.label),
			description: await TextEditor.enrichHTML(this.system.description?.value ?? "", {
				relativeTo: this,
				rollData: this.getRollData(),
				secrets: false,
				async: true
			})
		};
		const context = this.system.prepareChatContext?.(baseContext) ?? baseContext;

		const messageConfig = foundry.utils.mergeObject(
			{
				rollMode: game.settings.get("core", "rollMode"),
				data: {
					style: CONST.CHAT_MESSAGE_STYLES.OTHER,
					content: await renderTemplate("systems/black-flag/templates/chat/item-card.hbs", context),
					speaker: ChatMessage.getSpeaker({ actor: this.actor }),
					flags: {
						core: { canPopout: true },
						"black-flag": {
							type: "item",
							uuid: this.uuid
						}
					}
				}
			},
			message
		);

		ChatMessage.applyRollMode(messageConfig.data, messageConfig.rollMode);

		// TODO: Call preCreateItemMessage hook

		const card = await ChatMessage.create(messageConfig.data);

		// TODO: Call postCreateItemMessage hook

		return card;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Embedded Operations         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static getCollectionName(name) {
		if (name === "Activity") name = "activities";
		if (name === "Advancement") name = "advancement";
		if (["activities", "advancement"].includes(name)) return name;
		return super.getCollectionName(name);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getEmbeddedCollection(embeddedName) {
		const collectionName = this.constructor.getCollectionName(embeddedName);
		const field = this.pseudoDocumentHierarchy[collectionName];
		return field ? this.system[collectionName] : super.getEmbeddedCollection(embeddedName);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritdoc */
	async _preCreate(data, options, user) {
		if ((await super._preCreate(data, options, user)) === false) return false;

		// Create class identifier based on name
		if (Object.hasOwn(this.system.identifier ?? {}, "value") && !this.system.identifier.value) {
			await this.updateSource({ "system.identifier.value": slugify$1(data.name, { strict: true }) });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onCreate(data, options, userId) {
		super._onCreate(data, options, userId);
		await this.system.onCreateActivities?.(data, options, userId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preUpdate(changed, options, user) {
		if ((await super._preUpdate(changed, options, user)) === false) return false;
		await this.system.preUpdateActivities?.(changed, options, user);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onUpdate(changed, options, userId) {
		super._onUpdate(changed, options, userId);
		await this.system.onUpdateActivities?.(changed, options, userId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onDelete(options, userId) {
		super._onDelete(options, userId);
		await this.system.onDeleteActivities?.(options, userId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare creation data for the provided items and any items contained within them. The data created by this method
	 * can be passed to `createDocuments` with `keepId` always set to true to maintain links to container contents.
	 * @param {BlackFlagItem[]} items - Items to create.
	 * @param {object} [context={}] - Context for the item's creation.
	 * @param {BlackFlagItem} [context.container] - Container in which to create the item.
	 * @param {boolean} [context.keepId=false] - Should IDs be maintained?
	 * @param {Function} [context.transformAll] - Method called on provided items and their contents.
	 * @param {Function} [context.transformFirst] - Method called only on provided items.
	 * @returns {Promise<object[]>} - Data for items to be created.
	 */
	static async createWithContents(items, { container, keepId = false, transformAll, transformFirst } = {}) {
		let depth = 0;
		if (container) {
			depth = 1 + (await container.system.allContainers()).length;
			if (depth > PhysicalTemplate.MAX_DEPTH) {
				ui.notifications.warn(game.i18n.format("BF.Container.Warning.MaxDepth", { depth: PhysicalTemplate.MAX_DEPTH }));
				return;
			}
		}

		const createItemData = async (item, containerId, depth) => {
			let newItemData = transformAll ? await transformAll(item) : item;
			if (transformFirst && depth === 0) newItemData = await transformFirst(newItemData);
			if (!newItemData) return;
			if (newItemData instanceof Item)
				newItemData = game.items.fromCompendium(newItemData, {
					clearSort: false,
					clearOwnership: false,
					keepId: true
				});
			foundry.utils.mergeObject(newItemData, { "system.container": containerId });
			if (!keepId) newItemData._id = foundry.utils.randomID();

			created.push(newItemData);

			const contents = await item.system.contents;
			if (contents && depth < PhysicalTemplate.MAX_DEPTH) {
				for (const doc of contents) await createItemData(doc, newItemData._id, depth + 1);
			}
		};

		const created = [];
		for (const item of items) await createItemData(item, container?.id, depth);
		return created;
	}
}

/**
 * Custom element for displaying a grouped set of inventory filters.
 */
class FiltersElement extends AppAssociatedElement {
	constructor() {
		super();
		this.#tab = this.getAttribute("tab");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		this.addEventListener("change", this.#onChangeFilter.bind(this), { signal: this.#controller.signal });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Document represented by the app.
	 * @type {BlackFlagActor|BlackFlagItem}
	 */
	get document() {
		return this.app.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set of filters offered by the app.
	 * @type {{[key: string]: integer}|null}
	 */
	get filters() {
		return this.app.document.flags["black-flag"]?.sheet?.filters?.[this.tab] ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tab that these filters affect.
	 * @type {string}
	 */
	#tab;

	get tab() {
		return this.#tab ?? this.closest("blackFlag-inventory").tab;
	}

	set tab(value) {
		this.#tab = value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a change to one of the included filters.
	 * @param {Event} event - Triggering change event.
	 */
	#onChangeFilter(event) {
		event.stopPropagation();
		this.document.update({ [`flags.black-flag.sheet.filters.${this.tab}.${event.target.filter}`]: event.target.value });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Filter items within a section according to a set of filters.
	 * @param {BlackFlagItem[]} items - List of items to filter.
	 * @param {object} [options={}]
	 * @param {CheckVisibilityCallback} [options.checkVisibility] - Additional section-specific visibility check.
	 * @param {Record<string, number>} [options.filters={}] - Filters to apply.
	 * @returns {BlackFlagItem[]} - Filtered items.
	 */
	static filter(items, { checkVisibility, filters = {} } = {}) {
		if (!checkVisibility && foundry.utils.isEmpty(filters)) return items;
		return items.filter(item => {
			if (checkVisibility?.(item) === false) return false;
			for (const [filter, value] of Object.entries(filters ?? {})) {
				if (value === 0) continue;
				const matches = item.system.evaluateFilter?.(filter);
				if ((value === 1 && matches === false) || (value === -1 && matches === true)) return false;
			}
			return true;
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve the current value of the specified filter.
	 * @param {string} filter - Filtering key.
	 * @returns {number|undefined} - Valid filter value (-1, 0, or +1).
	 */
	getValueOf(filter) {
		return this.filters?.[filter];
	}
}

/**
 * Custom element for displaying sorting options on inventories.
 */
class SortingElement extends AppAssociatedElement {
	constructor() {
		super();
		this.#tab = this.getAttribute("tab");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		for (const input of this.querySelectorAll('input[type="radio"]')) {
			input.name ??= `${this.tab}-sort`;
			if (input.value === this.sorting) input.checked = true;
		}
		this.addEventListener("change", this.#onChangeSorting.bind(this), { signal: this.#controller.signal });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Document represented by the app.
	 * @type {BlackFlagActor|BlackFlagItem}
	 */
	get document() {
		return this.app.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the current sorting value for this tab.
	 * @type {string}
	 */
	get sorting() {
		return this.app.document.flags["black-flag"]?.sheet?.sorting?.[this.tab] ?? "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tab that this sorting affects.
	 * @type {string}
	 */
	#tab;

	get tab() {
		return this.#tab ?? this.closest("blackFlag-inventory").tab;
	}

	set tab(value) {
		this.#tab = value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a change to one of the included filters.
	 * @param {Event} event - Triggering change event.
	 */
	#onChangeSorting(event) {
		event.stopPropagation();
		this.document.update({ [`flags.black-flag.sheet.sorting.${this.tab}`]: event.target.value });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sort items within a section based on the sorting mode.
	 * @param {BlackFlagItem[]} items - List of items to sort.
	 * @param {string} sortingMode - Sorting mode to apply.
	 * @returns {BlackFlagItem[]} - Sorted items.
	 */
	static sort(items, sortingMode) {
		switch (sortingMode) {
			case "alpha":
				return items.sort((lhs, rhs) => lhs.name.localeCompare(rhs.name));
			case "currency":
				const conv = i => CONFIG.BlackFlag.currencies[i.identifier]?.conversion ?? 1;
				return items.sort((lhs, rhs) => conv(rhs) - conv(lhs));
			default:
				return items.sort((lhs, rhs) => lhs.sort - rhs.sort);
		}
	}
}

class InventoryElement extends DocumentSheetAssociatedElement {
	constructor() {
		super();
		this.#tab = this.getAttribute("tab");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		const { signal } = this.#controller;

		this.addEventListener("drop", this._onDrop.bind(this), { signal });

		for (const element of this.querySelectorAll("[data-item-id]")) {
			element.setAttribute("draggable", true);
			element.addEventListener("dragstart", this._onDragStart.bind(this), { signal });
		}

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener(
				"click",
				event => {
					event.stopImmediatePropagation();
					this._onAction(event.currentTarget, event.currentTarget.dataset.action);
				},
				{ signal }
			);
		}

		for (const input of this.querySelectorAll('input[type="number"]')) {
			input.addEventListener("change", this._onChangeInput.bind(this), { signal });
		}

		for (const input of this.querySelectorAll('input[inputmode="numeric"]')) {
			input.addEventListener("change", this._onChangeInputDelta.bind(this), { signal });
		}

		for (const control of this.querySelectorAll("[data-context-menu]")) {
			control.addEventListener(
				"click",
				event => {
					event.stopPropagation();
					event.currentTarget.closest("[data-activity-id], [data-item-id]").dispatchEvent(
						new PointerEvent("contextmenu", {
							view: window,
							bubbles: true,
							cancelable: true,
							clientX: event.clientX,
							clientY: event.clientY
						})
					);
				},
				{ signal }
			);
		}

		this.querySelectorAll("input").forEach(e => e.addEventListener("focus", () => e.select()));

		new BlackFlagContextMenu(this, "[data-item-id], [data-activity-id]", [], {
			jQuery: true,
			onOpen: this._onContextMenu.bind(this)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Containing actor for this inventory, either the document or its parent if document is an item.
	 * @type {BlackFlagActor|null}
	 */
	get actor() {
		if (this.document instanceof Actor) return this.document;
		return this.document.actor ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Cached data on constructed sections.
	 * @type {{[key: string]: SheetSectionConfiguration}}
	 */
	#sectionsCache;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tab that this inventory represents.
	 * @type {string}
	 */
	#tab;

	get tab() {
		return this.#tab;
	}

	set tab(value) {
		this.#tab = value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the set of ContextMenu options which should be applied to inventory entries.
	 * @param {BlackFlagItem} item - The item for which the context menu is being activated.
	 * @param {Activity} [activity] - Activity for which the context menu is being activated.
	 * @param {SheetSectionConfiguration} [section] - Configuration data for the section to which the item belongs.
	 * @returns {ContextMenuEntry[]} - Context menu entries.
	 * @protected
	 */
	_getContextMenuOptions(item, activity, section) {
		const type = item.type === "spell" ? "Spell" : item.system.isPhysical ? "Item" : "Feature";
		return [
			{
				name: "BF.ACTIVITY.Core.Action.View",
				icon: "<i class='fa-solid fa-eye fa-fw'></i>",
				condition: li => activity && !this.isEditable,
				callback: li => this._onAction(li[0], "viewActivity"),
				group: "activity"
			},
			{
				name: "BF.ACTIVITY.Core.Action.Activate",
				icon: '<i class="fa-solid fa-power-off fa-fw" inert></i>',
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "activate"),
				group: "activity"
			},
			{
				name: "BF.ACTIVITY.Core.Action.Edit",
				icon: '<i class="fa-solid fa-edit fa-fw" inert></i>',
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "editActivity"),
				group: "activity"
			},
			{
				name: "BF.ACTIVITY.Core.Action.Delete",
				icon: '<i class="fa-solid fa-trash fa-fw destructive" inert></i>',
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "deleteActivity"),
				group: "activity"
			},
			{
				name: "BF.Item.Action.Post",
				icon: '<i class="fa-solid fa-envelope fa-fw" inert></i>',
				callback: li => this._onAction(li[0], "post"),
				group: "item"
			},
			{
				name: `BF.${type}.Action.View`,
				icon: '<i class="fa-solid fa-eye fa-fw" inert></i>',
				condition: li => !this.isEditable,
				callback: li => this._onAction(li[0], "view"),
				group: "item"
			},
			{
				name: `BF.${type}.Action.Edit`,
				icon: '<i class="fa-solid fa-edit fa-fw" inert></i>',
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "edit"),
				group: "item"
			},
			{
				name: `BF.${type}.Action.Duplicate`,
				icon: '<i class="fa-solid fa-copy fa-fw" inert></i>',
				condition: li => this.isEditable && section?.options?.canDuplicate !== false,
				callback: li => this._onAction(li[0], "duplicate"),
				group: "item"
			},
			{
				name: `BF.${type}.Action.Delete`,
				icon: '<i class="fa-solid fa-trash fa-fw destructive" inert></i>',
				condition: li => this.isEditable && section?.options?.canDelete !== false,
				callback: li => this._onAction(li[0], "delete"),
				group: "item"
			},
			{
				name: `BF.Feature.Action.${item.enabled ? "Disable" : "Enable"}`,
				icon: `<i class="fa-regular ${item.enabled ? "fa-square-check" : "fa-square"} fa-fw" inert></i>`,
				condition: () =>
					this.actor &&
					this.isEditable &&
					item.system.activities?.size &&
					(this.actor.type === "npc" || type === "Feature"),
				callback: li => this._onAction(li[0], "enable"),
				group: "state"
			},
			{
				name: `BF.Item.Action.${item.system.equipped ? "Unequip" : "Equip"}`,
				icon: '<i class="fa-solid fa-shield-alt fa-fw" inert></i>',
				condition: () => this.actor && this.isEditable && type === "Item" && item.system.equippable,
				callback: li => this._onAction(li[0], "equip"),
				group: "state"
			},
			{
				name: `BF.Spell.Action.${item.system.prepared ? "Unprepare" : "Prepare"}`,
				icon: '<i class="fa-solid fa-sun fa-fw" inert></i>',
				condition: () => this.actor && this.isEditable && type === "Spell" && item.system.preparable,
				callback: li => this._onAction(li[0], "prepare"),
				group: "state"
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @param {object} [options={}]
	 * @param {Event} [options.originalEvent] - Original triggering event.
	 * @returns {Promise}
	 * @protected
	 */
	async _onAction(target, action, { originalEvent } = {}) {
		const event = new CustomEvent("bf-inventory", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (target.dispatchEvent(event) === false) return;

		const dataset = (target.closest("[data-item-id]") || target)?.dataset ?? {};
		const item = await this.getItem(dataset.itemId);
		if (action !== "add" && !item) return this.app._onAction?.(event, dataset);
		const activityId = (target.closest("[data-activity-id]") || target)?.dataset?.activityId;
		const activity = item?.system.activities?.get(activityId);

		switch (action) {
			case "add":
				return this._onAddItem(target);
			case "adjustment":
				return this._onAdjustment(item, target);
			case "attune":
				return item.setFlag("black-flag", "relationship.attuned", !item.system.attuned);
			case "deleteActivity":
				if (activity) return activity.deleteDialog();
			case "delete":
				return item.deleteDialog();
			case "duplicate":
				return item.clone({ name: game.i18n.format("DOCUMENT.CopyOf", { name: item.name }) }, { save: true });
			case "editActivity":
			case "viewActivity":
				if (activity) return activity.sheet.render({ force: true });
			case "edit":
			case "view":
				return item.sheet.render(true);
			case "enable":
				return item.setFlag("black-flag", "relationship.enabled", !item.enabled);
			case "equip":
				return item.setFlag("black-flag", "relationship.equipped", !item.system.equipped);
			case "expand":
				return this._onExpand(item, target);
			case "activate":
				if (activity) return activity.activate({ event: originalEvent });
			case "post":
				return item.postToChat();
			case "prepare":
				return item.setFlag("black-flag", "relationship.prepared", !item.system.prepared);
		}

		return this.app._onAction?.(event, dataset);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle creating a new item within a certain section.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 * @protected
	 */
	async _onAddItem(target) {
		const sections = CONFIG.BlackFlag.sheetSections[this.document.type]?.filter(s => s.tab === this.tab) ?? [];
		const types = Array.from(
			new Set(
				sections?.flatMap(s => {
					const filter = s.filters.find(f => f.k === "type");
					return foundry.utils.getType(filter?.v) === "string" ? [filter.v] : filter.v;
				})
			)
		).filter(t => t);
		Item.implementation.createDialog(
			{
				folder: this.document.folder,
				"system.container": this.document.type === "container" ? this.document.id : undefined
			},
			{ parent: this.actor, pack: this.document.pack, types: types.length ? types : null }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking one of the adjustment buttons.
	 * @param {BlackFlagItem} item - Item that needs its data adjusted.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 * @protected
	 */
	async _onAdjustment(item, target) {
		const { direction, property } = target.dataset;
		const current = foundry.utils.getProperty(item, property) ?? 0;
		item.update({ [property]: current + (direction === "increase" ? 1 : -1) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle changing an input field directly in the inventory.
	 * @param {Event} event - Triggering change event.
	 * @returns {Promise}
	 * @protected
	 */
	async _onChangeInput(event) {
		const itemId = event.target.closest("[data-item-id]")?.dataset.itemId;
		const item = await this.getItem(itemId);
		if (!item) return;

		event.stopImmediatePropagation();
		const { property } = event.target.dataset;
		const min = event.target.min !== "" ? Number(event.target.min) : -Infinity;
		const max = event.target.max !== "" ? Number(event.target.max) : Infinity;
		const value = Math.clamp(event.target.valueAsNumber, min, max);
		if (Number.isNaN(value)) return;

		event.target.value = value;
		item.update({ [property]: value });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle input changes to numeric form fields, allowing them to accept delta-typed inputs.
	 * @param {Event} event - Triggering change event.
	 * @protected
	 */
	async _onChangeInputDelta(event) {
		const itemId = event.target.closest("[data-item-id]")?.dataset.itemId;
		const item = await this.getItem(itemId);
		if (!item) return;

		event.stopImmediatePropagation();
		const { property } = event.target.dataset;
		let value = event.target.value.trim();
		if (["+", "-"].includes(value[0])) {
			const delta = parseFloat(value);
			value = Number(foundry.utils.getProperty(item, property)) + delta;
		} else if (value[0] === "=") {
			value = Number(value.slice(1));
		}
		const min = event.target.min !== "" ? Number(event.target.min) : -Infinity;
		const max = event.target.max !== "" ? Number(event.target.max) : Infinity;
		value = Math.clamp(value, min, max);
		if (Number.isNaN(value)) return;

		event.target.value = value;
		item.update({ [property]: value });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle opening the context menu.
	 * @param {HTMLElement} element - The element the context menu was triggered on.
	 * @protected
	 */
	_onContextMenu(element) {
		const item = this.getItem(element.closest("[data-item-id]")?.dataset.itemId);
		// Parts of ContextMenu doesn't play well with promises, so don't show menus for containers in packs
		if (!item || item instanceof Promise) {
			ui.context.menuItems = [];
			return;
		}
		const activity = item.system.activities?.get(element.closest("[data-activity-id]")?.dataset.activityId);
		const section = this.getSectionConfiguration(element.closest("[data-section]")?.dataset.section);
		ui.context.menuItems = this._getContextMenuOptions(item, activity, section);

		/**
		 * A hook event that fires when the context menu for an inventory list is constructed.
		 * @function blackFlag.getInventoryContext
		 * @memberof hookEvents
		 * @param {InventoryElement} html - The HTML element to which the context options are attached.
		 * @param {BlackFlagItem} item - The item for which the context options are being prepared.
		 * @param {Activity} [activity] - The activity for which the context options are being prepared.
		 * @param {ContextMenuEntry[]} entryOptions - The context menu entries.
		 */
		Hooks.call("blackFlag.getInventoryContext", this, item, activity, ui.context.menuItems);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle expanding or collapsing an item's summary.
	 * @param {BlackFlagItem} item - Item that should be expanded.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 * @protected
	 */
	async _onExpand(item, target) {
		const row = target.closest("[data-item-id]");
		let expanded = row?.nextElementSibling?.dataset.expandFor === item.id ? row.nextElementSibling : null;
		if (!this.app.expanded || !expanded) return;

		// Collapsed if already expanded
		if (this.app.expanded.has(item.id)) {
			this.app.expanded.delete(item.id);
			expanded.classList.add("collapsed");
		} else {
			// If no summary section exists yet, render and insert one
			if (!expanded.querySelector(".item-summary")) {
				const summary = await renderTemplate(
					"systems/black-flag/templates/shared/parts/inventory-summary.hbs",
					await item.getSummaryContext({ sections: this.document.isOwner })
				);
				const div = document.createElement("div");
				div.innerHTML = summary;
				expanded.querySelector("td .wrapper").append(div.querySelector(".item-summary"));
			}
			this.app.expanded.add(item.id);
			requestAnimationFrame(() => {
				expanded.querySelector(".item-summary")?.getBoundingClientRect();
				expanded.classList.remove("collapsed");
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin dragging an entry.
	 * @param {DragEvent} event - Triggering drag event.
	 * @protected
	 */
	async _onDragStart(event) {
		const itemId = event.currentTarget.dataset.itemId;
		const item = await this.getItem(itemId);
		if (item) DragDrop$1.beginDragEvent(event, item);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry is dropped onto the element.
	 * @param {DragEvent} event - Triggering drop event.
	 * @returns {Promise}
	 * @protected
	 */
	async _onDrop(event) {
		event.preventDefault();
		event.stopImmediatePropagation();

		if (!this.isEditable) return false;

		const { data } = DragDrop$1.getDragData(event);
		if (!this._validateDrop(data)) return this.app._onDrop?.(event);
		// TODO: Add support for dropping folders

		const hookName = `drop${this.document.constructor.metadata.name}SheetData`;
		if (Hooks.call(hookName, this.document, this.app, data) === false) return;

		try {
			const item = await Item.implementation.fromDropData(data);
			if (!item) return false;
			return this.constructor.dropItems(event, this.document, [item]);
		} finally {
			DragDrop$1.finishDragEvent(event);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can the dragged document be dropped?
	 * @param {object} data
	 * @returns {boolean}
	 * @protected
	 */
	_validateDrop(data) {
		if (data.type !== "Item") return false;
		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an item dropped onto the sheet.
	 * @param {DragEvent} event - Triggering drop event.
	 * @param {BlackFlagActor|BlackFlagItem} target - Document to which the items were dropped.
	 * @param {BlackFlagItem|BlackFlagItem[]} itemData - One or more items dropped.
	 * @returns {Promise}
	 */
	static async dropItems(event, target, itemData) {
		const isContainer = target.type === "container";
		const actor = isContainer ? target.parent : target;

		if (actor?.sheet._handleDroppedItems) itemData = await actor.sheet._handleDroppedItems(event, itemData);
		if (!itemData?.length) return;

		const item = itemData[0];
		// TODO: Add support for multiple items

		if (isContainer) {
			const parentContainers = await target.system.allContainers();
			if (target.uuid === item.uuid || parentContainers.includes(item)) {
				ui.notifications.error("BF.Container.Warning.Recursive", { localize: true });
				return;
			}
		}

		// Document already exists in this collection, just perform sorting
		// TODO: Support using modifier key to change to copy rather than move operation in certain contexts
		if (actor?.uuid === item.parent?.uuid && target.pack === item.pack) {
			// If this inventory is on an actor, clear the container if set
			if (!isContainer && item.system.container !== null) {
				await item.update({ "system.container": null });
			}

			// If this inventory is on an container, set it to this
			else if (isContainer && item.system.container !== target.id) {
				await item.update({ "system.container": target.id });
			}

			// Then perform a sort
			return this._sortItems(event, target, [item]);
		}

		// TODO: Ensure created items can be created in this context
		// TODO: Perform consumable stacking

		// Create an item
		const options = { transformFirst: item => this._transformDroppedItem(event, target, item) };
		if (isContainer) options.container = target;
		const toCreate = await BlackFlagItem.createWithContents([item], options);
		if (isContainer && target.folder) toCreate.forEach(d => (d.folder = target.folder));
		return BlackFlagItem.createDocuments(toCreate, { pack: target.pack, parent: actor, keepId: true });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sort a dropped item based on where it was dropped.
	 * @param {DragEvent} event - Triggering drag event.
	 * @param {BlackFlagActor|BlackFlagItem} target - Document to which the items were dropped.
	 * @param {BlackFlagItem|object} itemData - Data for the item being dropped.
	 * @returns {Promise}
	 * @protected
	 */
	static async _sortItems(event, target, itemData) {
		const dropTarget = event.target.closest("[data-item-id]");
		if (!dropTarget) return;
		const item = itemData[0];
		// TODO: Add support for multiple items

		const getItem = async id => {
			if (target instanceof Actor) return target.items.get(id);
			else return (await target.system.contents).get(id);
		};

		const sortTarget = await getItem(dropTarget.dataset.itemId);

		// Don't sort on yourself
		if (item.id === sortTarget.id) return;

		// Identify sibling items based on adjacent HTML elements
		const siblings = [];
		for (const el of dropTarget.parentElement.children) {
			const siblingId = el.dataset.itemId;
			if (siblingId && siblingId !== item.id) siblings.push(await getItem(siblingId));
		}

		// Perform the sort
		const sortUpdates = SortingHelpers.performIntegerSort(item, { target: sortTarget, siblings });
		const updateData = sortUpdates.map(u => {
			const update = u.update;
			update._id = u.target.id;
			return update;
		});

		// Perform the update
		// TODO: Test what happens if you only have permission to some of these objects, perhaps no sorting in sidebar?
		Item.updateDocuments(updateData, {
			pack: target.pack,
			parent: target.type === "container" ? target.actor : target
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle any extra parsing or cleanup actions for items dropped on the sheet.
	 * @param {DragEvent} event - Triggering drop event.
	 * @param {BlackFlagActor|BlackFlagItem} target - Document to which the items were dropped.
	 * @param {BlackFlagItem|object} itemData - Data for the item being dropped.
	 * @returns {Promise<object|false>} - Parsed data or `false` to prevent this item from being created.
	 * @protected
	 */
	static async _transformDroppedItem(event, target, itemData) {
		if (itemData instanceof Item) itemData = itemData.toObject();

		const findItem = async query => {
			if (target instanceof Actor) return target.items.find(query);
			else return (await target.system.contents).find(query);
		};

		// TODO: Ensure no items not allowed on this actor type are dropped

		// TODO: Convert spells to spell scrolls if dropped on the inventory tab

		// TODO: Determine proper spell mode for spells dropped directly into spellcasting section

		// TODO: Stack identical consumables

		// Stack identical currencies
		if (itemData.type === "currency") {
			const existingItem = await findItem(
				i => i.type === "currency" && i.identifier === itemData.system.identifier.value
			);
			if (existingItem) {
				await existingItem.update({
					"system.quantity": existingItem.system.quantity + Math.max(1, itemData.system.quantity)
				});
				return false;
			}
		}

		return itemData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Find an item inside the inventory.
	 * @param {Function} query
	 * @returns {BlackFlagItem|Promise<BlackFlagItem>}
	 */
	findItem(query) {
		if (this.document.type === "container") {
			const contents = this.document.system.contents;
			if (contents instanceof Promise) return contents.then(c => c.find(query));
			else return contents.find(query);
		}
		return this.document.items.find(query);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve an item with the specified ID.
	 * @param {string} id
	 * @returns {BlackFlagItem|Promise<BlackFlagItem>}
	 */
	getItem(id) {
		if (this.document.type === "container") return this.document.system.getContainedItem(id);
		return this.document.items.get(id);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Construct sheet sections based on data in `CONFIG.BlackFlag.sheetSections`.
	 * @param {BlackFlagActor|BlackFlagItem} document - Document for who the sections should be built.
	 * @param {string} [tab] - Only build sections for a specific tab.
	 * @returns {object}
	 * @internal
	 */
	static buildSections(document, tab) {
		const sections = {};

		for (const config of CONFIG.BlackFlag.sheetSections[document.type] ?? []) {
			if (tab && config.tab !== tab) continue;
			const collection = tab ? sections : (sections[config.tab] ??= {});
			const toAdd = config.expand ? config.expand(document, foundry.utils.deepClone(config)) : [config];
			toAdd.forEach(c => (collection[c.id] = { ...c, items: [] }));
		}

		return sections;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sort provided items into sections defined by the document's type.
	 * @param {BlackFlagActor|BlackFlagItem} document - Document for who the sections should be created.
	 * @param {BlackFlagItem[]} items - Items to categorize.
	 * @param {object} [options={}]
	 * @param {async Function} [options.callback] - Method called for each item after it is added to a section.
	 * @param {boolean} [options.hide=true] - Should sections marked autoHide by hidden if empty?
	 * @returns {object} - Object with sections grouped by tabs and all their items.
	 */
	static async organizeItems(document, items, { callback, hide = true } = {}) {
		const sections = this.buildSections(document);
		const uncategorized = [];

		if (document instanceof Actor) items = items.filter(i => !document.items.has(i.system.container));

		for (const item of items) {
			const section = InventoryElement.organizeItem(item, sections);
			if (section === false) uncategorized.push(item);
			if (callback) await callback(item, section);
		}

		const filters = document.flags["black-flag"]?.sheet?.filters ?? {};
		const sorting = document.flags["black-flag"]?.sheet?.sorting ?? {};
		for (const [tab, data] of Object.entries(sections)) {
			for (const [key, section] of Object.entries(data)) {
				section.items = FiltersElement.filter(section.items, {
					checkVisibility: section.checkVisibility,
					filters: filters[tab]
				});
				section.items = SortingElement.sort(section.items, section.options?.sorting ?? sorting[tab]);
				if (hide && section.options?.autoHide && !section.items.length) delete data[key];
			}
		}

		if (uncategorized.length) sections.uncategorized = uncategorized;

		return sections;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Place an item in the appropriate section.
	 * @param {BlackFlagItem} item - Item to organize.
	 * @param {object} sections - Sections to populate.
	 * @returns {object|false} - Section into which the item was inserted, or false if no section match was found.
	 * @internal
	 */
	static organizeItem(item, sections) {
		for (const tab of Object.values(sections)) {
			for (const section of Object.values(tab)) {
				if (performCheck(item, section.filters)) {
					section.items.push(item);
					return section;
				}
			}
		}

		return false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch the configuration information for a specific section.
	 * @param {string} id - ID of the section to fetch.
	 * @returns {SheetSectionConfiguration}
	 */
	getSectionConfiguration(id) {
		if (!this.#sectionsCache) {
			const sections = this.constructor.buildSections(this.document, this.getAttribute("tab"));
			this.#sectionsCache = sections;
		}
		return this.#sectionsCache[id];
	}
}

/**
 * Application for viewing a documents's ID & UUID, changing its identifier, and setting source data if present.
 */
class SourceConfig extends BFDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["config", "identity", "standard-form"],
		sheetConfig: false,
		position: {
			width: 500
		},
		form: {
			submitOnChange: true
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		source: {
			template: "systems/black-flag/templates/shared/identity-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get title() {
		return `${game.i18n.localize("BF.SOURCE.Config")}: ${this.document.name}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const compendiumSource = fromUuid(this.document._stats.compendiumSource);
		const context = await super._prepareContext(options);
		const source = this.document.system.toObject();
		context.compendiumLink = (await compendiumSource)?.toAnchor().outerHTML;
		context.document = this.document;
		if (Object.hasOwn(this.document.system.identifier ?? {}, "value"))
			context.identifier = {
				field: this.document.system.schema.fields.identifier.fields.value,
				placeholder: slugify$1(this.document.name, { strict: true }),
				value: this.document.system.identifier.value
			};
		if (Object.hasOwn(this.document.system.description ?? {}, "source"))
			context.source = {
				data: this.document.system.description.source,
				fields: this.document.system.schema.fields.description.fields.source.fields,
				source: source.description.source
			};
		return context;
	}
}

/**
 * Adds identity & lock control to header and support for edit mode.
 * @param {typeof DocumentSheet} Base - The base class being mixed.
 * @returns {typeof BlackFlagDocumentSheet}
 */
function DocumentSheetMixin(Base) {
	return class BlackFlagDocumentSheet extends Base {
		/**
		 * Sheet modes that can be active.
		 * @type {Record<string, boolean>}
		 */
		modes = {
			editing: false
		};

		/* <><><><> <><><><> <><><><> <><><><> */
		/*              Rendering              */
		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		async getData(options) {
			const context = await super.getData(options);
			context.modes = this.modes;
			context.editable = this.isEditable && this.modes.editing;
			return context;
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/** @inheritDoc */
		_getHeaderButtons() {
			let buttons = super._getHeaderButtons();
			if (game.user.isGM || this.document.isOwner) {
				// Identity / Source button
				buttons.unshift({
					label: game.i18n.localize("BF.Identity.Label"),
					class: "identity-config",
					icon: "fa-solid fa-id-card",
					onclick: async ev => new SourceConfig({ document: this.document }).render({ force: true })
				});
			}
			if (this.isEditable && this.options.editable !== false) {
				// Editing Mode toggle
				const getLabel = () => (this.modes.editing ? "BF.EditingMode.Editable" : "BF.EditingMode.Locked");
				const getIcon = () => `fa-solid fa-lock${this.modes.editing ? "-open" : ""} fa-fw`;
				buttons.unshift({
					label: getLabel(),
					class: "toggle-editing-mode",
					icon: getIcon(),
					onclick: async ev => {
						this.modes.editing = !this.modes.editing;
						ev.currentTarget.innerHTML = `<i class="${getIcon()}"></i> <span>${game.i18n.localize(getLabel())}</span>`;
						await this.submit();
						this.render();
					}
				});
			}
			return buttons;
		}
	};
}

/**
 * Base document sheet from which all actor configuration applications should be based.
 */
class BaseConfigSheet extends BFDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["config-sheet", "standard-form"],
		sheetConfig: false,
		actions: {
			addModifier: BaseConfigSheet.#addModifier,
			deleteModifier: BaseConfigSheet.#deleteModifier
		},
		form: {
			submitOnChange: true
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.CONFIG = CONFIG.BlackFlag;
		context.fields = this.document.schema.fields;
		context.source = this.document.toObject();
		context.system = {
			data: this.document.system,
			source: context.source.system,
			fields: this.document.system.schema.fields
		};
		context.modifierSections = this.prepareModifiers();
		context.proficiencyOptions = [
			{ value: 0, label: game.i18n.localize("BF.Proficiency.Level.None") },
			{ value: 0.5, label: game.i18n.localize("BF.Proficiency.Level.Half") },
			{ value: 1, label: game.i18n.localize("BF.Proficiency.Level.Proficient") },
			{ value: 2, label: game.i18n.localize("BF.Proficiency.Level.Expertise") }
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch modifiers from the document where certain filters are met or not.
	 * @param {FilterDescription[]} [include=[]] - Filters that should be included.
	 * @param {FilterDescription[]} [exclude=[]] - Filters that should not be included.
	 * @param {Function} [filter] - Additional filtering function to apply.
	 * @returns {Modifier[]}
	 */
	getModifiers(include = [], exclude = [], filter = null) {
		let modifiers = [];
		for (let modifier of this.document.system.modifiers) {
			let valid = true;
			for (const i of include) {
				if (!modifier.filter.some(f => foundry.utils.objectsEqual(i, f))) valid = false;
			}
			for (const e of exclude) {
				if (modifier.filter.some(f => foundry.utils.objectsEqual(e, f))) valid = false;
			}
			if (!valid) continue;

			const mod = foundry.utils.deepClone(modifier);
			mod.index = modifier.index;
			mod.requireProficiency = mod.filter.some(f => f.k === "proficiency");
			modifiers.push(mod);
		}
		return foundry.utils.getType(filter) === "function" ? modifiers.filter(filter) : modifiers;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare modifier sections that should be displayed.
	 * @returns {object}
	 * @abstract
	 */
	prepareModifiers() {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a modifier of certain type.
	 * @this {BaseConfigSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #addModifier(event, target) {
		const category = target.closest("[data-modifier-category]")?.dataset.modifierCategory;
		const type = target.closest("[data-modifier-type]")?.dataset.modifierType;
		if (!category || !type) return;
		const data = this._getModifierData(category, type);
		this.document.system.addModifier(data);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle removing a modifier of certain type.
	 * @this {BaseConfigSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #deleteModifier(event, target) {
		const index = target.closest("[data-index]")?.dataset.index;
		if (index) this.document.system.deleteModifier(index);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Produce modifier creation data.
	 * @param {string} category - Modifier category.
	 * @param {string} type - Modifier type.
	 * @returns {object}
	 * @abstract
	 */
	_getModifierData(category, type) {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		if ("modifier" in submitData) {
			const modifierData = this.document.system.toObject().modifiers ?? [];
			for (const [index, updates] of Object.entries(submitData.modifier)) {
				const entryData = modifierData[Number(index)];
				if (!entryData) continue;
				if ("requireProficiency" in updates) {
					updates.filter = entryData.filter;
					if (updates.requireProficiency) updates.filter.push({ k: "proficiency", v: 1, o: "gte" });
					else updates.filter.findSplice(f => f.k === "proficiency");
				}
				foundry.utils.mergeObject(entryData, updates, { performDeletions: true });
			}
			delete submitData.modifier;
			foundry.utils.setProperty(submitData, "system.modifiers", modifierData);
		}
		return submitData;
	}
}

/**
 * Config sheet that allows for selecting a key used for abilities, skills, and tools.
 */
class BaseSelectorConfigSheet extends BaseConfigSheet {
	constructor(options) {
		super(options);
		this.selectedId = this.options.selectedId ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		selector: {
			template: "systems/black-flag/templates/actor/config/id-selector.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The ability being modified by this app.
	 * @type {string|null}
	 */
	selectedId;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "selector":
				return this._prepareSelectorContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the ID selector section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareSelectorContext(context, options) {
		context.options = [{ value: "", label: game.i18n.localize("BF.Global") }, { rule: true }];
		context.selected = this.selectedId;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		super._onChangeForm(formConfig, event);
		if (event.target.name === "selectedId") {
			this.selectedId = event.target.value;
			this.render();
		}
	}
}

/**
 * Dialog for configuring an individual ability.
 */
class AbilityConfig extends BaseSelectorConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["ability", "form-list"],
		position: {
			width: 450
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		...super.PARTS,
		config: {
			classes: ["contents"],
			template: "systems/black-flag/templates/actor/config/ability-config.hbs"
		},
		modifiers: {
			classes: ["contents"],
			template: "systems/black-flag/templates/actor/config/modifier-section.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Ability.Label[other]") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "config":
				return this._prepareConfigContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareSelectorContext(context, options) {
		context = await super._prepareSelectorContext(context, options);
		context.options = [...context.options, ...CONFIG.BlackFlag.abilities.localizedOptions];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the config section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareConfigContext(context, options) {
		context.ability = this.selectedId
			? {
					data:
						context.system.source.abilities[this.selectedId] ?? context.system.data.abilities[this.selectedId] ?? {},
					fields: context.system.fields.abilities.model.fields,
					id: this.selectedId,
					keyPath: `system.abilities.${this.selectedId}`
				}
			: null;
		context.canSetValue = !!game.settings.get("black-flag", "abilitySelectionManual") || game.user.isGM;
		context.proficiencyOptions = context.proficiencyOptions.filter(o => [0, 1].includes(o.value));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareModifiers() {
		let checkModifiers;
		let saveModifiers;
		let global;
		if (this.selectedId) {
			checkModifiers = this.getModifiers([
				{ k: "type", v: "ability-check" },
				{ k: "ability", v: this.selectedId }
			]);
			saveModifiers = this.getModifiers([
				{ k: "type", v: "ability-save" },
				{ k: "ability", v: this.selectedId }
			]);
			global = false;
		} else {
			const filter = modifier => !modifier.filter.some(f => f.k === "ability");
			checkModifiers = this.getModifiers([{ k: "type", v: "ability-check" }], [], filter);
			saveModifiers = this.getModifiers([{ k: "type", v: "ability-save" }], [], filter);
			global = true;
		}
		return [
			{
				category: "check",
				type: "bonus",
				label: "BF.CHECK.Label[one]",
				global,
				showProficiency: true,
				modifiers: checkModifiers.filter(m => m.type === "bonus")
			},
			{
				category: "check",
				type: "min",
				label: "BF.CHECK.Label[one]",
				showProficiency: true,
				modifiers: checkModifiers.filter(m => m.type === "min")
			},
			{
				category: "check",
				type: "note",
				label: "BF.CHECK.Label[one]",
				modifiers: checkModifiers.filter(m => m.type === "note")
			},
			{
				category: "save",
				type: "bonus",
				label: "BF.SavingThrow.LabelShort[one]",
				showProficiency: true,
				modifiers: saveModifiers.filter(m => m.type === "bonus")
			},
			{
				category: "save",
				type: "min",
				label: "BF.SavingThrow.LabelShort[one]",
				showProficiency: true,
				modifiers: saveModifiers.filter(m => m.type === "min")
			},
			{
				category: "save",
				type: "note",
				label: "BF.SavingThrow.LabelShort[one]",
				modifiers: saveModifiers.filter(m => m.type === "note")
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_getModifierData(category, type) {
		const data = { type, filter: [{ k: "type", v: `ability-${category}` }] };
		if (this.selectedId) data.filter.push({ k: "ability", v: this.selectedId });
		return data;
	}
}

/**
 * Configuration application for AC formulas, bonuses, and other values.
 */
class ArmorClassConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["armor-class"],
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/config/armor-class-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.ArmorClass.Label") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);

		context.armorFormulas = context.system.data.attributes.ac.formulas.map(data => ({
			...data,
			checked: data.enabled !== false,
			disabled: {
				checkbox: data.type !== "base",
				input: true
			},
			keyPath: "baseFormulas"
		}));

		context.equipped = {};
		for (const key of ["armor", "shield"]) {
			const item = context.system.data.attributes.ac[`equipped${key.capitalize()}`];
			if (item)
				context.equipped[key] = {
					anchor: item.toAnchor().outerHTML,
					img: item.img,
					magicalBonus: numberFormat(item.system.properties.has("magical") ? item.system.magicalBonus : 0, {
						signDisplay: "always"
					}),
					name: item.name,
					value: numberFormat(item.system.armor.value, { signDisplay: key === "shield" ? "always" : "auto" })
				};
		}
		if (foundry.utils.isEmpty(context.equipped)) delete context.equipped;

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareModifiers() {
		return [
			{
				category: "armor-class",
				type: "bonus",
				label: "BF.ArmorClass.Label",
				modifiers: this.getModifiers([{ k: "type", v: "armor-class" }], [], f => f.type === "bonus")
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_getModifierData(category, type) {
		const data = { type, filter: [{ k: "type", v: "armor-class" }] };
		return data;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);

		if (submitData.baseFormulas) {
			foundry.utils.setProperty(submitData, "system.attributes.ac.baseFormulas", filteredKeys(submitData.baseFormulas));
			delete submitData.baseFormulas;
		}

		return submitData;
	}
}

/**
 * Configuration application for hit points & hit dice.
 */
class HealthConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["health"],
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/config/health-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.localize("BF.Health.Label");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		context.hp = {
			data: context.system.data.attributes.hp,
			fields: context.system.fields.attributes.fields.hp.fields,
			source: context.system.source.attributes.hp
		};

		// Display positive ability modifier as its own row, but if negative merge into classes totals
		const ability = CONFIG.BlackFlag.abilities.localized[CONFIG.BlackFlag.defaultAbilities.hitPoints];
		const mod = this.document.system.abilities?.[CONFIG.BlackFlag.defaultAbilities.hitPoints]?.mod ?? 0;
		if (ability && mod > 0) context.ability = { mod, label: ability };

		// Summarize HP from classes
		context.classes = Object.values(this.document.system.progression?.classes ?? {}).map(cls => ({
			id: cls.document.id,
			anchor: cls.document.toAnchor().outerHTML,
			name: cls.document.name,
			total: cls.document.system.advancement.byType("hitPoints")[0]?.getAdjustedTotal(mod > 0 ? 0 : mod) ?? 0
		}));

		// Display active effects targeting bonus fields
		context.effects = {
			level: this.document.activeEffectAttributions("system.attributes.hp.bonuses.level"),
			overall: this.document.activeEffectAttributions("system.attributes.hp.bonuses.overall")
		};
		Object.keys(context.effects).forEach(
			k =>
				(context.effects[k] = context.effects[k]
					.filter(e => e.mode === CONST.ACTIVE_EFFECT_MODES.ADD)
					.map(e => ({ ...e, anchor: e.document.toAnchor().outerHTML })))
		);

		// Create level multiplier HTML
		context.levels = this.document.system.progression?.level ?? 0;
		context.levelMultiplier = `
			<span class="multiplier"><span class="times">&times;</span> ${numberFormat(context.levels)}</span>
		`;

		context.hd = {
			data: context.system.data.attributes.hd,
			fields: context.system.fields.attributes.fields.hd.fields,
			source: context.system.source.attributes.hp
		};
		context.hd.types = Object.entries(context.hd.data.d).map(([denomination, data]) => ({
			data,
			denomination,
			keyPath: `system.attributes.hd.d.${denomination}.`,
			label: `d${denomination}`
		}));
		context.hd.typeFields = context.hd.fields.d.model.fields;

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		for (const [denomination, data] of Object.entries(submitData.system?.attributes?.hd?.d ?? {})) {
			if (!("available" in data)) continue;
			data.spent = this.document.system.attributes.hd.d[denomination].max - data.available;
			delete data.available;
		}
		return submitData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processSubmitData(event, form, submitData) {
		const clone = this.document.clone(submitData);
		const { value, max } = this.document.system.attributes.hp;
		const maxDelta = clone.system.attributes.hp.max - max;
		const current = submitData.system.attributes.hp.value ?? value;
		foundry.utils.setProperty(submitData, "system.attributes.hp.value", Math.max(current + maxDelta, 0));
		super._processSubmitData(event, form, submitData);
	}
}

/**
 * Configuration application for actor initiative.
 */
class InitiativeConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["initiative", "form-list"],
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/config/initiative-config.hbs"
		},
		modifiers: {
			classes: ["contents"],
			template: "systems/black-flag/templates/actor/config/modifier-section.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Initiative.Label") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		const defaultAbility = CONFIG.BlackFlag.abilities.localized[CONFIG.BlackFlag.defaultAbilities.initiative];
		context.abilityOptions = [
			{ value: "", label: game.i18n.format("BF.Default.Specific", { default: defaultAbility }) },
			{ rule: true },
			...CONFIG.BlackFlag.abilities.localizedOptions
		];
		context.initiative = {
			data: context.system.data.attributes.initiative,
			fields: context.system.fields.attributes.fields.initiative.fields,
			source: context.system.source.attributes.initiative
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareModifiers() {
		const modifiers = this.getModifiers([{ k: "type", v: "initiative" }]);
		return [
			{
				category: "initiative",
				type: "bonus",
				label: "BF.Initiative.Label",
				modifiers: modifiers.filter(m => m.type === "bonus")
			},
			{
				category: "initiative",
				type: "min",
				label: "BF.Initiative.Label",
				modifiers: modifiers.filter(m => m.type === "min")
			},
			{
				category: "initiative",
				type: "note",
				label: "BF.Initiative.Label",
				modifiers: modifiers.filter(m => m.type === "note")
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_getModifierData(category, type) {
		const data = { type, filter: [{ k: "type", v: "initiative" }] };
		return data;
	}
}

/**
 * Base configuration application that supports adding & deleting custom values.
 */
class BaseCustomConfigSheet extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			addCustom: BaseCustomConfigSheet.#addCustom,
			deleteCustom: BaseCustomConfigSheet.#deleteCustom
		},
		customKeyPath: ""
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a custom tag.
	 * @this {BaseCustomConfigSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #addCustom(event, target) {
		this.submit({ updateData: { newCustom: true } });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle removing a custom tag.
	 * @this {BaseCustomConfigSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #deleteCustom(event, target) {
		this.submit({ updateData: { deleteCustom: Number(target.dataset.index) } });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		foundry.utils.setProperty(
			submitData,
			this.options.customKeyPath,
			Array.from(Object.values(submitData.custom ?? {}))
		);
		return submitData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _processSubmitData(event, form, submitData) {
		if (submitData.newCustom || submitData.deleteCustom !== undefined) {
			const custom = foundry.utils.getProperty(submitData, this.options.customKeyPath) ?? [];
			if (submitData.deleteCustom !== undefined) custom.splice(submitData.deleteCustom, 1);
			if (submitData.newCustom) custom.push("");
			foundry.utils.setProperty(submitData, this.options.customKeyPath, custom);
		}
		super._processSubmitData(event, form, submitData);
	}
}

/**
 * Class for configuring language proficiencies.
 */
class LanguageConfig extends BaseCustomConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["language", "grid-columns"],
		position: {
			width: "auto"
		},
		customKeyPath: "system.proficiencies.languages.custom"
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		dialects: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/actor/config/language-config-dialects.hbs"
		},
		custom: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/actor/config/language-config-custom.hbs"
		},
		tags: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/actor/config/language-config-tags.hbs"
		},
		communication: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/actor/config/language-config-communication.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Language.Label[other]") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);

		const languages = context.system.source.proficiencies.languages ?? {};
		context.languages = {
			communication: Object.entries(CONFIG.BlackFlag.rangedCommunication).reduce((obj, [key, config]) => {
				obj[key] = { label: game.i18n.localize(config.label), value: languages.communication[key] ?? {} };
				return obj;
			}, {}),
			data: languages,
			dialects: choices("languages", { chosen: languages.value }),
			fields: context.system.fields.proficiencies.fields.languages.fields,
			tagOptions: Object.entries(CONFIG.BlackFlag.languageTags.localized).reduce((obj, [key, label]) => {
				obj[key] = { label, chosen: languages.tags.includes(key) };
				return obj;
			}, {})
		};

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Life-Cycle Handlers         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);
		for (const checkbox of this.element.querySelectorAll('input[type="checkbox"]:checked')) {
			this._onToggleCategory(checkbox);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		if (event.target instanceof HTMLInputElement) this._onToggleCategory(event.target);
		super._onChangeForm(formConfig, event);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Disable all children when a category is checked.
	 * @param {HTMLInputElement} checkbox - Checkbox to compare.
	 * @protected
	 */
	_onToggleCategory(checkbox) {
		const children = checkbox.closest("li")?.querySelector("ol");
		if (!children) return;

		for (const child of children.querySelectorAll('input[type="checkbox"]')) {
			child.checked = child.disabled = checkbox.checked;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		const languages = submitData.system.proficiencies?.languages ?? {};
		foundry.utils.setProperty(submitData, "system.proficiencies.languages", {
			communication: Object.entries(languages.communication ?? {}).reduce((obj, [key, value]) => {
				if (!value) obj[`-=${key}`] = null;
				else obj[key] = { range: value };
				return obj;
			}, {}),
			custom: languages.custom,
			tags: filteredKeys(languages.tags ?? {}),
			value: filteredKeys(languages.value ?? {})
		});
		return submitData;
	}
}

/**
 * Configuration application for a PC's luck.
 */
class LuckConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["luck"],
		position: {
			width: 400
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/config/luck-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Luck.Label") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		context.formulaDisabled =
			!!foundry.utils.getProperty(this.document.overrides, "system.attributes.luck.formula") ||
			!!foundry.utils.getProperty(this.document.advancementOverrides, "system.attributes.luck.formula");
		return context;
	}
}

/**
 * Configuration application for an actor's movement.
 */
class MovementConfig extends BaseCustomConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["movement"],
		position: {
			width: 450
		},
		customKeyPath: "system.traits.movement.custom"
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/config/movement-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.MOVEMENT.Label") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);

		context.movement = {
			data: context.system.source.traits.movement,
			fields: context.system.fields.traits.fields.movement.fields
		};
		context.showBase = Object.hasOwn(this.document.system.traits.movement ?? {}, "base");
		context.types = Object.entries(CONFIG.BlackFlag.movementTypes).reduce((obj, [key, config]) => {
			const keyPath = `system.traits.movement.types.${key}`;
			obj[key] = {
				label: game.i18n.localize(config.label),
				value: context.movement.data.types?.[key] ?? "",
				placeholder:
					foundry.utils.getProperty(this.document.overrides, keyPath) ??
					foundry.utils.getProperty(this.document.advancementOverrides, keyPath) ??
					""
			};
			return obj;
		}, {});
		context.tagOptions = Object.entries(CONFIG.BlackFlag.movementTags).reduce((obj, [key, config]) => {
			if (!config.validTypes || config.validTypes.has(this.document.type)) {
				obj[key] = { label: game.i18n.localize(config.label), chosen: context.movement.data.tags?.includes(key) };
			}
			return obj;
		}, {});

		if (Object.hasOwn(this.document.system.traits, "pace")) {
			context.pace = {
				data: context.system.source.traits.pace,
				fields: context.system.fields.traits.fields.pace.fields,
				types: CONFIG.BlackFlag.movementTypes.localizedOptions.map(({ value, label }) => ({
					field: context.system.fields.traits.fields.pace.fields.types.model,
					label,
					name: `system.traits.pace.types.${value}`,
					value: context.system.source.traits.pace.types[value]
				}))
			};
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		if (!submitData.system.traits.movement) foundry.utils.setProperty(submitData, "system.traits.movement", {});
		submitData.system.traits.movement.tags = filteredKeys(submitData.system.traits.movement.tags ?? {});
		return submitData;
	}
}

/**
 * Class for configuring armor & weapon proficiencies.
 */
class ProficiencyConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["proficiency", "grid-columns"],
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		armor: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/actor/config/proficiency-config-armor.hbs"
		},
		weapons: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/actor/config/proficiency-config-weapons.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", {
			type: game.i18n
				.getListFormatter()
				.format([game.i18n.localize("BF.Armor.Label[one]"), game.i18n.localize("BF.WEAPON.Label[one]")])
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		const proficiencies = this.document.system.proficiencies ?? {};
		context.armorOptions = choices("armor", { chosen: proficiencies.armor?.value });
		context.weaponOptions = choices("weapons", { chosen: proficiencies.weapons?.value });
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Life-Cycle Handlers         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);
		for (const checkbox of this.element.querySelectorAll('input[type="checkbox"]:checked')) {
			this._onToggleCategory(checkbox);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		if (event.target instanceof HTMLInputElement) this._onToggleCategory(event.target);
		super._onChangeForm(formConfig, event);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Disable all children when a category is checked.
	 * @param {HTMLInputElement} checkbox - Checkbox to compare.
	 * @protected
	 */
	_onToggleCategory(checkbox) {
		const children = checkbox.closest("li")?.querySelector("ol");
		if (!children) return;

		for (const child of children.querySelectorAll('input[type="checkbox"]')) {
			child.checked = child.disabled = checkbox.checked;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		return foundry.utils.expandObject({
			"system.proficiencies.armor.value": filteredKeys(submitData.armor),
			"system.proficiencies.weapons.value": filteredKeys(submitData.weapons)
		});
	}
}

/**
 * Configuration application for condition & damage resistances, immunities, and vulnerabilities.
 */
class ResistanceConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["resistance"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		damageAll: {
			template: "systems/black-flag/templates/actor/config/resistance-entries.hbs"
		},
		damageNonmagical: {
			template: "systems/black-flag/templates/actor/config/resistance-entries.hbs"
		},
		conditions: {
			template: "systems/black-flag/templates/actor/config/resistance-entries.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Resistance.Config") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	async _preparePartContext(partId, context, options) {
		context = { ...(await super._preparePartContext(partId, context, options)) };
		let all = false;
		switch (partId) {
			case "conditions":
				context.header = "BF.Condition.Label[other]";
				context.name = "BF.Condition.Label[one]";
				context.entries = Object.entries(CONFIG.BlackFlag.conditions.localized).map(([key, label]) =>
					this._prepareEntry(key, "condition", label)
				);
				break;
			case "damageAll":
				all = true;
			case "damageNonmagical":
				context.header = all ? "BF.DAMAGE.Source.All" : "BF.DAMAGE.Source.Nonmagical";
				context.name = "BF.DAMAGE.Label";
				const options = { section: all ? "value" : "nonmagical" };
				context.entries = [
					this._prepareEntry("all", "damage", game.i18n.localize("BF.Resistance.AllDamage"), options),
					...Object.entries(CONFIG.BlackFlag.damageTypes.localized).map(([key, label]) =>
						this._prepareEntry(key, "damage", label, options)
					)
				];
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare a single entry in the resistances list.
	 * @param {string} key - Key for the entry.
	 * @param {"condition"|"damage"} type - Type of resistance being prepared.
	 * @param {string} label - Display label for the entry.
	 * @param {object} [options={}]
	 * @param {string} [options.section="value"] - Key of the set for which to get the values.
	 * @returns {object}
	 */
	_prepareEntry(key, type, label, { section = "value" } = {}) {
		return {
			label,
			prefix: `system.traits.${type}`,
			key: `${section}.${key}`,
			resistant: this.document._source.system.traits?.[type]?.resistances?.[section]?.includes(key),
			immune: this.document._source.system.traits?.[type]?.immunities?.[section]?.includes(key),
			vulnerable: this.document._source.system.traits?.[type]?.vulnerabilities?.[section]?.includes(key)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		formData = super._processFormData(event, form, formData);
		for (const type of ["damage", "condition"]) {
			for (const kind of ["resistances", "immunities", "vulnerabilities"]) {
				for (const section of ["value", "nonmagical"]) {
					if (type !== "damage" && section === "nonmagical") continue;
					const path = `system.traits.${type}.${kind}.${section}`;
					foundry.utils.setProperty(formData, path, filteredKeys(foundry.utils.getProperty(formData, path)));
				}
			}
		}
		return formData;
	}
}

/**
 * Configuration application for an actor's senses.
 */
class SensesConfig extends BaseCustomConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["senses", "form-list"],
		position: {
			width: 450
		},
		customKeyPath: "system.traits.senses.custom"
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		types: {
			template: "systems/black-flag/templates/actor/config/senses-config-types.hbs"
		},
		tags: {
			template: "systems/black-flag/templates/actor/config/senses-config-tags.hbs"
		},
		custom: {
			template: "systems/black-flag/templates/actor/config/senses-config-custom.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.SENSES.Label[other]") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);

		const senses = context.system.source.traits.senses ?? {};
		context.senses = {
			data: senses,
			fields: context.system.fields.traits.fields.senses.fields,
			tagOptions: Object.entries(CONFIG.BlackFlag.senseTags).reduce((obj, [key, config]) => {
				obj[key] = { label: game.i18n.localize(config.label), chosen: senses.tags?.includes(key) };
				return obj;
			}, {}),
			types: Object.entries(CONFIG.BlackFlag.senses.localized).reduce((obj, [key, label]) => {
				const keyPath = `system.traits.senses.types.${key}`;
				obj[key] = {
					label,
					value: senses.types?.[key] ?? "",
					placeholder:
						foundry.utils.getProperty(this.document.overrides, keyPath) ??
						foundry.utils.getProperty(this.document.advancementOverrides, keyPath) ??
						""
				};
				return obj;
			}, {})
		};

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		submitData.system.traits.senses.tags = filteredKeys(submitData.system.traits.senses.tags ?? {});
		return submitData;
	}
}

/**
 * Dialog for configuring skill proficiencies.
 */
class SkillConfig extends BaseSelectorConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["skill", "form-list"],
		position: {
			width: 450
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		...super.PARTS,
		config: {
			classes: ["contents"],
			template: "systems/black-flag/templates/actor/config/skill-config.hbs"
		},
		modifiers: {
			classes: ["contents"],
			template: "systems/black-flag/templates/actor/config/modifier-section.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Skill.Label[other]") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "config":
				return this._prepareConfigContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareSelectorContext(context, options) {
		context = await super._prepareSelectorContext(context, options);
		context.options = [...context.options, ...CONFIG.BlackFlag.skills.localizedOptions];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the config section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareConfigContext(context, options) {
		context.skill = this.selectedId
			? {
					data:
						context.system.source.proficiencies.skills[this.selectedId] ??
						context.system.data.proficiencies.skills[this.selectedId] ??
						{},
					fields: context.system.fields.proficiencies.fields.skills.model.fields,
					id: this.selectedId,
					keyPath: `system.proficiencies.skills.${this.selectedId}`
				}
			: null;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareModifiers() {
		let checkModifiers;
		let passiveModifiers;
		let global;
		if (this.selectedId) {
			checkModifiers = this.getModifiers([
				{ k: "type", v: "skill-check" },
				{ k: "skill", v: this.selectedId }
			]);
			passiveModifiers = this.getModifiers([
				{ k: "type", v: "skill-passive" },
				{ k: "skill", v: this.selectedId }
			]);
			global = false;
		} else {
			const filter = modifier => !modifier.filter.some(f => f.k === "skill");
			checkModifiers = this.getModifiers([{ k: "type", v: "skill-check" }], [], filter);
			passiveModifiers = this.getModifiers([{ k: "type", v: "skill-passive" }], [], filter);
			global = true;
		}
		return [
			{
				category: "check",
				type: "bonus",
				label: "BF.CHECK.Label[one]",
				global,
				showProficiency: global,
				modifiers: checkModifiers.filter(m => m.type === "bonus")
			},
			{
				category: "passive",
				type: "bonus",
				label: "BF.Skill.Passive.LabelGeneric",
				global,
				showProficiency: global,
				modifiers: passiveModifiers
			},
			{
				category: "check",
				type: "min",
				label: "BF.CHECK.Label[one]",
				global,
				showProficiency: global,
				modifiers: checkModifiers.filter(m => m.type === "min")
			},
			{
				category: "check",
				type: "note",
				label: "BF.CHECK.Label[one]",
				global,
				modifiers: checkModifiers.filter(m => m.type === "note")
			}
		];
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */
	/*  Action Handlers                          */
	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/** @override */
	_getModifierData(category, type) {
		const data = { type, filter: [{ k: "type", v: `skill-${category}` }] };
		if (this.selectedId) data.filter.push({ k: "skill", v: this.selectedId });
		return data;
	}
}

const { SetField: SetField$s, StringField: StringField$V } = foundry.data.fields;

/**
 * Dialog for configuring tool & vehicle proficiencies.
 */
class ToolConfig extends BaseSelectorConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["tool", "form-list"],
		position: {
			width: 450
		},
		trait: "tools"
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		...super.PARTS,
		config: {
			template: "systems/black-flag/templates/actor/config/tool-config.hbs"
		},
		modifiers: {
			classes: ["contents"],
			template: "systems/black-flag/templates/actor/config/modifier-section.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: traitLabel(this.options.trait, 999) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Config for the currently selected tool.
	 * @type {object|null}
	 */
	get toolConfig() {
		return this.selectedId ? configForKey(this.selectedId, { trait: this.options.trait }) : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context.toolSource =
			context.system.source.proficiencies[this.options.trait] ??
			context.system.data.proficiencies[this.options.trait] ??
			{};
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "config":
				return this._prepareConfigContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareSelectorContext(context, options) {
		context = await super._prepareSelectorContext(context, options);
		context.options = [
			...context.options,
			...Object.keys(context.toolSource).map(value => ({
				value,
				label: keyLabel(value, { trait: this.options.trait })
			}))
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the config section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareConfigContext(context, options) {
		if (this.selectedId)
			context.tool = {
				data:
					context.system.source.proficiencies[this.options.trait]?.[this.selectedId] ??
					context.system.data.proficiencies[this.options.trait][this.selectedId] ??
					{},
				fields: context.system.fields.proficiencies.fields[this.options.trait].model.fields,
				id: this.selectedId,
				keyPath: `system.proficiencies.${this.options.trait}.${this.selectedId}`
			};
		else
			context.toolSelector = {
				field: new SetField$s(new StringField$V()),
				options: Array.from(choices(this.options.trait).set).map(value => ({
					value,
					label: keyLabel(value, { trait: this.options.trait })
				})),
				value: new Set(Object.keys(context.toolSource))
			};
		context.trait = this.options.trait;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareModifiers() {
		let checkModifiers;
		let global;
		const shortTrait = this.options.trait.replace("s", "");
		if (this.selectedId) {
			checkModifiers = this.getModifiers([
				{ k: "type", v: `${shortTrait}-check` },
				{ k: shortTrait, v: this.selectedId }
			]);
			global = false;
		} else {
			const filter = modifier => !modifier.filter.some(f => f.k === shortTrait);
			checkModifiers = this.getModifiers([{ k: "type", v: `${shortTrait}-check` }], [], filter);
			global = true;
		}
		return [
			{
				category: "check",
				type: "bonus",
				label: "BF.CHECK.Label[one]",
				global,
				modifiers: checkModifiers.filter(m => m.type === "bonus")
			},
			{
				category: "check",
				type: "min",
				label: "BF.CHECK.Label[one]",
				global,
				modifiers: checkModifiers.filter(m => m.type === "min")
			},
			{
				category: "check",
				type: "note",
				label: "BF.CHECK.Label[one]",
				global,
				modifiers: checkModifiers.filter(m => m.type === "note")
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		super._onChangeForm(formConfig, event);
		if (event.target.name === "listed-tools") this._onChangeTools(event);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Respond to a change in the current tools.
	 * @param {Event} event - Triggering event.
	 */
	_onChangeTools(event) {
		if (event.target.open) return;
		const removeKeys = new Set(Object.keys(this.document.system.proficiencies[this.options.trait]));
		const updates = {};
		for (const key of event.target.value) {
			if (key in this.document.system.proficiencies[this.options.trait]) removeKeys.delete(key);
			else updates[`system.proficiencies.${this.options.trait}.${key}`] = {};
		}
		removeKeys.forEach(key => (updates[`system.proficiencies.${this.options.trait}.-=${key}`] = null));
		this.submit({ updateData: foundry.utils.expandObject(updates) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getModifierData(category, type) {
		const shortTrait = this.options.trait.replace("s", "");
		const data = { type, filter: [{ k: "type", v: `${shortTrait}-${category}` }] };
		if (this.selectedId) data.filter.push({ k: shortTrait, v: this.selectedId });
		return data;
	}
}

/**
 * Configuration application for an actor's type & size.
 */
class TypeConfig extends BaseCustomConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["type"],
		position: {
			width: 500
		},
		customKeyPath: "system.traits.type.custom"
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/config/type-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get title() {
		return game.i18n.localize("BF.CreatureType.Label");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);

		const type = context.system.source.traits?.type ?? {};
		context.custom = type.custom;
		context.showDimensions = Object.hasOwn(this.document.system.traits, "dimensions");
		context.showSwarm = Object.hasOwn(this.document.system.traits.type ?? {}, "swarm");
		context.showTags = Object.hasOwn(this.document.system.traits.type ?? {}, "tags");
		context.tagOptions = new SelectChoices(CONFIG.BlackFlag.creatureTags, new Set(type.tags)).localize().sort();

		context.type = {
			data: context.system.source.traits.type,
			fields: context.system.fields.traits.fields.type.fields,
			options:
				this.document.type === "vehicle"
					? CONFIG.BlackFlag.vehicles.localizedOptions
					: CONFIG.BlackFlag.creatureTypes.localizedOptions
		};

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		if (!submitData.system.traits.type) foundry.utils.setProperty(submitData, "system.traits.type", {});
		submitData.system.traits.type.tags = filteredKeys(submitData.system.traits.type.tags ?? {});
		return submitData;
	}
}

/**
 * Sheet class containing implementation shared across all actor types.
 */
class BaseActorSheet extends DocumentSheetMixin(ActorSheet) {
	/**
	 * Fields that will be enriched during data preparation.
	 * @type {object}
	 */
	static enrichedFields = {};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * IDs for items on the sheet that have their descriptions expanded in-line.
	 * @type {Set<string>}
	 */
	expanded = new Set();

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Filters that can be applied to different item lists.
	 * @type {Record<string, Record<string, number>>}
	 */
	filters = {};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	modes = {
		conditionAdd: false,
		editing: false
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sorting mode applied to different item lists.
	 * @type {Record<string, string>}
	 */
	sorting = {};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get template() {
		return `systems/black-flag/templates/actor/${this.actor.type}.hbs`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.appID = this.id;
		context.CONFIG = CONFIG.BlackFlag;
		context.system = this.document.system;
		context.source = this.document.toObject().system;

		context.effects = EffectsElement.prepareActorContext(this.document.allApplicableEffects());

		await this.prepareActions(context);
		await this.prepareItems(context);
		await this.prepareTraits(context);

		const enrichmentContext = {
			relativeTo: this.actor,
			rollData: this.actor.getRollData(),
			secrets: this.actor.isOwner,
			async: true
		};
		context.enriched = {};
		for (const [key, path] of Object.entries(this.constructor.enrichedFields)) {
			context.enriched[key] = await TextEditor.enrichHTML(foundry.utils.getProperty(context, path), enrichmentContext);
		}
		context.editorSelected = this.editorSelected;

		const token = this.actor.isToken ? this.actor.token : this.actor.prototypeToken;
		context.showTokenArtwork = this.modes.editing || this.actor.img !== token.texture.src;

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare activity context within the inventory list.
	 * @param {Activity} activity - Activity to prepare.
	 * @returns {object}
	 */
	prepareActivity(activity) {
		return activity.listContext;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare actions for display.
	 * @param {object} context - Context object for rendering the sheet. **Will be mutated.**
	 */
	async prepareActions(context) {
		context.actions = Object.entries(CONFIG.BlackFlag.actionTypes.localized).reduce((obj, [key, label]) => {
			obj[key] = { label, activities: [] };
			return obj;
		}, {});
		context.actions.other = { label: game.i18n.localize("BF.ACTIVATION.Type.Other"), activities: [] };
		for (const item of this.actor.items) {
			if (!item.system.displayActions) continue;
			for (const activity of item.system.actions?.() ?? []) {
				if (!activity.displayAction) continue;
				const data = {
					activity,
					item: activity.item,
					label: activity.activationLabel,
					activationTooltip: activity.activation.condition,
					usesColumn: activity.usesColumn,
					challengeColumn: activity.challengeColumn,
					effectColumn: activity.effectColumn
				};
				if (activity.actionType in context.actions) context.actions[activity.actionType].activities.push(data);
				else context.actions.other.activities.push(data);
			}
		}
		await this.prepareSpecialActions(context.actions);
		for (const [key, value] of Object.entries(context.actions)) {
			if (!value.activities.length) delete context.actions[key];
			else
				context.actions[key].activities.sort((lhs, rhs) => (lhs.item?.sort ?? Infinity) - (rhs.item?.sort ?? Infinity));
		}
		// TODO: Figure out how these should be sorted
	}

	/**
	 * Prepare any additional actions not covered by activities.
	 * @param {Record<string, {label: string, actions: object[]}>} actions - Action sections already prepared.
	 */
	async prepareSpecialActions(actions) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the items for display on the sheet.
	 * @param {object} context - Context object for rendering the sheet. **Will be mutated.**
	 * @abstract
	 */
	async prepareItems(context) {
		context.itemContext ??= {};
		context.sections = await InventoryElement.organizeItems(this.actor, this.actor.items, {
			callback: async (item, section) => {
				const itemContext = (context.itemContext[item.id] ??= {});
				await this.prepareItem(item, itemContext, section);
			},
			hide: !this.modes.editing
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare context data for a specific item.
	 * @param {BlackFlagItem} item - Item being prepared.
	 * @param {object} context - Context object for this item.
	 * @param {object} section - Sheet section within which this item will be displayed.
	 */
	async prepareItem(item, context, section) {
		context.activities = item.system.activities?.map(this.prepareActivity.bind(this));

		context.buttons ??= [];
		context.dataset ??= {};
		if ((item.system.activities?.size || item.transferredEffects.length) && section.tab === "features")
			context.buttons.push({
				action: "enable",
				classes: "status",
				disabled: !item.isOwner,
				label: "BF.Feature.Enabled",
				pressed: item.enabled,
				title: `BF.Feature.${item.enabled ? "Enabled" : "Disabled"}`,
				icon: `<i class="fa-regular ${item.enabled ? "fa-square-check" : "fa-square"}"></i>`
			});

		if (this.expanded.has(item.id)) context.expanded = await item.getSummaryContext({ secrets: this.actor.isOwner });

		context.canDelete = section.options?.canDelete !== false;
		context.canDuplicate = section.options?.canDuplicate !== false;

		const totalWeight = await item.system.totalWeight;
		context.weight = totalWeight
			? formatWeight(totalWeight.toNearest(0.1), item.system.weight.units, { unitDisplay: "short" })
			: "â€”";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare various traits that might be displayed on the actor's sheet.
	 * @param {object} context - Context object for rendering the sheet. **Will be mutated.**
	 */
	async prepareTraits(context) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _renderOuter() {
		const jQuery = await super._renderOuter();

		// Adjust header button HTML to allow for more precise styling
		for (const button of jQuery[0].querySelectorAll(".header-button")) {
			let content = "";
			for (const node of button.childNodes) {
				if (node instanceof Text) {
					if (!node.textContent.trim().replaceAll("\n", "")) content += node.textContent;
					else {
						content += `<span>${node.textContent}</span>`;
						button.dataset.tooltip = node.textContent.trim();
						button.setAttribute("aria-label", node.textContent.trim());
					}
				} else content += node.outerHTML;
			}
			button.innerHTML = content;
		}

		return jQuery;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		NotificationTooltip.activateListeners(this.actor, html);

		for (const element of html.querySelectorAll(".item-tooltip")) this._applyItemTooltip(element);

		for (const element of html.querySelectorAll("[data-action]")) {
			element.addEventListener("click", this._onAction.bind(this));
			element.addEventListener("contextmenu", event => {
				if (event.ctrlKey) this._onAction(event);
			});
		}

		// Hit Points
		for (const element of html.querySelectorAll('[name$=".hp.value"]')) {
			element.addEventListener("change", this._onChangeHP.bind(this));
		}

		if (!this.modes.editing) {
			for (const element of html.querySelectorAll(".profile")) {
				element.addEventListener("click", this._onShowArtwork.bind(this));
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add tooltips to inventory items.
	 * @param {HTMLElement} element - The element to get a tooltip.
	 * @protected
	 */
	_applyItemTooltip(element) {
		if ("tooltip" in element.dataset) return;

		const target = element.closest("[data-item-id], [data-effect-id], [data-uuid]");
		let { uuid, effectId, itemId, parentId } = target?.dataset ?? {};
		if (!uuid && itemId) uuid = this.actor.items.get(itemId)?.uuid;
		else if (!uuid && effectId) {
			const collection = parentId ? this.actor.items.get(parentId)?.effects : this.actor.effects;
			uuid = collection.get(effectId)?.uuid;
		}
		if (!uuid) return;

		element.dataset.tooltip = `<section class="loading" data-uuid="${uuid}"></section>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_disableFields(form) {
		super._disableFields(form);
		for (const button of form.querySelectorAll('[data-action="expand"], [data-action="view"]')) {
			button.disabled = false;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a click on an action link.
	 * @param {ClickEvent} event - Triggering click event.
	 * @param {DOMStringMap} [dataset] - Dataset to use instead of that of the event target.
	 * @returns {Promise}
	 */
	async _onAction(event, dataset) {
		const { action, subAction, ...properties } = dataset ?? event.currentTarget.dataset;
		switch (action) {
			case "condition":
				const condition = event.target.closest("[data-condition]")?.dataset.condition;
				switch (subAction) {
					case "add":
						this.modes.conditionAdd = !this.modes.conditionAdd;
						return this.render();
					case "delete":
						return this.actor.system.setConditionLevel(condition);
					case "set-level":
						this.modes.conditionAdd = false;
						return this.actor.system.setConditionLevel(condition, Number(properties.level));
				}
				break;
			case "config":
				const options = { document: this.actor, selectedId: properties.key };
				switch (properties.type) {
					case "ability":
						return new AbilityConfig(options).render({ force: true });
					case "armor-class":
						return new ArmorClassConfig(options).render({ force: true });
					case "health":
						return new HealthConfig(options).render({ force: true });
					case "initiative":
						return new InitiativeConfig(options).render({ force: true });
					case "language":
						return new LanguageConfig(options).render({ force: true });
					case "luck":
						return new LuckConfig(options).render({ force: true });
					case "movement":
						return new MovementConfig(options).render({ force: true });
					case "proficiency":
						return new ProficiencyConfig(options).render({ force: true });
					case "resistance":
						return new ResistanceConfig(options).render({ force: true });
					case "senses":
						return new SensesConfig(options).render({ force: true });
					case "skill":
						return new SkillConfig(options).render({ force: true });
					case "tool":
						return new ToolConfig(options).render({ force: true });
					case "type":
						return new TypeConfig(options).render({ force: true });
					case "vehicle":
						return new ToolConfig({ ...options, trait: "vehicles" }).render({ force: true });
				}
				break;
			case "effect":
				return BlackFlagActiveEffect.onEffectAction.bind(this)(event);
			case "item":
				const itemId = properties.itemId ?? event.target.closest("[data-item-id]")?.dataset.itemId;
				const item = this.actor.items.get(itemId);
				switch (subAction) {
					case "delete":
						return item?.deleteDialog();
					case "edit":
					case "view":
						return item?.sheet.render(true);
				}
				break;
			case "rest":
				return this.actor.rest({ type: properties.type });
			case "roll":
				properties.event = event;
				return this.actor.roll(subAction, properties);
			case "toggle-mode":
				this.modes[properties.type] = !this.modes[properties.type];
				return this.render();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle changes to the HP and damage on character sheets.
	 * @param {Event} event - Triggering event.
	 * @returns {Promise}
	 */
	async _onChangeHP(event) {
		event.stopPropagation();
		let value = event.target.value.trim();
		let delta;
		if (value.startsWith("+") || value.startsWith("-")) delta = parseInt(value);
		else {
			if (value.startsWith("=")) value = value.slice(1);
			delta = parseInt(value) - foundry.utils.getProperty(this.actor, event.target.name);
		}

		const changed = await this.actor.applyDamage(delta, { multiplier: -1 });
		if (!changed) event.target.value = foundry.utils.getProperty(this.actor, event.target.name);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_onEditImage(event) {
		const attr = event.currentTarget.dataset.edit;
		const current = foundry.utils.getProperty(this.object, attr);
		const { img } = this.document.constructor.getDefaultArtwork?.(this.document.toObject()) ?? {};
		const fp = new FilePicker({
			current,
			type: "image",
			redirectToRoot: img ? [img] : [],
			callback: path => {
				event.currentTarget.src = path;
				if (this.options.submitOnChange) return this._onSubmit(event, { updateData: { [attr]: path } });
			},
			top: this.position.top + 40,
			left: this.position.left + 10,
			document: this.document
		});
		return fp.browse();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle showing the actor's portrait or token artwork.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	_onShowArtwork(event) {
		const path = event.target.src;
		new ImagePopout(path, { title: this.actor.name, uuid: this.actor.uuid }).render(true);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _updateObject(event, formData) {
		const updates = foundry.utils.expandObject(formData);

		// Preserve item updates to send to items
		const itemUpdates = Object.entries(updates.item ?? {}).map(([_id, data]) => {
			return { _id, ...data };
		});
		delete updates.item;

		await super._updateObject(event, foundry.utils.flattenObject(updates));
		await this.actor.updateEmbeddedDocuments("Item", itemUpdates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onDrop(event) {
		const { data } = DragDrop$1.getDragData(event);

		// TODO: Handle folders
		// Forward dropped effects to the effects element
		if (data.type === "ActiveEffect") {
			if (Hooks.call("dropActorSheetData", this.actor, this, data) === false) return;
			EffectsElement.dropEffects(event, this.actor, [await ActiveEffect.implementation.fromDropData(data)]);
			return;
		}

		// Forward dropped items to the inventory element
		else if (data.type === "Item") {
			if (Hooks.call("dropActorSheetData", this.actor, this, data) === false) return;
			InventoryElement.dropItems(event, this.actor, [await Item.implementation.fromDropData(data)]);
			return;
		}

		super._onDrop(event);
	}
}

/**
 * Base sheet for handling sheets in the stat block-style.
 */
class BaseStatblockSheet extends BaseActorSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			dragDrop: [{ dragSelector: "[data-item-id]" }],
			width: 460,
			height: null,
			tabs: [
				{ group: "primary", navSelector: 'nav[data-group="primary"]', contentSelector: ".sheet-body", initial: "main" }
			],
			scrollY: [".window-content"]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item types that will be displayed with full descriptions on the main tab of the NPC sheet.
	 * @type {Set<string>}
	 */
	static mainItemTypes = new Set(["feature", "weapon"]);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the uses for an item for display on the main tab.
	 * @param {BlackFlagItem} item - Item being displayed.
	 * @param {Activity} [activity] - Activity being highlighted.
	 * @returns {string}
	 */
	prepareUsesDisplay(item, activity) {
		const uses = item.system.uses ?? {};
		const parts = [];

		if (activity?.activation.type === "legendary" && activity.activation.value > 1) {
			const pluralRule = getPluralRules().select(activity.activation.value);
			parts.push(
				game.i18n.format(`BF.LegendaryAction.Cost[${pluralRule}]`, {
					count: numberFormat(activity.activation.value)
				})
			);
		}

		if (uses.max) {
			let label;
			let recharge;

			// If max is set and min is zero, display as "1 of 3"
			if (uses.min === 0) {
				label = game.i18n.format("BF.Uses.Display.Of", {
					value: numberFormat(uses.value),
					max: numberFormat(uses.max)
				});
			}

			// If min isn't zero, display just current value "1"
			else label = numberFormat(uses.value);

			// If only a single recovery formula that is Recharge
			if (uses.recovery.length === 1 && uses.recovery[0].period === "recharge") {
				if (uses.spent === 0 && uses.max === 1) label = game.i18n.localize("BF.Recovery.Recharge.Charged");
				else if (uses.max === 1) label = null;
				if (uses.spent > 0) {
					if (uses.recovery[0].formula === "6") recharge = game.i18n.localize("BF.Recovery.Recharge.Single");
					else recharge = game.i18n.format("BF.Recovery.Recharge.Range", { min: uses.recovery[0].formula });
				}
			}

			// If only a single recovery formula that recovers all uses is set, display "/SR" or "/Day"
			else if (uses.recovery.length === 1 && uses.recovery[0].type === "recoverAll") {
				const config = CONFIG.BlackFlag.recoveryPeriods[uses.recovery[0].period];
				const abbreviation = game.i18n.localize(config?.npcLabel ?? config?.abbreviation);
				if (abbreviation) label = game.i18n.format("BF.Uses.Display.Recovery", { value: label, period: abbreviation });
			}

			parts.push(label, recharge);
		}

		return game.i18n.getListFormatter({ type: "unit" }).format(parts.filter(p => p));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareActions(context) {
		context.actions = Object.entries(CONFIG.BlackFlag.actionTypes.localized).reduce((obj, [key, label]) => {
			obj[key] = { label, items: [] };
			return obj;
		}, {});
		context.actions.other = { label: game.i18n.localize("BF.ACTIVATION.Type.Other"), items: [] };
		context.passive = [];
		context.spellcasting = { uses: {} };
		for (const item of this.actor.items) {
			if (item.type === "spell") {
				const uses = item.system.uses;
				const key = !uses.max ? "atwill" : `${uses.max}-${uses.recovery[0]?.period ?? ""}`;
				context.spellcasting.uses[key] ??= { spells: [] };
				context.spellcasting.uses[key].spells.push(item);
			} else if (this.constructor.mainItemTypes.has(item.type)) {
				const activities = Array.from(item.system.activities ?? []);
				const onlyActivity = activities.length === 1 ? activities[0] : undefined;
				const actionTypes = new Set(activities.map(a => a.actionType));
				const firstActionType = actionTypes.first();
				const data = {
					activity: onlyActivity,
					item,
					description: await TextEditor.enrichHTML(item.system.description.value, {
						secrets: false,
						rollData: item.getRollData(),
						async: true,
						relativeTo: item
					}),
					uses: this.prepareUsesDisplay(item, onlyActivity)
				};
				if (actionTypes.has("action")) context.actions.action.items.push(data);
				else if (firstActionType === "free" || !actionTypes.size) context.passive.push(data);
				else if (firstActionType in context.actions) context.actions[firstActionType].items.push(data);
				else context.actions.other.items.push(data);
			}
		}

		await this.prepareSpellcasting(context);

		// Sorting & Clearing
		context.passive.sort((lhs, rhs) => lhs.item.sort - rhs.item.sort);
		for (const [key, value] of Object.entries(context.actions)) {
			if (!value.items.length && (key !== "action" || !context.spellcasting)) delete context.actions[key];
			else context.actions[key].items.sort((lhs, rhs) => (lhs.item?.sort ?? Infinity) - (rhs.item?.sort ?? Infinity));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the spellcasting section of the sheet.
	 * @param {object} context - Context object for rendering the sheet. **Will be mutated.**
	 */
	async prepareSpellcasting(context) {
		const spellcasting = context.system.spellcasting;
		if (!spellcasting || foundry.utils.isEmpty(context.spellcasting.uses)) {
			delete context.spellcasting;
			return;
		}

		let ability;
		let dc;
		if (context.editable) {
			ability = `<select name="system.spellcasting.ability">${HandlebarsHelpers.selectOptions(
				CONFIG.BlackFlag.abilities.localized,
				{ hash: { selected: spellcasting.ability } }
			)}</select>`;
			dc = `<input type="number" name="system.spellcasting.dc" value="${context.source.spellcasting.dc}"
			       placeholder="${spellcasting.autoDC}" step="1" min="0">`;
		} else {
			ability = CONFIG.BlackFlag.abilities.localizedAbbreviations[spellcasting.ability];
			dc = spellcasting.dc;
		}
		context.spellcasting.label = game.i18n.format("BF.Spellcasting.NPC.Description", {
			ability,
			dc,
			name: this.actor.name.toLowerCase()
		});

		const sections = [];
		for (const [, value] of Object.entries(context.spellcasting.uses).sort((a, b) => b[0].localeCompare(a[0]))) {
			const uses = value.spells[0].system.uses;
			if (uses.max) {
				const config = CONFIG.BlackFlag.recoveryPeriods[uses.recovery[0]?.period];
				const abbreviation = game.i18n.localize(config?.npcLabel ?? config?.abbreviation);
				if (abbreviation)
					value.label = game.i18n.format("BF.Uses.Display.Recovery", {
						value: numberFormat(uses.max),
						period: abbreviation.toLowerCase()
					});
				else value.label = numberFormat(uses.max);
			} else {
				value.label = game.i18n.localize("BF.Spell.Preparation.Mode.AtWill");
			}
			const spells = [];
			for (const spell of value.spells.sort((lhs, rhs) => lhs.name.localeCompare(rhs.name, game.i18n.lang))) {
				const usesRemaining = uses.max
					? ` <span class="remaining">${numberFormat(spell.system.uses.value)}</span>`
					: "";
				spells.push(
					`<span class="spell"><a data-action="activate" data-item-id="${spell.id}">${spell.name.toLowerCase()}</a>${usesRemaining}</span>`
				);
			}
			sections.push(`<p>${value.label}: ${spells.join(", ")}`);
		}

		context.spellcasting.description = `<p class="description">${context.spellcasting.label}</p>${sections.join("\n")}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareTraits(context) {
		context.traits = {};
		const none = game.i18n.localize("None");

		// Search through active effects for any that apply to traits
		const validKeyPaths = new Set([
			"system.traits.damage.resistances.value",
			"system.traits.damage.resistances.nonmagical",
			"system.traits.condition.resistances.value",
			"system.traits.damage.immunities.value",
			"system.traits.damage.immunities.nonmagical",
			"system.traits.condition.immunities.value",
			"system.traits.damage.vulnerabilties.value",
			"system.traits.damage.vulnerabilties.nonmagical",
			"system.traits.condition.vulnerabilities.value"
		]);
		const associatedEffects = [];
		for (const effect of this.actor.allApplicableEffects()) {
			if (effect.disabled) continue;
			const data = { effect };
			for (const change of effect.changes) {
				if (validKeyPaths.has(change.key)) {
					data[change.key] ??= [];
					data[change.key].push(change.value);
				}
			}
			if (Object.values(data).length > 1) associatedEffects.push(data);
		}

		for (const name of ["resistances", "immunities", "vulnerabilities"]) {
			const damage = { ...foundry.utils.getProperty(context.source, `traits.damage.${name}`) };
			damage.value = new Set(damage.value ?? []);
			damage.nonmagical = new Set(damage.nonmagical ?? []);
			const condition = { ...foundry.utils.getProperty(context.source, `traits.condition.${name}`) };
			condition.value = new Set(condition.value ?? []);
			this.actor.system.cleanLabelResistances(condition, damage);
			const sections = [damage.label.toLowerCase(), condition.label.toLowerCase()].filter(t => t);

			for (const effect of associatedEffects) {
				const damage = {
					value: new Set(effect[`system.traits.damage.${name}.value`] ?? []),
					nonmagical: new Set(effect[`system.traits.damage.${name}.nonmagical`] ?? [])
				};
				const condition = { value: new Set(effect[`system.traits.condition.${name}.value`] ?? []) };
				this.actor.system.cleanLabelResistances(condition, damage);
				const effectSections = [damage.label.toLowerCase(), condition.label.toLowerCase()].filter(t => t);
				if (effectSections.length) {
					sections.push(`<span data-tooltip="${effectSections.join(" | ")}">${effect.effect.name}</span>`);
				}
			}

			if (sections.length || this.modes.editing) context.traits[name] = sections.join(" | ") || none;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove the title from the app's header bar.
	 * @param {HTMLElement} element - Element of the app's window.
	 * @protected
	 */
	_removeTitle(element) {
		const title = element.querySelector(".window-header .window-title");
		const textSource = title.querySelector(".title-text") ?? title;
		const idLink = title.querySelector(".document-id-link");
		title.innerHTML = `<span class="title-text">${textSource.innerText}</span>`;
		title.appendChild(idLink);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _renderOuter() {
		const jQuery = await super._renderOuter();
		this._removeTitle(jQuery[0]);
		return jQuery;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_replaceHTML(element, html) {
		super._replaceHTML(element, html);
		this._removeTitle(element[0]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onAction(event, dataset) {
		const { action } = dataset ?? event.currentTarget.dataset;
		switch (action) {
			case "add-feature":
				const features = this.element[0].querySelector('blackflag-inventory[tab="features"]');
				const section = features?.querySelector('[data-section="features"]');
				return features?._onAddItem(section);
		}
		return super._onAction(event, dataset);
	}
}

/**
 * Dialog that presents a list of class, subclass, lineage, heritage, or background options for the player to choose.
 */
class ConceptSelectionDialog extends BFApplication {
	// constructor(type, options = {}) {
	// 	super(options);
	// 	this.options.classes.push(type);
	// }

	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			choose: ConceptSelectionDialog.#chooseConcept
		},
		classes: ["concept-selection-dialog"],
		details: {
			classIdentifier: null,
			multiclass: false,
			type: null
		},
		position: {
			width: "auto",
			height: "auto"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		class: {
			template: "systems/black-flag/templates/actor/concept-selection-dialog-class.hbs"
		},
		other: {
			template: "systems/black-flag/templates/actor/concept-selection-dialog-other.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor to which the item will be applied.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.options.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get title() {
		return game.i18n.format("BF.ConceptSelection.Title", {
			type: game.i18n.localize(CONFIG.Item.typeLabels[this.type])
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Type of item to be selected by this dialog.
	 * @type {string}
	 */
	get type() {
		return this.options.details.type;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_configureRenderOptions(options) {
		super._configureRenderOptions(options);
		if (this.type === "class") options.parts = ["class"];
		else options.parts = ["other"];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onFirstRender(context, options) {
		super._onFirstRender(context, options);
		this.element.classList.add(this.type);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);

		context.choices = await Promise.all(
			Object.values(CONFIG.BlackFlag.registration.list(this.type) ?? {}).map(o => this.getOptionData(o))
		);
		if (this.type === "class") {
			const existingClasses = new Set(Object.keys(this.actor.system.progression.classes));
			context.choices = context.choices.filter(choice => !existingClasses.has(choice.document.identifier));
		} else if (this.type === "subclass")
			context.choices = context.choices.filter(
				choice => choice.document.system.identifier.class === this.options.details.classIdentifier
			);
		context.type = this.type;
		context.typeName = game.i18n.localize(CONFIG.Item.typeLabels[this.type]).toLowerCase();
		context.typeNamePlural = game.i18n.localize(CONFIG.Item.typeLabelsPlural[this.type]).toLowerCase();

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the data for individual options.
	 * @param {object} option - Registration information for this option.
	 * @returns {object}
	 */
	async getOptionData(option) {
		const doc = await fromUuid(option.sources[option.sources.length - 1]);
		const optionContext = {
			document: doc,
			enriched: {
				description: await TextEditor.enrichHTML(doc.system.description.short, { secrets: false, async: true })
			},
			system: doc.system
		};

		if (this.type === "class" && this.options.details.multiclass) {
			const abilities = this.actor.system.abilities;
			const keyAbilityOptions = doc.system.advancement.byType("keyAbility")[0]?.configuration.options;
			const validAbilities = Array.from(keyAbilityOptions).some(
				a => (abilities[a]?.value ?? 0) >= CONFIG.BlackFlag.multiclassingAbilityThreshold
			);
			if (!validAbilities) {
				const pluralRule = getPluralRules().select(keyAbilityOptions.size);
				optionContext.multiclassMessage = game.i18n.format(
					`BF.Progression.Warning.InsufficientSecondaryScore[${pluralRule}]`,
					{
						ability: game.i18n
							.getListFormatter({ type: "disjunction" })
							.format(keyAbilityOptions.map(a => CONFIG.BlackFlag.abilities.localized[a])),
						class: doc.name,
						threshold: numberFormat(CONFIG.BlackFlag.multiclassingAbilityThreshold)
					}
				);
			}
		}

		return optionContext;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle choosing an option.
	 * @this {ConceptSelectionDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #chooseConcept(event, target) {
		const uuid = event.target.closest("[data-uuid]").dataset.uuid;
		const document = await fromUuid(uuid);
		await this.close();
		if (this.type === "class") await this.actor.system.levelUp(document);
		else if (this.type === "subclass") await this.actor.createEmbeddedDocuments("Item", [document.toObject()]);
		else await this.actor.system.setConcept(document);
	}
}

class LairSheet extends BaseActorSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "actor", "sheet", "lair"],
			dragDrop: [{ dragSelector: "[data-item-id]" }],
			width: 520,
			height: null,
			scrollY: [".window-content"]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static enrichedFields = {
		description: "system.description.value",
		lairActions: "system.description.lairActions",
		regionalEffects: "system.description.regionalEffects",
		conclusion: "system.description.conclusion"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareItem(item, context, section) {
		await super.prepareItem(item, context, section);
		context.activity = item.system.activities.find(a => a.activation.primary) ?? item.system.activities.contents[0];
		context.description = await TextEditor.enrichHTML(item.system.description.value, {
			relativeTo: item,
			rollData: item.getRollData(),
			secrets: false,
			async: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getHeaderButtons() {
		const buttons = super._getHeaderButtons();
		if (this.actor.isOwner && !this.actor.pack) {
			buttons.splice(buttons.findIndex(b => b.class === "toggle-editing-mode") + 1, 0, {
				label: "BF.Initiative.Action.Enter",
				class: "initiative",
				icon: "fa-solid fa-bolt",
				onclick: () => this.actor.configureInitiativeRoll()
			});
		}
		return buttons;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async activateEditor(name, options = {}, initialContent = "") {
		options.relativeLinks = true;
		options.plugins = {
			menu: ProseMirror.ProseMirrorMenu.build(ProseMirror.defaultSchema, {
				compact: true,
				destroyOnSave: true,
				onSave: () => this.saveEditor(name, { remove: true })
			})
		};
		return super.activateEditor(name, options, initialContent);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onAction(event, dataset) {
		const { action, type } = dataset ?? event.currentTarget.dataset;
		switch (action) {
			case "add":
				Item.implementation.createDialog(
					{ "system.type.category": "monsters", "system.type.value": type },
					{ parent: this.actor, pack: this.actor.pack, types: ["feature"] }
				);
				return;
		}
		return super._onAction(event, dataset);
	}
}

/**
 * Dialog that gives the open of increasing a current class or multi-classing into a new one.
 */
class LevelUpDialog extends BFApplication {
	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			choose: LevelUpDialog.#chooseOption
		},
		classes: ["level-up-dialog"],
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/actor/level-up-dialog.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor to which the level up will be applied.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.options.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get title() {
		return `${game.i18n.localize("BF.Progression.Action.LevelUp.Label")} ${this.actor.name}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);

		context.system = this.actor.system;
		const primaryClass = this.actor.system.progression.levels[1].class;
		const abilityValue = this.actor.system.abilities[primaryClass.system.keyAbility]?.value ?? 0;
		if (abilityValue < CONFIG.BlackFlag.multiclassingAbilityThreshold) {
			context.multiclassMessage = game.i18n.format("BF.Progression.Warning.InsufficientPrimaryScore", {
				ability: CONFIG.BlackFlag.abilities.localized[primaryClass.system.keyAbility],
				threshold: numberFormat(CONFIG.BlackFlag.multiclassingAbilityThreshold),
				value: numberFormat(abilityValue)
			});
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle choosing an option.
	 * @this {LevelUpDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #chooseOption(event, target) {
		const classIdentifier = target.closest("[data-class]")?.dataset.class;
		const cls = this.actor.system.progression.classes[classIdentifier]?.document;
		await this.close();
		if (cls) {
			try {
				this.actor.system.levelUp(cls);
			} catch (err) {
				ui.notifications.warn(err.message);
			}
		} else {
			new ConceptSelectionDialog({ document: this.actor, details: { multiclass: true, type: "class" } }).render({
				force: true
			});
		}
	}
}

/**
 * Configuration application for setting NPC spellcasting details and spell uses.
 */
class NPCSpellcastingConfig extends BaseConfigSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["npc-spellcasting", "form-list"],
		position: {
			width: 450
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		details: {
			template: "systems/black-flag/templates/actor/config/npc-spellcasting-config-details.hbs"
		},
		spells: {
			template: "systems/black-flag/templates/actor/config/npc-spellcasting-config-spells.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.format("BF.Action.Configure.Specific", { type: game.i18n.localize("BF.Spellcasting.Label") });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "spells":
				return this._prepareSpellsContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the config section.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareSpellsContext(context, options) {
		context.periodOptions = Object.entries(CONFIG.BlackFlag.recoveryPeriods)
			.filter(([, v]) => !v.combatOnly)
			.map(([value, { label }]) => ({ value, label }));
		context.spells = this.document.items.reduce((arr, item) => {
			if (item.type === "spell") {
				arr.push({
					id: item.id,
					name: item.name,
					uses: item._source.system.uses.max,
					period: item.system.uses.recovery[0]?.period
				});
			}
			return arr;
		}, []);
		context.spells.sort((lhs, rhs) => lhs.name.localeCompare(rhs.name, game.i18n.lang));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_prepareSubmitData(event, form, formData) {
		const submitData = this._processFormData(event, form, formData);
		return submitData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _processSubmitData(event, form, { spell, ...submitData }) {
		await super._processSubmitData(event, form, submitData);

		const spellUpdates = [];
		for (const [_id, { uses, period }] of Object.entries(spell)) {
			const update = { _id };
			const spell = this.document.items.get(_id);
			const activities = spell.system.activities.filter(a => a.activation?.primary);
			if (period) {
				update["system.uses.max"] = uses ?? "";
				update["system.uses.recovery"] = [{ period }];
				activities.forEach(a => {
					update[`system.activities.${a.id}.consumption.targets`] = [{ type: "item" }];
				});
			} else {
				update["system.uses.max"] = "";
				update["system.uses.recovery"] = [];
				activities.forEach(a => {
					update[`system.activities.${a.id}.consumption.targets`] = [];
				});
			}
			spellUpdates.push(update);
		}
		await this.document.updateEmbeddedDocuments("Item", spellUpdates);
	}
}

class NPCSheet extends BaseStatblockSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "actor", "sheet", "npc", "statblock"]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static enrichedFields = {
		biography: "system.biography.value"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.cr = formatCR(context.system.attributes.cr);

		context.labels = {
			sizeAndType: `${game.i18n.localize(CONFIG.BlackFlag.sizes[context.system.traits.size]?.label ?? "")} ${
				context.system.traits.type.label
			}`
		};

		context.placeholders = {
			perception: 10 + (context.system.abilities.wisdom?.mod ?? 0),
			stealth: 10 + (context.system.abilities.dexterity?.mod ?? 0)
		};

		context.stealthLabel = numberFormat(context.system.attributes.stealth);
		if (context.system.attributes.baseStealth)
			context.stealthLabel = game.i18n.format("BF.Armor.StealthReduction", {
				reduced: context.stealthLabel,
				full: numberFormat(context.system.attributes.baseStealth)
			});

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareActions(context) {
		await super.prepareActions(context);

		// Legendary Actions
		if (context.actions.legendary) {
			const leg = context.system.attributes.legendary;
			context.actions.legendary.count = {
				prefix: "system.attributes.legendary",
				value: leg.value ?? 0,
				max: context.editable ? leg.max ?? 0 : context.source.attributes.legendary.max
			};
			context.actions.legendary.description = game.i18n.format(
				`BF.LegendaryAction.Description[${getPluralRules().select(context.system.attributes.legendary.max)}]`,
				{ type: context.actor.name.toLowerCase(), count: context.system.attributes.legendary.max }
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareTraits(context) {
		super.prepareTraits(context);
		const { proficiencies } = context.system;
		context.traits.speed = this.actor.system.traits.movement.label?.toLowerCase() || "â€”";
		context.traits.senses = this.actor.system.traits.senses.label?.toLowerCase() || "â€”";
		context.traits.languages = proficiencies.languages.label || "â€”";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getHeaderButtons() {
		const buttons = super._getHeaderButtons();
		if (this.actor.isOwner && !game.packs.get(this.actor.pack)?.locked) {
			buttons.splice(
				buttons.findIndex(b => b.class === "toggle-editing-mode") + 1,
				0,
				{
					label: "BF.Rest.Type.Short.Label",
					class: "short-rest",
					icon: "fa-solid fa-utensils",
					onclick: () => this.actor.shortRest()
				},
				{
					label: "BF.Rest.Type.Long.Label",
					class: "long-rest",
					icon: "fa-solid fa-campground",
					onclick: () => this.actor.longRest()
				}
			);
		}
		return buttons;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getSubmitData(updateData = {}) {
		const data = super._getSubmitData(updateData);

		// TODO: Convert to custom NumberField
		if ("system.attributes.cr" in data) {
			let cr = data["system.attributes.cr"];
			cr =
				{
					"": null,
					"-": null,
					"1/8": 0.125,
					"â…›": 0.125,
					"1/4": 0.25,
					"Â¼": 0.25,
					"1/2": 0.5,
					"Â½": 0.5
				}[cr] ?? parseFloat(cr);
			if (Number.isNaN(cr)) cr = null;
			else if (cr > 1) cr = parseInt(cr);
			data["system.attributes.cr"] = cr;
		}

		if ("system.attributes.legendary.value" in data)
			data["system.attributes.legendary.spent"] =
				this.actor.system.attributes.legendary.max - parseInt(data["system.attributes.legendary.value"]);

		return data;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onAction(event, dataset) {
		const { action, ...properties } = dataset ?? event.currentTarget.dataset;
		switch (action) {
			case "config":
				switch (properties.type) {
					case "spellcasting":
						return new NPCSpellcastingConfig({ document: this.actor }).render({ force: true });
				}
		}
		return super._onAction(event, dataset);
	}
}

class PCSheet extends BaseActorSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "actor", "sheet", "pc"],
			width: 820,
			height: 880,
			tabs: [
				{ group: "primary", navSelector: 'nav[data-group="primary"]', contentSelector: ".sheet-body", initial: "main" }
			],
			scrollY: [".window-content"]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static enrichedFields = {
		backstory: "system.biography.backstory",
		motivation: "system.biography.motivation",
		allies: "system.biography.allies"
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Advancement flows currently displayed on the sheet.
	 * @type {[key: string]: AdvancementFlow}
	 */
	advancementFlows = {};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	modes = {
		editing: false,
		progression: false
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		if (this.modes.progression) this.prepareProgression(context);

		context.canResetAbilityAssignment =
			context.editable && (game.settings.get("black-flag", "abilitySelectionManual") || game.user.isGM);
		context.displayXPBar = game.settings.get(game.system.id, "levelingMode") === "xp";
		context.luckPoints = Array.fromRange(CONFIG.BlackFlag.luck.max, 1).map(l => ({
			selected: context.system.attributes.luck.value >= l
		}));

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareSpecialActions(actions) {
		actions.other.activities.push({
			name: "BF.Rest.Type.Short.Label",
			label: "BF.Rest.Action.Rest.Label",
			dataset: { action: "rest", type: "short" }
		});
		actions.other.activities.push({
			name: "BF.Rest.Type.Long.Label",
			label: "BF.Rest.Action.Rest.Label",
			dataset: { action: "rest", type: "long" }
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareItem(item, context, section) {
		await super.prepareItem(item, context, section);

		if (item.type === "spell") {
			const { alwaysPrepared, mode } = item.getFlag("black-flag", "relationship") ?? {};
			const ritual = item.system.tags.has("ritual");
			const always = (alwaysPrepared && item.system.alwaysPreparable) || ritual;
			const pressed = always || item.system.prepared;
			if (always || item.system.preparable)
				context.buttons.push({
					action: "prepare",
					classes: "status fade",
					disabled: !item.isOwner || always,
					label: "BF.Spell.Preparation.Prepared",
					pressed,
					title: `BF.Spell.Preparation.${always ? "Always" : !item.system.prepared ? "Not" : ""}Prepared`,
					icon: `<i class="fa-${pressed ? "solid" : "regular"} fa-${
						ritual ? "atom" : always ? "bahai" : "sun"
					}" inert></i>`
				});
			context.dataset.spellType = mode;
			if (item.system.prepared && !ritual) context.dataset.spellPrepared = "";
			if (alwaysPrepared) context.dataset.spellAlwaysPrepared = "";
			if (item.system.tags.size) context.dataset.properties = Array.from(item.system.tags).join(" ");
		}

		if (item.system.attunable)
			context.buttons.push({
				action: "attune",
				classes: "status fade",
				disabled: !item.isOwner,
				label: "BF.Attunement.Attuned",
				pressed: item.system.attuned,
				title: `BF.Attunement.${item.system.attuned ? "Attuned" : "NotAttuned"}`,
				icon: '<i class="fa-solid fa-sun" inert></i>'
			});

		if (item.system.equippable)
			context.buttons.push({
				action: "equip",
				classes: "status fade",
				disabled: !item.isOwner,
				label: "BF.Item.Equipped",
				pressed: item.system.equipped,
				title: `BF.Item.${item.system.equipped ? "Equipped" : "Unequipped"}`,
				icon: '<i class="fa-solid fa-shield-halved" inert></i>'
			});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare levels on the progression tab and assign them advancement flows.
	 * @param {object} context - Context being prepared.
	 */
	async prepareProgression(context) {
		context.progressionLevels = [];
		const flowIds = new Set(Object.keys(this.advancementFlows));

		const levels = [{ levels: { character: 0, class: 0 } }, ...Object.values(context.system.progression.levels)];
		for (let data of levels.reverse()) {
			const level = data.levels.character;
			const levelData = {
				number: level,
				...data,
				class: data.class,
				flows: [],
				highestLevel: level !== 0 && level === context.system.progression.level
			};

			for (const advancement of this.actor.advancementForLevel(level)) {
				const id = `${advancement.item.id}.${advancement.id}#${level}`;
				const flow = (this.advancementFlows[id] ??= advancement.flow(this.actor, data.levels));
				flowIds.delete(id);
				levelData.flows.push(flow);
			}

			context.progressionLevels.push(levelData);
		}

		// Remove any flows that no longer have associated advancements
		flowIds.forEach(id => delete this.advancementFlows[id]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareTraits(context) {
		context.traits = [];
		const { traits, proficiencies } = context.system;
		const none = game.i18n.localize("None");

		// Size
		const size = CONFIG.BlackFlag.sizes[traits.size];
		if (size || this.modes.editing)
			context.traits.push({
				key: "size",
				classes: "single",
				label: "BF.Size.Label",
				value: size ? game.i18n.localize(size.label) : none,
				config: "type"
			});

		// Creature Type
		const type = CONFIG.BlackFlag.creatureTypes[traits.type.value];
		if (type || this.modes.editing)
			context.traits.push({
				key: "type",
				classes: "single",
				label: "BF.CreatureType.Type.Label",
				value: traits.type.label,
				config: "type"
			});

		// Movement
		const movement = game.i18n.getListFormatter({ style: "narrow" }).format(traits.movement.labels);
		if (movement || this.modes.editing)
			context.traits.push({
				key: "movement",
				classes: traits.movement.labels.length > 1 ? null : "single",
				label: "BF.Speed.Label",
				value: movement,
				config: "movement"
			});

		// Senses
		const senses = this.actor.system.traits.senses.label;
		if (senses || this.modes.editing)
			context.traits.push({
				key: "senses",
				label: "BF.SENSES.Label[other]",
				value: senses || none,
				config: "senses"
			});

		// Languages
		context.traits.push({
			key: "languages",
			label: "BF.Language.Label[other]",
			value: proficiencies.languages.label || none,
			config: "language"
		});

		// Armor
		context.traits.push({
			key: "armor",
			label: "BF.Armor.Label[other]",
			value: localizedList(proficiencies.armor.value, [], { style: "short", trait: "armor" }) || none,
			config: "proficiency"
		});

		// Weapons
		context.traits.push({
			key: "weapons",
			label: "BF.WEAPON.Label[other]",
			value: localizedList(proficiencies.weapons.value, [], { style: "short", trait: "weapons" }) || none,
			config: "proficiency"
		});

		const prepareResistance = (key, label) => {
			const traits = context.system.traits;
			const value = [traits.damage[key].label, traits.condition[key].label].filter(t => t).join(" | ");
			if (!value && !this.modes.editing) return;
			context.traits.push({
				key,
				label,
				value: value || game.i18n.localize("None"),
				config: "resistance"
			});
		};
		prepareResistance("resistances", game.i18n.localize("BF.Resistance.Label"));
		prepareResistance("immunities", game.i18n.localize("BF.Immunity.Label"));
		prepareResistance("vulnerabilities", game.i18n.localize("BF.Vulnerability.Label"));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _render(force, options) {
		await super._render(force, options);
		if (this._state !== Application.RENDER_STATES.RENDERED || !this.modes.progression) return;

		// Render advancement steps
		for (const flow of Object.values(this.advancementFlows)) {
			flow._element = null;
			// TODO: Some sort of race condition here when advancement is being applied
			await flow._render(true, options);
		}

		this.setPosition();
		if (this.options.scrollY) this._restoreScrollPositions(this.element);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onAction(event, dataset) {
		const { action, subAction, ...properties } = dataset ?? event.currentTarget.dataset;
		switch (action) {
			case "luck":
				switch (subAction) {
					case "add":
						return this.actor.system.addLuck();
					case "remove":
						return this.actor.update({ "system.attributes.luck.value": this.actor.system.attributes.luck.value - 1 });
				}
				break;
			case "progression":
				switch (subAction) {
					case "reset-abilities":
						await this.actor.system.resetAbilities();
					case "assign-abilities":
						return new AbilityAssignmentDialog({ document: this.actor }).render({ force: true });
					case "level-down":
						return Dialog.confirm({
							title: `${game.i18n.localize("BF.Progression.Action.LevelDown.Label")}: ${this.actor.name}`,
							content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize(
								"BF.Progression.Action.LevelDown.Message"
							)}</p>`,
							yes: () => this.actor.system.levelDown()
						});
					case "level-up":
						const allowMulticlassing = game.settings.get(game.system.id, "allowMulticlassing");
						const cls = this.actor.system.progression.levels[1]?.class;
						if (cls) {
							if (allowMulticlassing) {
								return new LevelUpDialog({ document: this.actor }).render({ force: true });
							} else {
								try {
									return await this.actor.system.levelUp(cls);
								} catch (err) {
									return ui.notifications.warn(err.message);
								}
							}
						}
						properties.type = "class";
					case "select":
						if (!properties.type) return;
						const classIdentifier = event.target.closest("[data-class]")?.dataset.class;
						return new ConceptSelectionDialog({
							document: this.actor,
							details: { classIdentifier, type: properties.type }
						}).render({ force: true });
				}
				break;
		}
		return super._onAction(event, dataset);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_updateObject(event, formData) {
		const updates = foundry.utils.expandObject(formData);

		// Intercept updates to available hit dice
		const hdUpdates = foundry.utils.getProperty(updates, "system.attributes.hd.d");
		if (hdUpdates) {
			const hd = this.actor.system.attributes.hd;
			for (const [denomination, update] of Object.entries(hdUpdates)) {
				const d = hd.d[denomination];
				updates.system.attributes.hd.d[denomination].spent = Math.clamp(d.max - update.available, 0, d.max);
			}
		}

		// Intercept updates to available spell slots
		const slotUpdates = foundry.utils.getProperty(updates, "system.spellcasting.slots");
		if (slotUpdates) {
			const slots = this.actor.system.spellcasting.slots;
			for (const [slot, update] of Object.entries(slotUpdates)) {
				if ("value" in update) {
					const value = slots[slot];
					foundry.utils.setProperty(updates, `system.spellcasting.slots.${slot}.spent`, value.max - update.value);
				}
			}
		}

		return super._updateObject(event, foundry.utils.flattenObject(updates));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _onDropItem(event, data) {
		if (!this.actor.isOwner) return false;
		const item = await Item.implementation.fromDropData(data);
		const itemData = item.toObject();

		// Handle item sorting within the same Actor
		if (this.actor.uuid === item.parent?.uuid) return this._onSortItem(event, itemData);

		// Create the owned item
		return this._onDropItemCreate(event, item);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _onDropFolder(event, data) {
		if (!this.actor.isOwner) return [];
		const folder = await Folder.implementation.fromDropData(data);
		if (folder.type !== "Item") return [];
		const droppedItems = await Promise.all(
			folder.contents.map(async item => {
				if (!(document instanceof Item)) item = await fromUuid(item.uuid);
				return item;
			})
		);
		return this._onDropItemCreate(event, droppedItems);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a dropped item in place of normal handler in InventoryElement.
	 * @param {Event} event - Triggering drop event.
	 * @param {BlackFlagItem[]} items - Dropped items.
	 * @returns {BlackFlagItem[]|void} - Return any items that should continue through to InventoryElement for handling.
	 */
	async _handleDroppedItems(event, items) {
		if (!(items instanceof Array)) items = [items];

		const { classes, concepts, others } = items.reduce(
			(types, item) => {
				if (item.type === "class") types.classes.push(item);
				else if (["background", "heritage", "lineage"].includes(item.type)) types.concepts.push(item);
				else types.others.push(item);
				return types;
			},
			{ classes: [], concepts: [], others: [] }
		);

		// For classes, call level up method
		for (const cls of classes) {
			try {
				await this.actor.system.levelUp(cls);
			} catch (err) {
				ui.notifications.warn(err.message);
			}
		}

		// For concepts, use the set concept method
		for (const concept of concepts) {
			try {
				await this.actor.system.setConcept(concept);
			} catch (err) {
				ui.notifications.warn(err.message);
			}
		}

		// For normal items, create normally
		if (others.length) {
			return others;
		}
	}
}

/**
 * Sheet for siege weapon actors.
 */
class SiegeWeaponSheet extends BaseStatblockSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "actor", "sheet", "siege-weapon", "statblock"]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static enrichedFields = {
		description: "system.description.value"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.labels = {
			sizeAndType: `${game.i18n.localize(CONFIG.BlackFlag.sizes[context.system.traits.size]?.label ?? "")} ${game.i18n.localize(
				"BF.Object"
			)}`
		};

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareActions(context) {
		await super.prepareActions(context);
		for (const [key, { items }] of Object.entries(context.actions)) {
			context.passive.push(...items);
			delete context.actions[key];
		}
		context.passive.findSplice(d => d.item.identifier === "siege-weapon-resilience");
	}
}

/**
 * Sheet for vehicle actors.
 */
class VehicleSheet extends BaseStatblockSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "actor", "sheet", "vehicle", "statblock"]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static enrichedFields = {
		description: "system.description.value"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		const dimensions = game.i18n.format("BF.VEHICLE.Dimensions", {
			length: numberFormat(context.system.traits.dimensions.length, { unit: context.system.traits.dimensions.units }),
			width: numberFormat(context.system.traits.dimensions.width, { unit: context.system.traits.dimensions.units })
		});
		context.labels = {
			sizeAndType: `${game.i18n.localize(CONFIG.BlackFlag.sizes[context.system.traits.size]?.label ?? "")} ${
				CONFIG.BlackFlag.vehicles.localized[context.system.traits.type.value] ?? ""
			} (${dimensions})`
		};

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareActions(context) {
		await super.prepareActions(context);
		const descriptions = {
			action: "system.description.actions",
			bonus: "system.description.bonusActions",
			reaction: "system.description.reactions"
		};
		for (const [key, keyPath] of Object.entries(descriptions)) {
			if (!(key in context.actions)) continue;
			context.actions[key].description = foundry.utils.getProperty(context, keyPath);
			context.actions[key].descriptionKeyPath = keyPath;
		}
		context.passive.findSplice(d => d.item.identifier === "vehicle-resilience");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareTraits(context) {
		super.prepareTraits(context);
		context.traits.speed = this.actor.system.traits.movement.label || "â€”";
	}
}

/**
 * Base configuration dialog for actor properties.
 * @abstract
 */
class BaseConfig extends DocumentSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			width: 450,
			height: "auto",
			sheetConfig: false,
			submitOnChange: true,
			submitOnClose: true,
			closeOnSubmit: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get title() {
		return `${game.i18n.format("BF.Configuration.Title", { type: this.type })}`;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Configuration type used when building the title.
	 * @type {string}
	 */
	get type() {
		return "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		return foundry.utils.mergeObject(
			{
				CONFIG: CONFIG.BlackFlag,
				source: this.document.toObject().system,
				system: this.document.system,
				modifierSections: this.prepareModifiers() ?? {}
			},
			await super.getData(options)
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch modifiers from the document where certain filters are met or not.
	 * @param {FilterDescription[]} [include=[]] - Filters that should be included.
	 * @param {FilterDescription[]} [exclude=[]] - Filters that should not be included.
	 * @param {Function} [filter] - Additional filtering function to apply.
	 * @returns {Modifier[]}
	 */
	getModifiers(include = [], exclude = [], filter = null) {
		let modifiers = [];
		for (let modifier of this.document.system.modifiers) {
			let valid = true;
			for (const i of include) {
				if (!modifier.filter.some(f => foundry.utils.objectsEqual(i, f))) valid = false;
			}
			for (const e of exclude) {
				if (modifier.filter.some(f => foundry.utils.objectsEqual(e, f))) valid = false;
			}
			if (!valid) continue;

			const mod = foundry.utils.deepClone(modifier);
			mod.index = modifier.index;
			mod.requireProficiency = mod.filter.some(f => f.k === "proficiency");
			modifiers.push(mod);
		}
		return foundry.utils.getType(filter) === "function" ? modifiers.filter(filter) : modifiers;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare modifier sections that should be displayed.
	 * @returns {object}
	 * @abstract
	 */
	prepareModifiers() {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll('[data-action="modifier"]')) {
			element.addEventListener("click", this._onModifierAction.bind(this));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle creating and deleting modifiers.
	 * @param {ClickEvent} event - Triggering click event.
	 * @returns {Promise}
	 */
	async _onModifierAction(event) {
		const { subAction } = event.currentTarget.dataset;
		const index = event.target.closest("[data-index]")?.dataset.index;
		const category = event.target.closest("[data-modifier-category]").dataset.modifierCategory;
		const type = event.target.closest("[data-modifier-type]").dataset.modifierType;
		switch (subAction) {
			case "add":
				const data = this._getModifierData(category, type);
				return this.document.system.addModifier(data);
			case "delete":
				return this.document.system.deleteModifier(index);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Produce modifier creation data.
	 * @param {string} category - Modifier category.
	 * @param {string} type - Modifier type.
	 * @returns {object}
	 * @abstract
	 */
	_getModifierData(category, type) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _updateObject(event, formData) {
		const data = foundry.utils.expandObject(formData);

		// Intercept changes to modifiers
		if (data.modifier) {
			for (const [index, updates] of Object.entries(data.modifier)) {
				if (foundry.utils.hasProperty(updates, "requireProficiency")) {
					updates.filter = this.document.system.modifiers[Number(index)].filter;
					if (updates.requireProficiency) updates.filter.push({ k: "proficiency", v: 1, o: "gte" });
					else updates.filter.findSplice(f => f.k === "proficiency");
				}
				await this.document.system.updateModifier(Number(index), updates, { render: false });
			}
			delete data.modifier;
			formData = foundry.utils.flattenObject(data);
		}

		super._updateObject(event, formData);
	}
}

/**
 * Dialog for performing rests on actors.
 * @abstract
 */
class BaseRestDialog extends BFFormDialog {
	constructor(options = {}) {
		super(options);
		this.#config = options.config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["rest", "form-list"],
		config: null,
		document: null,
		form: {
			handler: BaseRestDialog.#handleFormSubmission
		},
		position: {
			width: 380
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor that is performing the rest.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.options.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The rest configuration.
	 * @type {RestConfiguration}
	 */
	#config;

	get config() {
		return this.#config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Was the rest button pressed?
	 * @type {boolean}
	 */
	#rested = false;

	get rested() {
		return this.#rested;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Result of the rest operation.
	 * @type {object}
	 */
	result = {};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.localize(CONFIG.BlackFlag.rest.types[this.config.type]?.label);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const restConfig = CONFIG.BlackFlag.rest.types[this.config.type];
		const context = {
			...(await super._prepareContext(options)),
			actor: this.actor,
			config: this.config,
			fields: [],
			hd: this.actor.system.attributes?.hd,
			hp: this.actor.system.attributes?.hp,
			note: restConfig?.hint ? game.i18n.localize(restConfig.hint) : ""
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle submission of the dialog using the form buttons.
	 * @this {BaseRestDialog}
	 * @param {Event|SubmitEvent} event - The form submission event.
	 * @param {HTMLFormElement} form - The submitted form.
	 * @param {FormDataExtended} formData - Data from the dialog.
	 */
	static async #handleFormSubmission(event, form, formData) {
		foundry.utils.mergeObject(this.config, formData.object);
		this.#rested = true;
		await this.close();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A helper constructor that displays the appropriate rest dialog and returns user choices when complete.
	 * @param {BlackFlagActor} actor - Actor that is taking the rest.
	 * @param {RestConfiguration} config - Configuration information for the rest.
	 * @returns {Promise<RestConfiguration>}
	 */
	static async rest(actor, config) {
		return new Promise((resolve, reject) => {
			const app = new this({
				config,
				buttons: [
					{
						default: true,
						icon: "fa-solid fa-bed",
						label: game.i18n.localize("BF.Rest.Action.Rest.Label"),
						name: "rest",
						type: "submit"
					}
				],
				document: actor
			});
			app.addEventListener("close", () => (app.rested ? resolve(app.config) : reject()), { once: true });
			app.render({ force: true });
		});
	}
}

/**
 * Dialog for performing a long rest.
 */
class LongRestDialog extends BaseRestDialog {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["long-rest"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		content: {
			template: "systems/black-flag/templates/actor/rest/long-rest.hbs"
		}
	};
}

class ShortRestDialog extends BaseRestDialog {
	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			rollHitDie: ShortRestDialog.#rollHitDie
		},
		classes: ["short-rest"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		content: {
			template: "systems/black-flag/templates/actor/rest/short-rest.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle rolling a hit die.
	 * @this {ShortRestDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #rollHitDie(event, target) {
		const denomination = target.dataset.denomination;
		await this.actor.rollHitDie({ denomination });
		foundry.utils.mergeObject(this.config, new FormDataExtended(this.form).object);
		this.render();
	}
}

var _module$p = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AbilityAssignmentDialog: AbilityAssignmentDialog,
	AbilityConfig: AbilityConfig,
	ArmorClassConfig: ArmorClassConfig,
	BaseActorSheet: BaseActorSheet,
	BaseConfig: BaseConfig,
	BaseCustomConfigSheet: BaseCustomConfigSheet,
	BaseRestDialog: BaseRestDialog,
	BaseSelectorConfigSheet: BaseSelectorConfigSheet,
	BaseStatblockSheet: BaseStatblockSheet,
	BasicConfigSheet: BaseConfigSheet,
	ConceptSelectionDialog: ConceptSelectionDialog,
	HealthConfig: HealthConfig,
	InitiativeConfig: InitiativeConfig,
	LairSheet: LairSheet,
	LanguageConfig: LanguageConfig,
	LevelUpDialog: LevelUpDialog,
	LongRestDialog: LongRestDialog,
	LuckConfig: LuckConfig,
	MovementConfig: MovementConfig,
	NPCSheet: NPCSheet,
	NPCSpellcastingConfig: NPCSpellcastingConfig,
	PCSheet: PCSheet,
	ProficiencyConfig: ProficiencyConfig,
	ResistanceConfig: ResistanceConfig,
	SensesConfig: SensesConfig,
	ShortRestDialog: ShortRestDialog,
	SiegeWeaponSheet: SiegeWeaponSheet,
	SkillConfig: SkillConfig,
	ToolConfig: ToolConfig,
	TypeConfig: TypeConfig,
	VehicleSheet: VehicleSheet
});

/**
 * Custom element for displaying the actions on the actor sheets.
 */
class ActionsElement extends DocumentSheetAssociatedElement {
	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		const { signal } = this.#controller;

		// Attach listeners to buttons
		for (const button of this.querySelectorAll("[data-action]")) {
			const handler = event => {
				event.stopImmediatePropagation();
				this._onAction(event.currentTarget, event.currentTarget.dataset.action, { event });
			};
			button.addEventListener("click", handler, { signal });
			button.addEventListener(
				"contextmenu",
				event => {
					if (event.ctrlKey) handler(event);
				},
				{ signal }
			);
		}

		new BlackFlagContextMenu(this, "[data-item-id]", [], { jQuery: true, onOpen: this._onContextMenu.bind(this) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor that originates these actions.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the set of ContextMenu options which should be applied to action entries.
	 * @param {BlackFlagItem} item - The item for which the context menu is being activated.
	 * @param {Activity} [activity] - Activity for which the context menu is being activated.
	 * @returns {ContextMenuEntry[]} - Context menu entries.
	 * @protected
	 */
	_getContextMenuOptions(item, activity) {
		return [
			{
				name: "BF.ACTIVITY.Core.Action.View",
				icon: "<i class='fa-solid fa-eye fa-fw'></i>",
				condition: li => activity && !this.isEditable,
				callback: li => this._onAction(li[0], "view"),
				group: "activity"
			},
			{
				name: "BF.ACTIVITY.Core.Action.Activate",
				icon: '<i class="fa-solid fa-power-off fa-fw" inert></i>',
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "activate"),
				group: "activity"
			},
			{
				name: "BF.ACTIVITY.Core.Action.Edit",
				icon: '<i class="fa-solid fa-edit fa-fw" inert></i>',
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "edit"),
				group: "activity"
			},
			{
				name: "BF.ACTIVITY.Core.Action.Delete",
				icon: '<i class="fa-solid fa-trash fa-fw destructive" inert></i>',
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "delete"),
				group: "activity"
			},
			{
				name: "BF.Item.Action.Post",
				icon: '<i class="fa-solid fa-envelope fa-fw" inert></i>',
				callback: li => this._onAction(li[0], "post"),
				group: "item"
			},
			{
				name: "BF.Item.Action.View",
				icon: "<i class='fa-solid fa-eye fa-fw'></i>",
				condition: li => !this.isEditable,
				callback: li => this._onAction(li[0], "viewItem"),
				group: "item"
			},
			{
				name: "BF.Item.Action.Edit",
				icon: '<i class="fa-solid fa-edit fa-fw" inert></i>',
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "editItem"),
				group: "item"
			},
			{
				name: "BF.Item.Action.Delete",
				icon: '<i class="fa-solid fa-trash fa-fw destructive" inert></i>',
				condition: li => this.isEditable,
				callback: li => this._onAction(li[0], "deleteItem"),
				group: "item"
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking an action.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @param {object} [options={}]
	 * @param {Event} [options.event] - Triggering event.
	 * @returns {Promise}
	 */
	async _onAction(target, action, { event } = {}) {
		const actionEvent = new CustomEvent("bf-actions", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (target.dispatchEvent(actionEvent) === false) return;

		const dataset = (
			target.closest("[data-activity], [data-activity-id], [data-activity-uuid], [data-item-id]") || target
		).dataset;
		let activity;
		const item = this.actor.items.get(dataset.itemId);
		if (dataset.activityUuid || dataset.activity) activity = await fromUuid(dataset.activityUuid ?? dataset.activity);
		else activity = item?.system.activities?.get(dataset.activityId);

		switch (action) {
			case "activate":
				if (activity) return activity.activate({ event });
			case "activateItem":
				return item?.activate({ event });
			case "delete":
				if (activity) return activity.deleteDialog();
			case "deleteItem":
				if (item) return item.deleteDialog();
				break;
			case "edit":
			case "view":
				if (activity) return activity.sheet.render({ force: true });
			case "editItem":
			case "viewItem":
				if (item) return item.sheet.render(true);
				break;
			case "post":
				if (item) return item.postToChat();
				break;
		}

		return this.app._onAction?.(event ?? actionEvent, dataset);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle opening the context menu.
	 * @param {HTMLElement} element - The element the context menu was triggered on.
	 * @protected
	 */
	_onContextMenu(element) {
		const dataset = element.closest("[data-item-id]")?.dataset ?? {};
		const item = this.actor.items.get(dataset?.itemId);
		if (!item) {
			ui.context.menuItems = [];
			return;
		}
		const activity = item?.system.activities?.get(dataset.activityId);

		ui.context.menuItems = this._getContextMenuOptions(item, activity);
		/**
		 * A hook event that fires when the context menu for an actions list is constructed.
		 * @function blackFlag.getActionsContext
		 * @memberof hookEvents
		 * @param {ActionsElement} html - The HTML element to which the context options are attached.
		 * @param {BlackFlagItem} item - The item for which the context options are being prepared.
		 * @param {Activity} [activity] - The activity for which the context options are being prepared.
		 * @param {ContextMenuEntry[]} entryOptions - The context menu entries.
		 */
		Hooks.call("blackFlag.getActionsContext", this, item, activity, ui.context.menuItems);
	}
}

const { DialogV2 } = foundry.applications.api;

/**
 * Presents a list of pseudo document types to create.
 *
 * @param {BlackFlagItem} item - Item to which this pseudo document will be added.
 * @param {object} [dialogData={}] - An object of dialog data which configures how the modal window is rendered.
 * @param {object} [options={}] - Dialog rendering options.
 */
class PseudoDocumentSelection extends DialogV2 {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["black-flag", "pseudo-document-selection"],
		errorMessage: "",
		item: null,
		position: {
			width: 500
		},
		type: null
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Template to use when rendering the dialog.
	 * @type {string}
	 */
	static TEMPLATE = "systems/black-flag/templates/pseudo-document-selection.hbs";

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item to which this pseudo document is being added.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.options.item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _renderHTML(context, options) {
		const form = await super._renderHTML(context, options);
		const content = await renderTemplate(this.constructor.TEMPLATE, context);
		form.insertAdjacentHTML("afterbegin", `<div class="dialog-content standard-form">${content}</div>`);
		if (context.buttonLabel) {
			form.querySelector("button").innerHTML = `<i class="fa-regular fa-save" inert></i> ${context.buttonLabel}`;
		}
		return form;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A helper constructor function which displays the selection dialog and returns a Promise once its workflow has
	 * been resolved.
	 * @param {BlackFlagItem} item - Item to which the advancement should be added.
	 * @param {object} [config={}]
	 * @param {boolean} [config.rejectClose=false] - Trigger a rejection if the window was closed without a choice.
	 * @param {object} [config.options={}] - Additional rendering options passed to the Dialog.
	 * @returns {Promise<PseudoDocument[]|null>} - Result of the creation operation.
	 */
	static async createDialog(item, { rejectClose = false, options = {} } = {}) {
		return new Promise((resolve, reject) => {
			const dialog = new this(
				foundry.utils.mergeObject(
					{
						item,
						buttons: [
							{
								action: "submit",
								callback: (event, target, html) => {
									const formData = new FormDataExtended(html.querySelector("form"));
									const type = formData.object.type;
									if (!type) throw new Error(game.i18n.localize(this.DEFAULT_OPTIONS.errorMessage));
									resolve(item.createEmbeddedDocuments(this.DEFAULT_OPTIONS.type, [{ type }], { renderSheet: true }));
								},
								class: "heavy-button",
								label: game.i18n.localize("Submit"),
								icon: "fa-regular fa-save"
							}
						],
						close: () => {
							if (rejectClose) reject(game.i18n.localize(this.DEFAULT_OPTIONS.errorMessage));
							else resolve(null);
						}
					},
					options
				)
			);
			dialog.render({ force: true });
		});
	}
}

/**
 * Presents a list of activity types to create when clicking the new activity button.
 */
class ActivitySelection extends PseudoDocumentSelection {
	/** @override */
	static DEFAULT_OPTIONS = {
		errorMessage: "BF.ACTIVITY.Selection.Error",
		type: "Activity"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return `${game.i18n.localize("BF.ACTIVITY.Selection.Title")}: ${this.options.item.name}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get id() {
		return `item-${this.item.id}-activity-selection`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.types = {};
		for (const [name, config] of Object.entries(CONFIG.Activity.types)) {
			if (name === CONST.BASE_DOCUMENT_TYPE) continue;
			const activity = config.documentClass;
			context.types[name] = {
				label: game.i18n.localize(activity.metadata.title),
				icon: activity.metadata.icon,
				hint: game.i18n.localize(activity.metadata.hint)
			};
		}
		context.types = BlackFlag.utils.sortObjectEntries(context.types, { sortKey: "label" });
		context.buttonLabel = game.i18n.localize("BF.ACTIVITY.Core.Action.Create");
		return context;
	}
}

/**
 * Custom element for displaying the activities on an item sheet.
 */
class ActivitiesElement extends DocumentSheetAssociatedElement {
	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		const { signal } = this.#controller;

		this.addEventListener("dragenter", this._onDragEnter.bind(this), { signal });
		this.addEventListener("dragover", this._onDragOver.bind(this), { signal });
		this.addEventListener("dragleave", this._onDragLeave.bind(this), { signal });
		this.addEventListener("drop", this._onDrop.bind(this), { signal });

		for (const element of this.querySelectorAll("[data-activity-id]")) {
			element.setAttribute("draggable", true);
			element.ondragstart = this._onDragStart.bind(this);
			element.ondragend = this._onDragEnd.bind(this);
		}

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener(
				"click",
				event => {
					event.stopImmediatePropagation();
					this._onAction(event.currentTarget, event.currentTarget.dataset.action);
				},
				{ signal }
			);
		}

		new BlackFlagContextMenu(this, "[data-activity-id]", [], { jQuery: true, onOpen: this._onContextMenu.bind(this) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activities collection stored on the item.
	 * @type {ActivityCollection}
	 */
	get activities() {
		return this.item.system.activities;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item represented by the app.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stored copy of client rect during drag events.
	 * @type {DOMRect}
	 */
	#rect;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the set of ContextMenu options which should be applied for activity entries.
	 * @param {Activity} activity - The activity for which the context menu is being activated.
	 * @returns {ContextMenuEntry[]} - Context menu entries.
	 */
	_getContextMenuOptions(activity) {
		return [
			{
				name: "BF.ACTIVITY.Core.Action.View",
				icon: "<i class='fa-solid fa-eye fa-fw'></i>",
				condition: li => activity && !this.isEditable,
				callback: li => this._onAction(li[0], "view")
			},
			{
				name: "BF.ACTIVITY.Core.Action.Edit",
				icon: "<i class='fa-solid fa-edit fa-fw'></i>",
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "edit")
			},
			{
				name: "BF.ACTIVITY.Core.Action.Duplicate",
				icon: "<i class='fa-solid fa-copy fa-fw'></i>",
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "duplicate")
			},
			{
				name: "BF.ACTIVITY.Core.Action.Delete",
				icon: "<i class='fa-solid fa-trash fa-fw'></i>",
				condition: li => activity && this.isEditable,
				callback: li => this._onAction(li[0], "delete"),
				group: "destructive"
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {Element} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @returns {Promise|void}
	 */
	_onAction(target, action) {
		const id = target.closest("[data-activity-id]")?.dataset.activityId;
		const activity = this.activities.get(id);
		if (["edit", "delete", "duplicate"].includes(action) && !activity) return;
		switch (action) {
			case "add":
				return ActivitySelection.createDialog(this.item);
			case "edit":
			case "view":
				return activity.sheet.render({ force: true });
			case "delete":
				return activity.deleteDialog();
			case "duplicate":
				const data = activity.toObject();
				delete data._id;
				return this.item.createEmbeddedDocuments("Activity", [data]);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle opening the context menu.
	 * @param {HTMLElement} element - The element the context menu was triggered on.
	 * @protected
	 */
	_onContextMenu(element) {
		const activity = this.activities.get(element.closest("[data-activity-id]")?.dataset.activityId);
		ui.context.menuItems = this._getContextMenuOptions(activity);
		/**
		 * A hook event that fires when the context menu for an activities list is constructed.
		 * @function blackFlag.getItemActivityContext
		 * @memberof hookEvents
		 * @param {InventoryElement} html - The HTML element to which the context options are attached.
		 * @param {Activity} activity - The activity for which the context options are being prepared.
		 * @param {ContextMenuEntry[]} entryOptions - The context menu entries.
		 */
		Hooks.call("blackFlag.getItemActivityContext", this, activity, ui.context.menuItems);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin dragging an entry.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragStart(event) {
		const activityId = event.currentTarget.dataset.activityId;
		const activity = this.activities.get(activityId);
		DragDrop$1.beginDragEvent(event, activity);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stop dragging an entry.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragEnd(event) {
		delete this.dataset.dropStatus;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry drags into the element.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragEnter(event) {
		const { data } = DragDrop$1.getDragData(event);
		if (!data) this.dataset.dropStatus = "unknown";
		else this.dataset.dropStatus = this._validateDrop(data) ? "valid" : "invalid";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry drags over the element.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragOver(event) {
		event.preventDefault();
		this.#rect = this.getBoundingClientRect();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry being dragged over leaves the element.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragLeave(event) {
		if (
			event.clientY <= this.#rect.top ||
			event.clientY >= this.#rect.bottom ||
			event.clientX <= this.#rect.left ||
			event.clientX >= this.#rect.right
		) {
			delete this.dataset.dropStatus;
			this.#rect = null;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry is dropped onto the element.
	 * @param {DragEvent} event - Triggering drop event.
	 * @returns {Promise}
	 */
	async _onDrop(event) {
		event.stopImmediatePropagation();
		const { data } = DragDrop$1.getDragData(event);
		if (!this._validateDrop(data)) return false;

		if (data.uuid?.startsWith(this.item.uuid)) return this._onSortActivity(event, data);

		try {
			const doc = (await fromUuid(data.uuid)).toObject() ?? data.data;
			if (!doc) return false;

			// Drop an activity
			if (data.type === "Activity") {
				delete doc._id;
				await this.item.createEmbeddedDocuments("Activity", [doc]);
			}

			// Create a Cast activity if spell is dropped
			else if (data.type === "Item" && doc.type === "spell") {
				const created = await this.item.createEmbeddedDocuments("Activity", [
					{
						type: "cast",
						system: { spell: { uuid: data.uuid } }
					}
				]);
				created[0]?.sheet.render({ force: true });
			}
		} finally {
			DragDrop$1.finishDragEvent(event);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle sorting activities relative to one another.
	 * @param {DragEvent} event - Triggering drop event.
	 * @param {DragEventPayload} data - Drag event data.
	 * @returns {Promise}
	 */
	async _onSortActivity(event, data) {
		const dragActivity = await fromUuid(data.uuid);
		const dropRow = event.target.closest("[data-activity-id]");
		const dropActivity = this.activities.get(dropRow?.dataset.activityId);
		if (!dragActivity || !dropActivity || dragActivity === dropActivity) return;
		const siblings = this.activities.contents.filter(a => a.id !== dragActivity.id);
		const sortUpdates = SortingHelpers.performIntegerSort(dragActivity, { target: dropActivity, siblings });
		const updateData = {};
		for (const update of sortUpdates) {
			updateData[`system.activities.${update.target.id}.sort`] = update.update.sort;
		}
		if (!foundry.utils.isEmpty(updateData)) this.item.update(updateData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can the dragged document be dropped?
	 * @param {object} data
	 * @returns {boolean}
	 */
	_validateDrop(data) {
		if (data.type === "Activity") return true;
		if (data.type === "Item") return true;
		return false;
	}
}

/**
 * Presents a list of advancement types to create when clicking the new advancement button.
 * Once a type is selected, this hands the process over to the advancement's individual editing interface.
 */
class AdvancementSelection extends PseudoDocumentSelection {
	/** @override */
	static DEFAULT_OPTIONS = {
		errorMessage: "BF.Advancement.Selection.Error",
		type: "Advancement"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return `${game.i18n.localize("BF.Advancement.Selection.Title")}: ${this.options.item.name}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get id() {
		return `item-${this.item.id}-advancement-selection`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.types = {};
		for (const [name, config] of Object.entries(CONFIG.Advancement.types)) {
			const advancement = config.documentClass;
			if (
				!(advancement.prototype instanceof BlackFlag.documents.advancement.Advancement) ||
				!config.validItemTypes.has(this.item.type) ||
				config.hidden
			)
				continue;
			context.types[name] = {
				label: game.i18n.localize(advancement.metadata.title),
				icon: advancement.metadata.icon,
				hint: game.i18n.localize(advancement.metadata.hint),
				disabled: !advancement.availableForItem(this.item)
			};
		}
		context.types = BlackFlag.utils.sortObjectEntries(context.types, { sortKey: "label" });
		context.buttonLabel = game.i18n.localize("BF.Advancement.Core.Action.Create");
		return context;
	}
}

/**
 * Custom element for displaying the advancement on an item sheet.
 */
class AdvancementElement extends DocumentSheetAssociatedElement {
	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		this.#controller = new AbortController();
		const { signal } = this.#controller;

		this.addEventListener("drop", this._onDrop.bind(this), { signal });

		for (const element of this.querySelectorAll("[data-advancement-id]")) {
			element.setAttribute("draggable", true);
			element.ondragstart = this._onDragStart.bind(this);
		}

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener("click", event => {
				event.stopImmediatePropagation();
				this._onAction(event.currentTarget, event.currentTarget.dataset.action);
			});
		}

		new BlackFlagContextMenu(this, "[data-advancement-id]", [], {
			jQuery: true,
			onOpen: this._onContextMenu.bind(this)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Advancement collection stored on the item.
	 * @type {AdvancementCollection}
	 */
	get advancement() {
		return this.item.system.advancement;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item represented by the app.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the provided advancement collection for display.
	 * @param {AdvancementCollection} advancement
	 * @returns {object}
	 */
	static prepareContext(advancement) {
		const context = {};

		const needingConfiguration = advancement.filter(a => !a.levels.length);
		if (needingConfiguration.length) {
			context.unconfigured = {
				items: needingConfiguration.map(a => ({
					id: a.id,
					order: a.constructor.order,
					title: a.title,
					icon: a.icon,
					classRestriction: a.level.classRestriction
				}))
			};
		}

		for (const level of advancement.levels) {
			const levels = { character: level, class: level };
			const items = advancement.byLevel(level).map(a => ({
				id: a.id,
				order: a.sortingValueForLevel(levels),
				title: a.titleForLevel(levels),
				icon: a.icon,
				classRestriction: a.level.classRestriction,
				summary: a.summaryForLevel(levels)
			}));
			if (!items.length) continue;
			context[level] = { items: items.sort((a, b) => a.order.localeCompare(b.order)) };
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the set of ContextMenu options which should be applied for advancement entries.
	 * @param {Advancement} advancement - The advancement for which the context menu is being activated.
	 * @returns {ContextMenuEntry[]} - Context menu entries.
	 */
	_getContextMenuOptions(advancement) {
		return [
			{
				name: "BF.Advancement.Core.Action.View",
				icon: "<i class='fa-solid fa-eye fa-fw' inert></i>",
				condition: li => advancement && !this.isEditable,
				callback: li => this._onAction(li[0], "view")
			},
			{
				name: "BF.Advancement.Core.Action.Edit",
				icon: "<i class='fa-solid fa-edit fa-fw' inert></i>",
				condition: li => advancement && this.isEditable,
				callback: li => this._onAction(li[0], "edit")
			},
			{
				name: "BF.Advancement.Core.Action.Duplicate",
				icon: "<i class='fa-solid fa-copy fa-fw' inert></i>",
				condition: li => this.isEditable && advancement?.constructor.availableForItem(this.item),
				callback: li => this._onAction(li[0], "duplicate")
			},
			{
				name: "BF.JournalPage.Class.DisplayAdvancement",
				icon: `<i class="fa-regular fa-square${
					advancement?.getFlag(game.system.id, "hideOnClassTable") ? "" : "-check"
				} fa-fw"></i>`,
				condition: li => advancement && this.isEditable,
				callback: li => {
					if (advancement.getFlag(game.system.id, "hideOnClassTable") === true) {
						advancement.unsetFlag(game.system.id, "hideOnClassTable");
					} else {
						advancement.setFlag(game.system.id, "hideOnClassTable", true);
					}
				},
				group: "state"
			},
			{
				name: "BF.Advancement.Core.Action.Delete",
				icon: "<i class='fa-solid fa-trash fa-fw' inert></i>",
				condition: li => advancement && this.isEditable,
				callback: li => this._onAction(li[0], "delete"),
				group: "destructive"
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {Element} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @returns {Promise|void}
	 */
	_onAction(target, action) {
		const event = new CustomEvent("bf-advancement", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (target.dispatchEvent(event) === false) return;

		const id = target.closest("[data-advancement-id]")?.dataset.advancementId;
		const advancement = this.advancement.get(id);
		if (["edit", "delete", "duplicate"].includes(action) && !advancement) return;
		switch (action) {
			case "add":
				return AdvancementSelection.createDialog(this.item);
			case "edit":
			case "view":
				return advancement.sheet.render({ force: true });
			case "delete":
				return advancement.deleteDialog();
			case "duplicate":
				const data = advancement.toObject();
				delete data._id;
				return this.item.createEmbeddedDocuments("Advancement", [data]);
			default:
				return log(`Invalid advancement action type clicked ${action}.`, { level: "warn" });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle opening the context menu.
	 * @param {HTMLElement} element - The element the context menu was triggered on.
	 * @protected
	 */
	_onContextMenu(element) {
		const advancement = this.advancement.get(element.closest("[data-advancement-id]")?.dataset.advancementId);
		ui.context.menuItems = this._getContextMenuOptions(advancement);
		/**
		 * A hook event that fires when the context menu for an activities list is constructed.
		 * @function blackFlag.getItemAdvancementContext
		 * @memberof hookEvents
		 * @param {InventoryElement} html - The HTML element to which the context options are attached.
		 * @param {Advancement} advancement - The advancement for which the context options are being prepared.
		 * @param {ContextMenuEntry[]} entryOptions - The context menu entries.
		 */
		Hooks.call("blackFlag.getItemAdvancementContext", this, advancement, ui.context.menuItems);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin dragging an entry.
	 * @param {DragEvent} event - Triggering drag event.
	 */
	_onDragStart(event) {
		const advancementId = event.currentTarget.dataset.advancementId;
		const advancement = this.advancement.get(advancementId);
		DragDrop$1.beginDragEvent(event, advancement);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An entry is dropped onto the element.
	 * @param {DragEvent} event - Triggering drop event.
	 * @returns {Promise}
	 */
	async _onDrop(event) {
		event.preventDefault();
		event.stopImmediatePropagation();

		if (!this.isEditable) return false;

		const { data } = DragDrop$1.getDragData(event);
		if (data.uuid?.startsWith(this.item.uuid)) return false;
		if (!this._validateDrop(data)) return this.app._onDrop?.(event);

		try {
			const advancement = (await fromUuid(data.uuid)).toObject() ?? data.data;
			if (!advancement) return false;
			return this.constructor.dropAdvancement(event, this.document, [advancement]);
		} finally {
			DragDrop$1.finishDragEvent(event);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can the dragged document be dropped?
	 * @param {object} data
	 * @returns {boolean}
	 */
	_validateDrop(data) {
		if (data.type !== "Advancement") return false;
		return !data.uuid?.startsWith(this.item.uuid);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an advancement dropped onto the sheet.
	 * @param {DragEvent} event - Triggering drop event.
	 * @param {BlackFlagItem} target - Document to which the advancement was dropped.
	 * @param {BlackFlagAdvancement[]} advancementData - One or more advancements dropped.
	 * @returns {Promise}
	 */
	static async dropAdvancement(event, target, advancementData) {
		const advancement = [];
		for (const data of advancementData) {
			const AdvancementClass = CONFIG.Advancement.types[data.type]?.documentClass;
			if (!AdvancementClass) continue;
			if (
				!CONFIG.Advancement.types[data.type].validItemTypes?.has(target.type) ||
				!AdvancementClass.availableForItem(target)
			) {
				ui.notifications.error("BF.Advancement.Core.Warning.CantBeAdded", { localize: true });
				return false;
			}

			delete data._id;
			advancement.push(data);
		}
		target.createEmbeddedDocuments("Advancement", advancement);
		// TODO: If item is on an actor, apply initial advancement
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an item dropped onto the sheet.
	 * @param {DragEvent} event - Triggering drop event.
	 * @param {BlackFlagItem} target - Document to which the items were dropped.
	 * @param {BlackFlagAdvancement[]} itemData - One or more items dropped.
	 */
	static async dropItems(event, target, itemData) {
		const itemsByLevel = itemData.reduce((map, item) => {
			if (item.uuid && item.system.level?.value) {
				if (!map.has(item.system.level.value)) {
					map.set(item.system.level.value, []);
				}
				map.get(item.system.level.value).push(item.uuid);
			}
			return map;
		}, new Map());

		const advancementToCreate = [];
		const advancementUpdates = [];
		for (const [level, uuids] of itemsByLevel.entries()) {
			const advancement = target.system.advancement.byLevel(level).find(a => a.type === "grantFeatures");
			if (advancement) {
				const pool = advancement.toObject().configuration.pool;
				for (const uuid of uuids) {
					if (!pool.find(e => e.uuid === uuid)) pool.push({ uuid });
				}
				advancementUpdates.push({ _id: advancement.id, "configuration.pool": pool });
			} else {
				advancementToCreate.push({
					type: "grantFeatures",
					level: {
						value: level,
						classIdentifier:
							target.type === "class"
								? target.identifier
								: CONFIG.BlackFlag.registration.get("class", target.system.identifier?.associated)
									? target.system.identifier.associated
									: undefined
					},
					configuration: {
						pool: uuids.map(uuid => ({ uuid }))
					}
				});
			}
		}

		await target.createEmbeddedDocuments("Advancement", advancementToCreate);
		await target.updateEmbeddedDocuments("Advancement", advancementUpdates);
	}
}

/**
 * Abstract custom element that connects with a chat message.
 */
class MessageAssociatedElement extends HTMLElement {
	connectedCallback() {
		this.#message = game.messages.get(this.closest("[data-message-id]")?.dataset.messageId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Reference to the chat message that contains this component.
	 * @type {BlackFlagChatMessage}
	 */
	#message;

	get message() {
		return this.#message;
	}
}

/**
 * Element for displaying collapsible content in a chat message.
 */
class ChatTrayElement extends MessageAssociatedElement {
	static observedAttributes = ["open"];

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the tray expanded or collapsed?
	 * @type {boolean}
	 */
	get open() {
		return this.hasAttribute("open");
	}

	set open(open) {
		if (open) this.setAttribute("open", "");
		else this.removeAttribute("open");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		this.querySelector(".collapsible")?.addEventListener("click", this._handleClickToggle.bind(this));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	attributeChangedCallback(name, oldValue, newValue) {
		if (name === "open") this._handleToggleOpen(newValue !== null);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicks to the collapsible header.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	_handleClickToggle(event) {
		if (!event.target.closest(".collapsible-content")) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this.toggleAttribute("open");
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle changing the collapsed state of this element.
	 * @param {boolean} open - Is the element open?
	 */
	_handleToggleOpen(open) {
		this.dispatchEvent(new Event("toggle"));

		this.querySelector(".collapsible")?.classList.toggle("collapsed", !open);

		const popout = this.closest(".chat-popout");
		if (popout) popout.style.height = "";
	}
}

/**
 * Element that handles displaying attack results.
 */
class AttackResultElement extends ChatTrayElement {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The attack roll.
	 * @type {ChallengeRoll}
	 */
	roll;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Damage descriptions that will be applied by this application.
	 * @type {DamageDescription[]}
	 */
	targets = [];

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The list of application targets.
	 * @type {HTMLUListElement}
	 */
	#targetList;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		if (!this.message) return;

		// Build the frame HTML only once
		if (!this.#targetList) {
			const div = document.createElement("div");
			div.classList.add("card-tray", "attack-tray", "collapsible");
			if (!this.open) div.classList.add("collapsed");
			div.innerHTML = `
				<label>
					<i class="fa-solid fa-bullseye" inert></i>
					<span>${game.i18n.localize("BF.TARGET.Label[other]")}</span>
					<i class="fa-solid fa-caret-down" inert></i>
				</label>
				<div class="collapsible-content">
					<div class="wrapper">
						<ul class="targets unlist"></ul>
					</div>
				</div>
			`;
			this.replaceChildren(div);
			this.#targetList = div.querySelector(".targets");
			div.addEventListener("click", this._handleClickToggle.bind(this));
		}
		// TODO: Add event listener for when luck is applied to the message

		this.buildTargetsList();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Build a list of targeted tokens based on current mode & replace any existing targets.
	 */
	buildTargetsList() {
		const targetedTokens = this.message.getFlag(game.system.id, "targets") ?? [];
		const targets = targetedTokens.map(t => this.buildTargetListEntry(t)).filter(t => t);
		if (targets.length) this.#targetList.replaceChildren(...targets);
		else {
			const li = document.createElement("li");
			li.classList.add("none");
			li.innerText = game.i18n.localize("BF.Tokens.None.Targeted");
			this.#targetList.replaceChildren(li);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a list entry for a single target.
	 * @param {TargetDescriptor} target - Targeting data.
	 * @returns {HTMLLIElement|void}
	 */
	buildTargetListEntry(target) {
		const isHit = this.roll.isCriticalSuccess || (this.roll.total >= target.ac && !this.roll.isCriticalFailure);
		const li = document.createElement("li");
		li.classList.add("target", isHit ? "hit" : "miss");
		li.dataset.uuid = target.uuid;
		li.innerHTML = '<div class="name"></div>';
		li.querySelector("div.name").innerText = target.name;
		if (game.user.isGM || game.settings.get(game.system.id, "attackVisibility") !== "hideAC")
			li.innerHTML += `
			<div class="ac">
				<i class="fa-solid fa-shield-halved" inert></i>
				<span>${target.ac}</span>
			</div>
		`;

		li.addEventListener("click", this.message.onTargetMouseDown.bind(this));
		li.addEventListener("pointerover", this.message.onTargetHoverIn.bind(this));
		li.addEventListener("pointerout", this.message.onTargetHoverOut.bind(this));

		return li;
	}
}

/**
 * Abstract custom element with some form internal architecture and app hookups.
 */
class FormAssociatedElement extends AppAssociatedElement {
	static formAssociated = true;

	/* <><><><> <><><><> <><><><> <><><><> */

	constructor() {
		super();
		this.#internals = this.attachInternals();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		super.connectedCallback();
		if (this.form) {
			this.form.addEventListener("formdata", this.#formDataHandler);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		if (this.form) {
			this.form.removeEventListener("formdata", this.#formDataHandler);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Internal form interaction implementation.
	 * @type {ElementInternals}
	 */
	#internals;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The bound form data handler method.
	 * @type {Function}
	 */
	#formDataHandler = this.#onFormData.bind(this);

	/**
	 * Form associated with this control.
	 * @type {HTMLFormElement}
	 */
	get form() {
		return this.#internals.form;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	get name() {
		return this.getAttribute("name");
	}

	set name(value) {
		this.setAttribute("name", value);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	get value() {
		return this.#createValue();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this element disabled?
	 * @type {boolean}
	 */
	get disabled() {
		return this.hasAttribute("disabled");
	}

	set disabled(value) {
		this.toggleAttribute("disabled", value);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove remapped for field upon submission.
	 * @param {FormDataEvent} event - The FormData event.
	 * @protected
	 */
	#onFormData(event) {
		for (const field of this.querySelectorAll('[name^="$"]')) {
			event.formData.delete(field.name);
			delete event.formData.object[field.name];
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	#createValue() {
		const form = document.createElement("form");
		Array.from(this.children).forEach(c => form.insertAdjacentElement("beforeend", c));
		const formData = new FormDataExtended(form);
		Array.from(form.children).forEach(c => this.insertAdjacentElement("beforeend", c));
		let object = foundry.utils.expandObject(formData.object).$ ?? {};
		object = this._mutateFormData(object) ?? object;
		return object;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mutate this form's FormData before merging with parent data.
	 * @param {object} object - Form data for just this element.
	 * @returns {*}
	 * @abstract
	 */
	_mutateFormData(object) {}
}

/**
 * Custom element for displaying the list of consumption types on an activity.
 */
class ConsumptionElement extends FormAssociatedElement {
	connectedCallback() {
		super.connectedCallback();

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener("click", event => {
				event.stopImmediatePropagation();
				this.#onAction(event.currentTarget, event.currentTarget.dataset.action);
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activity represented by the app.
	 * @type {Activity}
	 */
	get activity() {
		return this.app.activity;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does the user have permission to edit the document?
	 * @type {boolean}
	 */
	get isEditable() {
		return this.activity.item.testUserPermission(game.user, "EDIT");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Path on the activity of the consumption targets collection property.
	 * @type {string}
	 */
	get #keyPath() {
		return `${this.name ?? "consumption"}.targets`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {Element} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @returns {Promise|void}
	 */
	#onAction(target, action) {
		const event = new CustomEvent("consumption", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (!this.isEditable || target.dispatchEvent(event) === false) return;

		const li = target.closest("[data-index]");
		const index = li?.dataset.index;
		const typesCollection = foundry.utils.getProperty(this.activity.toObject(), this.#keyPath) ?? [];
		if (action !== "add" && !index) return;
		switch (action) {
			case "add":
				const types = this.activity.validConsumptionTypes;
				const filteredTypes = types.difference(
					new Set(foundry.utils.getProperty(this.activity.toObject(), this.#keyPath).map(t => t.type))
				);
				const type = filteredTypes.first() ?? types.first();
				if (!type) return;
				typesCollection.push({
					type,
					target: ConsumptionTargetData.getValidTargets(type, this.activity)?.[0]?.value
				});
				break;
			case "delete":
				typesCollection.splice(index, 1);
				break;
			default:
				return;
		}

		return this.app.submit({ updateData: { [this.#keyPath]: typesCollection } });
	}
}

/**
 * Bit of text with a button after it for copying it.
 */
class CopyableElement extends HTMLElement {
	/** @override */
	connectedCallback() {
		const button = document.createElement("button");
		button.ariaLabel = this.getAttribute("label") ?? game.i18n.localize("BF.Copy.Action");
		button.classList.add("copy-button", "link-button");
		button.dataset.tooltip = button.ariaLabel;
		button.innerHTML = '<i class="fa-regular fa-clipboard" inert></i>';
		button.addEventListener("click", this._onClick.bind(this));
		this.append(button);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	disconnectedCallback() {
		this.querySelector("button")?.remove();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle copying the contents.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	_onClick(event) {
		event.preventDefault();
		event.stopPropagation();
		const value = this.getAttribute("value") ?? this.innerText;
		game.clipboard.copyPlainText(value);
		game.tooltip.activate(event.target, { text: game.i18n.format("BF.Copy.Complete", { value }), direction: "UP" });
	}
}

class BlackFlagDialog extends Dialog {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getData(options = {}) {
		const context = super.getData(options);
		for (const button of Object.values(context.buttons)) {
			if (button.cssClass.includes("default")) button.cssClass += " heavy-button";
			else button.cssClass += " light-button";
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Wrap the Dialog with an enclosing Promise which resolves or rejects when the client makes a choice.
	 * @param {object} tooltip
	 * @param {HTMLElement} tooltip.element - Element onto which to attach the tooltip.
	 * @param {DialogData} [data] - Data passed to the Dialog constructor.
	 * @param {DialogOptions} [options] - Options passed to the Dialog constructor.
	 * @param {object} [renderOptions] - Options passed to the Dialog render call.
	 * @returns {Promise} - A Promise that resolves to the chosen result.
	 */
	static async tooltipWait({ element, ...tooltipOptions }, data = {}, options = {}, renderOptions = {}) {
		return new Promise((resolve, reject) => {
			// Wrap buttons with Promise resolution.
			const buttons = foundry.utils.deepClone(data.buttons);
			for (const [id, button] of Object.entries(buttons)) {
				const cb = button.callback;
				button.callback = (html, event) => {
					const result = cb instanceof Function ? cb.call(this, html, event) : undefined;
					resolve(result === undefined ? id : result);
				};
			}

			// Wrap close with Promise resolution or rejection.
			const originalClose = data.close;
			const close = element => {
				const result = originalClose instanceof Function ? originalClose() : undefined;
				const tooltip = element.closest(".locked-tooltip");
				if (tooltip) game.tooltip.dismissLockedTooltip(tooltip);
				else game.tooltip.deactivate();
				if (result !== undefined) resolve(result);
				else reject(new Error("The Dialog was closed without a choice being made."));
			};

			// Construct the dialog.
			const dialog = new this({ ...data, buttons, close }, { ...options, popOut: false });
			dialog._element = $(document.createElement("section"));
			dialog._render(true).then(() => {
				let content = dialog.element;
				if (!(content instanceof HTMLElement)) {
					content = $(document.createElement("div"));
					content.append(dialog.element);
					content = content[0];
				}
				content.classList.add("dialog-tooltip");
				game.tooltip.activate(element, { content, locked: true, ...tooltipOptions });
			});
		});

		// TODO: Reject properly when tooltip is closed by moving mouse away
	}
}

class CurrencyElement extends InventoryElement {
	/**
	 * Bring up the currency adding dialog.
	 * @param {HTMLElement} target - Button or context menu entry that triggered this action.
	 */
	async _onAddItem(target) {
		const content = await renderTemplate("systems/black-flag/templates/shared/add-currency-dialog.hbs", {
			currencies: Object.entries(CONFIG.BlackFlag.currencies).reduce((obj, [k, config]) => {
				if (config.default) obj[k] = config;
				return obj;
			}, {})
		});

		let formData;
		try {
			formData = await BlackFlagDialog.tooltipWait(
				{ element: target, cssClass: "add-currency" },
				{
					content,
					buttons: {
						addCurrency: {
							label: `<i class="fas fa-coins"></i> ${game.i18n.localize("Add Currency")}`,
							callback: html => new FormData(html.querySelector("form"))
						}
					},
					default: "addCurrency",
					render: true
				},
				{ jQuery: false }
			);
		} catch (err) {
			console.error(err);
			return;
		}
		if (!formData) return;

		let toCreate = [];
		for (let [key, delta] of formData.entries()) {
			delta = Number(delta);
			if (!delta || !Number.isFinite(delta)) continue;
			const existingItem = await this.findItem(i => i.type === "currency" && i.identifier === key);

			// Update the existing currency item in this inventory
			if (existingItem) {
				await existingItem.update({ "system.quantity": Math.max(0, existingItem.system.quantity + delta) });
			}

			// Fetch the base currency item and create it in this context
			else if (delta > 0) {
				const uuid = CONFIG.BlackFlag.currencies[key]?.uuid;
				const item = uuid ? await fromUuid(uuid) : null;
				if (!item) {
					console.error(`Could not find reference currency for "${key}" to create.`);
					continue;
				}
				const itemData = item.toObject();
				itemData.system.quantity = delta;
				if (this.document.type === "container") itemData.system.container = this.document.id;
				toCreate.push(itemData);
			}
		}

		if (toCreate.length) await Item.createDocuments(toCreate, { pack: this.document.pack, parent: this.actor });
	}
}

/**
 * Adds functionality to a custom HTML element for displaying a target selector and displaying targets.
 * @param {typeof HTMLElement} Base - The base class being mixed.
 * @returns {typeof TargetedApplicationElement}
 */
function TargetedApplicationElement(Base) {
	return class TargetedApplicationElement extends Base {
		/* <><><><> <><><><> <><><><> <><><><> */
		/*             Properties              */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Currently registered hook for monitoring for changes to selected tokens.
		 * @type {number|null}
		 */
		selectedTokensHook = null;

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Current target selection mode.
		 * @type {"targeted"|"selected"}
		 */
		get targetingMode() {
			if (this.targetSourceControl.hidden) return "selected";
			return this.targetSourceControl.querySelector('[aria-pressed="true"]')?.dataset.mode ?? "targeted";
		}

		set targetingMode(mode) {
			if (this.targetSourceControl.hidden) mode = "selected";
			const toPress = this.targetSourceControl.querySelector(`[data-mode="${mode}"]`);
			const currentlyPressed = this.targetSourceControl.querySelector('[aria-pressed="true"]');
			if (currentlyPressed) currentlyPressed.ariaPressed = false;
			toPress.ariaPressed = true;

			this.buildTargetsList();
			if (mode === "targeted" && this.selectedTokensHook !== null) {
				Hooks.off("controlToken", this.selectedTokensHook);
				this.selectedTokensHook = null;
			} else if (mode === "selected" && this.selectedTokensHook === null) {
				this.selectedTokensHook = Hooks.on(
					"controlToken",
					foundry.utils.debounce(() => this.buildTargetsList(), 50)
				);
			}
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * The list of application targets.
		 * @type {HTMLUListElement}
		 */
		targetList;

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * The controls for selecting target source mode.
		 * @type {HTMLElement}
		 */
		targetSourceControl;

		/* <><><><> <><><><> <><><><> <><><><> */
		/*              Rendering              */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Return the HTML elements needed to build the target source control and target list.
		 * @returns {HTMLElement[]}
		 */
		buildTargetContainer() {
			this.targetSourceControl = document.createElement("div");
			this.targetSourceControl.classList.add("target-source-control");
			this.targetSourceControl.innerHTML = `
				<button type="button" class="link-button" data-mode="targeted" aria-pressed="false">
					<i class="fa-solid fa-bullseye" inert></i> ${game.i18n.localize("BF.Tokens.Targeted")}
				</button>
				<button type="button" class="link-button" data-mode="selected" aria-pressed="false">
					<i class="fa-solid fa-expand" inert></i> ${game.i18n.localize("BF.Tokens.Selected")}
				</button>
			`;
			this.targetSourceControl
				.querySelectorAll("button")
				.forEach(b => b.addEventListener("click", this._onChangeTargetMode.bind(this)));
			if (!this.message?.getFlag(game.system.id, "targets")?.length) this.targetSourceControl.hidden = true;

			this.targetList = document.createElement("ul");
			this.targetList.classList.add("targets", "unlist");

			return [this.targetSourceControl, this.targetList];
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Build a list of targeted tokens based on current mode & replace any existing targets.
		 */
		buildTargetsList() {
			if (!this.targetList) throw new Error("Must create a element to contain the target list.");
			const targetedTokens = new Map();
			switch (this.targetingMode) {
				case "targeted":
					this.message.getFlag(game.system.id, "targets")?.forEach(t => targetedTokens.set(t.uuid, t.name));
					break;
				case "selected":
					canvas.tokens?.controlled?.forEach(t => targetedTokens.set(t.actor?.uuid, t.name));
					break;
			}
			const targets = Array.from(targetedTokens.entries())
				.map(([uuid, name]) => this.buildTargetListEntry({ uuid, name }))
				.filter(_ => _);
			if (targets.length) this.targetList.replaceChildren(...targets);
			else {
				const li = document.createElement("li");
				li.classList.add("none");
				li.innerText = game.i18n.localize(`BF.Tokens.None${this.targetingMode.capitalize()}`);
				this.targetList.replaceChildren(li);
			}
		}

		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Create a list entry for a single target.
		 * @param {object} data
		 * @param {string} data.uuid - UUID of the targeted actor.
		 * @param {string} data.name - Name of the targeted token.
		 * @returns {HTMLLIElement|void}
		 * @abstract
		 */
		buildTargetListEntry({ uuid, name }) {}

		/* <><><><> <><><><> <><><><> <><><><> */
		/*            Event Handlers           */
		/* <><><><> <><><><> <><><><> <><><><> */

		/**
		 * Handle clicking on the target mode buttons.
		 * @param {PointerEvent} event - Triggering click event.
		 */
		async _onChangeTargetMode(event) {
			event.preventDefault();
			this.targetingMode = event.currentTarget.dataset.mode;
		}
	};
}

/**
 * List of multiplier options as tuples containing their numeric value and rendered text.
 * @type {[number, string][]}
 */
const MULTIPLIERS = [
	[-1, "-1"],
	[0, "0"],
	[0.25, "Â¼"],
	[0.5, "Â½"],
	[1, "1"],
	[2, "2"]
];

/**
 * Element that handles applying damage to actors from a chat card.
 */
class DamageApplicationElement extends TargetedApplicationElement(ChatTrayElement) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The apply damage button within the element.
	 * @type {HTMLButtonElement}
	 */
	#applyButton;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Damage descriptions that will be applied by this application.
	 * @type {DamageDescription[]}
	 */
	damages = [];

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Options for each application target.
	 * @type {Map<string, DamageApplicationOptions>}
	 */
	#targetOptions = new Map();

	/**
	 * Options for a specific target.
	 * @param {string} uuid - UUID of the targeted token.
	 * @returns {DamageApplicationOptions}
	 */
	getTargetOptions(uuid) {
		if (!this.#targetOptions.has(uuid)) this.#targetOptions.set(uuid, { multiplier: 1 });
		return this.#targetOptions.get(uuid);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		if (!this.message) return;

		// Build the frame HTML only once
		if (!this.targetList) {
			const div = document.createElement("div");
			div.classList.add("card-tray", "damage-tray", "collapsible");
			if (!this.open) div.classList.add("collapsed");
			div.innerHTML = `
				<label>
					<i class="fa-solid fa-heart-crack" inert></i>
					<span>${game.i18n.localize("BF.DAMAGE.Application.Label")}</span>
					<i class="fa-solid fa-caret-down" inert></i>
				</label>
				<div class="collapsible-content">
					<div class="wrapper">
						<button class="apply-damage light-button" type="button" data-action="applyDamage">
							<i class="fa-solid fa-reply-all fa-flip-horizontal" inert></i>
							${game.i18n.localize("BF.DAMAGE.Application.Action.Apply")}
						</button>
					</div>
				</div>
			`;
			this.replaceChildren(div);
			this.#applyButton = div.querySelector(".apply-damage");
			this.#applyButton.addEventListener("click", this._onApplyDamage.bind(this));
			div.querySelector(".wrapper").prepend(...this.buildTargetContainer());
			div.addEventListener("click", this._handleClickToggle.bind(this));
		}

		this.targetingMode = this.targetSourceControl.hidden ? "selected" : "targeted";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	buildTargetListEntry({ uuid, name }) {
		const actor = fromUuidSync(uuid);
		if (!actor?.isOwner) return;

		// Calculate damage to apply
		const targetOptions = this.getTargetOptions(uuid);
		const { temp, tempMax, total, active, threshold } = this.calculateDamage(actor, targetOptions);

		const types = [];
		for (const [change, values] of Object.entries(active)) {
			for (const type of values) {
				if (type === "all") {
					types.push({ type, change, icon: "systems/black-flag/artwork/damage/all.svg" });
				} else {
					const config = CONFIG.BlackFlag.damageTypes[type] ?? CONFIG.BlackFlag.healingTypes[type];
					if (!config) continue;
					types.push({ type, change, icon: config.icon });
				}
			}
		}
		let changeSources = types.reduce((acc, { type, change, icon }) => {
			const { label, pressed } = this.getChangeSourceOptions(type, change, targetOptions);
			acc += `
				<button class="change-source unbutton" type="button" data-type="${type}" data-change="${change}"
								data-tooltip="${label}" aria-label="${label}" aria-pressed="${pressed}">
					<blackFlag-icon src="${icon}" inert></blackFlag-icon>
					<i class="fa-solid fa-slash" inert></i>
					<i class="fa-solid fa-arrow-turn-down" inert></i>
				</button>
			`;
			return acc;
		}, "");
		if (threshold) {
			const { label, pressed } = this.getChangeSourceOptions(null, "threshold", targetOptions);
			changeSources += `
				<button class="change-source unbutton" type="button" data-change="threshold" data-tooltip="${label}"
			        	aria-label="${label}" aria-pressed="${pressed}">
					<blackFlag-icon src="systems/black-flag/artwork/damage/threshold.svg" inert></blackFlag-icon>
					<i class="fa-solid fa-slash" inert></i>
				</button>
				`;
		}

		const li = document.createElement("li");
		li.classList.add("target");
		li.dataset.targetUuid = uuid;
		li.innerHTML = `
			<img class="icon circular" data-uuid="${actor.uuid}">
			<div class="name-stacked">
				<span class="title"></span>
				${changeSources ? `<span class="subtitle">${changeSources}</span>` : ""}
			</div>
			<div class="calculated damage">
				${total}
			</div>
			<div class="calculated temp" data-tooltip="BF.HitPoint.Temp.LabelLong">
				${temp}
			</div>
			<div class="calculated temp-max" data-tooltip="BF.HitPoint.TempMax.LabelLong">
				${tempMax}
			</div>
			<menu class="damage-multipliers unlist"></menu>
		`;
		Object.assign(li.querySelector(".icon"), { alt: name, src: actor.img });
		li.querySelector(".title").innerText = name;

		const menu = li.querySelector("menu");
		for (const [value, display] of MULTIPLIERS) {
			const entry = document.createElement("li");
			entry.innerHTML = `
				<button type="button" class="multiplier-button" value="${value}">
					<span>${display}</span>
				</button>
			`;
			menu.append(entry);
		}

		this.refreshListEntry(actor, li, targetOptions);
		li.addEventListener("click", this._onChangeOptions.bind(this));
		const icon = li.querySelector("img");
		icon.addEventListener("click", this.message.onTargetMouseDown.bind(this));
		icon.addEventListener("pointerover", this.message.onTargetHoverIn.bind(this));
		icon.addEventListener("pointerout", this.message.onTargetHoverOut.bind(this));

		return li;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate the total damage that will be applied to an actor.
	 * @param {BlackFlagActor} actor
	 * @param {DamageApplicationOptions} options
	 * @returns {{ temp: number, total: number, active: Record<string, Set<string>>, threshold: boolean }}
	 */
	calculateDamage(actor, options) {
		const damages = actor.calculateDamage(this.damages, options);
		const types = ["resistance", "vulnerability", "immunity"];

		let temp = 0;
		let tempMax = 0;
		let total = 0;
		let active = { modification: new Set(), resistance: new Set(), vulnerability: new Set(), immunity: new Set() };
		let threshold = false;
		for (const damage of damages) {
			if (damage.type === "temp") temp += damage.value;
			if (damage.type === "max") tempMax += damage.rollType === "healing" ? -1 * damage.value : damage.value;
			else total += damage.value;
			types.forEach(t => {
				if (damage.active.all?.[t]) active[t].add("all");
				if (damage.active.type?.[t]) active[t].add(damage.type);
			});
			if (damage.active.threshold) threshold = true;
		}
		temp = Math.floor(Math.max(0, temp));
		total = total > 0 ? Math.floor(total) : Math.ceil(total);

		// Add values from options to prevent active changes from being lost when re-rendering target list
		types.forEach(t => {
			if (foundry.utils.getType(options.ignore?.[t]) === "Set") active[t] = active[t].union(options.ignore[t]);
		});
		if (foundry.utils.getType(options.downgrade) === "Set") {
			active.immunity = active.immunity.union(options.downgrade);
		}

		return { temp, tempMax, total, active, threshold };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the label and pressed value for a specific change source.
	 * @param {string} type - Damage type represented by this source.
	 * @param {string} change - Change type (e.g. resistance, immunity, etc.).
	 * @param {DamageApplicationOptions} options - Options object from which to determine final values.
	 * @returns {{ label: string, pressed: string }}
	 */
	getChangeSourceOptions(type, change, options) {
		let mode = "active";
		let label;

		if (change === "threshold") {
			if (options.ignore?.threshold) mode = "ignore";
			label = game.i18n.localize("BF.DAMAGE.Threshold");
		} else {
			if (options.ignore?.[change]?.has(type)) mode = "ignore";
			else if (change === "immunity" && options.downgrade?.has(type)) mode = "downgrade";
			const typeLabel =
				type === "all"
					? game.i18n.localize("BF.Resistance.AllDamage")
					: CONFIG.BlackFlag.damageTypes.localized[type] ?? CONFIG.BlackFlag.healingTypes.localized[type];
			label = game.i18n.format(`BF.DAMAGE.Application.Change.${change.capitalize()}`, { type: typeLabel });
		}

		if (mode === "ignore") label = game.i18n.format("BF.DAMAGE.Application.Ignoring", { source: label });
		if (mode === "downgrade") label = game.i18n.format("BF.DAMAGE.Application.Downgrading", { source: label });

		return { label, pressed: mode === "active" ? "false" : mode === "ignore" ? "true" : "mixed" };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Refresh the damage total on a list entry based on modified options.
	 * @param {BlackFlagActor} token
	 * @param {HTMLLiElement} entry
	 * @param {DamageApplicationOptions} options
	 */
	refreshListEntry(token, entry, options) {
		const { temp, tempMax, total } = this.calculateDamage(token, options);
		const calculatedDamage = entry.querySelector(".calculated.damage");
		calculatedDamage.innerText = numberFormat(-total, { signDisplay: "exceptZero" });
		calculatedDamage.classList.toggle("healing", total < 0);
		calculatedDamage.dataset.tooltip = `BF.${total < 0 ? "Healing" : "DAMAGE"}.Label`;
		calculatedDamage.hidden = !total && !!temp && !!tempMax;
		const calculatedTemp = entry.querySelector(".calculated.temp");
		calculatedTemp.innerText = numberFormat(-temp, { sign: true });
		calculatedTemp.hidden = !temp;
		const calculatedTempMax = entry.querySelector(".calculated.temp-max");
		calculatedTempMax.innerText = numberFormat(-tempMax, { sign: true });
		calculatedTempMax.classList.toggle("healing", tempMax < 0);
		calculatedTempMax.hidden = !tempMax;

		const pressedMultiplier = entry.querySelector('.multiplier-button[aria-pressed="true"]');
		if (Number(pressedMultiplier?.dataset.multiplier) !== options.multiplier) {
			if (pressedMultiplier) pressedMultiplier.ariaPressed = false;
			const toPress = entry.querySelector(`[value="${options.multiplier}"]`);
			if (toPress) toPress.ariaPressed = true;
		}

		for (const element of entry.querySelectorAll(".change-source")) {
			const { type, change } = element.dataset;
			const { label, pressed } = this.getChangeSourceOptions(type, change, options);
			element.dataset.tooltip = label;
			element.ariaLabel = label;
			element.ariaPressed = pressed;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking the apply damage button.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	async _onApplyDamage(event) {
		event.preventDefault();
		for (const target of this.targetList.querySelectorAll("[data-target-uuid]")) {
			const token = fromUuidSync(target.dataset.targetUuid);
			const options = this.getTargetOptions(target.dataset.targetUuid);
			await token?.applyDamage(this.damages, options);
		}
		this.open = false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking a multiplier button or resistance toggle.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	async _onChangeOptions(event) {
		event.preventDefault();
		const button = event.target.closest("button");
		const uuid = event.target.closest("[data-target-uuid]")?.dataset.targetUuid;
		if (!button || !uuid) return;

		const options = this.getTargetOptions(uuid);

		// Set multiplier
		if (button.classList.contains("multiplier-button")) {
			options.multiplier = Number(button.value);
		}

		// Set imm/res/vul ignore & downgrade
		else if (button.classList.contains("change-source")) {
			const { type, change } = button.dataset;
			if (change === "immunity") {
				if (options.ignore?.immunity?.has(type)) {
					options.ignore.immunity.delete(type);
					options.downgrade ??= new Set();
					options.downgrade.add(type);
				} else if (options.downgrade?.has(type)) {
					options.downgrade.delete(type);
				} else {
					options.ignore ??= {};
					options.ignore.immunity ??= new Set();
					options.ignore.immunity.add(type);
				}
			} else if (change === "threshold") {
				options.ignore ??= {};
				options.ignore.threshold = !options.ignore.threshold;
			} else if (options.ignore?.[change]?.has(type)) options.ignore[change].delete(type);
			else {
				options.ignore ??= {};
				options.ignore[change] ??= new Set();
				options.ignore[change].add(type);
			}
		}

		const token = fromUuidSync(uuid);
		const entry = this.targetList.querySelector(`[data-target-uuid="${token.uuid}"]`);
		this.refreshListEntry(token, entry, options);
	}
}

/**
 * Custom element for displaying the list of damages on an activity.
 */
class DamageListElement extends FormAssociatedElement {
	connectedCallback() {
		super.connectedCallback();

		const damageCollection = foundry.utils.getProperty(this.activity, this.name);

		if (this.single) {
			this._toggleState(null, !!damageCollection?.custom?.enabled);
		} else {
			for (const li of this.querySelectorAll("[data-index]")) {
				const selected = li.querySelector('[name$=".custom.enabled"]');
				this._toggleState(li.dataset.index, selected?.value === "true");
			}
		}

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener("click", event => {
				event.stopImmediatePropagation();
				this._onAction(event.currentTarget, event.currentTarget.dataset.action);
			});
		}

		if (this.single) this.querySelectorAll('[data-action="delete"]').forEach(e => e.remove());
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activity represented by the app.
	 * @type {Activity}
	 */
	get activity() {
		return this.app.activity;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does the user have permission to edit the document?
	 * @type {boolean}
	 */
	get isEditable() {
		return this.activity.item.testUserPermission(game.user, "EDIT");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does this represent only a single entry, rather than a list?
	 * @type {boolean}
	 */
	get single() {
		return this.hasAttribute("single");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {Element} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @returns {Promise|void}
	 * @protected
	 */
	_onAction(target, action) {
		const event = new CustomEvent("damage", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (!this.isEditable || target.dispatchEvent(event) === false) return;

		const li = target.closest("li");
		const index = li?.dataset.index;
		const damageCollection = foundry.utils.getProperty(this.activity.toObject(), this.name) ?? [];

		switch (action) {
			case "add":
				damageCollection.push({});
				break;
			case "customize":
				const enabled = li.querySelector('input[name$=".custom.enabled"]');
				const formula = li.querySelector('input[name$=".custom.formula"]');
				if (!enabled) return;
				if (enabled.value === "true") {
					enabled.value = "false";
				} else {
					enabled.value = "true";
					if (!formula.value) formula.value = this._createFormula(index);
				}
				return this.app.submit();
			case "delete":
				damageCollection.splice(index, 1);
				break;
			default:
				return;
		}

		return this.app.submit({ updateData: { [this.name]: damageCollection } });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a formula based on the values at the given index.
	 * @param {number} index - Index of the damage entry within the damage collection.
	 * @returns {string} - Formula that can be used as the basis of a custom formula.
	 * @internal
	 */
	_createFormula(index) {
		let damage = foundry.utils.getProperty(this.activity.toObject(), this.name);
		if (!this.single) damage = damage[index];
		if (damage.denomination) {
			const dice = `${damage.number || 1}d${damage.denomination}`;
			return damage.bonus ? `${dice} + ${damage.bonus}` : dice;
		}
		return damage.bonus ?? "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Change between normal editing mode & custom formula mode.
	 * @param {number} index - Index of the damage entry within the damage collection.
	 * @param {boolean} showCustomFormula - Should custom formula or normal controls be displayed?
	 * @internal
	 */
	_toggleState(index, showCustomFormula) {
		const li = this.querySelector(this.single ? "li" : `[data-index="${index}"]`);
		if (showCustomFormula) li.dataset.customFormula = "";
		else delete li.dataset.customFormula;

		const normal = ["die-count", "die-denomination", "plus", "bonus"];
		for (const cls of normal) {
			const element = li.querySelector(`.${cls}`);
			if (showCustomFormula) element?.classList.add("hidden");
			else element?.classList.remove("hidden");
		}

		const formulaElement = li.querySelector(".custom");
		if (showCustomFormula) formulaElement?.classList.remove("hidden");
		else formulaElement?.classList.add("hidden");

		const control = li.querySelector('[data-action="customize"]');
		if (showCustomFormula) control?.classList.add("active");
		else control?.classList.remove("active");
	}
}

/**
 * Custom element for displaying and rolling death saves.
 */
class DeathSavesElement extends AppAssociatedElement {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor represented by the app.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.app.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Death saving information on the actor.
	 * @type {object}
	 */
	get death() {
		return this.actor.system.attributes.death;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		super.connectedCallback();

		const buttons = [];
		for (const type of ["failure", "success"]) {
			const key = `BF.Death.${type.capitalize()}`;
			for (const number of Array.fromRange(3, 1)) {
				const n = type === "failure" ? 4 - number : number;
				buttons.push({
					classes: type,
					n,
					filled: this.death[type] >= n,
					tooltip: `${key}.Label`,
					label: game.i18n.format(`${key}.Count`, { count: numberFormat(n, { ordinal: true }) })
				});
			}
		}

		const makeButton = b => `
			<button type="button" class="${b.classes}" data-n="${b.n}" data-tooltip="${b.tooltip}"
			  aria-label="${b.label}" aria-pressed="${b.filled}"></button>
		`;
		this.insertAdjacentHTML(
			"afterbegin",
			`
			<button type="button" data-action="roll" aria-label="roll death save">
				<blackFlag-icon src="systems/black-flag/artwork/interface/death-save.svg"></blackFlag-icon>
			</button>
			<div class="levels">
				${buttons.map(b => makeButton(b)).join("")}
			</div>
			<slot></slot>
		`
		);

		this.querySelector('[data-action="roll"]').addEventListener("click", this._onRoll.bind(this));
		for (const button of this.querySelectorAll(".levels button")) {
			button.addEventListener("click", this._onModifySuccessFailure.bind(this));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle rolling a death save.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	_onRoll(event) {
		event.stopImmediatePropagation();
		this.actor.rollDeathSave();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking one of the success/failure buttons.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	_onModifySuccessFailure(event) {
		const type = event.target.classList.contains("success") ? "success" : "failure";
		const n = Number(event.target.dataset.n);
		const newValue = this.death[type] === n ? this.death[type] - 1 : n;
		this.actor.update({ [`system.attributes.death.${type}`]: newValue });
	}
}

/**
 * Application to handle applying active effects from a chat card.
 */
class EffectApplicationElement extends TargetedApplicationElement(ChatTrayElement) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Active effects that will be applied by this application.
	 * @type {BlackFlagActiveEffect[]}
	 */
	effects = [];

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The list of active effects.
	 * @type {HTMLUListElement}
	 */
	effectsList;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Checked status for application targets.
	 * @type {Map<string, boolean>}
	 */
	#targetOptions = new Map();

	/**
	 * Options for a specific target.
	 * @param {string} uuid - UUID of the target.
	 * @returns {boolean} - Should this target be checked?
	 */
	targetChecked(uuid) {
		if (this.targetingMode === "selected") return true;
		return this.#targetOptions.get(uuid) ?? true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	connectedCallback() {
		super.connectedCallback();
		if (!this.message) return;

		// Build the frame HTML only once
		if (!this.effectsList || !this.targetList) {
			if (!this.effects.length) {
				const item = this.message.getAssociatedItem();
				this.effects = Array.from(this.querySelectorAll("option"))
					.map(o => item?.effects.get(o.value))
					.filter(_ => _);
			}

			const div = document.createElement("div");
			div.classList.add("card-tray", "effects-tray", "collapsible");
			if (!this.open) div.classList.add("collapsed");
			div.innerHTML = `
				<label>
					<i class="fa-solid fa-bolt" inert></i>
					<span>${game.i18n.localize("BF.EFFECT.Application.Label")}</span>
					<i class="fa-solid fa-caret-down" inert></i>
				</label>
				<div class="collapsible-content">
					<div class="wrapper">
						<hr>
						<menu class="effects unlist"></menu>
					</div>
				</div>
			`;
			this.replaceChildren(div);
			this.effectsList = div.querySelector(".effects");
			this.buildEffectsList();
			div.querySelector(".wrapper").prepend(...this.buildTargetContainer());
			this.targetList.addEventListener("change", this._onCheckTarget.bind(this));
			div.addEventListener("click", this._handleClickToggle.bind(this));
		}

		this.targetingMode = this.targetSourceControl.hidden ? "selected" : "targeted";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Build a list of active effects.
	 */
	buildEffectsList() {
		for (const effect of this.effects) {
			const li = document.createElement("li");
			li.classList.add("effect");
			li.dataset.id = effect.id;
			li.innerHTML = `
				<img class="icon">
				<div class="name-stacked">
					<span class="title"></span>
					<span class="subtitle">${effect.duration.label}</span>
				</div>
				<button class="apply-effect light-button" type="button" data-action="applyEffect"
								data-tooltip="BF.EFFECT.Action.ApplyTokens"
								aria-label="${game.i18n.localize("BF.EFFECT.Action.ApplyTokens")}">
					<i class="fas fa-reply-all fa-flip-horizontal" inert></i>
				</button>
			`;
			Object.assign(li.querySelector(".icon"), { alt: effect.name, src: effect.img });
			li.querySelector(".title").innerText = effect.name;
			this.effectsList.append(li);
			li.addEventListener("click", this._onApplyEffect.bind(this));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	buildTargetListEntry({ uuid, name }) {
		const actor = fromUuidSync(uuid);
		if (!actor?.isOwner) return;

		const disabled = this.targetingMode === "selected" ? " disabled" : "";
		const checked = this.targetChecked(uuid) ? " checked" : "";

		const li = document.createElement("li");
		li.classList.add("target");
		li.dataset.targetUuid = uuid;
		li.innerHTML = `
			<img class="icon circular" data-uuid="${actor.uuid}">
			<div class="name-stacked">
				<span class="title"></span>
			</div>
			<div class="checkbox">
				<input type="checkbox" name="${uuid}"${checked}${disabled}></input>
			</div>
		`;
		Object.assign(li.querySelector(".icon"), { alt: name, src: actor.img });
		li.querySelector(".title").innerText = name;

		return li;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle applying an Active Effect to a Token.
	 * @param {BlackFlagActiveEffect} effect - The effect to apply.
	 * @param {BlackFlagActor} actor - The actor.
	 * @returns {Promise<BlackFlagActiveEffect>} - The created effect.
	 * @throws {Error} - If the effect could not be applied.
	 * @protected
	 */
	async _applyEffectToActor(effect, actor) {
		const origin = effect;
		if (!game.user.isGM && !actor.isOwner) {
			throw new Error(game.i18n.localize("BF.EFFECT.Application.Warning.NotOwner"));
		}

		const effectFlags = {
			flags: {
				[game.system.id]: {
					scaling: this.message.getFlag(game.system.id, "scaling"),
					spellSlot: this.message.getFlag(game.system.id, "spellSlot")
				}
			}
		};

		// Enable an existing effect on the target if it originated from this effect
		const existingEffect = actor.effects.find(e => e.origin === origin.uuid);
		if (existingEffect) {
			return existingEffect.update(
				foundry.utils.mergeObject(
					{
						...effect.constructor.getInitialDuration(),
						disabled: false
					},
					effectFlags
				)
			);
		}

		// Otherwise, create a new effect on the target
		const effectData = foundry.utils.mergeObject(
			{
				...effect.toObject(),
				disabled: false,
				transfer: false,
				origin: origin.uuid
			},
			effectFlags
		);
		const applied = await ActiveEffect.implementation.create(effectData, { parent: actor });
		return applied;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking the apply effect button.
	 * @param {PointerEvent} event - Triggering click event.
	 */
	async _onApplyEffect(event) {
		event.preventDefault();
		const effect = this.message.getAssociatedItem()?.effects.get(event.target.closest("[data-id]")?.dataset.id);
		if (!effect) return;
		for (const target of this.targetList.querySelectorAll("[data-target-uuid]")) {
			const actor = fromUuidSync(target.dataset.targetUuid);
			if (!actor || !target.querySelector("input")?.checked) continue;
			try {
				await this._applyEffectToActor(effect, actor);
			} catch (err) {
				Hooks.onError("EffectApplicationElement._applyEffectToToken", err, { notify: "warn", log: "warn" });
			}
		}
		this.querySelector(".collapsible").dispatchEvent(new PointerEvent("click", { bubbles: true, cancelable: true }));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle checking or unchecking a target.
	 * @param {Event} event - Triggering change event.
	 */
	_onCheckTarget(event) {
		const uuid = event.target.closest("[data-target-uuid]")?.dataset.targetUuid;
		if (!uuid) return;
		this.#targetOptions.set(uuid, event.target.checked);
	}
}

/**
 * Custom element for displaying a single inventory filter.
 */
class FilterElement extends AppAssociatedElement {
	static formAssociated = true;

	/* <><><><> <><><><> <><><><> <><><><> */

	constructor() {
		super();
		this.#controller = new AbortController();
		this.#filter = this.getAttribute("filter");
		this.#internals = this.attachInternals();
		this.#shadowRoot = this.attachShadow({ mode: "closed" });
		if (this.hasAttribute("value")) this.#value = this.getAttribute("value");

		const style = document.createElement("style");
		style.innerText = `
		  :host {
				--filter-indicator-display: inline-block;
				--filter-indicator-size: 0.5em;
				--filter-indicator-border-color: currentcolor;
				--filter-indicator-border: 1px solid var(--filter-indicator-border-color);
				--filter-indicator-positive-color: #5cff5c;
				--filter-indicator-negative-color: #ff6767;
				--filter-indicator-text-color: black;
			}
			:host > .frame {
				position: relative;
				display: var(--filter-indicator-display);
				width: var(--filter-indicator-size);
				height: var(--filter-indicator-size);
				border: var(--filter-indicator-border);
				border-radius: var(--filter-indicator-size);
				&[data-value="-1"] { background-color: var(--filter-indicator-negative-color); }
				&[data-value="1"] { background-color: var(--filter-indicator-positive-color); }

				> span {
					position: absolute;
					inset: 0;
					inset-block-start: -1px;
					display: grid;
					place-content: center;
					color: var(--filter-indicator-text-color);
					font-size: 0.8em;
					font-weight: 100;
					text-shadow: none;
				}
			}
		`;
		this.#shadowRoot.appendChild(style);

		const span = document.createElement("span");
		span.classList.add("frame");
		this.#shadowRoot.appendChild(span);
		const text = document.createElement("span");
		text.classList.add("text");
		span.appendChild(text);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		super.connectedCallback();
		this.#filters = this.closest("blackFlag-filters");
		this.#value = this.#filters?.getValueOf(this.#filter);
		this.#matchInternalState();

		if (!this.hasAttribute("name")) this.setAttribute("name", this.name);

		this.addEventListener("click", this.#onClick.bind(this), { signal: this.#controller.signal });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		this.#controller.abort();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Controller for handling removal of event listeners.
	 * @type {AbortController}
	 */
	#controller;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Form that contains this control.
	 * @type {HTMLFormElement}
	 */
	get form() {
		return this.#internals.form;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Name of the filter targeted by this control.
	 * @type {string}
	 */
	#filter;

	get filter() {
		return this.#filter;
	}

	set filter(value) {
		this.#filter = value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Reference to the containing <blackFlag-filters> element.
	 * @type {FiltersElement}
	 */
	#filters;

	get filters() {
		return this.#filters;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Internal element implementation.
	 * @type {ElementInternals}
	 */
	#internals;

	/* <><><><> <><><><> <><><><> <><><><> */

	get name() {
		return `filters.${this.filters?.tab}.${this.filter}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Shadow root.
	 * @type {ShadowRoot}
	 */
	#shadowRoot;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Value of this filter. Can be `0` (no filter), `+1` (only items that match), or `-1` (no items that match).
	 * @type {number}
	 */
	#value;

	get value() {
		return this.#value;
	}

	set value(value) {
		value = parseInt(value);
		if (![-1, 0, 1].includes(value)) throw new Error("Filter value must be -1, 0, or +1.");
		this.#value = value;
		this.#matchInternalState();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set the internal styling to match the current value.
	 */
	#matchInternalState() {
		this.#internals.setFormValue(this.#value ?? 0);
		this.#shadowRoot.querySelector(".frame").dataset.value = this.#value ?? 0;
		this.#shadowRoot.querySelector(".text").innerText = this.#value === 1 ? "+" : this.#value === -1 ? "-" : "";
		this.setAttribute("value", this.#value ?? 0);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking on the control.
	 * @param {PointerEvent} event - The triggering click event.
	 */
	#onClick(event) {
		if (this.value === 1) this.value = -1;
		else this.value = (this.value ?? 0) + 1;
		this.dispatchEvent(new Event("change", { bubbles: true }));
	}
}

/**
 * Custom element for displaying SVG icons that are cached and can be styled.
 */
class IconElement extends HTMLElement {
	constructor() {
		super();
		this.#internals = this.attachInternals();
		this.#internals.role = "img";
		this.#shadowRoot = this.attachShadow({ mode: "closed" });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The custom element's form and accessibility internals.
	 * @type {ElementInternals}
	 */
	#internals;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Shadow root that contains the icon.
	 * @type {ShadowRoot}
	 */
	#shadowRoot;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stylesheet that is shared among all icons.
	 * @type {CSSStyleSheet}
	 */
	static #stylesheet;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Cached SVG files grouped by path.
	 * @type {Map<string, SVGElement|Promise<SVGElement>>}
	 */
	static #svgCache = new Map();

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Path to the SVG source file.
	 * @type {string}
	 */
	get src() {
		return this.getAttribute("src");
	}

	set src(src) {
		this.setAttribute("src", src);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Methods                 */
	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		// Create icon styles or fetch the shared stylesheet
		if (!this.constructor.#stylesheet) {
			this.constructor.#stylesheet = new CSSStyleSheet();
			this.constructor.#stylesheet.replaceSync(`
				:host {
					display: contents;
					--_icon-fill: var(--icon-fill, currentcolor);
					--_icon-width: var(--icon-width, var(--icon-size, 1em));
					--_icon-height: var(--icon-height, var(--icon-size, 1em));
				}
				svg {
					fill: var(--_icon-fill, #000);
					width: var(--_icon-width, 1em);
					height: var(--_icon-height, 1em);
				}
			`);
		}
		this.#shadowRoot.adoptedStyleSheets = [this.constructor.#stylesheet];

		const insertElement = element => {
			if (!element) return;
			const clone = element.cloneNode(true);
			this.#shadowRoot.replaceChildren(clone);
		};

		// Insert element immediately if already available, otherwise wait for fetch
		const element = this.constructor.fetch(this.src);
		if (element instanceof Promise) element.then(insertElement);
		else insertElement(element);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch an SVG element from a source.
	 * @param {string} src - Path of the SVG file to retrieve.
	 * @returns {SVGElement|Promise<SVGElement>} - Promise if the element is not cached, otherwise the element directly.
	 */
	static fetch(src) {
		if (!this.#svgCache.has(src))
			this.#svgCache.set(
				src,
				fetch(src)
					.then(b => b.text())
					.then(t => {
						const temp = document.createElement("div");
						temp.innerHTML = t;
						const svg = temp.querySelector("svg");
						this.#svgCache.set(src, svg);
						return svg;
					})
			);
		return this.#svgCache.get(src);
	}
}

/**
 * Custom element for displaying luck controls on a chat message.
 */
class MessageLuckElement extends MessageAssociatedElement {
	/**
	 * How long should luck be able to be applied to rolls (in milliseconds).
	 * @type {number}
	 */
	static LUCK_CONTROL_PERIOD = 5 * 60 * 1000;

	/* <><><><> <><><><> <><><><> <><><><> */

	connectedCallback() {
		super.connectedCallback();
		this.replaceChildren();
		this.#createLuckInterface();
		this.#hookID = Hooks.on("updateActor", this.#onUpdateActor.bind(this));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		Hooks.off("updateActor", this.#hookID);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	#createLuckInterface() {
		// Add controls based on current status
		const createLuckPoints = (total, selected) => {
			let text = "";
			for (const number of Array.fromRange(total, 1)) {
				text += `<li class="luck-point${number <= selected ? " selected" : ""}"></li>\n`;
			}
			return text;
		};

		const config = CONFIG.BlackFlag.luck;
		const luckAvailable = this.actor.system.attributes.luck.value;

		this.innerHTML = `
			<div class="luck-controls">
				<div class="luck-total">
					<span>Luck</span>
					<ol class="luck-points">
						${createLuckPoints(config.max, luckAvailable)}
					</ol>
				</div>
				<button data-action="luck-bonus" data-tooltip="${game.i18n.localize("BF.Luck.Action.Bonus")}">
					<i class="fa-solid fa-plus"></i>
					<ol class="luck-points cost">
						${createLuckPoints(config.costs.bonus)}
					</ol>
				</button>
				<button data-action="luck-reroll" data-tooltip="${game.i18n.localize("BF.Luck.Action.Reroll")}">
					<i class="fa-solid fa-clock-rotate-left"></i>
					<ol class="luck-points cost">
						${createLuckPoints(config.costs.reroll)}
					</ol>
				</button>
			</div>
		`;

		// Disable controls that don't have enough luck & add event listeners
		const bonusButton = this.querySelector('[data-action="luck-bonus"]');
		const rerollButton = this.querySelector('[data-action="luck-reroll"]');
		bonusButton.addEventListener("click", e => this.#onLuckBonus(e));
		rerollButton.addEventListener("click", e => this.#onLuckReroll(e));
		if (luckAvailable < config.costs.bonus) bonusButton.disabled = true;
		if (luckAvailable < config.costs.reroll) rerollButton.disabled = true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	get actor() {
		// TODO: Adjust this logic to work fully with unlinked tokens
		return game.actors.get(this.message.speaker.actor);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * ID of the change listener.
	 * @type {number}
	 */
	#hookID;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should the luck interface even be displayed?
	 * @param {BlackFlagChatMessage} message - Message for which the luck could be added.
	 * @returns {boolean}
	 */
	static shouldDisplayLuckInterface(message) {
		// Grab the actor who performed the roll
		const actor = message.getAssociatedActor();

		// Must have rolls to apply luck
		if (!message.rolls?.length) return false;

		// Only user who performed the roll should see the UI
		if (message.author !== game.user) return false;

		// Only PCs can spend luck
		if (actor?.type !== "pc") return false;

		// Only display the UI if roll was within the past 5 minutes
		if (message.timestamp < Date.now() - this.LUCK_CONTROL_PERIOD) return false;

		// Only display initiative rolls if a combatant is found
		if (message.getFlag("core", "initiativeRoll")) return !!message.getCombatant();

		// Only certain roll types can be modified by luck
		const rollType = message.getFlag(game.system.id, "roll.type");
		return CONFIG.BlackFlag.luck.validRollTypes.has(rollType);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle increasing a roll result by spending luck.
	 * @param {ClickEvent} event - Triggering click event.
	 * @returns {Promise}
	 */
	async #onLuckBonus(event) {
		const actor = this.actor;

		// Ensure there is enough luck on actor to spend
		const cost = CONFIG.BlackFlag.luck.costs.bonus;
		if (actor.system.attributes.luck.value < cost) {
			return ui.notifications.warn("BF.Luck.Warning.Insufficient", { localize: true });
		}

		// Fetch the roll
		const rollIndex = this.message.rolls.findIndex(r => r instanceof CONFIG.Dice.ChallengeRoll);
		const roll = this.message.rolls[rollIndex];
		if (!roll) return;
		const originalTotal = roll.total;

		// Update the roll with bonus
		let bonusTerm = roll.terms.find(t => t.options.luckBonus);
		if (!bonusTerm) {
			const operatorTerm = new foundry.dice.terms.OperatorTerm({ operator: "+" });
			await operatorTerm.evaluate();
			roll.terms.push(operatorTerm);
			bonusTerm = new foundry.dice.terms.NumericTerm({ number: 0, options: { luckBonus: true } });
			await bonusTerm.evaluate();
			roll.terms.push(bonusTerm);
		}
		bonusTerm.number += 1;
		roll._total = roll._evaluateTotal();
		roll.resetFormula();

		// Store the modified roll back as JSON
		const rollCollection = this.message.toObject().rolls;
		rollCollection[rollIndex] = JSON.stringify(roll.toJSON());
		const messageUpdates = { rolls: rollCollection };

		// Set flag to track luck spent
		const previousBonus = this.message.flags[game.system.id]?.luck?.bonus ?? 0;
		messageUpdates[`flags.${game.system.id}.luck.bonus`] = previousBonus + 1;

		// Spend luck on actor
		await actor.update(
			{ "system.attributes.luck.value": actor.system.attributes.luck.value - cost },
			{ fromLuckCard: this.message.id }
		);

		// Update initiative if necessary
		if (this.message.getFlag("core", "initiativeRoll")) {
			await this.message.getCombatant(originalTotal)?.update({ initiative: roll.total });
		}

		// Re-render the chat message
		await this.message.update(messageUpdates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle re-rolling a single die by spending luck.
	 * @param {ClickEvent} event - Triggering click event.
	 * @returns {Promise}
	 */
	async #onLuckReroll(event) {
		const actor = this.actor;

		// Ensure there is enough luck on actor to spend
		const cost = CONFIG.BlackFlag.luck.costs.reroll;
		if (actor.system.attributes.luck.value < cost) {
			return ui.notifications.warn("BF.Luck.Warning.Insufficient", { localize: true });
		}

		// Only a single re-roll is allowed
		if (this.message.flags[game.system.id]?.luck?.reroll) {
			return ui.notifications.warn("BF.Luck.Warning.OnlyOneReroll", { localize: true });
		}

		// Fetch the roll
		const rollIndex = this.message.rolls.findIndex(r => r instanceof CONFIG.Dice.ChallengeRoll);
		const roll = this.message.rolls[rollIndex];
		if (!roll) return;
		const originalTotal = roll.total;

		// If more than one result is present, prompt for which should be re-rolled
		const die = roll.challengeDie;
		const resultValues = new Set();
		let results = die.results.filter(r => {
			if (resultValues.has(r.result)) return false;
			resultValues.add(r.result);
			return !r.rerolled;
		});
		let result = results[0];
		if (resultValues.size > 1) {
			// Prompt for which die to re-roll
			result = await BlackFlagDialog.tooltipWait(
				{ element: event.currentTarget },
				{
					content: game.i18n.localize("BF.Luck.RerollPrompt"),
					buttons: results.reduce((obj, r) => {
						obj[r.result] = { label: r.result, callback: html => r };
						return obj;
					}, {}),
					render: true
				}
			);
		}

		// Update the roll with a re-rolled value (somehow)
		result.active = true;
		await die.reroll(`r1=${result.result}`);
		const rerolledDie = results.find(r => r.rerolled);
		if (rerolledDie) rerolledDie.luckReroll = true;
		// TODO: Play dice rolling sound?

		// After the re-roll, keep & drop modifiers should still be respected
		const keepDropModifiers = die.modifiers.reduce((arr, modifier) => {
			const key = Object.keys(die.constructor.MODIFIERS)
				.sort((a, b) => b.length - a.length)
				.find(c => modifier.startsWith(c));
			const command = die.constructor.MODIFIERS[key];
			if (["keep", "drop"].includes(command)) arr.push({ modifier, command });
			return arr;
		}, []);
		if (keepDropModifiers.length) {
			die.results
				.filter(r => !r.rerolled)
				.forEach(d => {
					d.active = true;
					d.discarded = false;
				});
			keepDropModifiers.forEach(({ modifier, command }) => die[command](modifier));
		}
		roll._total = roll._evaluateTotal();

		// TODO: Ensure minimum roll modifier is still respected

		// Store the modified roll back as JSON
		const rollCollection = this.message.toObject().rolls;
		rollCollection[rollIndex] = JSON.stringify(roll.toJSON());
		const messageUpdates = { rolls: rollCollection };

		// Set flag to track luck spent
		messageUpdates[`flags.${game.system.id}.luck.reroll`] = true;

		// Spend luck on actor
		await actor.update(
			{ "system.attributes.luck.value": actor.system.attributes.luck.value - cost },
			{ fromLuckCard: this.message.id }
		);

		// Update initiative if necessary
		if (this.message.getFlag("core", "initiativeRoll")) {
			await this.message.getCombatant(originalTotal)?.update({ initiative: roll.total });
		}

		// Re-render the chat message
		await this.message.update(messageUpdates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Watch for changes to luck on the associated actor.
	 * @param {BlackFlagActor} actor - Actor that was changed.
	 * @param {object} changes - Changes applied.
	 * @param {object} options - Options for the change.
	 * @param {string} userId - ID of the user who performed the change.
	 */
	#onUpdateActor(actor, changes, options, userId) {
		if (
			actor !== this.actor ||
			options.fromLuckCard === this.message.id ||
			!foundry.utils.hasProperty(changes, "system.attributes.luck.value")
		)
			return;
		if (this.constructor.shouldDisplayLuckInterface(this.message)) {
			this.replaceChildren();
			this.#createLuckInterface();
		} else {
			this.remove();
		}
	}
}

/**
 * Custom element for allowing multiple selections.
 */
class MultiSelectElement extends FormAssociatedElement {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Methods                 */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	connectedCallback() {
		let dropdown = this.querySelector(".dropdown");
		if (dropdown) {
			dropdown.replaceChildren();
		} else {
			dropdown = document.createElement("div");
			dropdown.classList.add("dropdown");
			this.appendChild(dropdown);
		}

		const button = document.createElement("button");
		button.classList.add("dropdown-button");
		button.type = "button";
		button.innerHTML = `
			<span class="label">${this.getAttribute("label")}</span>
			<span class="icon"><i class="fa-solid fa-angles-down" inert></i></span>
		`;
		dropdown.appendChild(button);

		const list = document.createElement("ul");
		list.classList.add("select-list");
		dropdown.appendChild(list);

		const options = this.querySelectorAll("datalist option");
		for (const option of options) {
			const item = document.createElement("li");
			item.classList.add("select-entry");
			item.innerHTML = `
				<label>
					<span class="label">${option.innerText}</span>
					<input type="checkbox" name="$.${option.value}"${option.selected ? " checked" : ""}>
				</label>
			`;
			list.appendChild(item);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_mutateFormData(object) {
		return filteredKeys(object);
	}
}

/**
 * Custom element for displaying limited uses & recovery details.
 */
class UsesElement extends FormAssociatedElement {
	connectedCallback() {
		super.connectedCallback();

		for (const element of this.querySelectorAll("[data-action]")) {
			element.addEventListener("click", event => {
				event.stopImmediatePropagation();
				this.#onAction(event.currentTarget, event.currentTarget.dataset.action);
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Document represented by the app.
	 * @type {Activity|BlackFlagItem}
	 */
	get document() {
		return this.app.activity ?? this.app.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine which recovery periods are still available for creation.
	 * @type {string[]}
	 */
	get validPeriods() {
		const recoveryCollection = foundry.utils.getProperty(this.document.toObject(), `${this.name}.recovery`);
		const existingPeriods = new Set(recoveryCollection?.map(r => r.period));
		return Object.keys(CONFIG.BlackFlag.recoveryPeriods).filter(p => !existingPeriods.has(p));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle one of the actions from the buttons or context menu.
	 * @param {Element} target - Button or context menu entry that triggered this action.
	 * @param {string} action - Action being triggered.
	 * @returns {Promise|void}
	 */
	#onAction(target, action) {
		const event = new CustomEvent("uses", {
			bubbles: true,
			cancelable: true,
			detail: action
		});
		if (!this.isEditable || target.dispatchEvent(event) === false) return;

		const li = target.closest("[data-index]");
		const index = li?.dataset.index;
		const recoveryCollection = foundry.utils.getProperty(this.document.toObject(), `${this.name}.recovery`) ?? [];
		if (action !== "add" && !index) return;
		switch (action) {
			case "add":
				const validPeriods = this.validPeriods;
				if (!validPeriods.length) return;
				recoveryCollection.push({
					period: validPeriods[0]
				});
				break;
			case "delete":
				recoveryCollection.splice(index, 1);
				break;
			default:
				return;
		}

		return this.app.submit({ updateData: { [`${this.name}.recovery`]: recoveryCollection } });
	}
}

/**
 * Custom element for displaying the XP bar on the character sheet.
 */
class XPBarElement extends AppAssociatedElement {
	connectedCallback() {
		super.connectedCallback();

		const xp = this.actor?.system.progression?.xp;
		if (!xp) return;
		this.innerHTML = `
			<div role="meter"></div>
			<label id="${this.app.id}-xp-bar-label">${game.i18n.localize("BF.ExperiencePoints.Label")}</label>
			<div class="input">
				<input type="number" name="xpChange" placeholder="${game.i18n.localize("BF.ExperiencePoints.Action.Add")}">
				<button type="submit" name="addXP"><i class="fa-solid fa-plus"></i></button>
			</div>
			<div class="values">
				<span class="min"></span>
				<span class="sep">/</span>
				<span class="max"></span>
			</div>
		`;
		this.#setValues();
		this.querySelector('[name="xpChange"]').addEventListener("change", event => event.stopPropagation());
		this.querySelector("button").addEventListener("click", this.#onSubmit.bind(this));
		this.#hookID = Hooks.on("updateActor", this.#onUpdateActor.bind(this));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	disconnectedCallback() {
		Hooks.off("updateActor", this.#hookID);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set the various values to match what is configured on actor.
	 */
	#setValues() {
		const xp = this.actor.system.progression?.xp;
		const bar = this.querySelector('[role="meter"]');
		bar.style = `--bar-percentage: ${xp.percentage}%;`;
		bar.setAttribute("aria-valuenow", xp.percentage);
		bar.setAttribute("aria-valuetext", game.i18n.format("BF.ExperiencePoints.LabelSpecific", { value: xp.value }));
		bar.setAttribute("aria-valuemin", xp.min);
		bar.setAttribute("aria-valuemax", xp.max);
		this.querySelector('[name="xpChange"]').value = "";
		this.querySelector(".values .min").innerText = numberFormat(xp.value);
		this.querySelector(".values .max").innerText = numberFormat(xp.max);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * ID of the change listener.
	 * @type {number}
	 */
	#hookID;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor that this XP bar is representing.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.app.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle updating XP.
	 * @param {ClickEvent} event - Triggering click event.
	 */
	async #onSubmit(event) {
		event.preventDefault();
		const input = this.querySelector('[name="xpChange"]');
		if (Number.isNumeric(input.valueAsNumber)) {
			const value = Math.round(input.valueAsNumber);
			const update = {
				value: this.actor.system.progression.xp.value + value,
				log: this.actor.system.progression.xp.log.concat([{ amount: value, source: "manual" }])
			};
			await this.actor.update({ "system.progression.xp": update }, { render: false });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Watch for changes to XP on this actor.
	 * @param {BlackFlagActor} actor - Actor that was changed.
	 * @param {object} changes - Changes applied.
	 * @param {object} options - Options for the change.
	 * @param {string} userId - ID of the user who performed the change.
	 */
	#onUpdateActor(actor, changes, options, userId) {
		if (actor !== this.actor || !foundry.utils.hasProperty(changes, "system.progression.xp.value")) return;
		this.#setValues();
	}
}

var _module$o = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActionsElement: ActionsElement,
	ActivitiesElement: ActivitiesElement,
	AdvancementElement: AdvancementElement,
	AppAssociatedElement: AppAssociatedElement,
	AttackResultElement: AttackResultElement,
	ChatTrayElement: ChatTrayElement,
	ConsumptionElement: ConsumptionElement,
	CopyableElement: CopyableElement,
	CurrencyElement: CurrencyElement,
	DamageApplicationElement: DamageApplicationElement,
	DamageListElement: DamageListElement,
	DeathSavesElement: DeathSavesElement,
	DocumentSheetAssociatedElement: DocumentSheetAssociatedElement,
	EffectApplicationElement: EffectApplicationElement,
	EffectsElement: EffectsElement,
	FilterElement: FilterElement,
	FiltersElement: FiltersElement,
	FormAssociatedElement: FormAssociatedElement,
	IconElement: IconElement,
	InventoryElement: InventoryElement,
	MessageAssociatedElement: MessageAssociatedElement,
	MessageLuckElement: MessageLuckElement,
	MultiSelectElement: MultiSelectElement,
	SortingElement: SortingElement,
	TargetedApplicationMixin: TargetedApplicationElement,
	UsesElement: UsesElement,
	XPBarElement: XPBarElement
});

/**
 * Extension of FormApplication to incorporate certain PseudoDocument-specific logic.
 */
class PseudoDocumentSheet extends BFApplication {
	constructor(pseudoDocument, options = {}) {
		super({ document: pseudoDocument, ...options });
		this.#pseudoDocumentId = pseudoDocument.id;
		this.#pseudoDocumentType = pseudoDocument.metadata.name;
		this.#item = pseudoDocument.item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		id: "{id}",
		classes: ["sheet"],
		tag: "form",
		document: null,
		viewPermission: CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED,
		editPermission: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER,
		actions: {
			copyUuid: { handler: PseudoDocumentSheet.#onCopyUuid, buttons: [0, 2] },
			toggleCollapsed: PseudoDocumentSheet.#toggleCollapsed
		},
		form: {
			handler: this.#onSubmitDocumentForm,
			submitOnChange: true,
			closeOnSubmit: false
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The ID of the pseudo document being created or edited.
	 * @type {string}
	 */
	#pseudoDocumentId;

	/**
	 * Collection representing this PseudoDocument.
	 * @type {string}
	 */
	#pseudoDocumentType;

	/**
	 * The PseudoDocument represented by this sheet.
	 * @type {PseudoDocument}
	 */
	get document() {
		return this.item.getEmbeddedDocument(this.#pseudoDocumentType, this.#pseudoDocumentId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Expanded states for additional settings sections.
	 * @type {Map<string, boolean>}
	 */
	#expandedSections = new Map();

	get expandedSections() {
		return this.#expandedSections;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this PseudoDocument sheet visible to the current User?
	 * This is governed by the viewPermission threshold configured for the class.
	 * @type {boolean}
	 */
	get isVisible() {
		return this.item.testUserPermission(game.user, this.options.viewPermission);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this PseudoDocument sheet editable by the current User?
	 * This is governed by the editPermission threshold configured for the class.
	 * @type {boolean}
	 */
	get isEditable() {
		if (this.item.pack) {
			const pack = game.packs.get(this.item.pack);
			if (pack.locked) return false;
		}
		return this.item.testUserPermission(game.user, this.options.editPermission);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Parent item to which this PseudoDocument belongs.
	 * @type {BlackFlagItem}
	 */
	#item;

	get item() {
		return this.#item;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Initialization            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_initializeApplicationOptions(options) {
		options = super._initializeApplicationOptions(options);
		options.uniqueId = CSS.escape(`${this.constructor.name}-${options.document.uuid}`);
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.document = this.document;
		context.editable = this.isEditable;
		context.options = this.options;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _renderFrame(options) {
		const frame = await super._renderFrame(options);

		// Add form options
		if (this.options.tag === "form") frame.autocomplete = "off";

		// Add document ID copy
		const copyLabel = game.i18n.localize("SHEETS.CopyUuid");
		const copyId = `<button type="button" class="header-control fa-solid fa-passport icon" data-action="copyUuid"
														data-tooltip="${copyLabel}" aria-label="${copyLabel}"></button>`;
		this.window.close.insertAdjacentHTML("beforebegin", copyId);

		return frame;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Life-Cycle Handlers         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_canRender(_options) {
		if (!this.isVisible)
			throw new Error(
				game.i18n.format("SHEETS.DocumentSheetPrivate", {
					type: game.i18n.localize(this.document.constructor.metadata.label)
				})
			);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onFirstRender(context, options) {
		super._onFirstRender(context, options);
		this.document.constructor._registerApp(this.document, this);
		this.item.apps[this.id] = this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);

		for (const element of this.element.querySelectorAll("[data-expand-id]")) {
			element
				.querySelector(".collapsible")
				?.classList.toggle("collapsed", !this.#expandedSections.get(element.dataset.expandId));
		}
		if (!this.isEditable) this._disableFields();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_onClose(_options) {
		this.document.constructor._unregisterApp(this.document, this);
		delete this.item?.apps[this.id];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle click events to copy the UUID of this document to clipboard.
	 * @this {PseudoDocumentSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 * @this {DocumentSheetV2}
	 */
	static #onCopyUuid(event, target) {
		event.preventDefault(); // Don't open context menu
		event.stopPropagation(); // Don't trigger other events
		if (event.detail > 1) return; // Ignore repeated clicks
		const id = event.button === 2 ? this.document.id : this.document.uuid;
		const type = event.button === 2 ? "id" : "uuid";
		const label = game.i18n.localize(this.document.constructor.metadata.label);
		game.clipboard.copyPlainText(id);
		ui.notifications.info(game.i18n.format("DOCUMENT.IdCopiedClipboard", { label, type, id }));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle toggling the collapsed state of an additional settings section.
	 * @this {PseudoDocumentSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #toggleCollapsed(event, target) {
		if (event.target.closest(".collapsible-content")) return;
		target.classList.toggle("collapsed");
		this.#expandedSections.set(
			target.closest("[data-expand-id]")?.dataset.expandId,
			!target.classList.contains("collapsed")
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Process form submission for the sheet.
	 * @this {PseudoDocumentSheet}
	 * @param {SubmitEvent} event - The originating form submission event.
	 * @param {HTMLFormElement} form - The form element that was submitted.
	 * @param {FormDataExtended} formData - Processed data for the submitted form.
	 * @returns {Promise<void>}
	 */
	static async #onSubmitDocumentForm(event, form, formData) {
		const submitData = this._prepareSubmitData(event, form, formData);
		await this._processSubmitData(event, form, submitData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare data used to update the PseudoDocument upon form submission.
	 * @param {SubmitEvent} event -  The originating form submission event.
	 * @param {HTMLFormElement} form - The form element that was submitted.
	 * @param {FormDataExtended} formData - Processed data for the submitted form.
	 * @returns {object} - Prepared submission data as an object.
	 * @protected
	 */
	_prepareSubmitData(event, form, formData) {
		const submitData = this._processFormData(event, form, formData);
		// TODO: Handle validation
		return submitData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Customize how form data is extracted into an expanded object.
	 * @param {SubmitEvent} event - The originating form submission event.
	 * @param {HTMLFormElement} form - The form element that was submitted.
	 * @param {FormDataExtended} formData - Processed data for the submitted form.
	 * @returns {object} - An expanded object of processed form data.
	 */
	_processFormData(event, form, formData) {
		return foundry.utils.expandObject(formData.object);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Submit a document update based on the processed form data.
	 * @param {SubmitEvent} event - The originating form submission event.
	 * @param {HTMLFormElement} form - The form element that was submitted.
	 * @param {object} submitData - Processed and validated form data to be used for a document update.
	 * @returns {Promise<void>}
	 * @protected
	 */
	async _processSubmitData(event, form, submitData) {
		await this.document.update(submitData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Programmatically submit the form, providing additional data to be merged with form data.
	 * @param {object} options
	 * @param {object} [options.updateData] - Additional data merged with processed form data
	 * @returns {Promise<void>}
	 */
	async submit({ updateData } = {}) {
		const formConfig = this.options.form;
		if (!formConfig?.handler)
			throw new Error(
				`The ${this.constructor.name} PseudoDocumentSheet does not support a single top-level form element.`
			);
		const form = this.element;
		const event = new Event("submit");
		const formData = new FormDataExtended(form);
		const submitData = this._prepareSubmitData(event, form, formData);
		foundry.utils.mergeObject(submitData, updateData, { inplace: true });
		await this._processSubmitData(event, form, submitData);
	}
}

/**
 * Base sheet for activities.
 */
class ActivitySheet extends PseudoDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["activity", "form-list", "standard-form"],
		window: {
			icon: "fa-solid fa-gauge"
		},
		actions: {
			addEffect: ActivitySheet.#addEffect,
			deleteEffect: ActivitySheet.#deleteEffect
		},
		position: {
			width: 600
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		tabs: {
			template: "templates/generic/tab-navigation.hbs"
		},
		identity: {
			template: "systems/black-flag/templates/activity/activity-identity.hbs",
			templates: ["systems/black-flag/templates/activity/parts/activity-identity.hbs"]
		},
		activation: {
			template: "systems/black-flag/templates/activity/activity-activation.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-time.hbs",
				"systems/black-flag/templates/activity/parts/activity-targeting.hbs",
				"systems/black-flag/templates/activity/parts/activity-consumption.hbs",
				"systems/black-flag/templates/activity/parts/activity-consumption-part.hbs",
				"systems/black-flag/templates/shared/parts/activity-affects.hbs",
				"systems/black-flag/templates/shared/parts/activity-range.hbs",
				"systems/black-flag/templates/shared/parts/activity-template.hbs",
				"systems/black-flag/templates/shared/uses-config.hbs"
			]
		},
		effect: {
			template: "systems/black-flag/templates/activity/activity-effect.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Key paths to the parts of the submit data stored in arrays that will need special handling on submission.
	 * @type {string[]}
	 */
	static CLEAN_ARRAYS = ["consumption.targets", "damage.parts", "system.effects"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	tabGroups = {
		sheet: "identity",
		activation: "time"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The activity being created or edited.
	 * @type {Activity}
	 */
	get activity() {
		return this.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return this.activity.name;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		return {
			...(await super._prepareContext(options)),
			activity: this.activity,
			fields: this.activity.schema.fields,
			inferred: this.activity._inferredSource,
			source: this.activity.toObject(),
			system: this.activity.system,
			systemFields: this.activity.system.schema.fields,
			tabs: this._getTabs()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = { ...(await super._preparePartContext(partId, context, options)) };
		switch (partId) {
			case "activation":
				return this._prepareActivationContext(context, options);
			case "effect":
				return this._prepareEffectContext(context, options);
			case "identity":
				return this._prepareIdentityContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the activation tab.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareActivationContext(context, options) {
		context.tab = context.tabs.activation;

		context.data = {};
		context.disabled = {};
		for (const field of ["activation", "duration", "range", "target"]) {
			context.data[field] = this.activity[field].override ? context.source[field] : context.inferred[field];
			context.disabled[field] = this.activity[field].canOverride && !this.activity[field].override;
		}

		const activationOptions = CONFIG.BlackFlag.activationOptions({ chosen: context.data.activation.type });
		const defaultActivation = activationOptions.get(this.item.system.casting?.type)?.label;
		context.activation = {
			options: activationOptions.formOptions(),
			scalar: activationOptions.get(context.data.activation.type)?.scalar ?? false
		};
		if (defaultActivation)
			context.activation.options.unshift(
				{ value: "", label: game.i18n.format("BF.Default.Specific", { default: defaultActivation.toLowerCase() }) },
				{ rule: true }
			);

		context.consumptionTypeOptions = Array.from(this.activity.validConsumptionTypes).map(value => ({
			value,
			label: game.i18n.localize(CONFIG.BlackFlag.consumptionTypes[value].label)
		}));

		context.durationOptions = CONFIG.BlackFlag.durationOptions({
			chosen: this.activity.duration.units,
			isSpell: this.activity.isSpell
		});

		context.rangeOptions = [
			{ value: "", label: "" },
			{ rule: true },
			...CONFIG.BlackFlag.rangeTypes.localizedOptions,
			...CONFIG.BlackFlag.distanceUnits.localizedOptions.map(o => ({
				...o,
				group: game.i18n.localize("BF.Distance.Label")
			}))
		];

		context.showPrimaryActivation = this.activity.isSpell;

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare a specific applied effect if present in the activity data.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {object} effect - Applied effect context being prepared.
	 * @returns {object}
	 * @protected
	 */
	_prepareAppliedEffectContext(context, effect) {
		return effect;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare a specific damage part if present in the activity data.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {object} part - Damage part context being prepared.
	 * @returns {object}
	 * @protected
	 */
	_prepareDamagePartContext(context, part) {
		return part;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the effect tab.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareEffectContext(context, options) {
		context.tab = context.tabs.effect;

		if (context.activity.system.effects) {
			const appliedEffects = new Set(context.activity.system.effects?.map(e => e?._id) ?? []);
			context.allEffects = this.item.effects.map(effect => ({
				value: effect.id,
				label: effect.name,
				selected: appliedEffects.has(effect.id)
			}));
			context.appliedEffects = context.activity.system.effects
				.map((data, index) => {
					if (!data.effect) return null;
					const effect = {
						data,
						collapsed: this.expandedSections.get(`effect.${data._id}`) ? "" : "collapsed",
						effect: data.effect,
						fields: this.activity.system.schema.fields.effects.element.fields,
						link: data.effect.toAnchor().outerHTML,
						prefix: `system.effects.${index}.`,
						source: context.source.system.effects[index] ?? data,
						additionalSettings: null
					};
					return this._prepareAppliedEffectContext(context, effect);
				})
				.filter(_ => _);
		}

		context.denominationOptions = [
			{ value: "", label: "" },
			...CONFIG.BlackFlag.dieSteps.map(value => ({ value, label: `d${value}` }))
		];
		const damageTypes = Object.entries(CONFIG.BlackFlag.damageTypes.localized).map(([value, label]) => ({
			value,
			label
		}));
		if (context.activity.system.damage?.parts) {
			const scalingOptions = [
				{ value: "", label: game.i18n.localize("BF.DAMAGE.Scaling.Mode.None") },
				...Object.entries(CONFIG.BlackFlag.damageScalingModes).map(([value, config]) => ({
					value,
					label: game.i18n.localize(config.label)
				}))
			];
			let indexOffset = 0;
			context.damageParts = context.activity.system.damage.parts.map((data, index) => {
				if (data.base) indexOffset--;
				const part = {
					data,
					fields: this.activity.system.schema.fields.damage.fields.parts.element.fields,
					index: index + indexOffset,
					prefix: `$.${index + indexOffset}.`,
					source: context.source.system.damage.parts[index + indexOffset] ?? data,
					canScale: this.activity.canScaleDamage,
					scalingOptions,
					typeOptions: [
						{ value: "", label: "" },
						...damageTypes,
						{ rule: true },
						{ value: "max", label: game.i18n.localize("BF.DAMAGE.Type.Max") },
						{ value: "variable", label: game.i18n.localize("BF.DAMAGE.Type.Variable") }
					],
					variableTypeOptions: damageTypes.map(({ value, label }) => ({
						value,
						label,
						selected: data.additionalTypes?.has(value)
					}))
				};
				return this._prepareDamagePartContext(context, part);
			});
		}
		context.showBaseDamage = Object.hasOwn(this.item.system, "damage");

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the identity tab.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareIdentityContext(context, options) {
		context.tab = context.tabs.identity;
		context.description = await TextEditor.enrichHTML(context.source.description ?? "", {
			relativeTo: this.activity,
			rollData: this.item.getRollData(),
			secrets: true
		});
		context.placeholder = {
			name: game.i18n.localize(this.activity.metadata.title),
			img: this.activity.metadata.icon
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the tab information for the sheet.
	 * @returns {Record<string, Partial<ApplicationTab>>}
	 * @protected
	 */
	_getTabs() {
		return this._markTabs({
			identity: {
				id: "identity",
				group: "sheet",
				icon: "fa-solid fa-tag",
				label: "BF.ACTIVITY.SECTION.Identity"
			},
			activation: {
				id: "activation",
				group: "sheet",
				icon: "fa-solid fa-clapperboard",
				label: "BF.ACTIVITY.SECTION.Activation",
				tabs: {
					time: {
						id: "time",
						group: "activation",
						icon: "fa-solid fa-clock",
						label: "BF.ACTIVITY.SECTION.Time"
					},
					consumption: {
						id: "consumption",
						group: "activation",
						icon: "fa-solid fa-boxes-stacked",
						label: "BF.ACTIVITY.SECTION.Consumption"
					},
					targeting: {
						id: "activation-targeting",
						group: "activation",
						icon: "fa-solid fa-bullseye",
						label: "BF.ACTIVITY.SECTION.Target"
					}
				}
			},
			effect: {
				id: "effect",
				group: "sheet",
				icon: "fa-solid fa-sun",
				label: "BF.ACTIVITY.SECTION.Effect"
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Helper to mark the tabs data structure with the appropriate CSS class if it is active.
	 * @param {Record<string, Partial<ApplicationTab>>} tabs - Tabs definition to modify.
	 * @returns {Record<string, Partial<ApplicationTab>>}
	 * @internal
	 */
	_markTabs(tabs) {
		for (const v of Object.values(tabs)) {
			v.active = this.tabGroups[v.group] === v.id;
			v.cssClass = v.active ? "active" : "";
			if ("tabs" in v) this._markTabs(v.tabs);
		}
		return tabs;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle creating a new active effect and adding it to the applied effects list.
	 * @this {ActivitySheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #addEffect(event, target) {
		if (!this.activity.system.effects) return;
		const effectData = this._addEffectData();
		const [created] = await this.item.createEmbeddedDocuments("ActiveEffect", [effectData]);
		this.activity.update({ "system.effects": [...this.activity.toObject().system.effects, { _id: created.id }] });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The data for a newly created applied effect.
	 * @returns {object}
	 * @protected
	 */
	_addEffectData() {
		return {
			name: this.item.name,
			img: this.item.img,
			origin: this.item.uuid,
			transfer: false
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle deleting an active effect and removing it from the applied effects list.
	 * @this {ActivitySheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #deleteEffect(event, target) {
		if (!this.activity.system.effects) return;
		const effectId = target.closest("[data-effect-id]")?.dataset.effectId;
		const result = await this.item.effects.get(effectId)?.deleteDialog();
		if (result instanceof ActiveEffect) {
			const effects = this.activity.toObject().system.effects.filter(e => e._id !== effectId);
			this.activity.update({ "system.effects": effects });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Form Submission           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const submitData = super._processFormData(event, form, formData);
		for (const keyPath of this.constructor.CLEAN_ARRAYS) {
			const data = foundry.utils.getProperty(submitData, keyPath);
			if (data) foundry.utils.setProperty(submitData, keyPath, Object.values(data));
		}
		if (foundry.utils.hasProperty(submitData, "appliedEffects")) {
			const effects = submitData.effects ?? this.activity.toObject().system.effects;
			submitData.system ??= {};
			submitData.system.effects = effects.filter(e => submitData.appliedEffects.includes(e._id));
			for (const _id of submitData.appliedEffects) {
				if (submitData.system.effects.find(e => e._id === _id)) continue;
				submitData.system.effects.push({ _id });
			}
		}
		return submitData;
	}
}

/**
 * Application for configuring Attack activities.
 */
class AttackSheet extends ActivitySheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["attack-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		identity: {
			template: "systems/black-flag/templates/activity/attack-identity.hbs",
			templates: [...super.PARTS.identity.templates, "systems/black-flag/templates/activity/parts/attack-identity.hbs"]
		},
		effect: {
			template: "systems/black-flag/templates/activity/attack-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-effects.hbs",
				"systems/black-flag/templates/activity/parts/attack-damage.hbs",
				"systems/black-flag/templates/activity/parts/attack-details.hbs",
				"systems/black-flag/templates/activity/parts/damage-part.hbs",
				"systems/black-flag/templates/activity/parts/damage-parts.hbs"
			]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);
		context.abilityOptions = [
			{ value: "none", label: game.i18n.localize("None") },
			...CONFIG.BlackFlag.abilities.localizedOptions.map(o => ({
				...o,
				group: game.i18n.localize("BF.Ability.Label[other]")
			}))
		];
		const defaultAbility = this.activity.system.defaultAbility;
		if (defaultAbility)
			context.abilityOptions.unshift(
				{
					value: "",
					label: game.i18n.format("BF.Default.Specific", { default: game.i18n.localize(defaultAbility).toLowerCase() })
				},
				{ rule: true }
			);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareIdentityContext(context) {
		context = await super._prepareIdentityContext(context);
		const defaultType = CONFIG.BlackFlag.weaponTypes[this.item.system.type?.value]?.label;
		const defaultClassification = CONFIG.BlackFlag.attackTypes[this.item.system.type?.classification];
		context.defaultType = defaultType
			? game.i18n.format("BF.Default.Specific", { default: game.i18n.localize(defaultType).toLowerCase() })
			: null;
		context.defaultClassification = defaultClassification
			? game.i18n.format("BF.Default.Specific", { default: game.i18n.localize(defaultClassification).toLowerCase() })
			: null;
		return context;
	}
}

/**
 * Application for configuring Cast activities.
 */
class CastSheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["cast-activity"],
		actions: {
			removeSpell: CastSheet.#removeSpell
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		identity: {
			template: "systems/black-flag/templates/activity/cast-identity.hbs",
			templates: super.PARTS.identity.templates
		},
		effect: {
			template: "systems/black-flag/templates/activity/cast-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/cast-spell.hbs",
				"systems/black-flag/templates/activity/parts/cast-details.hbs"
			]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		return {
			...(await super._prepareContext(options)),
			spell: {
				data: this.activity.system._source.spell,
				document: await fromUuid(this.activity.system.spell.uuid),
				fields: this.activity.system.schema.fields.spell.fields
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);

		if (context.spell.document) {
			context.spell.contentLink = context.spell.document.toAnchor().outerHTML;
			if (context.spell.document.system.circle.base > 0) {
				context.circleOptions = Object.entries(CONFIG.BlackFlag.spellCircles())
					.filter(([circle]) => Number(circle) >= context.spell.document.system.circle.base)
					.map(([value, label]) => ({ value, label }));
			}
		}

		context.abilityOptions = [
			{ value: "", label: game.i18n.localize("BF.Default.Generic") },
			{ rule: true },
			...CONFIG.BlackFlag.abilities.localizedOptions
		];

		context.propertyOptions = [
			...Object.entries(CONFIG.BlackFlag.spellComponents).map(([value, { label }]) => ({
				value,
				label: game.i18n.localize(label),
				group: game.i18n.localize("BF.Spell.Component.Label")
			})),
			...Object.entries(CONFIG.BlackFlag.spellTags).map(([value, { label }]) => ({
				value,
				label: game.i18n.localize(label),
				group: game.i18n.localize("BF.Spell.Tag.Label")
			}))
		];

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareIdentityContext(context) {
		context = await super._prepareIdentityContext(context);
		if (context.spell.document)
			context.placeholder = {
				name: context.spell.document.name,
				img: context.spell.document.img
			};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getTabs() {
		const tabs = super._getTabs();
		tabs.effect.label = "BF.CAST.SECTION.Spell";
		tabs.effect.icon = "fa-solid fa-wand-sparkles";
		return tabs;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle removing the associated spell.
	 * @this {CastSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #removeSpell(event, target) {
		this.activity.update({ "system.spell.uuid": null });
	}
}

/**
 * Application for configuring Check activities.
 */
class CheckSheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["check-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		effect: {
			template: "systems/black-flag/templates/activity/check-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-effects.hbs",
				"systems/black-flag/templates/activity/parts/check-details.hbs"
			]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);

		const group = game.i18n.localize("BF.Ability.Label[other]");
		context.abilityOptions = [
			{ value: "", label: "" },
			{ rule: true },
			{ value: "spellcasting", label: game.i18n.localize("BF.Spellcasting.Label") },
			...CONFIG.BlackFlag.abilities.localizedOptions.map(o => ({ ...o, group }))
		];

		context.associatedOptions = [
			...CONFIG.BlackFlag.skills.localizedOptions.map(o => ({
				...o,
				group: game.i18n.localize("BF.Skill.Label[other]")
			})),
			...CONFIG.BlackFlag.tools.localizedOptions.map(o => ({
				...o,
				group: game.i18n.localize("BF.Tool.Label[other]")
			})),
			...CONFIG.BlackFlag.vehicles.localizedPluralOptions.map(o => ({
				...o,
				group: game.i18n.localize("BF.VEHICLE.Label[other]")
			}))
		];

		context.calculationOptions = [
			{ value: "", label: game.i18n.localize("BF.Formula.Custom.Label") },
			{ rule: true },
			{ value: "spellcasting", label: game.i18n.localize("BF.Spellcasting.Label") },
			...CONFIG.BlackFlag.abilities.localizedOptions.map(o => ({ ...o, group }))
		];

		return context;
	}
}

/**
 * Application for configuring Damage activities.
 */
class DamageSheet extends ActivitySheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["damage-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		effect: {
			template: "systems/black-flag/templates/activity/damage-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-effects.hbs",
				"systems/black-flag/templates/activity/parts/damage-damage.hbs",
				"systems/black-flag/templates/activity/parts/damage-part.hbs",
				"systems/black-flag/templates/activity/parts/damage-parts.hbs"
			]
		}
	};
}

/**
 * Application for configuring Forward activities.
 */
class ForwardSheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["forward-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		identity: {
			template: "systems/black-flag/templates/activity/forward-identity.hbs",
			templates: super.PARTS.identity.templates
		},
		activation: {
			template: "systems/black-flag/templates/activity/forward-activation.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-consumption.hbs",
				"systems/black-flag/templates/activity/parts/activity-consumption-part.hbs",
				"systems/black-flag/templates/shared/uses-config.hbs"
			]
		},
		effect: {
			template: "systems/black-flag/templates/activity/forward-effect.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareActivationContext(context) {
		context = await super._prepareActivationContext(context);
		context.showPrimaryActivation = false;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);
		context.activityOptions = [
			{ value: "", label: "" },
			...this.item.system.activities.contents
				.filter(a => a.type !== "forward")
				.map(activity => ({ value: activity.id, label: activity.name }))
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the tab information for the sheet.
	 * @returns {Record<string, Partial<ApplicationTab>>}
	 * @protected
	 */
	_getTabs() {
		return this._markTabs({
			identity: {
				id: "identity",
				group: "sheet",
				icon: "fa-solid fa-tag",
				label: "BF.ACTIVITY.SECTION.Identity"
			},
			activation: {
				id: "activation",
				group: "sheet",
				icon: "fa-solid fa-boxes-stacked",
				label: "BF.ACTIVITY.SECTION.Consumption"
			},
			effect: {
				id: "effect",
				group: "sheet",
				icon: "fa-solid fa-sun",
				label: "BF.ACTIVITY.SECTION.Effect"
			}
		});
	}
}

/**
 * Application for configuring Healing activities.
 */
class HealSheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["heal-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		effect: {
			template: "systems/black-flag/templates/activity/heal-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-effects.hbs",
				"systems/black-flag/templates/activity/parts/damage-part.hbs",
				"systems/black-flag/templates/activity/parts/heal-healing.hbs"
			]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);
		context.scalingOptions = [
			{ value: "", label: game.i18n.localize("BF.DAMAGE.Scaling.Mode.None") },
			...Object.entries(CONFIG.BlackFlag.damageScalingModes).map(([value, config]) => ({
				value,
				label: game.i18n.localize(config.label)
			}))
		];
		return context;
	}
}

/**
 * Application for configuring Save activities.
 */
class SaveSheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["save-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		effect: {
			template: "systems/black-flag/templates/activity/save-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-effects.hbs",
				"systems/black-flag/templates/activity/parts/damage-part.hbs",
				"systems/black-flag/templates/activity/parts/damage-parts.hbs",
				"systems/black-flag/templates/activity/parts/save-damage.hbs",
				"systems/black-flag/templates/activity/parts/save-details.hbs"
			]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);
		const group = game.i18n.localize("BF.Formula.Default.DC");
		context.abilityOptions = [
			{ value: "custom", label: game.i18n.localize("BF.Formula.Custom.Label") },
			{ value: "spellcasting", label: game.i18n.localize("BF.Spellcasting.Label") },
			...CONFIG.BlackFlag.abilities.localizedOptions.map(o => ({ ...o, group }))
		];
		const defaultAbility = this.activity.system.defaultAbility;
		if (defaultAbility) {
			context.abilityOptions.unshift(
				{
					value: "",
					label: game.i18n.format("BF.Default.Specific", { default: game.i18n.localize(defaultAbility).toLowerCase() })
				},
				{ rule: true }
			);
		}
		return context;
	}
}

/**
 * Application for configuring Cast activities.
 */
class SummonSheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["summon-activity"],
		actions: {
			addProfile: SummonSheet.#addProfile,
			deleteProfile: SummonSheet.#deleteProfile
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		identity: {
			template: "systems/black-flag/templates/activity/summon-identity.hbs",
			templates: super.PARTS.identity.templates
		},
		effect: {
			template: "systems/black-flag/templates/activity/summon-effect.hbs",
			templates: [
				"systems/black-flag/templates/activity/parts/activity-effects.hbs",
				"systems/black-flag/templates/activity/parts/summon-changes.hbs",
				"systems/black-flag/templates/activity/parts/summon-profiles.hbs"
			]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	tabGroups = {
		sheet: "identity",
		activation: "time",
		effect: "profiles"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareEffectContext(context) {
		context = await super._prepareEffectContext(context);

		context.creatureSizeOptions = CONFIG.BlackFlag.sizes.localizedOptions;
		context.creatureTypeOptions = CONFIG.BlackFlag.creatureTypes.localizedOptions;

		context.profileModes = [
			{ value: "", label: game.i18n.localize("BF.SUMMON.FIELDS.summon.mode.Direct") },
			{ value: "cr", label: game.i18n.localize("BF.SUMMON.FIELDS.summon.mode.CR") }
		];
		context.profiles = this.activity.system.profiles
			.map((data, index) => ({
				data,
				index,
				collapsed: this.expandedSections.get(`profiles.${data._id}`) ? "" : "collapsed",
				fields: context.systemFields.profiles.element.fields,
				prefix: `system.profiles.${index}.`,
				rootId: `${context.partId}-profile-${index}`,
				source: context.source.system.profiles[index] ?? data,
				document: data.uuid ? fromUuidSync(data.uuid) : null,
				mode: this.activity.system.summon.mode,
				typeOptions:
					this.activity.system.summon.mode === "cr"
						? context.creatureTypeOptions.map(t => ({
								...t,
								selected: data.types.has(t.value)
							}))
						: null
			}))
			.sort((lhs, rhs) =>
				(lhs.name || lhs.document?.name || "").localeCompare(rhs.name || rhs.document?.name || "", game.i18n.lang)
			);

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getTabs() {
		const tabs = super._getTabs();
		tabs.effect.label = "BF.SUMMON.SECTIONS.Summoning";
		tabs.effect.icon = "fa-solid fa-spaghetti-monster-flying";
		tabs.effect.tabs = this._markTabs({
			profiles: {
				id: "profiles",
				group: "effect",
				icon: "fa-solid fa-address-card",
				label: "BF.SUMMON.SECTIONS.Profiles"
			},
			changes: {
				id: "changes",
				group: "effect",
				icon: "fa-solid fa-sliders",
				label: "BF.SUMMON.SECTIONS.Changes"
			}
		});
		return tabs;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender() {
		super._onRender();
		this.element.querySelector(".activity-profiles").addEventListener("drop", this.#onDrop.bind(this));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a new entry to the summoning profiles list.
	 * @this {SummonSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #addProfile(event, target) {
		this.activity.update({ "system.profiles": [...this.activity.system._source.profiles, {}] });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle removing an entry from the summoning profiles list.
	 * @this {SummonSheet}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #deleteProfile(event, target) {
		const profiles = this.activity.system.toObject().profiles;
		profiles.splice(target.closest("[data-index]").dataset.index, 1);
		this.activity.update({ "system.profiles": profiles });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle dropping actors onto the sheet.
	 * @param {Event} event - Triggering drop event.
	 */
	async #onDrop(event) {
		// Try to extract the data
		const data = TextEditor.getDragEventData(event);

		// Handle dropping linked items
		if (data?.type !== "Actor") return;
		const actor = await Actor.implementation.fromDropData(data);
		const profiles = this.activity.system.toObject().profiles;

		// If dropped onto existing profile, add or replace link
		const profileId = event.target.closest("[data-profile-id]")?.dataset.profileId;
		if (profileId) {
			const profile = profiles.find(p => p._id === profileId);
			profile.uuid = actor.uuid;
			this.activity.update({ "system.profiles": profiles });
		}

		// Otherwise create a new profile
		else this.activity.update({ "system.profiles": [...profiles, { uuid: actor.uuid }] });
	}
}

/**
 * Application for configuring Utility activities.
 */
class UtilitySheet extends ActivitySheet {
	/** @inheritDoc */
	static DEFAULT_OPTIONS = {
		classes: ["utility-activity"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		identity: {
			template: "systems/black-flag/templates/activity/utility-identity.hbs",
			templates: super.PARTS.identity.templates
		},
		effect: {
			template: "systems/black-flag/templates/activity/utility-effect.hbs",
			templates: ["systems/black-flag/templates/activity/parts/activity-effects.hbs"]
		}
	};
}

const { BooleanField: BooleanField$m, StringField: StringField$U } = foundry.data.fields;

/**
 * Dialog for configuring the activation of the Summon activity.
 */
class SummonActivationDialog extends ActivityActivationDialog {
	/** @inheritDoc */
	static PARTS = {
		...super.PARTS,
		creation: {
			template: "systems/black-flag/templates/activity/summon-activation-creation.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareCreationContext(context, options) {
		context = await super._prepareCreationContext(context, options);

		const profiles = this.activity.system.availableProfiles;
		if (
			this._shouldDisplay("create.summons") &&
			(profiles.length || this.activity.system.creatureSizes.size > 1 || this.activity.system.creatureTypes.size > 1) &&
			canvas.scene
		) {
			context.hasCreation = true;
			context.summonsFields = [];

			if (!foundry.utils.hasProperty(this.options.display, "create.summons"))
				context.summonsFields.push({
					field: new BooleanField$m({ label: game.i18n.localize("BF.SUMMON.Action.Place") }),
					name: "create.summons",
					value: this.config.create?.summons
				});

			if (this.config.create?.summons) {
				const rollData = this.activity.getRollData();
				if (profiles.length > 1) {
					let options = profiles.map(profile => ({
						value: profile._id,
						label: this.getProfileLabel(profile, rollData)
					}));
					if (options.every(o => o.label.startsWith("1 Ã— "))) {
						options = options.map(({ value, label }) => ({ value, label: label.replace("1 Ã— ", "") }));
					}
					context.summonsFields.push({
						field: new StringField$U({ label: game.i18n.localize("BF.SUMMON.Profile.Label") }),
						name: "summons.profile",
						value: this.config.summons?.profile,
						options
					});
				} else context.summonsProfile = profiles[0]._id;

				if (this.activity.system.creatureSizes.size > 1)
					context.summonsFields.push({
						field: new StringField$U({ label: game.i18n.localize("BF.Size.Label") }),
						name: "summons.creatureSize",
						value: this.config.summons?.creatureSize,
						options: Array.from(this.activity.system.creatureSizes)
							.map(value => ({ value, label: CONFIG.BlackFlag.sizes.localized[value] }))
							.filter(k => k)
					});

				if (this.activity.system.creatureTypes.size > 1)
					context.summonsFields.push({
						field: new StringField$U({ label: game.i18n.localize("BF.CreatureType.Label") }),
						name: "summons.creatureType",
						value: this.config.summons?.creatureType,
						options: Array.from(this.activity.system.creatureTypes)
							.map(value => ({ value, label: CONFIG.BlackFlag.creatureTypes.localized[value] }))
							.filter(k => k)
					});
			}
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine the label for a profile in the ability use dialog.
	 * @param {SummonsProfile} profile - Profile for which to generate the label.
	 * @param {object} rollData - Roll data used to prepare the count.
	 * @returns {string}
	 */
	getProfileLabel(profile, rollData) {
		let label;
		if (profile.name) label = profile.name;
		else {
			switch (this.activity.system.summon.mode) {
				case "cr":
					const cr = simplifyBonus(profile.cr, rollData);
					label = game.i18n.format("BF.SUMMON.Profile.ChallengeRatingLabel", { cr: formatCR(cr) });
					break;
				default:
					const doc = fromUuidSync(profile.uuid);
					if (doc) label = doc.name;
					break;
			}
		}
		label ??= "â€”";

		let count = simplifyFormula(Roll.replaceFormulaData(profile.count ?? "1", rollData));
		if (Number.isNumeric(count)) count = parseInt(count);
		if (count) label = `${count} Ã— ${label}`;

		return label;
	}
}

var _module$n = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActivityActivationDialog: ActivityActivationDialog,
	ActivityChoiceDialog: ActivityChoiceDialog,
	ActivitySelection: ActivitySelection,
	ActivitySheet: ActivitySheet,
	AttackSheet: AttackSheet,
	CastSheet: CastSheet,
	CheckSheet: CheckSheet,
	DamageSheet: DamageSheet,
	ForwardSheet: ForwardSheet,
	HealSheet: HealSheet,
	SaveSheet: SaveSheet,
	SummonActivationDialog: SummonActivationDialog,
	SummonSheet: SummonSheet,
	UtilitySheet: UtilitySheet
});

/**
 * Base configuration application for advancements that can be extended by other types to implement custom
 * editing interfaces.
 *
 * @param {Advancement} advancement - The advancement item being edited.
 * @param {object} [options={}] - Additional options passed to FormApplication.
 * @param {string} [options.dropKeyPath=null] - Path within advancement configuration where dropped items are stored.
 *                                              If populated, will enable default drop & delete behavior.
 */
class AdvancementConfig extends PseudoDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["advancement-config", "standard-form"],
		actions: {
			deleteDropped: AdvancementConfig.#onDeleteDropped
		},
		dragDropHandlers: {
			dragenter: AdvancementConfig.#onDragEnter,
			dragleave: AdvancementConfig.#onDragLeave,
			drop: AdvancementConfig.#onDrop
		},
		dropKeyPath: null,
		position: {
			width: 400,
			height: "auto"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The advancement being created or edited.
	 * @type {Advancement}
	 */
	get advancement() {
		return this.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does the drop target support multiple documents?
	 * @type {boolean|null}
	 */
	get multiDrop() {
		if (!this.options.dropKeyPath) return null;
		const field = this.advancement.metadata.dataModels?.configuration?.schema.getField(this.options.dropKeyPath);
		return field instanceof foundry.data.fields.ArrayField;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		const type = game.i18n.localize(this.advancement.metadata.title);
		return `${game.i18n.format("BF.Advancement.Config.Title", { item: this.item.name })}: ${type}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const levels = [
			[0, game.i18n.localize("BF.Advancement.Core.Level.Any.Short")],
			...Array.fromRange(CONFIG.BlackFlag.maxLevel, 1).map(l => [l, l])
		].slice(this.advancement.minimumLevel);
		const context = await super._prepareContext(options);
		context.configuration = {
			data: this.advancement.configuration,
			fields: this.advancement.configuration?.schema?.fields
		};
		context.fields = this.advancement.schema.fields;
		context.source = this.advancement._source;
		context.advancement = this.advancement;
		context.default = {
			title: game.i18n.localize(this.advancement.metadata.title),
			icon: this.advancement.metadata.icon,
			identifier: this.advancement.title.slugify({ strict: true }),
			identifierHint: this.advancement.metadata.identifier.hint
		};
		context.levels = Object.fromEntries(levels);
		context.levelOptions = levels.map(([value, label]) => ({ value, label }));
		context.showClassIdentifier = this.item.system.metadata?.category === "features";
		context.showClassRestriction = this.item.type === "class" || !!this.advancement.level.classIdentifier;
		context.showHint = this.advancement.metadata.configurableHint;
		context.showIdentifier = this.advancement.metadata.identifier.configurable;
		context.showLevelSelector = !this.advancement.metadata.multiLevel;

		context.classIdentifierOptions = [
			{ value: "", label: game.i18n.localize("BF.Level.Overall") },
			...Object.entries(CONFIG.BlackFlag.registration.all.class).map(([value, { name }]) => ({
				value,
				label: name,
				group: game.i18n.localize("BF.Level.Class")
			}))
		];
		context.classRestrictionOptions = [
			{ value: "", label: game.i18n.localize("BF.Advancement.Core.ClassRestriction.None") },
			{ value: "original", label: game.i18n.localize("BF.Advancement.Core.ClassRestriction.Original") },
			{ value: "multiclass", label: game.i18n.localize("BF.Advancement.Core.ClassRestriction.Multiclass") }
		];

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _processSubmitData(event, form, submitData) {
		submitData.configuration ??= {};
		submitData.configuration = await this.prepareConfigurationUpdate(submitData.configuration, submitData);
		if (submitData.level?.classIdentifier && submitData.level?.value === 0) {
			submitData.level.value = 1;
		}
		await this.advancement.update(submitData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any changes to configuration data before it is saved to the advancement.
	 * @param {object} configuration - Configuration object.
	 * @param {object} submitData - Processed and validated form data to be used for a document update.
	 * @returns {object} - Modified configuration.
	 */
	async prepareConfigurationUpdate(configuration, submitData) {
		return configuration;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle deleting an existing Item entry from the Advancement.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onDeleteDropped(event, target) {
		event.preventDefault();
		const uuidToDelete = target.closest("[data-item-uuid]")?.dataset.itemUuid;
		if (!uuidToDelete) return;
		let updates;
		if (this.multiDrop) {
			const items = foundry.utils.getProperty(this.advancement.configuration, this.options.dropKeyPath);
			updates = {
				configuration: await this.prepareConfigurationUpdate({
					[this.options.dropKeyPath]: items.filter(i => i.uuid !== uuidToDelete)
				})
			};
		} else {
			updates = { [`configuration.${this.options.dropKeyPath}`]: null };
		}
		await this.advancement.update(updates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add drag target highlight when drag enters drop area.
	 * @this {AdvancementConfig}
	 * @param {Event} event - Triggering event.
	 * @param {DragDrop} dragDrop - The drag event manager.
	 */
	static async #onDragEnter(event, dragDrop) {
		const dropTarget = event.target.closest(".drop-area");
		if (!dropTarget) return;
		dragDrop.enterDragArea(event, dropTarget);

		const { data } = dragDrop.getDragData(event);
		let valid = true;
		if (data?.type !== "Item") valid = false;
		else {
			try {
				const item = await Item.implementation.fromDropData(data);
				this._validateDroppedItem(event, item);
			} catch (err) {
				valid = false;
			}
		}

		dropTarget.classList.add(valid ? "valid" : "invalid");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove drag target highlight when drag leaves.
	 * @this {AdvancementConfig}
	 * @param {Event} event - Triggering event.
	 * @param {DragDrop} dragDrop - The drag event manager.
	 */
	static async #onDragLeave(event, dragDrop) {
		dragDrop.exitDragArea(event, area => {
			if (!area.classList.contains("drop-area")) return false;
			area.classList.remove("valid");
			area.classList.remove("invalid");
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle dropping an entry onto the app.
	 * @this {AdvancementConfig}
	 * @param {Event} event - Triggering event.
	 * @param {DragDrop} dragDrop - The drag event manager.
	 * @returns {Promise}
	 */
	static async #onDrop(event, dragDrop) {
		if (!this.options.dropKeyPath)
			throw new Error(
				"AdvancementConfig#options.dropKeyPath must be configured or #_onDrop must be overridden to support" +
					" drag and drop on advancement config items."
			);
		const dropArea = event.target.closest(".drop-area");
		if (dropArea) {
			dropArea.classList.remove("valid");
			dropArea.classList.remove("invalid");
		}

		// Try to extract the data
		const { data } = dragDrop.getDragData(event);

		if (data?.type !== "Item") return;

		try {
			const item = await Item.implementation.fromDropData(data);
			this._validateDroppedItem(event, item);

			let existingItems = foundry.utils.getProperty(this.advancement.configuration, this.options.dropKeyPath);
			if (!this.multiDrop) existingItems = [{ uuid: existingItems }];

			// Abort if this uuid exists already
			if (existingItems.find(i => i.uuid === item.uuid)) {
				ui.notifications.warn("BF.Advancement.Config.Warning.Duplicate", { localize: true });
				return;
			}
			// TODO: Allow dragging to re-order entries

			const newValue = this.multiDrop ? [...existingItems, { uuid: item.uuid }] : item.uuid;
			await this.advancement.update({ [`configuration.${this.options.dropKeyPath}`]: newValue });
		} catch (err) {
			ui.notifications.error(err.message);
			return;
		} finally {
			dragDrop.finishDragEvent(event);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Called when an item is dropped to validate the Item before it is saved. An error should be thrown
	 * if the item is invalid.
	 * @param {Event} event - Triggering drop event.
	 * @param {BlackFlagItem} item - The materialized Item that was dropped.
	 * @throws An error if the item is invalid.
	 * @protected
	 */
	_validateDroppedItem(event, item) {
		// Abort if this uuid is the parent item
		if (item.uuid === this.item.uuid) {
			throw new Error(game.i18n.localize("BF.Advancement.Config.Warning.Recursive"));
		}
	}
}

/**
 * Base class for the advancement interface displayed in the progression tab that should be subclassed by
 * individual advancement types.
 *
 * @param {BlackFlagActor} actor - Actor to which the advancement is being applied.
 * @param {Advancement} advancement - Advancement being represented.
 * @param {{character: number, class: number}} levels - Level for which to configure this flow.
 * @param {object} [options={}] - Application rendering options.
 */
class AdvancementFlow extends FormApplication {
	constructor(actor, advancement, levels, options = {}) {
		super({}, options);
		this.#advancementId = advancement.id;
		this.actor = actor;
		this.item = advancement.item;
		this.levels = levels;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/advancement-flow.hbs",
			popOut: false,
			closeOnSubmit: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * ID of the advancement this flow modifies.
	 * @type {string}
	 * @private
	 */
	#advancementId;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor to which the advancement is being applied.
	 * @type {BlackFlagActor}
	 */
	actor;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The item that houses the Advancement.
	 * @type {BlackFlagItem}
	 */
	item;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Levels for which to configure this flow.
	 * @type {{character: number, class: number}}
	 */
	levels;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Data retained by the advancement manager during a reverse step. If restoring data using
	 * {@link Advancement#restore}, this data should be used when displaying the flow's form.
	 * @type {object|null}
	 */
	retainedData = null;

	/* <><><><> <><><><> <><><><> <><><><> */

	get element() {
		// Fix an issue with jQuery not being able to fetch element properly
		if (this._element) return this._element;
		return $(document.getElementById(this.id));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	get id() {
		return `${this.advancement.uuid}-${this.levels.character}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	get title() {
		return this.advancement.title;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The Advancement object this flow modifies.
	 * @type {Advancement|null}
	 */
	get advancement() {
		return this.item.system.advancement?.get(this.#advancementId) ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	getData() {
		return {
			appId: this.id,
			accentColor: this.advancement.item.accentColor,
			advancement: this.advancement,
			modes: { editing: this.advancement.actor.sheet.modes.editing ?? false },
			type: this.advancement.constructor.typeName,
			title: this.advancement.titleForLevel(this.levels, { flow: true }),
			icon: this.advancement.icon,
			summary: this.advancement.summaryForLevel(this.levels, { flow: true }),
			levels: this.levels,
			needsConfiguration: !this.advancement.configuredForLevel(this.levels),
			warningKey: this.advancement.warningKey(this.levels)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		html.querySelector('[data-action="reverse"]')?.addEventListener("click", event => {
			this.advancement.reverse(this.levels);
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _updateObject(event, formData) {
		await this.advancement.apply(this.levels, formData);
	}
}

/**
 * Configuration application for feature grants.
 */
class GrantFeaturesConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["grant-features", "form-list"],
		dropKeyPath: "pool",
		position: {
			width: 420
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		items: {
			template: "systems/black-flag/templates/advancement/grant-features-config-items.hbs",
			templates: ["systems/black-flag/templates/advancement/parts/features-list.hbs"]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_validateDroppedItem(event, item) {
		super._validateDroppedItem(event, item);
		this.advancement._validateItemType(item);
	}
}

/**
 * Configuration application for feature choices.
 */
class ChooseFeaturesConfig extends GrantFeaturesConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["choose-features", "grid-columns"],
		position: {
			width: 640
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		details: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/choose-features-config-details.hbs"
		},
		items: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/choose-features-config-items.hbs",
			templates: ["systems/black-flag/templates/advancement/parts/features-list.hbs"]
		},
		levels: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/advancement/parts/choice-levels.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = { ...(await super._preparePartContext(partId, context, options)) };
		if (partId === "details") return await this._prepareDetailsContext(context, options);
		if (partId === "levels") return await this._prepareLevelsContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the details.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareDetailsContext(context, options) {
		context.validTypeOptions = Array.from(this.advancement.constructor.VALID_TYPES).map(value => ({
			value,
			label: game.i18n.localize(CONFIG.Item.typeLabels[value])
		}));
		const makeLabels = obj =>
			Object.entries(obj)
				.map(([value, d]) => ({ value, label: game.i18n.localize(`${d.localization}[one]`) }))
				.sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));
		if (this.advancement.configuration.type === "feature") {
			const selectedCategory = CONFIG.BlackFlag.featureCategories[this.advancement.configuration.restriction.category];
			context.typeRestriction = {
				categoryLabel: game.i18n.localize("BF.Feature.Category.Label"),
				categoryOptions: makeLabels(CONFIG.BlackFlag.featureCategories),
				typeLabel: game.i18n.localize("BF.Feature.Type.Label"),
				typeOptions: selectedCategory?.children ? makeLabels(selectedCategory.children) : null
			};
		} else if (this.advancement.configuration.type === "talent") {
			context.typeRestriction = {
				categoryLabel: game.i18n.localize("BF.Feature.Talent.Category.Label"),
				categoryOptions: makeLabels(CONFIG.BlackFlag.talentCategories)
			};
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the levels list.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareLevelsContext(context, options) {
		context.choices = Object.entries(context.levels).reduce((obj, [level, label]) => {
			obj[level] = { label, ...this.advancement.configuration.choices[level] };
			return obj;
		}, {});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareConfigurationUpdate(configuration) {
		if (configuration.choices) configuration.choices = cleanedObjectUpdate(configuration.choices);

		// Ensure items are still valid if type restriction has changed
		const pool = [];
		for (const data of configuration.pool ? Object.values(configuration.pool) : this.advancement.configuration.pool) {
			if (
				this.advancement._validateItemType(await fromUuid(data.uuid), {
					type: configuration.type,
					restriction: configuration.restriction ?? {},
					strict: false
				})
			)
				pool.push(data);
		}
		configuration.pool = pool;

		return configuration;
	}
}

/**
 * Dialog that presents a list of features from which to choose.
 */
class ChooseFeaturesDialog extends BFApplication {
	constructor(advancementFlow, { resolve, reject, ...options } = {}) {
		options.details ??= {};
		options.details.flow = advancementFlow;
		super(options);
		this.#responses = { resolve, reject };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			choose: ChooseFeaturesDialog.#chooseFeature
		},
		classes: ["choose-features-dialog", "form-list"],
		details: {
			flow: null,
			level: null,
			isReplacement: false,
			type: null
		},
		dragDropHandlers: {
			drop: ChooseFeaturesDialog.#onDrop
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		options: {
			template: "systems/black-flag/templates/advancement/choose-features-dialog.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Advancement for which this choice is being made.
	 * @type {Advancement}
	 */
	get advancement() {
		return this.options.details.flow.advancement;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Functions to call when a choice is made.
	 * @type {{resolve: Function, reject: Function}}
	 */
	#responses;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		const configType = this.options.details.type ?? this.advancement.configuration.type;
		const config = this.advancement.configuration;
		let type;
		if (configType === "feature") {
			const category = CONFIG.BlackFlag.featureCategories[config.restriction?.category];
			const subtype = category?.types?.[config.restriction?.type];
			if (subtype) type = subtype.localization;
			else if (category) type = category.localization;
			if (type) type = `${type}[one]`;
		}
		if (!type) type = CONFIG.Item.typeLabels[configType];
		return game.i18n.format(`BF.ConceptSelection.${this.options.details.isReplacement ? "Replace" : ""}Title`, {
			type: game.i18n.localize(type)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);

		context.advancement = this.advancement;
		context.allowDrops = this.advancement.configuration.allowDrops;
		context.choices = await Promise.all((await this.advancement.choices()).map(c => this.getChoiceData(c)));
		if (context.allowDrops)
			context.dropLabel = game.i18n.format("BF.Advancement.ChooseFeatures.Drop", {
				type: game.i18n.localize(`BF.Item.Type.${this.advancement.configuration.type.capitalize()}[one]`).toLowerCase()
			});
		if (this.options.details.isReplacement) {
			context.replacements = [];
			for (const level of Array.fromRange(this.options.details.level - 1, 1)) {
				const data = this.advancement.value.added[level];
				if (!data?.length) continue;
				const replaced = Object.values(this.advancement.value.replaced ?? {}).filter(r => r.level === level);
				for (const added of data) {
					if (!added.document || replaced.find(r => r.original === added.id)) continue;
					context.replacements.push({ value: added.document.id, label: added.document.name });
				}
			}
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare data for an individual choice in the list.
	 * @param {BlackFlagItem} doc - Document of the option being presented.
	 * @returns {object}
	 */
	async getChoiceData(doc) {
		const optionContext = { document: doc, system: doc.system };
		optionContext.enriched = {
			description: await TextEditor.enrichHTML(doc.system.description.value, { secrets: false, async: true })
		};
		if (doc.system.restriction) {
			optionContext.prerequisite = doc.system.createPrerequisiteLabel(this.advancement.actor);
			const validation = doc.system.validatePrerequisites(this.advancement.actor);
			optionContext.invalid = validation !== true && validation !== null;
		}
		return optionContext;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle choosing a featuring using the button.
	 * @this {ChooseFeaturesDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #chooseFeature(event, target) {
		this.handleChoice(target.closest("[data-uuid]").dataset.uuid);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle choosing a specific option.
	 * @param {string} uuid - UUID of the choice made.
	 */
	async handleChoice(uuid) {
		let replaces;
		if (this.options.details.isReplacement) replaces = this.element[0].querySelector('[name="replaces"]').value;
		this.close({ response: { choice: uuid, replaces } });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async close(options = {}) {
		await super.close(options);
		if (options.response) this.#responses.resolve(options.response);
		else this.#responses.reject();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle dropping an entry onto the app.
	 * @this {ChooseFeaturesDialog}
	 * @param {Event} event - Triggering event.
	 * @param {DragDrop} dragDrop - The drag event manager.
	 * @returns {Promise}
	 */
	static async #onDrop(event, dragDrop) {
		const data = TextEditor.getDragEventData(event);
		if (data?.type !== "Item") return false;
		const item = await Item.implementation.fromDropData(data);

		try {
			this.advancement._validateItemType(item, { flow: true });
		} catch (err) {
			ui.notifications.error(err.message);
			return;
		} finally {
			dragDrop.finishDragEvent(event);
		}

		if (this.advancement.selectionLimitReached(item)) {
			return ui.notifications.error(game.i18n.localize("BF.Advancement.ChooseFeatures.Warning.PreviouslyChosen"));
		}

		this.handleChoice(item.uuid);
	}
}

/**
 * Inline application that presents a list of feature choices.
 */
class ChooseFeaturesFlow extends AdvancementFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/choose-features-flow.hbs"
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData() {
		const context = await super.getData();
		const level = this.advancement.relavantLevel(this.levels);
		const config = this.advancement.configuration.choices[level];
		context.chosen = [];
		for (const data of this.advancement.value.added?.[level] ?? []) {
			const doc = data.document ?? (await fromUuid(data.uuid));
			context.chosen.push({
				anchor: doc.toAnchor().outerHTML,
				id: doc.id,
				replaced: !data.document,
				showDelete: (context.modes?.editing || context.needsConfiguration) && !!data.document
			});
		}
		context.replacementAvailable = config?.replacement && !this.advancement.value.replaced?.[level];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll('[data-action="remove-choice"]')) {
			element.addEventListener("click", e => {
				const id = e.target.closest("[data-id]").dataset.id;
				this.advancement.reverse(this.levels, id);
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _updateObject(event, formData) {
		const isReplacement = event.submitter?.dataset.action === "replace-choice";
		if (event.submitter?.dataset.action === "select-choice" || isReplacement) {
			let choice;
			let replaces;
			try {
				({ choice, replaces } = await new Promise((resolve, reject) => {
					new ChooseFeaturesDialog(this, {
						details: {
							isReplacement,
							level: this.advancement.relavantLevel(this.levels)
						},
						resolve,
						reject
					}).render({ force: true });
				}));
			} catch (err) {
				return;
			}
			return this.advancement.apply(this.levels, { choices: [choice], replaces });
		}
	}
}

/**
 * Configuration application for spell grants.
 */
class GrantSpellsConfig extends GrantFeaturesConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["grant-spells", "form-list"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		spellConfig: {
			template: "systems/black-flag/templates/advancement/parts/advancement-spell-configuration.hbs"
		},
		items: {
			template: "systems/black-flag/templates/advancement/grant-spells-config-items.hbs",
			templates: ["systems/black-flag/templates/advancement/parts/spells-list.hbs"]
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		await super._preparePartContext(partId, context, options);
		if (partId === "spellConfig") return await GrantSpellsConfig._prepareSpellConfigContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the spell configuration section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	static async _prepareSpellConfigContext(context, options) {
		const data = context.configuration.data.spell;
		context.spell = {
			abilityOptions: CONFIG.BlackFlag.abilities.localizedOptions,
			alwaysPreparable: CONFIG.BlackFlag.spellPreparationModes[data.mode]?.preparable ?? false,
			data,
			fields: context.configuration.fields.spell.fields,
			originOptions: [
				{ value: "", label: "" },
				...CONFIG.BlackFlag.registration.groupedOptions(["class", "subclass"]).formOptions()
			],
			showRequireSpellSlot: CONFIG.BlackFlag.spellPreparationModes[data.mode]?.scalable ?? false
		};
		return context;
	}
}

/**
 * Configuration application for spell choices.
 */
class ChooseSpellsConfig extends ChooseFeaturesConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["choose-spells", "grid-columns"],
		position: {
			width: 920
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		spellConfig: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/parts/advancement-spell-configuration.hbs"
		},
		restrictions: {
			container: { classes: ["column-container"], id: "column-center" },
			template: "systems/black-flag/templates/advancement/choose-spells-config-restrictions.hbs"
		},
		items: {
			container: { classes: ["column-container"], id: "column-center" },
			template: "systems/black-flag/templates/advancement/choose-spells-config-items.hbs",
			templates: ["systems/black-flag/templates/advancement/parts/spells-list.hbs"]
		},
		levels: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/advancement/parts/choice-levels.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = { ...(await super._preparePartContext(partId, context, options)) };
		if (partId === "spellConfig") return await GrantSpellsConfig._prepareSpellConfigContext(context, options);
		if (partId === "restrictions") return await this._prepareRestrictionsContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the restrictions section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareRestrictionsContext(context, options) {
		context.ritualModeOptions = [
			{ value: "", label: "BF.Advancement.ChooseSpells.FIELDS.restriction.allowRituals.None" },
			{ value: "allow", label: "BF.Advancement.ChooseSpells.FIELDS.restriction.allowRituals.Allow" },
			{ value: "only", label: "BF.Advancement.ChooseSpells.FIELDS.restriction.allowRituals.Only" }
		];
		context.spellCircleOptions = [
			{ value: -1, label: game.i18n.localize("BF.Advancement.ChooseSpells.FIELDS.restriction.circle.Available") },
			{ rule: true },
			...CONFIG.BlackFlag.spellCircles({ formOptions: true })
		];
		return context;
	}
}

/**
 * Inline application that presents a list of spell choices.
 */
class ChooseSpellsFlow extends ChooseFeaturesFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/choose-spells-flow.hbs",
			submitOnChange: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData() {
		const context = await super.getData();
		context.abilities = Array.from(this.advancement.configuration.spell.ability).reduce((obj, key) => {
			obj[key] = CONFIG.BlackFlag.abilities.localized[key];
			return obj;
		}, {});
		context.abilitySelection = this.advancement.configuration.spell.ability.size > 1;
		context.needsAbilitySelection = context.abilitySelection && !this.advancement.value.ability;
		context.isFirstLevel = this.advancement.relavantLevel(this.levels) === this.advancement.levels[0];
		context.showReselectAbility =
			context.modes.editing && context.abilitySelection && !context.needsAbilitySelection && context.isFirstLevel;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _updateObject(event, formData) {
		if (formData.ability) this.advancement.apply(this.levels, formData);
		else super._updateObject(event, formData);
	}
}

/**
 * Base advancement data model shared by advancement system data.
 */
class AdvancementDataModel extends foundry.abstract.DataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform the pre-localization of this data model.
	 */
	static localize() {
		Localization.localizeDataModel(this);
	}
}

/**
 * A mirror of ForeignDocumentField that references a Document embedded within this Document.
 *
 * @param {typeof Document} model - The local DataModel class definition which this field should link to.
 * @param {StringFieldOptions} options - Options which configure the behavior of the field.
 */
class LocalDocumentField extends foundry.data.fields.DocumentIdField {
	constructor(model, options = {}) {
		if (!foundry.utils.isSubclass(model, foundry.abstract.DataModel)) {
			throw new Error("A LocalDocumentField must specify a DataModel subclass as its type");
		}

		super(options);
		this.model = model;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A reference to the model class which is stored in this field.
	 * @type {typeof Document}
	 */
	model;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static get _defaults() {
		return foundry.utils.mergeObject(super._defaults, {
			nullable: true,
			readonly: false,
			idOnly: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_cast(value) {
		if (typeof value === "string") return value;
		if (value instanceof this.model) return value._id;
		throw new Error(`The value provided to a LocalDocumentField must be a ${this.model.name} instance.`);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Step up through model's parents to find the specified collection.
	 * @param {DataModel} model
	 * @param {string} collection
	 * @returns {EmbeddedCollection|void}
	 */
	_findCollection(model, collection) {
		if (!model.parent) return;
		return model.parent[collection] ?? this._findCollection(model.parent, collection);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	initialize(value, model, options = {}) {
		if (this.idOnly) return value;
		const collection = this._findCollection(model, this.model.metadata.collection);
		return () => collection?.get(value) ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	toObject(value) {
		return value?._id ?? value;
	}
}

const {
	ArrayField: ArrayField$n,
	BooleanField: BooleanField$l,
	DocumentIdField: DocumentIdField$9,
	DocumentUUIDField: DocumentUUIDField$8,
	EmbeddedDataField: EmbeddedDataField$3,
	IntegerSortField,
	NumberField: NumberField$C,
	SchemaField: SchemaField$T,
	SetField: SetField$r,
	StringField: StringField$T
} = foundry.data.fields;

/**
 * Configuration data for the Equipment advancement.
 *
 * @property {EquipmentEntryData[]} pool - Different equipment entries that will be granted.
 */
class EquipmentConfigurationData extends AdvancementDataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			pool: new ArrayField$n(new EmbeddedDataField$3(EquipmentEntryData))
		};
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Data for a single entry in the equipment list.
 *
 * @property {string} _id - Unique ID of this entry.
 * @property {string|null} group - Parent entry that contains this one.
 * @property {number} sort - Sorting order of this entry.
 * @property {string} type - Entry type as defined in `EquipmentEntryData#TYPES`.
 * @property {number} [count] - Number of items granted. If empty, assumed to be `1`.
 * @property {string} [key] - Category or item key unless type is "linked", in which case it is a UUID.
 * @property {boolean} [requiresProficiency] - Is this only a valid item if character already has the
 *                                             required proficiency.
 */
class EquipmentEntryData extends foundry.abstract.DataModel {
	/**
	 * Types that group together child entries.
	 * @enum {string}
	 */
	static GROUPING_TYPES = {
		OR: "BF.Advancement.Equipment.Operator.OR",
		AND: "BF.Advancement.Equipment.Operator.AND"
	};

	/**
	 * Types that contain an option for the player.
	 * @enum {string}
	 */
	static OPTION_TYPES = {
		// Category types
		armor: "BF.Advancement.Equipment.Choice.Armor",
		tool: "BF.Advancement.Equipment.Choice.Tool",
		weapon: "BF.Advancement.Equipment.Choice.Weapon",

		// Generic item type
		linked: "BF.Advancement.Equipment.SpecificItem"
	};

	/**
	 * Equipment entry types.
	 * @type {Record<string, string>}
	 */
	static get TYPES() {
		return { ...this.GROUPING_TYPES, ...this.OPTION_TYPES };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Where in `CONFIG.BlackFlag` to find the type category labels.
	 * @enum {{ label: string, config: string }}
	 */
	static CATEGORIES = {
		armor: {
			localization: "BF.Item.Type.Armor",
			config: "armor"
		},
		tool: {
			localization: "BF.Item.Type.Tool",
			config: "tools"
		},
		weapon: {
			localization: "BF.Item.Type.Weapon",
			config: "weapons"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			_id: new DocumentIdField$9({ initial: () => foundry.utils.randomID() }),
			group: new StringField$T({ nullable: true, initial: null }),
			sort: new IntegerSortField(),
			type: new StringField$T({ required: true, initial: "OR", choices: this.TYPES }),
			count: new NumberField$C({ initial: undefined }),
			key: new StringField$T({ initial: undefined }),
			requiresProficiency: new BooleanField$l()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get any children represented by this entry in order.
	 * @returns {EquipmentEntryData[]}
	 */
	get children() {
		if (!(this.type in this.constructor.GROUPING_TYPES)) return [];
		return this.parent.pool.filter(entry => entry.group === this._id).sort((lhs, rhs) => lhs.sort - rhs.sort);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Transform this entry into a human readable label.
	 * @type {string}
	 */
	get label() {
		return this.generateLabel();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Blank label if no key is specified for a choice type.
	 * @type {string}
	 */
	get blankLabel() {
		const localization = this.constructor.CATEGORIES[this.type]?.localization;
		if (!localization) return "";
		return game.i18n.localize(`${localization}[${getPluralRules().select(this.count ?? 1)}]`);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the label for a category.
	 * @type {string}
	 */
	get categoryLabel() {
		const label = this.keyOptions[this.key];
		return label?.toLowerCase() ?? this.blankLabel.toLowerCase();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Build a list of possible key options for this entry's type.
	 * @returns {Record<string, string>}
	 */
	get keyOptions() {
		const config = foundry.utils.deepClone(CONFIG.BlackFlag[this.constructor.CATEGORIES[this.type]?.config]);
		const pluralRule = getPluralRules().select(this.count ?? 1);
		const choices = Object.entries(config ?? {}).reduce((obj, [key, value]) => {
			if (value.children) obj[key] = makeLabel(value, { pluralRule, labelKeyPath: null });
			return obj;
		}, {});

		// Special handling for weapons
		if (this.type === "weapon") {
			for (const [categoryKey, category] of Object.entries(CONFIG.BlackFlag.weapons.localized)) {
				for (const [typeKey, type] of Object.entries(CONFIG.BlackFlag.weaponTypes.localized)) {
					choices[`${categoryKey}.${typeKey}`] = game.i18n.format(`BF.WEAPON.Type.CombinedLabel[${pluralRule}]`, {
						category,
						type
					});
				}
			}
		}

		return choices;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Available options for one of the choose options types.
	 * @type {SelectChoices|null}
	 */
	get options() {
		let config = CONFIG.BlackFlag[this.constructor.CATEGORIES[this.type]?.config];
		if (!config) return null;
		if (!this.key) return new SelectChoices(config);
		if (config[this.key]?.children) return new SelectChoices(config[this.key].children);
		if (this.type !== "weapon") return null;

		const [category, type] = this.key.split(".");
		config = Object.entries(config[category]?.children ?? {}).reduce((obj, [k, v]) => {
			if (v.type === type) obj[k] = v;
			return obj;
		}, {});
		return !foundry.utils.isEmpty(config) ? new SelectChoices(config) : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Translate the selection into a final UUID to add.
	 * @param {string} [selection] - Selection key.
	 * @returns {string}
	 */
	findSelection(selection) {
		if (this.type === "linked") return this.key;
		return this.options.get(selection)?.link;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a human readable label, taking depth into account for OR prefixes.
	 * @param {number} depth
	 * @returns {string|void}
	 */
	generateLabel(depth = 1) {
		let label;
		switch (this.type) {
			// For AND/OR, use a simple conjunction/disjunction list (e.g. "first, second, and third")
			case "AND":
			case "OR":
				let entries = this.children.map(c => c.generateLabel(depth + 1)).filter(l => l);
				if (this.type === "OR") entries = this.prefixOrEntries(entries, depth);
				return game.i18n
					.getListFormatter({ type: this.type === "AND" ? "conjunction" : "disjunction", style: "long" })
					.format(entries);

			// For linked type, fetch the name using the index
			case "linked":
				const index = fromUuidSync(this.key);
				if (index) label = index.name;
				break;

			// For category types, grab category information from config
			default:
				label = this.categoryLabel;
				break;
		}

		if (!label) return;
		if (this.count > 1) label = `${numberFormat(this.count, { spellOut: true })} ${label}`;
		else if (this.type !== "linked") {
			label = game.i18n.format("BF.Advancement.Trait.Choice.AnyUncounted", { type: label });
		}
		if (this.type === "linked" && this.requiresProficiency) {
			label += ` (${game.i18n.localize("BF.Advancement.Equipment.Proficiency.IfProficient").toLowerCase()})`;
		}
		return label;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Available options, disabled if proficiency is required and actor doesn't have proficiency.
	 * @param {BlackFlagActor} actor - Actor for who the selection is being made.
	 * @returns {SelectChoices|null}
	 */
	optionsWithProficiency(actor) {
		const options = this.options;
		const proficiencyData = actor.system.proficiencies[this.constructor.CATEGORIES[this.type]?.config];
		if (!options || !proficiencyData || !this.requiresProficiency) return options;
		let proficiencies;
		if (proficiencyData.value) proficiencies = proficiencyData.value;
		else
			proficiencies = new Set(
				Object.entries(proficiencyData)
					.map(([k, v]) => (v.proficiency.multiplier > 0 ? k : null))
					.filter(p => p)
			);

		const validate = ([key, entry]) => {
			if (!proficiencies.has(key)) {
				if (entry.children) Object.entries(entry.children).forEach(validate);
				else entry.disabled = true;
			}
		};
		Object.entries(options).forEach(validate);

		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prefix each OR entry at a certain level with a letter.
	 * @param {string[]} entries - Entries to prefix.
	 * @param {number} depth - Current depth of the OR entry (1 or 2).
	 * @returns {string[]}
	 */
	prefixOrEntries(entries, depth) {
		const letters = game.i18n.localize(`BF.Advancement.Equipment.Prefixes.${depth}`);
		if (!letters) return entries;
		return entries.map((e, idx) => `(${letters[idx]}) ${e}`);
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {GrantedFeatureDay} GrantedEquipmentData
 * @property {string} count - Number of items added.
 * @property {string} part - ID of the part for which this selection was made.
 */

/**
 * Value data for the Equipment advancement.
 *
 * @property {GrantedEquipmentData[]} added - Equipment item added for each entry.
 * @property {Set<string>} contained - Items added within containers.
 * @property {number} wealth - Amount of wealth added if chosen over equipment.
 */
class EquipmentValueData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			added: new ArrayField$n(
				new SchemaField$T({
					count: new NumberField$C({ min: 1, integer: true }),
					document: new LocalDocumentField(foundry.documents.BaseItem),
					part: new StringField$T(),
					uuid: new DocumentUUIDField$8({ type: "Item" })
				})
			),
			contained: new SetField$r(new StringField$T()),
			wealth: new NumberField$C({ integer: true })
		};
	}
}

/**
 * Configuration application for equipment.
 */
class EquipmentConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["equipment", "form-list"],
		actions: {
			addEntry: EquipmentConfig.#onAddEntry,
			deleteEntry: EquipmentConfig.#onDeleteEntry
		},
		dragDropHandlers: {
			dragstart: EquipmentConfig.#onDragStart,
			drop: EquipmentConfig.#onDrop
		},
		dragSelectors: [".drag-bar"],
		position: {
			width: 480
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		equipment: {
			template: "systems/black-flag/templates/advancement/equipment-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = foundry.utils.mergeObject(
			await super._prepareContext(options),
			{
				showClassRestriction: false,
				showLevelSelector: false
			},
			{ inplace: false }
		);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		await super._preparePartContext(partId, context, options);
		if (partId === "equipment") await this._prepareEquipmentContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the equipment listing.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareEquipmentContext(context, options) {
		const processEntry = async (entry, depth = 1) => {
			const data = {
				id: entry._id,
				entry,
				depth,
				groupType: entry.type in EquipmentEntryData.GROUPING_TYPES,
				validGroupTypes: depth < 3 ? EquipmentEntryData.GROUPING_TYPES : null,
				validOptionTypes: EquipmentEntryData.OPTION_TYPES
			};
			if (entry.type in EquipmentEntryData.GROUPING_TYPES) {
				data.children = await Promise.all(entry.children.map(c => processEntry(c, depth + 1)));
			} else if (entry.type === "linked") {
				data.linked = fromUuidSync(entry.key);
				data.showRequireProficiency = ["armor", "tool", "weapon"].includes(data.linked?.type);
			}
			return data;
		};

		context.entries = await Promise.all(
			this.advancement.configuration.pool
				.filter(e => !e.group)
				.sort((lhs, rhs) => lhs.sort - rhs.sort)
				.map(e => processEntry(e))
		);

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a new entry.
	 * @this {EquipmentConfig}
	 * @param {PointerEvent} event - The originating click event.
	 * @param {HTMLElement} target - The target of the click event.
	 */
	static #onAddEntry(event, target) {
		this.submit({
			updateData: {
				action: "addEntry",
				depth: Number(target.closest("[data-depth]")?.dataset.depth ?? 0) + 1,
				entryId: target.closest("[data-entry-id]")?.dataset.entryId
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle removing a entry.
	 * @this {EquipmentConfig}
	 * @param {PointerEvent} event - The originating click event.
	 * @param {HTMLElement} target - The target of the click event.
	 */
	static #onDeleteEntry(event, target) {
		this.submit({
			updateData: {
				action: "deleteEntry",
				entryId: target.closest("[data-entry-id]")?.dataset.entryId
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const data = super._processFormData(event, form, formData);
		data.configuration ??= {};
		data.configuration.pool = Object.values(data.pool ?? {});
		return data;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareConfigurationUpdate(configuration, submitData) {
		switch (submitData.action) {
			case "addEntry":
				const highestSort = configuration.pool.reduce((sort, i) => (i.sort > sort ? i.sort : sort), 0);
				configuration.pool.push({
					_id: foundry.utils.randomID(),
					group: submitData.entryId,
					sort: highestSort + CONST.SORT_INTEGER_DENSITY,
					type: submitData.depth < 3 && !submitData.linkedUuid ? "OR" : "linked",
					key: submitData.linkedUuid
				});
				break;
			case "deleteEntry":
				const deleteIds = new Set();
				const getDeleteIds = entry => {
					deleteIds.add(entry._id);
					entry.children?.forEach(c => getDeleteIds(c));
				};
				getDeleteIds(this.advancement.configuration.pool.find(i => i._id === submitData.entryId));
				configuration.pool = configuration.pool.filter(e => !deleteIds.has(e._id));
				break;
		}
		return configuration;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin dragging an equipment entry.
	 * @this {EquipmentConfig}
	 * @param {Event} event - Triggering event.
	 * @param {DragDrop} dragDrop - The drag event manager.
	 */
	static #onDragStart(event, dragDrop) {
		const entry = event.target.closest("[data-entry-id]");
		if (!entry) return;
		dragDrop.beginDragEvent(event, {
			type: "equipment-entry",
			uuid: this.document.uuid,
			entryId: entry.dataset.entryId
		});
		const box = entry.getBoundingClientRect();
		event.dataTransfer.setDragImage(entry, box.width - 6, box.height / 2);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle dropping an equipment entry or an item.
	 * @this {EquipmentConfig}
	 * @param {Event} event - Triggering event.
	 * @param {DragDrop} dragDrop - The drag event manager.
	 * @returns {Promise}
	 */
	static async #onDrop(event, dragDrop) {
		const { data } = dragDrop.getDragData(event);

		// Handle re-ordering of the list
		if (data?.entryId && data.uuid === this.document.uuid) return this.#onSortEntry(event, data);

		// Handle dropping linked items
		if (data?.type !== "Item") return;
		const item = await Item.implementation.fromDropData(data);

		// Validate that this is a equipment item
		const metadata = item.system.constructor.metadata ?? {};
		if (metadata.category !== "equipment" && metadata.type !== "currency") {
			ui.notifications.error(
				game.i18n.format("BF.Advancement.Equipment.Warning.ItemTypeInvalid", {
					type: game.i18n.localize(CONFIG.Item.typeLabels[item.type])
				})
			);
			return;
		}

		// Determine where this was dropped
		const closestDrop = event.target.closest(
			'[data-entry-type="AND"], [data-entry-type="OR"], [data-entry-type="linked"]'
		);
		const { entryId, entryType } = closestDrop?.dataset ?? {};

		// If no closest entry, create at top level, or if closest is a group, create inside that group
		if (!entryId || entryType in EquipmentEntryData.GROUPING_TYPES)
			this.submit({
				updateData: {
					action: "addEntry",
					entryId,
					linkedUuid: item.uuid
				}
			});
		// If closest entry is linked, set its key to be this uuid
		else if (entryType === "linked")
			this.submit({
				updateData: {
					[`pool.${entryId}.key`]: item.uuid
				}
			});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle sorting an equipment entry.
	 * @param {Event} event - Triggering event.
	 * @param {object} data - Drag data.
	 */
	#onSortEntry(event, data) {
		const dropArea = event.target.closest("[data-entry-id]");
		const dragEntry = this.document.configuration.pool.find(e => e._id === data?.entryId);
		const dropEntry = this.document.configuration.pool.find(e => e._id === dropArea?.dataset.entryId);

		// If drag entry & drop entry are the same, or drop entry is drag entry's group, do nothing
		if (dropEntry?._id === dragEntry._id || dropEntry?._id === dragEntry.group) return;

		let updateData;
		let sortBefore;
		let target;

		// If drop entry is a group, move drag entry into it
		if (dropEntry?.type in EquipmentEntryData.GROUPING_TYPES) {
			let depth = Number(dropArea.dataset.depth) + 1;
			if (dragEntry.children?.length) {
				depth += 1;
				if (dragEntry.children.some(c => c.type in EquipmentEntryData.GROUPING_TYPES)) depth += 1;
			}
			if (depth > 3) {
				ui.notifications.warn("BF.Advancement.Equipment.Warning.Depth", { localize: true });
				return;
			}
			updateData = { [`pool.${dragEntry._id}.group`]: dropEntry._id };
			target = dropEntry.children.pop();
		}

		// If drag entry and drop entry are int he same group, perform relative sort
		else if (dropEntry && dropEntry.group === dragEntry.group) {
			target = dropEntry;
		}

		// If dropped outside any entry, move to the top level and sort to top or bottom of list
		else if (!dropEntry) {
			updateData = { [`pool.${dragEntry._id}.group`]: null };
			const box = this.element.getBoundingClientRect();
			sortBefore = event.clientY - box.y < box.height * 0.75;
			const sortedEntries = this.document.configuration.pool
				.filter(e => !e.group)
				.sort((lhs, rhs) => lhs.sort - rhs.sort);
			target = sortBefore ? sortedEntries.shift() : sortedEntries.pop();
		}

		// If they are in different groups, move entry to new group and then sort
		else if (dropEntry.group !== dragEntry.group) {
			updateData = { [`pool.${dragEntry._id}.group`]: dropEntry.group };
			target = dropEntry;
		}

		if (target && target !== dragEntry) {
			updateData ??= {};
			const siblings = this.document.configuration.pool.filter(s => s._id !== dragEntry._id);
			const sortUpdates = SortingHelpers.performIntegerSort(dragEntry, { target, siblings, sortBefore });
			for (const update of sortUpdates) {
				updateData[`pool.${update.target._id}.sort`] = update.update.sort;
			}
		}

		if (updateData) this.submit({ updateData });
	}
}

/**
 * Application for selecting starting equipment from a class & background.
 */
class EquipmentDialog extends BFApplication {
	constructor(options = {}) {
		super(options);
		this.#actor = options.actor;
	}

	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["equipment-dialog", "form-list"],
		tag: "form",
		window: {
			title: "BF.Advancement.Equipment.Selection.Title",
			icon: "fa-solid fa-shield"
		},
		form: {
			handler: EquipmentDialog.#onSubmitForm,
			closeOnSubmit: true
		},
		position: {
			width: 600,
			height: "auto"
		}
	};

	/** @override */
	static PARTS = {
		toggle: {
			template: "systems/black-flag/templates/advancement/equipment-dialog-toggle.hbs"
		},
		class: {
			template: "systems/black-flag/templates/advancement/equipment-dialog-selection.hbs"
		},
		background: {
			template: "systems/black-flag/templates/advancement/equipment-dialog-selection.hbs"
		},
		submit: {
			template: "systems/black-flag/templates/advancement/equipment-dialog-submit.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor for which the equipment is being selected.
	 * @type {BlackFlagActor}
	 */
	#actor;

	get actor() {
		return this.#actor;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The EquipmentAdvancement on the background & class documents.
	 * @type {{ background: EquipmentAdvancement, class: EquipmentAdvancement }}
	 */
	get advancements() {
		return Object.fromEntries(
			Object.entries(this.documents).map(([k, v]) => [k, v?.system.advancement.byType("equipment")[0]])
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Assignments that have been made.
	 * @type {{ background: GrantedEquipmentData[], class: GrantedEquipmentData[] }}
	 */
	#assignments;

	get assignments() {
		return this.#assignments;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The background & class documents offering starting equipment.
	 * @type {{ background: BlackFlagItem, class: BlackFlagItem }}
	 */
	get documents() {
		return {
			background: this.actor.system.progression.background,
			class: this.actor.system.progression.levels[1]?.class
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Total wealth granted after rolling.
	 * @type {number}
	 */
	#wealth;

	get wealth() {
		return this.#wealth;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "background":
			case "class":
				return this._prepareSelectionContext(partId, context, options);
			case "toggle":
				return this._prepareToggleContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare an entry in the equipment list for rendering.
	 * @param {EquipmentEntryData} entry - Entry to prepare.
	 * @returns {object}
	 */
	async _prepareEquipmentEntry(entry) {
		let disabled = false;
		if (entry.type === "linked" && entry.requiresProficiency) {
			const item = await fromUuid(entry.key);
			disabled = !item.system.proficientFor?.(this.actor);
		}
		return {
			count: entry.type in entry.constructor.OPTION_TYPES ? entry.count ?? 1 : null,
			disabled,
			entry,
			entries: await Promise.all(entry.children.map(e => this._prepareEquipmentEntry(e))),
			label: entry.label,
			options: entry.optionsWithProficiency(this.actor)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the rendering context for the individual selection sections.
	 * @param {string} partId - The part being rendered.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>} - Context data for a specific part.
	 * @protected
	 */
	async _prepareSelectionContext(partId, context, options) {
		context.document = this.documents[partId];
		context.documentType = game.i18n.localize(CONFIG.Item.typeLabels[partId]).toLowerCase();
		const advancement = this.advancements[partId];
		if (!context.document || !advancement) return context;

		context.locked = advancement.configuredForLevel();
		if (advancement)
			context.entries = await Promise.all(
				advancement.configuration.pool.filter(e => !e.group).map(e => this._prepareEquipmentEntry(e))
			);

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the rendering context for the mode toggle.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>} - Context data for a specific part.
	 */
	async _prepareToggleContext(context, options) {
		context.formula = `${CONFIG.BlackFlag.startingWealth.formula.replace("*", "Ã—")} ${
			CONFIG.BlackFlag.startingWealth.currency
		}`;
		context.locked =
			this.advancements.class?.configuredForLevel() || this.advancements.background?.configuredForLevel();
		context.mode = this.advancements.class?.value.wealth ? "wealth" : "equipment";
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		super._onChangeForm(formConfig, event);
		if (event.target.name === "mode") {
			this.element
				.querySelectorAll("fieldset")
				.forEach(f => f.toggleAttribute("disabled", event.target.value === "wealth"));
		} else {
			let li = event.target.closest("li");
			let checkbox = li?.querySelector("& > .select > input");
			while (checkbox) {
				checkbox.checked = true;
				li = li.closest("ul")?.closest("li");
				checkbox = li.querySelector("& > .select > input");
			}
			this.#refreshRequiredStates();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);
		this.#refreshRequiredStates();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Modify the "required" attribute on form elements to reflect state of OR choices.
	 * @param {HTMLULElement} [list] - List element within which to search.
	 * @param {boolean} [remove=false] - Remove the required attribute regardless of radio state.
	 */
	#refreshRequiredStates(list, remove = false) {
		if (!list) {
			this.element.querySelectorAll("fieldset > .equipment-list").forEach(l => this.#refreshRequiredStates(l));
		} else if (remove) {
			list.querySelectorAll("input, select").forEach(e => e.removeAttribute("required"));
		} else {
			for (const li of list.children) {
				const radio = li.querySelector("& > .select > input");
				const childList = li.querySelector("& > .details > ul");
				const childSelect = li.querySelector("& > .details > select");
				const required = !radio || radio.checked;

				radio?.setAttribute("required", "");
				if (childList) this.#refreshRequiredStates(childList, !required);
				else if (childSelect && required) childSelect.setAttribute("required", "");
				else if (childSelect) childSelect.removeAttribute("required");
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle submitting the form.
	 * @this {EquipmentDialog}
	 * @param {Event|SubmitEvent} event - The form submission event.
	 * @param {HTMLFormElement} form - The submitted form.
	 * @param {FormDataExtended} formData - Data from the form.
	 */
	static async #onSubmitForm(event, form, formData) {
		if (formData.get("mode") === "wealth") {
			if (!this.documents.class) throw new Error(game.i18n.localize("BF.Advancement.Equipment.Warning.NoClass"));
			const rolls = await CONFIG.Dice.BasicRoll.build(
				{ rolls: [{ parts: [CONFIG.BlackFlag.startingWealth.formula] }] },
				{ configure: false },
				{ data: { flavor: game.i18n.localize("BF.Advancement.Equipment.WealthRoll") } }
			);
			if (!rolls[0]) throw new Error("Could not roll for wealth.");
			this.#wealth = rolls[0].total;
			return;
		}

		this.#assignments = { background: [], class: [] };
		const selectionNeeded = [];
		const submittedSelections = foundry.utils.expandObject(formData.object)?.selection ?? {};

		const processPart = (part, type) => {
			const selection = submittedSelections[part._id];
			switch (part.type) {
				case "AND":
					part.children.forEach(p => processPart(p, type));
					break;
				case "OR":
					if (selection)
						processPart(
							part.children.find(c => c._id === selection),
							type
						);
					else selectionNeeded.push(part._id);
					break;
				default:
					const uuid = part.findSelection(selection);
					if (uuid) this.#assignments[type].push({ part: part._id, count: part.count ?? 1, uuid });
					else selectionNeeded.push(part._id);
			}
		};

		for (const [type, advancement] of Object.entries(this.advancements)) {
			if (!advancement || advancement.configuredForLevel()) continue;
			advancement.configuration.pool.filter(e => !e.group).forEach(p => processPart(p, type));
		}

		if (selectionNeeded.length) {
			throw new Error(game.i18n.localize("BF.Advancement.Equipment.Warning.ChoiceRequired"));
		}
	}
}

/**
 * Inline application that adds the select equipment button if both a class & background are added.
 */
class EquipmentFlow extends AdvancementFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/equipment-flow.hbs"
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _updateObject(event, formData) {
		if (event.submitter?.dataset.action === "select-equipment") {
			let result;
			try {
				result = await new Promise((resolve, reject) => {
					const dialog = new EquipmentDialog({ actor: this.actor });
					dialog.addEventListener("close", event => resolve(dialog), { once: true });
					dialog.render({ force: true });
				});
			} catch (err) {
				return;
			}

			if (result.assignments) {
				for (const [type, advancement] of Object.entries(result.advancements)) {
					await advancement?.apply(this.levels, { assignments: result.assignments[type] });
				}
			} else if (result.wealth) {
				result.advancements.class?.apply(this.levels, { wealth: result.wealth });
			}
		}
	}
}

/**
 * Inline application that presents ability selection for granting spells
 */
class GrantSpellsFlow extends AdvancementFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/grant-spells-flow.hbs",
			submitOnChange: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getData() {
		return foundry.utils.mergeObject(super.getData(), {
			abilities: Array.from(this.advancement.configuration.spell.ability).reduce((obj, key) => {
				obj[key] = CONFIG.BlackFlag.abilities.localized[key];
				return obj;
			}, {}),
			abilitySelection: this.advancement.configuration.spell.ability.size > 1
		});
	}
}

/**
 * Configuration application for hit points.
 */
class HitPointsConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["hit-points", "form-list"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		hitDice: {
			template: "systems/black-flag/templates/advancement/hit-points-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.hitDieSizes = Object.fromEntries(CONFIG.BlackFlag.hitDieSizes.map(n => [n, `d${n}`]));
		context.showClassRestriction = false;
		return context;
	}
}

/**
 * Inline application that presents hit points selection upon level up.
 */
class HitPointsFlow extends AdvancementFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/hit-points-flow.hbs"
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getData() {
		return foundry.utils.mergeObject(super.getData(), {
			denomination: this.advancement.configuration.denomination,
			isFirstLevel: this.levels.character === 1
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _updateObject(event, formData) {
		const action = event.submitter.dataset.action;
		const level = this.advancement.relavantLevel(this.levels);

		// Take the average value
		if (action === "take-average") {
			return this.advancement.apply(this.levels, { [level]: "avg" });
		} else if (action === "roll") {
			const roll = new Roll(`1d${this.advancement.configuration.denomination}`);
			await roll.evaluate();

			// Create chat message with roll results
			const cls = getDocumentClass("ChatMessage");
			const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", {
				type: game.i18n.localize("BF.HitPoint.Label[other]")
			});
			const messageData = {
				flavor,
				title: `${flavor}: ${this.advancement.actor.name}`,
				speaker: cls.getSpeaker({ actor: this.advancement.actor }),
				user: game.user.id,
				type: CONST.CHAT_MESSAGE_TYPES.ROLL,
				content: "",
				sound: CONFIG.sounds.dice,
				rolls: [roll],
				"flags.blackFlag.type": "hitPoints"
			};
			const message = new cls(messageData);
			await cls.create(message.toObject(), { rollMode: game.settings.get("core", "rollMode") });

			return this.advancement.apply(this.levels, { [level]: roll });
		}
	}
}

/**
 * Configuration application for improvement.
 */
class ImprovementConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["improvement", "form-list"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		improvement: {
			template: "systems/black-flag/templates/advancement/improvement-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.showClassRestriction = false;
		if (this.advancement.metadata.type === "expandedTalentList") context.showLevelSelector = false;
		context.talentCategories = Object.entries(CONFIG.BlackFlag.talentCategories.localizedPlural).reduce(
			(obj, [key, label]) => {
				obj[key] = { label, selected: this.advancement.configuration.talentList.has(key) ? "selected" : "" };
				return obj;
			},
			{}
		);
		return context;
	}
}

/**
 * Inline application that presents a ability & talent choices.
 */
class ImprovementFlow extends AdvancementFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/improvement-flow.hbs",
			submitOnChange: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getData(options) {
		const context = super.getData(options);
		context.abilities = Object.entries(CONFIG.BlackFlag.abilities.localized).reduce((obj, [key, label]) => {
			const ability = this.actor.system.abilities[key];
			if (ability.value < ability.max) {
				obj[key] = `${label}: ${numberFormat(ability.value)} â†’ ${numberFormat(ability.value + 1)}`;
			}
			return obj;
		}, {});
		context.selectAbility = !this.advancement.configuredForLevel(this.levels);
		context.selectTalent = foundry.utils.isEmpty(this.advancement.value.talent) && context.selectAbility;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll('[data-action="remove-choice"]')) {
			element.addEventListener("click", e => {
				const key = e.target.closest("[data-key]").dataset.key;
				this.advancement.reverse(this.levels, { key });
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _updateObject(event, formData) {
		if (event.submitter?.dataset.action === "select-choice") {
			let choice;
			try {
				const promise = new Promise((resolve, reject) => {
					new ChooseFeaturesDialog(this, { details: { type: "talent" }, resolve, reject }).render({ force: true });
				});
				choice = await promise;
			} catch (err) {
				return;
			}
			this.advancement.apply(this.levels, { talent: choice });
		} else {
			this.advancement.apply(this.levels, formData);
		}
	}
}

/**
 * Configuration application for key ability.
 */
class KeyAbilityConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["key-ability", "form-list"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		keyAbility: {
			template: "systems/black-flag/templates/advancement/key-ability-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.abilities = Object.entries(CONFIG.BlackFlag.abilities).reduce((obj, [key, config]) => {
			obj[key] = {
				label: config.labels.full,
				keySelected: this.advancement.configuration.options.has(key)
			};
			return obj;
		}, {});
		context.showClassRestriction = false;
		context.showLevelSelector = false;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareConfigurationUpdate(configuration) {
		configuration.options = filteredKeys(configuration.options);
		return configuration;
	}
}

/**
 * Configuration application for property advancement.
 */
class PropertyConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["property", "form-list"],
		actions: {
			addChange: PropertyConfig.#onAddChange,
			deleteChange: PropertyConfig.#onDeleteChange
		},
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		changes: {
			template: "systems/black-flag/templates/advancement/property-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.modes = Object.entries(CONST.ACTIVE_EFFECT_MODES).reduce((obj, e) => {
			obj[e[1]] = game.i18n.localize(`EFFECT.MODE_${e[0]}`);
			return obj;
		}, {});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a change to the list.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onAddChange(event, target) {
		const idx = this.advancement.configuration.changes.length;
		return this.submit({ updateData: { [`configuration.changes.${idx}`]: {} } });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle deleting a change to the list.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onDeleteChange(event, target) {
		target.closest("[data-index]")?.remove();
		return this.submit();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async prepareConfigurationUpdate(configuration) {
		configuration.changes = Object.values(configuration.changes ?? []);
		return configuration;
	}
}

/**
 * Configuration application for scale values.
 */
class ScaleValueConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["scale-value", "grid-columns"],
		position: {
			width: 640
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/scale-value-config-details.hbs"
		},
		scale: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/advancement/scale-value-config-scale.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Range of levels that can be used based on what item type this advancement is within.
	 * @type {number[]}
	 */
	get levelRange() {
		let levels = Array.fromRange(CONFIG.BlackFlag.maxLevel + 1);
		return ["class", "subclass"].includes(this.advancement.item.type) ? levels.slice(1) : levels;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		await super._preparePartContext(partId, context, options);
		context.type = CONFIG.Advancement.types.scaleValue.dataTypes[this.advancement.configuration.type].metadata;
		if (partId === "config") return await this._prepareConfigContext(context, options);
		if (partId === "scale") return await this._prepareScaleContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the config section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareConfigContext(context, options) {
		let identifierHint = game.i18n.format(this.advancement.metadata.identifier.hint, {
			parentIdentifier: this.advancement.parentIdentifier,
			identifier: this.advancement.identifier
		});
		if (this.advancement.configuration.type === "dice") {
			identifierHint = `${identifierHint} ${game.i18n.format("BF.Advancement.ScaleValue.Identifier.DiceHint", {
				parentIdentifier: this.advancement.parentIdentifier,
				identifier: this.advancement.identifier
			})}`;
		}
		context.default.identifierHint = identifierHint;
		context.types = Object.fromEntries(
			Object.entries(CONFIG.Advancement.types.scaleValue.dataTypes).map(([key, d]) => [
				key,
				game.i18n.localize(d.metadata.label)
			])
		);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the scale section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareScaleContext(context, options) {
		const ScaleValueType = CONFIG.Advancement.types.scaleValue.dataTypes[this.advancement.configuration.type];
		context.faces = Object.fromEntries(CONFIG.BlackFlag.scaleDiceSizes.map(die => [die, `d${die}`]));
		context.levels = this.levelRange.reduce((obj, level) => {
			obj[level] = {
				placeholder: this.advancement.valueForLevel(level - 1)?.placeholder ?? new ScaleValueType().placeholder,
				value: this.advancement.configuration.scale[level] ?? {}
			};
			return obj;
		}, {});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _processSubmitData(event, form, submitData) {
		const type = foundry.utils.getProperty(submitData, "configuration.type");
		if (!type || type === this.advancement.configuration.type) return super._processSubmitData(event, form, submitData);

		// Perform the update with old type
		delete submitData.configuration.type;
		await super._processSubmitData(event, form, submitData);

		// Transform values into new type
		const NewType = CONFIG.Advancement.types.scaleValue.dataTypes[type];
		for (const level of this.levelRange) {
			const value = this.advancement.valueForLevel(level);
			if (value) submitData.configuration.scale[level] = NewType.convertFrom(value)?.toObject();
			else submitData.configuration.scale[`-=${level}`] = null;
		}
		submitData.configuration.type = type;

		// Perform the update once more with new data
		return super._processSubmitData(event, form, submitData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareConfigurationUpdate(configuration) {
		// Determine keys that should be present
		const ScaleValueType =
			CONFIG.Advancement.types.scaleValue.dataTypes[configuration.type ?? this.advancement.configuration.type];
		const validKeys = Object.keys(ScaleValueType.schema.fields);

		let lastValue = {};
		const scale = {};
		for (const level of this.levelRange) {
			const value = configuration.scale[level] ?? {};
			scale[level] ??= {};
			for (const key of validKeys) {
				// No value or same as previous value, don't store it
				if (!value[key] || value[key] === lastValue[key]) scale[level][`-=${key}`] = null;
				// Value is new, store it and update lastValue
				else lastValue[key] = scale[level][key] = value[key];
				// TODO: Run value through validator on DataField
			}

			// Strip out any unrecognized keys
			for (const key of Object.keys(this.advancement.configuration.scale[level] ?? {})) {
				if (!validKeys.includes(key)) scale[level][`-=${key}`] = null;
			}

			// If all updates are removals, just remove the level
			if (Object.keys(scale[level]).every(k => k.startsWith("-="))) {
				delete scale[level];
				scale[`-=${level}`] = null;
			}
		}
		configuration.scale = scale;

		return configuration;
	}
}

/**
 * Configuration application for sizes.
 */
class SizeConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["size", "form-list"]
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		size: {
			template: "systems/black-flag/templates/advancement/size-config.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.sizes = Object.entries(CONFIG.BlackFlag.sizes).reduce((obj, [key, config]) => {
			obj[key] = {
				label: config.label,
				selected: this.advancement.configuration.options.has(key)
			};
			return obj;
		}, {});
		context.showLevelSelector = false;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	async prepareConfigurationUpdate(configuration) {
		configuration.options = filteredKeys(configuration.options);
		return configuration;
	}
}

/**
 * Inline application that presents a size choice.
 */
class SizeFlow extends AdvancementFlow {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/size-flow.hbs",
			submitOnChange: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	getData(options) {
		const context = super.getData(options);
		context.sizes = this.advancement.configuration.options.reduce((obj, key) => {
			obj[key] = CONFIG.BlackFlag.sizes[key].label;
			return obj;
		}, {});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _updateObject(event, formData) {
		this.advancement.apply(this.levels, formData.size);
	}
}

/**
 * Configuration application for spellcasting.
 */
class SpellcastingConfig extends AdvancementConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["spellcasting", "form-list"],
		actions: {
			addScale: SpellcastingConfig.#onAddScale,
			openScale: SpellcastingConfig.#onOpenScale
		},
		position: {
			width: 500
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/advancement-controls-section.hbs"
		},
		details: {
			template: "systems/black-flag/templates/advancement/spellcasting-config-details.hbs"
		},
		learning: {
			template: "systems/black-flag/templates/advancement/spellcasting-config-learning.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Formulas that can be configured.
	 * TODO: Fetch this information from the data model itself
	 */
	static KNOWN = Object.freeze({
		cantrips: { label: "BF.Spellcasting.FIELDS.cantrips.label", hint: "BF.Spellcasting.FIELDS.cantrips.hint" },
		rituals: { label: "BF.Spellcasting.FIELDS.rituals.label", hint: "BF.Spellcasting.FIELDS.rituals.hint" },
		spells: { label: "BF.Spellcasting.FIELDS.spells.label", hint: "BF.Spellcasting.FIELDS.spells.hint" }
	});

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		await super._preparePartContext(partId, context, options);
		context.showClassRestriction = false;
		if (partId === "details") return await this._prepareDetailsContext(context, options);
		if (partId === "learning") return await this._prepareLearningContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the config section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareDetailsContext(context, options) {
		const typeConfig = CONFIG.BlackFlag.spellcastingTypes[this.advancement.configuration.type];
		context.displayType = Object.keys(CONFIG.BlackFlag.spellcastingTypes).length > 1;
		context.progressionOptions = typeConfig?.progression;
		context.slots = {
			scaleValue: this.advancement.configuration.slots.scaleValue,
			display: this.advancement.configuration.type === "pact"
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the scale section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareLearningContext(context, options) {
		const typeConfig = CONFIG.BlackFlag.spellcastingTypes[this.advancement.configuration.type];
		if (this.advancement.configuration.spells.mode) {
			context.known = Object.entries(this.constructor.KNOWN).reduce((obj, [name, localization]) => {
				const config = this.advancement.configuration[name];
				const anchor = config.scaleValue?.toAnchor();
				if (anchor) anchor.dataset.action = "openScale";
				obj[name] = {
					...localization,
					anchor: anchor?.outerHTML,
					scaleValue: config.scaleValue
				};
				return obj;
			}, {});
			if (this.advancement.configuration.spells.mode !== "limited") delete context.known.spells;
		}

		context.learningModes =
			!typeConfig || typeConfig.learningModes === false
				? null
				: Object.entries(CONFIG.BlackFlag.spellLearningModes).reduce((obj, [k, v]) => {
						if (!typeConfig.learningModes || typeConfig.learningModes.has(k)) obj[k] = v;
						return obj;
					}, {});

		const schools = this.advancement.configuration.spells.schools;
		if (schools.size)
			context.schoolLabel = game.i18n.getListFormatter({ type: "unit" }).format(
				Array.from(schools)
					.map(s => CONFIG.BlackFlag.spellSchools.localized[s])
					.filter(s => s)
			);
		else context.schoolLabel = game.i18n.localize("BF.Spellcasting.Learning.Schools.NoRestriction");

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a spellcasting value.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onAddScale(event, target) {
		const name = target.closest("[data-name]").dataset.name;
		if (this.advancement.configuration[name].scaleValue) return;
		const title = game.i18n.localize(
			name === "slots" ? "BF.Spellcasting.FIELDS.slots.label" : this.constructor.KNOWN[name].label
		);
		const scaleData = { type: "spellcastingValue", title, identifier: `${name}-known` };
		const [scale] = await this.item.createEmbeddedDocuments("Advancement", [scaleData]);
		await this.advancement.update({ [`configuration.${name}.scale`]: scale.id });
		scale.sheet.render({ force: true });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle opening a spellcasting value sheet.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onOpenScale(event, target) {
		const advancement = await fromUuid(target.dataset.uuid);
		advancement?.sheet.render({ force: true });
	}
}

/**
 * Application for learning new spells.
 */
class SpellcastingDialog extends BFApplication {
	constructor(advancement, levels, options = {}) {
		super(options);

		this.advancement = advancement;
		this.levels = levels;
		this.existingSpells = this.advancement._getExistingSpells({ identifiers: true });

		this.slots = [];
		const level = this.advancement.relavantLevel(levels);
		const stats = this.advancement.statsForLevel(levels);

		const spellsBySlot = {};
		for (const spell of this.advancement._getAddedSpells(this.levels)) {
			spellsBySlot[spell.slot] ??= [];
			spellsBySlot[spell.slot].push(spell.uuid);
			this.existingSpells.delete(this.actor.items.get(spell.document)?.identifier);
		}

		for (const [type, data] of stats) {
			let total = data.total;
			if (type === "replacement" && this.advancement.replacesSpellAt(level)) {
				const replacedData = this.advancement.value.replaced?.[level];
				const replaces = this.getReplacesSlot(replacedData?.level, replacedData?.original);
				this.slots.push({ type, selected: spellsBySlot[type]?.shift(), replaces });
			} else {
				this.slots.push(...Array.fromRange(total).map((s, i) => ({ type, selected: spellsBySlot[type]?.shift() })));
			}
		}

		// Begin fetching spells to display
		this.allSpells = compendiums(Item, {
			type: "spell",
			indexFields: new Set(["system.source", "system.school", "system.circle.base", "system.tags"])
		}).then(spells =>
			spells.reduce((map, spell) => {
				map.set(spell.uuid, spell);
				return map;
			}, new Collection())
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			continue: SpellcastingDialog.#continue,
			learn: SpellcastingDialog.#learn
		},
		classes: ["spell-manager"],
		position: {
			width: 775,
			height: 700
		},
		tag: "form",
		window: {
			resizable: true
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		slots: {
			template: "systems/black-flag/templates/advancement/spellcasting-dialog-slots.hbs",
			scrollable: [""]
		},
		restrictions: {
			template: "systems/black-flag/templates/advancement/spellcasting-dialog-restrictions.hbs"
		},
		spells: {
			template: "systems/black-flag/templates/advancement/spellcasting-dialog-spells.hbs",
			scrollable: [""]
		},
		controls: {
			template: "systems/black-flag/templates/advancement/spellcasting-dialog-controls.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mapping of slot types to labels.
	 * @enum {string}
	 */
	static TYPE_LABELS = {
		cantrips: "BF.Spell.Circle.Cantrip[one]",
		replacement: "BF.Advancement.Spellcasting.Replacement.Slot",
		rituals: "BF.Spell.Tag.Ritual.Label",
		special: "BF.Item.Type.Spell[one]",
		spells: "BF.Item.Type.Spell[one]",
		"spellbook:free": "BF.Spellbook.FreeSpell.Label[one]"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actor for which the spells will be added.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.advancement.actor;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The associated spellcasting advancement.
	 * @type {SpellcastingAdvancement}
	 */
	advancement;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Indices of all spells that can potentially be added across all compendiums.
	 * @type {Promise<object[]>}
	 */
	allSpells;

	/**
	 * Set of sourceIds for spells already learned, not including those being added during this session.
	 * @type {Set<string>}
	 */
	existingSpells;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Level at which spells are being selected.
	 * @type {AdvancementLevels}
	 */
	levels;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Currently selected slot.
	 * @type {SpellSlotData}
	 */
	get currentSlot() {
		return this.slots[this.selectedSlot];
	}

	/**
	 * Index of the currently selected slot.
	 * @type {number}
	 */
	selectedSlot = 0;

	/**
	 * Data representing a single spell learning slot.
	 * @typedef {object} SpellSlotData
	 *
	 * @property {string} type - Type of spell that can be added to the slot.
	 * @property {string} selected - UUID for selected spell.
	 * @property {string} [name] - Name to display for this slot.
	 * @property {ReplacedSlotData} [replaces] - Data for the spell being replaced.
	 */

	/**
	 * @typedef {object} ReplacedSlotData
	 * @property {string} id - ID of the spell being replaced.
	 * @property {number} level - Level of the spell that was replaced.
	 * @property {string} type - Type of spell that can be added to the slot.
	 * @property {string} uuid - UUID for selected spell.
	 */

	/**
	 * List of slots that need to be filled with spells.
	 * @type {SpellSlotData[]}
	 */
	slots;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The spellcasting configuration.
	 * @type {SpellcastingConfigurationData}
	 */
	get spellcasting() {
		return this.advancement.configuration;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.localize("BF.Spellbook.Title");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		if (!this.currentSlot) return context;
		const level = this.advancement.relavantLevel(this.levels);

		let type = this.currentSlot.type;
		if (this.currentSlot.type === "replacement") type = this.currentSlot.replaces?.type ?? null;

		const filters = this.prepareFilters(type);
		if (filters) context.restrictions = this.prepareRestrictions(filters);

		const otherSelected = new Set();
		context.slots = this.slots.map((slot, index) => {
			if (slot.selected) otherSelected.add(slot.selected);
			return {
				...slot,
				name: slot.name ?? this.constructor.TYPE_LABELS[slot.type],
				number: slot.type === "replacement" ? "?" : index + 1,
				selected: index === this.selectedSlot,
				spell: slot.selected ? fromUuidSync(slot.selected) : null
			};
		});

		const replacedUuid = this.currentSlot.replaces?.uuid;
		context.spells = filters
			? (await this.allSpells).filter(
					s =>
						!this.existingSpells.has(s.system.identifier.value) &&
						filters &&
						performCheck(s, filters) &&
						s.uuid !== replacedUuid
				)
			: [];
		context.spells = context.spells.map(spell => ({
			...spell,
			disabled: this.currentSlot?.selected !== spell.uuid && otherSelected.has(spell.uuid),
			selected: this.currentSlot?.selected === spell.uuid
		}));

		// All spells selected for this class at lower levels that haven't already been replaced
		if (this.currentSlot.type === "replacement") {
			const validSlots = new Set(["replacement", "spells", "special"]);
			const previousSpells = new Set();
			const replacedData = this.advancement.value.replaced?.[level];
			for (const level of Array.fromRange(this.advancement.relavantLevel(this.levels) - 1, 1)) {
				for (const data of this.advancement.value._source.added?.[level] ?? []) {
					if (!validSlots.has(data.slot)) continue;
					let spell = this.actor.items.get(data.document);
					if (!spell && data.document === replacedData?.original) spell = fromUuidSync(data.uuid);
					if (spell) previousSpells.add({ id: data.document, level, name: spell.name });
				}
			}
			context.replacementOptions = [
				{ value: "", label: game.i18n.localize("BF.Advancement.Spellcasting.Replacement.None") },
				{ rule: true },
				...Array.from(previousSpells)
					.map(({ id, level, name: label }) => ({
						value: `${level}.${id}`,
						label,
						selected: id === this.currentSlot.replaces?.id
					}))
					.sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang))
			];
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the filters for spells in the current slot.
	 * @param {string} type - Type of slot being prepared.
	 * @returns {FilterDescription[]|void}
	 */
	prepareFilters(type) {
		const filters = [];
		const schools = this.spellcasting.spells.schools;
		const maxCircle = this.advancement.computeMaxCircle(this.advancement.relavantLevel(this.levels));

		// Always restrict by source unless current slot is special and there are no schools set
		// or the slot is ritual and ritual source isn't restricted
		if (
			!(
				(type === "special" && !schools.size) ||
				(type === "rituals" && !this.advancement.configuration.rituals.restricted)
			)
		) {
			filters.push({ k: "system.source", o: "has", v: this.spellcasting.source });
		}

		switch (type) {
			case "cantrips":
				// Cantrips are always circle 0
				filters.push({ k: "system.circle.base", v: 0 });
				break;
			case "rituals":
				filters.push(
					// Circle must be less than maximum
					{ k: "system.circle.base", o: "lte", v: maxCircle },
					// Must be a ritual spell
					{ k: "system.tags", o: "has", v: "ritual" }
				);
				break;
			case "spells":
				// Add restriction on school if they are set
				if (schools.size) filters.push({ k: "system.school", o: "in", v: schools });
			case "special":
			case "spellbook:free":
			case "spellbook:paid":
				filters.push(
					// No cantrips
					{ k: "system.circle.base", o: "gte", v: 1 },
					// Circle must be less than maximum
					{ k: "system.circle.base", o: "lte", v: maxCircle },
					// No ritual spells
					{ o: "NOT", v: { k: "system.tags", o: "has", v: "ritual" } }
				);
				break;
			default:
				return;
		}

		return filters;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare displayed restrictions based on provided filters.
	 * @param {FilterDescription[]} filters
	 * @returns {object}
	 */
	prepareRestrictions(filters) {
		const restrictions = {};

		const source = filters.find(f => f.k === "system.source");
		if (source) restrictions.source = CONFIG.BlackFlag.spellSources.localized[source.v];

		const schools = filters.find(f => f.k === "system.school");
		if (schools)
			restrictions.schools = game.i18n.getListFormatter({ type: "disjunction" }).format(
				Array.from(schools.v)
					.map(s => CONFIG.BlackFlag.spellSchools.localized[s])
					.filter(s => s)
			);

		const circle = filters.find(f => f.k === "system.circle.base" && !f.o);
		const maxCircle = filters.find(f => f.k === "system.circle.base" && f.o === "lte");
		if (circle?.v) restrictions.circle = CONFIG.BlackFlag.spellCircles()[circle.v];
		else if (maxCircle) restrictions.maxCircle = CONFIG.BlackFlag.spellCircles()[maxCircle.v];

		return restrictions;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Life-Cycle Handlers         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);
		this.element.querySelectorAll("[data-spell-uuid]").forEach(element => {
			element.dataset.tooltip = `<section class="loading" data-uuid="${element.dataset.spellUuid}"></section>`;
			element.dataset.tooltipClass = "black-flag black-flag-tooltip item-tooltip";
			element.dataset.tooltipDirection = "LEFT";
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*  Event Listeners                    */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle continuing to the next slot.
	 * @this {SpellcastingDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #continue(event, target) {
		let nextIndex = this.selectedSlot;
		do {
			nextIndex += 1;
			if (nextIndex > this.slots.length - 1) nextIndex = 0;
		} while (this.slots[nextIndex]?.selected && nextIndex !== this.selectedSlot);
		this.selectedSlot = nextIndex;
		this.render();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle learning spells.
	 * @this {SpellcastingDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #learn(event, target) {
		const toAdd = new Map();
		const toRemove = new Set();
		let replacement;
		const visibleSlots = new Set();

		for (const slot of this.slots) {
			visibleSlots.add(slot.type);
			if (!slot.selected) continue;
			if (slot.type === "replacement") replacement = { original: slot.replaces, replacement: slot.selected };
			else toAdd.set(slot.selected, slot.type);
		}

		for (const spell of this.advancement._getAddedSpells(this.levels)) {
			if (!visibleSlots.has(spell.slot) || spell.slot === "replacement") continue;
			if (toAdd.get(spell.uuid) === spell.slot) toAdd.delete(spell.uuid);
			else toRemove.add(spell.document);
		}

		await this.close();

		if (toRemove.size) await this.advancement.reverse(this.levels, { deleteIds: toRemove });

		if (toAdd.size || replacement)
			await this.advancement.apply(this.levels, {
				added: Array.from(toAdd.entries()).map(([uuid, slot]) => ({ uuid, slot })),
				replacement
			});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		super._onChangeForm(formConfig, event);

		switch (event.target.name) {
			case "replaces":
				if (this.currentSlot.type !== "replacement") return;
				if (event.target.value) {
					const [level, id] = event.target.value.split(".") ?? [];
					this.currentSlot.replaces = this.getReplacesSlot(Number(level), id);
				} else {
					this.currentSlot.replaces = null;
					this.currentSlot.selected = null;
				}
				return this.render();
			case "selected-slot":
				this.selectedSlot = Number(event.target.value);
				return this.render();
			case "selected-spell":
				this.currentSlot.selected = event.target.value;
				return this.render();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch the necessary slot data for a spell to be replaced.
	 * @param {number} [level] - Level of the spell being replaced.
	 * @param {string} [id] - ID of the spell being replaced.
	 * @returns {SpellSlotData|null}
	 */
	getReplacesSlot(level, id) {
		const addedData = this.advancement.value._source.added?.[level]?.find(a => a.document === id);
		const replacedSlot = this.advancement.value._source.replaced?.[level]?.slot;
		return addedData ? { id, level, type: replacedSlot ?? addedData.slot, uuid: addedData.uuid } : null;
	}
}

/**
 * Inline application that presents spell learning at level up.
 */
class SpellcastingFlow extends AdvancementFlow {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/spellcasting-flow.hbs"
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getData(options = {}) {
		const context = super.getData(options);
		const level = this.advancement.relavantLevel(this.levels);
		const stats = this.advancement.statsForLevel(this.levels);
		const validLevel = this.advancement.learnsSpellsAt(level) || this.advancement.replacesSpellAt(level);
		context.showLearnSpells = (validLevel && context.modes.editing) || stats.needToLearn;
		context.showReplacement =
			!context.showLearnSpells && this.advancement.replacesSpellAt(level) && stats.get("replacement").toLearn;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _updateObject(event, formData) {
		const action = event.submitter.dataset.action;
		if (action === "learn-spells") new SpellcastingDialog(this.advancement, this.levels).render({ force: true });
	}
}

/**
 * Configuration application for scale values.
 */
class SpellcastingValueConfig extends ScaleValueConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["scale-value", "form-list"],
		columns: 1,
		position: {
			width: 400
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/advancement/scale-value-config-details.hbs"
		},
		scale: {
			template: "systems/black-flag/templates/advancement/spellcasting-value-config-scale.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.showClassRestriction = false;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareConfigContext(context, options) {
		context = await super._prepareConfigContext(context, options);
		context.types = null;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareConfigurationUpdate(configuration) {
		let lastValue = {};
		const scale = {};
		for (const level of this.levelRange) {
			const value = configuration.scale[level] ?? {};
			scale[level] ??= {};

			// If no value or value is not greater than previous value, remove whole entry
			if (!value.value || value.value <= lastValue.value) {
				delete scale[level];
				scale[`-=${level}`] = null;
			}

			// Otherwise store it and track it as the last value
			else lastValue.value = scale[level].value = value.value;
		}
		configuration.scale = scale;

		return configuration;
	}
}

/**
 * Configuration application for traits.
 */
class TraitConfig extends AdvancementConfig {
	constructor(...args) {
		super(...args);
		this.selected = this.config.choices.length && !this.config.grants.size ? 0 : -1;
		this.trait = this.types.first() ?? "skills";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["trait", "grid-columns"],
		actions: {
			addChoice: TraitConfig.#onAddChoice,
			deleteChoice: TraitConfig.#onDeleteChoice
		},
		position: {
			width: 650
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/trait-config-details.hbs"
		},
		guaranteed: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/trait-config-guaranteed.hbs"
		},
		choices: {
			container: { classes: ["column-container"], id: "column-left" },
			template: "systems/black-flag/templates/advancement/trait-config-choices.hbs"
		},
		options: {
			container: { classes: ["column-container"], id: "column-right" },
			template: "systems/black-flag/templates/advancement/trait-config-options.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Shortcut to the configuration data on the advancement.
	 * @type {TraitConfigurationData}
	 */
	get config() {
		return this.advancement.configuration;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Index of the selected configuration, `-1` means `grants` array, any other number is equal
	 * to an index in `choices` array.
	 * @type {number}
	 */
	selected;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Trait type to display in the selector interface.
	 * @type {string}
	 */
	trait;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * List of trait types for the current selected configuration.
	 * @type {Set<string>}
	 */
	get types() {
		const pool = this.selected === -1 ? this.config.grants : this.config.choices[this.selected].pool;
		return new Set(Array.from(pool).map(k => k.split(":").shift()));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		await super._preparePartContext(partId, context, options);

		context.choices = this.config.choices.map((choice, index) => ({
			label: choiceLabel(choice, { only: true }).capitalize() || "â€”",
			data: choice,
			selected: this.selected === index
		}));
		context.grants = {
			label: localizedList(this.config.grants) || "â€”",
			data: this.config.grants,
			selected: this.selected === -1
		};
		context.selectedIndex = this.selected;

		if (partId === "config") return await this._prepareConfigContext(context, options);
		if (partId === "guaranteed") return await this._prepareGuaranteedContext(context, options);
		if (partId === "choices") return await this._prepareChoicesContext(context, options);
		if (partId === "options") return await this._prepareOptionsContext(context, options);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the config section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareConfigContext(context, options) {
		const traitConfig = CONFIG.BlackFlag.traits[this.advancement.bestGuessTrait()];
		if (traitConfig) {
			context.default.title = game.i18n.localize(traitConfig.labels.title);
			context.default.icon = traitConfig.icon;
		}
		context.default.hint = localizedList(this.config.grants, this.config.choices, {
			choiceMode: this.config.choiceMode
		});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the guaranteed section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareGuaranteedContext(context, options) {
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the choices section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareChoicesContext(context, options) {
		context.count = context.choices[this.selected]?.data.count;
		context.choiceModeOptions = [
			{ value: "inclusive", label: game.i18n.localize("BF.Advancement.Trait.Choice.Mode.Inclusive.Label") },
			{ value: "exclusive", label: game.i18n.localize("BF.Advancement.Trait.Choice.Mode.Exclusive.Label") }
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the options section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 */
	async _prepareOptionsContext(context, options) {
		const chosen = this.selected === -1 ? context.grants.data : context.choices[this.selected].data.pool;
		context.choiceOptions = choices(this.trait, { chosen, prefixed: true, any: this.selected !== -1 });
		context.selectedTraitHeader = `${CONFIG.BlackFlag.traits[this.trait].labels.localization}[other]`;
		context.selectedTrait = this.trait;
		context.validTraitTypes = Object.entries(CONFIG.BlackFlag.traits).reduce((obj, [key, config]) => {
			if (this.config.mode === "default" || (config.type === "proficiency" && config.expertise))
				obj[key] = config.labels.title;
			return obj;
		}, {});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(context, options) {
		super._onRender(context, options);

		// Handle selecting & disabling category children when a category is selected
		for (const checkbox of this.element.querySelectorAll(".trait-options input:checked")) {
			const toCheck = checkbox.name.endsWith("*")
				? checkbox.closest("ol").querySelectorAll(`input:not([name="${checkbox.name}"])`)
				: checkbox.closest("li").querySelector("ol")?.querySelectorAll("input");
			toCheck?.forEach(i => (i.checked = i.disabled = true));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a choice to the list.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onAddChoice(event, target) {
		this.config.choices.push({ count: 1 });
		this.selected = this.config.choices.length - 1;
		this.config.grants = Array.from(this.advancement.configuration.grants);
		this.config.choices.forEach(c => {
			if (!c.pool) return;
			c.pool = Array.from(c.pool);
		});
		await this.advancement.update({ configuration: this.config });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle deleting a choice to the list.
	 * @this {AdvancementConfig}
	 * @param {Event} event - The originating click event.
	 * @param {HTMLElement} target - The button that was clicked.
	 * @returns {Promise<BlackFlagItem>} - The updated parent Item after the application re-renders.
	 */
	static async #onDeleteChoice(event, target) {
		const input = target.closest("li").querySelector("[name='selectedIndex']");
		const selectedIndex = Number(input.value);
		this.config.choices.splice(selectedIndex, 1);
		if (selectedIndex <= this.selected) this.selected -= 1;
		this.config.grants = Array.from(this.advancement.configuration.grants);
		this.config.choices.forEach(c => {
			if (!c.pool) return;
			c.pool = Array.from(c.pool);
		});
		await this.advancement.update({ configuration: this.config });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onChangeForm(formConfig, event) {
		// Display new set of trait choices
		if (event.target.name === "selectedTrait") {
			this.trait = event.target.value;
			return this.render();
		}

		// Change selected configuration set
		if (event.target.name === "selectedIndex") {
			this.selected = Number(event.target.value ?? -1);
			const types = this.types;
			if (types.size && !types.has(this.trait)) this.trait = types.first();
			return this.render();
		}

		// If mode is changed from default to one of the others change selected type if current type is not valid
		if (
			event.target.name === "configuration.mode" &&
			event.target.value !== "default" &&
			this.config.mode === "default"
		) {
			const validTraitTypes = filteredKeys(CONFIG.BlackFlag.traits, c => c.type === "proficiency" && c.expertise);
			if (!validTraitTypes.includes(this.trait)) this.trait = validTraitTypes[0];
		}

		super._onChangeForm(formConfig, event);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareConfigurationUpdate(configuration) {
		const choicesCollection = foundry.utils.deepClone(this.config.choices);

		if (configuration.checked) {
			const prefix = `${this.trait}:`;
			const filteredSelected = filteredKeys(configuration.checked);

			// Update grants
			if (this.selected === -1) {
				const filteredPrevious = this.config.grants.filter(k => !k.startsWith(prefix));
				configuration.grants = [...filteredPrevious, ...filteredSelected];
			}

			// Update current choice pool
			else {
				const current = choicesCollection[this.selected];
				const filteredPrevious = current.pool.filter(k => !k.startsWith(prefix));
				current.pool = [...filteredPrevious, ...filteredSelected];
			}
			delete configuration.checked;
		}

		if (configuration.count) {
			choicesCollection[this.selected].count = configuration.count;
			delete configuration.count;
		}

		// TODO: Remove when https://github.com/foundryvtt/foundryvtt/issues/7706 is resolved
		choicesCollection.forEach(c => {
			if (!c.pool) return;
			c.pool = Array.from(c.pool);
		});
		configuration.choices = choicesCollection;
		configuration.grants ??= Array.from(this.config.grants);

		// If one of the expertise modes is selected, filter out any traits that are not of a valid type
		if ((configuration.mode ?? this.config.mode) !== "default") {
			const validTraitTypes = filteredKeys(CONFIG.BlackFlag.traits, c => c.type === "proficiency" && c.expertise);
			configuration.grants = configuration.grants.filter(k => validTraitTypes.some(t => k.startsWith(t)));
			configuration.choices.forEach(c => (c.pool = c.pool.filter(k => validTraitTypes.some(t => k.startsWith(t)))));
		}

		return configuration;
	}
}

/**
 * Inline application that presents a trait choice.
 */
class TraitFlow extends AdvancementFlow {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "systems/black-flag/templates/advancement/trait-flow.hbs",
			submitOnChange: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	getData(options) {
		const context = super.getData(options);
		const { choices, label } = this.advancement.availableChoices() ?? {};
		context.availableChoices = choices ?? {};
		context.blankLabel = label;
		context.chosen = this.advancement.value.selected?.map(key => ({
			key,
			label: keyLabel(key)
		}));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll('[data-action="remove-choice"]')) {
			element.addEventListener("click", e => {
				const key = e.target.closest("[data-key]").dataset.key;
				this.advancement.reverse(this.levels, key);
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _updateObject(event, formData) {
		if (formData.added) this.advancement.apply(this.levels, new Set([formData.added]));
	}
}

var _module$m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AdvancementConfig: AdvancementConfig,
	AdvancementFlow: AdvancementFlow,
	AdvancementSelection: AdvancementSelection,
	ChooseFeaturesConfig: ChooseFeaturesConfig,
	ChooseFeaturesDialog: ChooseFeaturesDialog,
	ChooseFeaturesFlow: ChooseFeaturesFlow,
	ChooseSpellsConfig: ChooseSpellsConfig,
	ChooseSpellsFlow: ChooseSpellsFlow,
	EquipmentConfig: EquipmentConfig,
	EquipmentDialog: EquipmentDialog,
	EquipmentFlow: EquipmentFlow,
	GrantFeaturesConfig: GrantFeaturesConfig,
	GrantSpellsConfig: GrantSpellsConfig,
	GrantSpellsFlow: GrantSpellsFlow,
	HitPointsConfig: HitPointsConfig,
	HitPointsFlow: HitPointsFlow,
	ImprovementConfig: ImprovementConfig,
	ImprovementFlow: ImprovementFlow,
	KeyAbilityConfig: KeyAbilityConfig,
	PropertyConfig: PropertyConfig,
	ScaleValueConfig: ScaleValueConfig,
	SizeConfig: SizeConfig,
	SizeFlow: SizeFlow,
	SpellcastingConfig: SpellcastingConfig,
	SpellcastingDialog: SpellcastingDialog,
	SpellcastingFlow: SpellcastingFlow,
	SpellcastingValueConfig: SpellcastingValueConfig,
	TraitConfig: TraitConfig,
	TraitFlow: TraitFlow
});

var _module$l = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BFApplication: BFApplication,
	BFDocumentSheet: BFDocumentSheet,
	BFFormDialog: BFFormDialog,
	PseudoDocumentSelection: PseudoDocumentSelection,
	PseudoDocumentSheet: PseudoDocumentSheet
});

/**
 * Parse the provided rolls, splitting parts based on damage types & properties, taking flavor into account.
 * @param {DamageRoll[]} rolls - Evaluated damage rolls to aggregate.
 * @param {object} [options={}]
 * @param {boolean} [options.respectProperties] - Should damage properties also affect grouping?
 * @returns {DamageRoll[]}
 */
function aggregateDamageRolls(rolls, { respectProperties } = {}) {
	const makeHash = (type, magical) => [type, ...(respectProperties ? [String(magical)] : [])].join();

	// Split rolls into new sets of terms based on damage type & properties
	const types = new Map();
	for (const roll of rolls) {
		if (!roll._evaluated) throw new Error("Only evaluated rolls can be aggregated.");
		for (const chunk of chunkTerms(roll.terms, roll.options.damageType)) {
			const key = makeHash(chunk.type, roll.options.magical);
			if (!types.has(key)) types.set(key, { type: chunk.type, terms: [] });
			const data = types.get(key);
			data.terms.push(new foundry.dice.terms.OperatorTerm({ operator: chunk.negative ? "-" : "+" }), ...chunk.terms);
			data.magical = roll.options.magical;
		}
	}

	// Create new damage rolls based on the aggregated terms
	const newRolls = [];
	for (const type of types.values()) {
		const roll = new CONFIG.Dice.DamageRoll();
		roll.terms = type.terms;
		roll._total = roll._evaluateTotal();
		roll._evaluated = true;
		roll.options = { damageType: type.type, magical: type.magical };
		roll.resetFormula();
		newRolls.push(roll);
	}

	return newRolls;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Split terms into groups based on operators. Addition & subtraction will split groups while multiplication and
 * division will keep groups together. These groups also contain information on contained types written in flavor
 * and whether they are negative.
 * @param {RollTerm[]} terms - Terms to chunk.
 * @param {string} type - Type specified in the roll as a whole.
 * @returns {{ terms: RollTerm[], negative: boolean, type: string }[]}
 */
function chunkTerms(terms, type) {
	const pushChunk = () => {
		currentChunk.type ??= type;
		chunks.push(currentChunk);
		currentChunk = null;
		negative = false;
	};
	const isValidType = t => t in CONFIG.BlackFlag.damageTypes || t in CONFIG.BlackFlag.healingTypes;
	const chunks = [];
	let currentChunk;
	let negative = false;

	for (let term of terms) {
		// Plus or minus operators split chunks
		if (term instanceof foundry.dice.terms.OperatorTerm && ["+", "-"].includes(term.operator)) {
			if (currentChunk) pushChunk();
			if (term.operator === "-") negative = !negative;
			continue;
		}

		// All other terms get added to the current chunk
		term = foundry.dice.terms.RollTerm.fromData(foundry.utils.deepClone(term.toJSON()));
		currentChunk ??= { terms: [], negative, type: null };
		currentChunk.terms.push(term);
		const flavor = term.flavor?.toLowerCase().trim();
		if (isValidType(flavor)) {
			currentChunk.type ??= flavor;
			term.options.flavor = "";
		}
	}

	if (currentChunk) pushChunk();
	return chunks;
}

/**
 * Extended version of ChatMessage to highlight critical damage, support luck modifications, and other system features.
 */
class BlackFlagChatMessage extends ChatMessage {
	/**
	 * Item types representing chat trays that can open and close.
	 * @type {string[]}
	 */
	static TRAY_TYPES = ["blackFlag-attackResult", "blackFlag-damageApplication", "blackFlag-effectApplication"];

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_initializeSource(data, options = {}) {
		if (data instanceof foundry.abstract.DataModel) data = data.toObject();

		// Migrate old activation messages to the new ones
		// Added in 1.3.063
		if (data.flags?.[game.system.id]?.messageType === "activation" && data.type !== "activation") {
			data.type = "activation";
			delete data.flags[game.system.id].messageType;
			const move = (origin, destination) => {
				const value = foundry.utils.getProperty(data, `flags.${game.system.id}.${origin}`);
				if (value && !foundry.utils.hasProperty(data, `system.${destination}`)) {
					foundry.utils.setProperty(data, `system.${destination}`, value);
					foundry.utils.setProperty(data, `flags.${game.system.id}.${origin}`, null);
				}
			};
			move("activation.cause", "cause");
			move("activation.consumed", "deltas");
			move("activation.effects", "effects");
		}

		return super._initializeSource(data, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The currently highlighted token from this message.
	 * @type {BlackFlagToken|null}
	 * @protected
	 */
	_highlighted = null;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get isRoll() {
		if (this.system?.isRoll !== undefined) return this.system.isRoll;
		return super.isRoll;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should roll DCs and other challenge details be displayed on this card?
	 * @type {boolean}
	 */
	get shouldDisplayChallenge() {
		if (game.user.isGM || this.author === game.user) return true;
		switch (game.settings.get(game.system.id, "challengeVisibility")) {
			case "all":
				return true;
			case "player":
				return !this.author.isGM;
			default:
				return false;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Store the state of any trays in the message.
	 * @type {Map<string, boolean>}
	 * @protected
	 */
	_trayStates;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		super.prepareData();
		BlackFlag.registry.messages.track(this);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getHTML(options = {}) {
		const rendered = await super.getHTML(options);
		const html = rendered instanceof HTMLElement ? rendered : rendered[0];

		if (foundry.utils.getType(this.system?.getHTML) === "function") {
			await this.system.getHTML(html, options);
			return rendered;
		}

		if (!this.isContentVisible) return rendered;

		this._renderStandardCard(html);
		if (this.isRoll) {
			this._highlightRollResults(html);
			this._renderLuckInterface(html);
			await this._renderAttackUI(html);
			await this._renderDamageUI(html);
		}
		this._collapseTrays(html);

		return rendered;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform some standard rendering steps shared across all Black Flag cards.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	async _renderStandardCard(html) {
		if (!this.isContentVisible) return;
		for (const element of html.querySelectorAll(".blackFlag-icon")) {
			const icon = document.createElement("blackFlag-icon");
			if (element.inert) icon.setAttribute("inert", "");
			icon.src = element.dataset.src;
			element.replaceWith(icon);
		}
		this._renderHeader(html);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle collapsing or expanding chat trays.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	_collapseTrays(html) {
		let collapse;
		switch (game.settings.get(game.system.id, "collapseChatTrays")) {
			case "always":
				collapse = true;
				break;
			case "never":
				collapse = false;
				break;
			case "older":
				collapse = this.timestamp < Date.now() - 5 * 60 * 1000;
				break;
		}
		for (const element of html.querySelectorAll(this.constructor.TRAY_TYPES.join(", "))) {
			element.toggleAttribute("open", this._trayStates?.get(element.tagName) ?? !collapse);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add classes to roll results to indicate successes and failures.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	_highlightRollResults(html) {
		const originatingMessage = game.messages.get(this.getFlag(game.system.id, "originatingMessage")) ?? this;
		const displayAttackResult = game.user.isGM || game.settings.get(game.system.id, "attackVisibility") !== "none";
		const displayChallenge = originatingMessage.shouldDisplayChallenge;

		const rollResults = html.querySelectorAll(".dice-roll");
		for (const [index, roll] of this.rolls.entries()) {
			const result = rollResults[index];
			if (!result) return;

			const isAttack = this.getFlag(game.system.id, "roll.type") === "attack";
			const isDeathSave = this.getFlag(game.system.id, "roll.type") === "death";
			const showResult = isAttack ? displayAttackResult : displayChallenge;

			if (isAttack || isDeathSave) {
				if (roll.isCriticalSuccess) result.classList.add("critical-success");
				else if (roll.isCriticalFailure) result.classList.add("critical-failure");
			}
			if (showResult) {
				if (roll.isSuccess) result.classList.add("success");
				else if (roll.isFailure) result.classList.add("failure");
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the to-hit tray.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	async _renderAttackUI(html) {
		const displayAttackResult = game.user.isGM || game.settings.get(game.system.id, "attackVisibility") !== "none";
		const roll = this.rolls.filter(r => r instanceof CONFIG.Dice.ChallengeRoll)[0];
		const targets = this.getFlag(game.system.id, "targets");
		if (displayAttackResult && roll && targets?.length) {
			const attackResult = document.createElement("blackFlag-attackResult");
			attackResult.roll = roll;
			html.querySelector(".message-content").appendChild(attackResult);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display total damage and apply damage controls.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	async _renderDamageUI(html) {
		const rolls = this.rolls.filter(r => r instanceof CONFIG.Dice.DamageRoll);
		if (!rolls.length) return;

		const aggregatedRolls = CONFIG.BlackFlag.aggregateDamageDisplay ? aggregateDamageRolls(rolls) : rolls;
		const context = aggregatedRolls.reduce(
			(obj, r) => {
				obj.formulaParts.push(CONFIG.BlackFlag.aggregateDamageDisplay ? r.formula : ` + ${r.formula}`);
				obj.total += r.total;
				obj.parts.push(this._splitDamageRoll(r));
				return obj;
			},
			{ formulaParts: [], total: 0, parts: [] }
		);
		context.formula = context.formulaParts.join("").replace(/^ \+ /, "");
		const rendered = await renderTemplate(`systems/${game.system.id}/templates/chat/damage-tooltip.hbs`, context);
		html.querySelectorAll(".message-content .dice-roll").forEach(e => e.remove());
		html.querySelector(".message-content").insertAdjacentHTML("afterbegin", rendered);

		// TODO: Add option to make this optionally visible to players
		if (game.user.isGM) {
			const damageApplication = document.createElement("blackFlag-damageApplication");
			damageApplication.damages = aggregateDamageRolls(rolls, { respectProperties: true }).map(roll => ({
				magical: roll.options.magical === true,
				rollType: this.getFlag(game.system.id, "roll.type"),
				type: roll.options.damageType,
				value: roll.total
			}));
			html.querySelector(".message-content").appendChild(damageApplication);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Split a damage roll into dice and constant components.
	 * @param {DamageRoll} roll - Roll to split.
	 * @returns {{ constant: number, dice: { result: string, classes: string }[], total: number, type: string }}
	 * @protected
	 */
	_splitDamageRoll(roll) {
		const data = { constant: 0, dice: [], total: roll.total, type: roll.options.damageType };
		data.config = CONFIG.BlackFlag.damageTypes[data.type] ?? CONFIG.BlackFlag.healingTypes[data.type];
		let hasMultiplication = false;
		for (let i = roll.terms.length - 1; i >= 0; ) {
			const term = roll.terms[i--];
			if (!(term instanceof foundry.dice.terms.NumericTerm) && !(term instanceof foundry.dice.terms.DiceTerm)) continue;
			const value = term.total;
			if (term instanceof foundry.dice.terms.DiceTerm)
				data.dice.push(
					...term.results.map(r => ({
						result: term.getResultLabel(r),
						classes: term.getResultCSS(r).filterJoin(" ")
					}))
				);
			let multiplier = 1;
			let operator = roll.terms[i];
			while (operator instanceof foundry.dice.terms.OperatorTerm) {
				if (!["+", "-"].includes(operator.operator)) hasMultiplication = true;
				if (operator.operator === "-") multiplier *= -1;
				operator = roll.terms[--i];
			}
			if (term instanceof foundry.dice.terms.NumericTerm) data.constant += value * multiplier;
		}
		if (hasMultiplication) data.constant = null;
		return data;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add the effect application UI to a message.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	// 	_renderEffectUI(html) {
	// 		if (this.getFlag(game.system.id, "messageType") !== "activation") return;
	// 		const item = this.getAssociatedItem();
	// 		const effects = this.getFlag(game.system.id, "activation.effects")
	// 			?.map(id => item?.effects.get(id))
	// 			.filter(e => e && game.user.isGM); // TODO: Allow effects tray to be visible to players
	// 		if (!effects?.length) return;
	//
	// 		const effectApplication = document.createElement("blackFlag-effectApplication");
	// 		effectApplication.effects = effects;
	// 		html.querySelector(".message-content").appendChild(effectApplication);
	// 	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Swap the header element with a collapsible chat tray.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	_renderHeader(html) {
		const header = html.querySelector(".card-header.collapsible");
		if (!header) return;
		const tray = document.createElement("blackflag-tray");
		tray.classList.add("card-header");
		header.replaceWith(tray);
		tray.append(header);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the luck controls on the chat card if necessary.
	 * @param {HTMLElement} html - Chat message HTML.
	 */
	_renderLuckInterface(html) {
		if (!MessageLuckElement.shouldDisplayLuckInterface(this)) return;
		const content = html.querySelector(".message-content");
		content.insertAdjacentHTML("beforeend", "<blackFlag-messageLuck></blackFlag-messageLuck>");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		BlackFlag.registry.messages.untrack(this);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle target selection and panning.
	 * @param {PointerEvent} event - The triggering event.
	 * @returns {Promise} - Promise that resolves once the canvas pan has completed.
	 */
	async onTargetMouseDown(event) {
		event.stopPropagation();
		const uuid = event.currentTarget.dataset.uuid;
		const doc = fromUuidSync(uuid);
		const token = doc instanceof Token ? doc : doc?.token?.object ?? doc?.getActiveTokens()[0];
		if (!token || !doc.testUserPermission(game.user, "OBSERVER")) return;
		const releaseOthers = !event.shiftKey;
		if (token.controlled) token.release();
		else {
			token.control({ releaseOthers });
			return canvas.animatePan(token.center);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle highlighting a token when a chat message is hovered over.
	 * @param {PointerEvent} event - The triggering event.
	 */
	onTargetHoverIn(event) {
		const uuid = event.currentTarget.dataset.uuid;
		const doc = fromUuidSync(uuid);
		const token = doc instanceof Token ? doc : doc?.token?.object ?? doc?.getActiveTokens()[0];
		if (token && token.isVisible) {
			if (!token.controlled) token._onHoverIn(event, { hoverOutOthers: true });
			this._highlighted = token;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle ending the highlighting of token.
	 * @param {PointerEvent} event - The triggering event.
	 */
	onTargetHoverOut(event) {
		if (this._highlighted) this._highlighted._onHoverOut(event);
		this._highlighted = null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the activity associated with this chat card.
	 * @returns {Activity|void}
	 */
	getAssociatedActivity() {
		return fromUuidSync(this.getFlag(game.system.id, "activity.uuid"));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the Actor which is the author of a chat card.
	 * @returns {BlackFlagActor|void}
	 */
	getAssociatedActor() {
		if (this.speaker.scene && this.speaker.token) {
			const scene = game.scenes.get(this.speaker.scene);
			const token = scene?.tokens.get(this.speaker.token);
			if (token) return token.actor;
		}
		return game.actors.get(this.speaker.actor);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the item associated with this chat card.
	 * @returns {BlackFlagItem|void}
	 */
	getAssociatedItem() {
		const item = fromUuidSync(this.getFlag(game.system.id, "item.uuid"));
		if (item) return item;

		const activity = fromUuidSync(this.getFlag(game.system.id, "activity.uuid"));
		if (activity) return activity.item;

		const actor = this.getAssociatedActor();
		if (!actor) return;

		const storedData = this.getFlag(game.system.id, "item.data");
		return storedData
			? new Item.implementation(storedData, { parent: actor })
			: actor.items.get(this.getFlag(game.system.id, "item.id"));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get a list of all chat messages containing rolls that originated from this message.
	 * @param {string} [type] - Type of rolls to get. If empty, all roll types will be fetched.
	 * @returns {BlackFlagChatMessage[]}
	 */
	getAssociatedRolls(type) {
		return BlackFlag.registry.messages.get(this.id, type);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Find the combatant associated with this message.
	 * @param {number} initiative - Initiative total to use to find exact matches.
	 * @returns {Combatant|void}
	 */
	getCombatant(initiative) {
		if (!initiative) {
			const rollIndex = this.rolls.findIndex(r => r instanceof CONFIG.Dice.ChallengeRoll);
			initiative = this.rolls[rollIndex]?.total;
		}

		const { exactMatch, tokenMatch, actorMatch } = Array.from(game.combats.map(c => Array.from(c.combatants)))
			.flat()
			.reduce((obj, combatant) => {
				if (obj.exactMatch) return obj;
				if (combatant.sceneId === this.speaker.scene) {
					if (combatant.tokenId === this.speaker.token) {
						obj.tokenMatch = combatant;
						if (combatant.initiative === initiative) obj.exactMatch = combatant;
					} else if (combatant.actorId === this.speaker.actor) obj.actorMatch = combatant;
				}
				return obj;
			}, {});
		return exactMatch ?? tokenMatch ?? actorMatch;
	}
}

class BlackFlagChatLog extends (foundry.applications?.sidebar?.tabs?.ChatLog ?? ChatLog) {
	/** @inheritDoc */
	async updateMessage(message, notify = false) {
		const element = this.element instanceof HTMLElement ? this.element : this.element[0];
		const card = element.querySelector(`.message[data-message-id="${message.id}"]`);
		if (card)
			message._trayStates = new Map(
				Array.from(card.querySelectorAll(BlackFlagChatMessage.TRAY_TYPES.join(", "))).map(t => [t.tagName, t.open])
			);

		await super.updateMessage(message, notify);
	}
}

/**
 * Extended version of `CombatTracker` class to support the initiative dialog.
 */
class BlackFlagCombatTracker extends (foundry.applications?.sidebar?.tabs?.CombatTracker ??
	CombatTracker) {
	async _onCombatantControl(event, target) {
		const button = target ?? event.target;
		const combatantId = button.closest("[data-combatant-id]").dataset.combatantId;
		const combatant = this.viewed.combatants.get(combatantId);
		const action = button.dataset.control || button.dataset.action;
		if (action === "rollInitiative" && combatant?.actor) {
			return combatant.actor.configureInitiativeRoll({ event });
		}
		return super._onCombatantControl(event);
	}
}

/**
 * Dialog rendering options for roll configuration dialogs.
 *
 * @typedef {DialogOptions} BasicRollConfigurationDialogOptions
 * @property {object} default
 * @property {number} default.rollMode - The roll mode that is selected by default.
 * @property {typeof BasicRoll} rollType - Roll type to use when constructing final roll.
 * @property {Modifier[]} rollNotes - Notes to display with the roll.
 */

/**
 * Roll configuration dialog.
 *
 * @param {BasicRollProcessConfiguration} [config={}] - Initial roll configurations.
 * @param {BasicRollMessageConfiguration} [message={}] - Message configuration.
 * @param {BasicRollConfigurationDialogOptions} [options={}] - Dialog rendering options.
 */
class BasicRollConfigurationDialog extends BFApplication {
	constructor(config = {}, message = {}, options = {}) {
		super(options);

		this.#config = config;
		this.#message = message;
		this.notes = this.options.rollNotes;
		this.#buildRolls(foundry.utils.deepClone(this.#config));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["roll-configuration", "form-list"],
		tag: "form",
		window: {
			title: "BF.Roll.Configuration.LabelGeneric",
			icon: "fa-solid fa-dice",
			minimizable: false
		},
		form: {
			handler: BasicRollConfigurationDialog.#handleFormSubmission
		},
		position: {
			width: 450
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		formulas: {
			template: "systems/black-flag/templates/dice/base-formulas.hbs"
		},
		configuration: {
			template: "systems/black-flag/templates/dice/base-configuration.hbs"
		},
		notes: {
			template: "systems/black-flag/templates/dice/base-roll-notes.hbs"
		},
		buttons: {
			template: "systems/black-flag/templates/dice/base-buttons.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll type to use when constructing final roll.
	 * @type {BasicRoll}
	 */
	static get rollType() {
		return CONFIG.Dice.BasicRoll;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll configuration.
	 * @type {BasicRollProcessConfiguration}
	 */
	#config;

	get config() {
		return this.#config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration information for the roll message.
	 * @type {BasicRollMessageConfiguration}
	 */
	#message;

	get message() {
		return this.#message;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll notes.
	 * @type {Modifier[]|void}
	 */
	notes;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The rolls being configured.
	 * @type {BasicRoll[]}
	 */
	#rolls;

	get rolls() {
		return this.#rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll type to use when constructing final roll.
	 * @type {BasicRoll}
	 */
	get rollType() {
		return this.options.rollType ?? this.constructor.rollType;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.config = this.config;
		context.message = this.message;
		context.notes = this.notes;
		context.options = this.options;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "buttons":
				return this._prepareButtonsContext(context, options);
			case "configuration":
				return this._prepareConfigurationContext(context, options);
			case "formulas":
				return this._prepareFormulasContext(context, options);
			case "notes":
				return this._prepareNotesContext(context, options);
			default:
				return context;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the context for the buttons.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareButtonsContext(context, options) {
		context.buttons = {
			roll: {
				icon: '<i class="fa-solid fa-dice" inert></i>',
				label: game.i18n.localize("BF.Roll.Action.RollGeneric")
			}
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the context for the roll configuration section.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareConfigurationContext(context, options) {
		context.fields = [
			{
				field: new foundry.data.fields.StringField({ label: game.i18n.localize("BF.Roll.Mode.Label") }),
				name: "rollMode",
				options: Object.entries(CONFIG.Dice.rollModes).map(([value, l]) => ({ value, label: game.i18n.localize(l) })),
				value: this.message.rollMode ?? this.options.default?.rollMode
			}
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the context for the formulas list.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareFormulasContext(context, options) {
		context.rolls = this.rolls.map(roll => ({ roll }));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the context for the roll notes.
	 * @param {ApplicationRenderContext} context - Shared context provided by _prepareContext.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareNotesContext(context, options) {
		context.notes = foundry.utils.deepClone(this.notes ?? []);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Roll Handling            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Build a roll from the provided config.
	 * @param {BasicRollProcessConfiguration[]} config - Roll process configuration data.
	 * @param {FormDataExtended} [formData] - Data provided by the configuration form.
	 */
	#buildRolls(config, formData) {
		const RollType = this.rollType;
		this.#rolls =
			config.rolls?.map((config, index) =>
				RollType.fromConfig(this._buildConfig(config, formData, index), this.config)
			) ?? [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Type-specific roll configuration.
	 * @param {BasicRollConfiguration} config - Roll configuration data.
	 * @param {FormDataExtended} formData - Data provided by the configuration form.
	 * @param {number} index - Index of the roll within all rolls being prepared.
	 * @returns {BasicRollConfiguration}
	 * @protected
	 */
	_buildConfig(config, formData, index) {
		config = foundry.utils.mergeObject({ parts: [], data: {}, options: {} }, config);

		/**
		 * A hook event that fires when a roll config is build within the roll prompt.
		 * @function blackFlag.buildRollConfig
		 * @memberof hookEvents
		 * @param {BasicRollConfigurationDialog} app - Roll configuration dialog.
		 * @param {BasicRollConfiguration} config - Roll configuration data.
		 * @param {object} data
		 * @param {FormDataExtended} data.formData - Any data entered into the rolling prompt.
		 * @param {number} data.index - Index of the roll within all rolls being prepared.
		 */
		Hooks.callAll("blackFlag.buildRollConfig", this, config, { formData, index });

		const situational = formData?.get(`roll.${index}.situational`);
		if (situational && config.situational !== false) {
			config.parts.push("@situational");
			config.data.situational = situational;
		} else {
			config.parts.findSplice(v => v === "@situational");
		}

		return config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Final roll preparation based on the pressed button.
	 * @param {string} action - That button that was pressed.
	 * @returns {BasicRoll[]}
	 * @protected
	 */
	_finalizeRolls(action) {
		return this.rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Rebuild rolls based on an updated config and re-render the dialog.
	 */
	rebuild() {
		this._onChangeForm(this.options.form, new Event("change"));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle submission of the dialog using the form buttons.
	 * @param {Event|SubmitEvent} event - The form submission event.
	 * @param {HTMLFormElement} form - The submitted form.
	 * @param {FormDataExtended} formData - Data from the dialog.
	 * @private
	 */
	static async #handleFormSubmission(event, form, formData) {
		this._handleFormChanges(formData);
		this.#rolls = this._finalizeRolls(event.submitter?.dataset?.action);
		await this.close({ [game.system.id]: { submitted: true } });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle changes to form data.
	 * @param {FormDataExtended} formData - Data from the dialog.
	 * @protected
	 */
	_handleFormChanges(formData) {
		if (formData.has("rollMode")) this.message.rollMode = formData.get("rollMode");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onChangeForm(formConfig, event) {
		super._onChangeForm(formConfig, event);

		const formData = new FormDataExtended(this.element);
		this._handleFormChanges(formData);
		this.#buildRolls(foundry.utils.deepClone(this.config), formData);
		this.render({ parts: ["formulas", "notes"] });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_onClose(options = {}) {
		if (!options[game.system.id]?.submitted) this.#rolls = [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Factory Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A helper constructor that displays the roll configuration dialog.
	 * @param {BasicRollProcessConfiguration} [config] - Initial roll configuration.
	 * @param {BasicRollDialogConfiguration} [dialog] - Configuration information for the dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Message configuration.
	 * @returns {Promise<BasicRoll[]>}
	 */
	static async configure(config = {}, dialog = {}, message = {}) {
		return new Promise((resolve, reject) => {
			const app = new this(config, message, dialog.options);
			app.addEventListener("close", () => resolve(app.rolls), { once: true });
			app.render({ force: true });
		});
	}
}

/**
 * Roll configuration dialog for Challenge Rolls.
 *
 * @param {ChallengeRollProcessConfiguration} [config={}] - Initial roll configuration.
 * @param {BasicRollMessageConfiguration} [message={}] - Message configuration.
 * @param {BasicRollConfigurationDialogOptions} [options={}] - Dialog rendering options.
 */
class ChallengeRollConfigurationDialog extends BasicRollConfigurationDialog {
	/** @override */
	static get rollType() {
		return CONFIG.Dice.ChallengeRoll;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _prepareButtonsContext(context, options) {
		context.buttons = {
			advantage: {
				icon: '<i class="fa-solid fa-square-caret-up"></i>',
				label: game.i18n.localize("BF.Roll.Action.Advantage.Label")
			},
			normal: {
				icon: '<i class="fa-solid fa-dice"></i>',
				label: game.i18n.localize("BF.Roll.Action.Normal.Label")
			},
			disadvantage: {
				icon: '<i class="fa-solid fa-square-caret-down"></i>',
				label: game.i18n.localize("BF.Roll.Action.Disadvantage.Label")
			}
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareNotesContext(context, options) {
		context = await super._prepareNotesContext(context, options);
		context.notes.forEach(n => {
			switch (n.note?.rollMode) {
				case CONFIG.Dice.ChallengeDie.MODES.ADVANTAGE:
					return (n.advantageAbbreviation = "BF.Roll.Action.Advantage.Abbreviation");
				case CONFIG.Dice.ChallengeDie.MODES.DISADVANTAGE:
					return (n.advantageAbbreviation = "BF.Roll.Action.Disadvantage.Abbreviation");
				case CONFIG.Dice.ChallengeDie.MODES.NORMAL:
					return (n.advantageAbbreviation = "BF.Roll.Action.Normal.Abbreviation");
			}
		});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Roll Handling            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_finalizeRolls(action) {
		const rolls = [];
		for (const roll of this.rolls) {
			switch (action) {
				case "advantage":
					roll.options.advantageMode = CONFIG.Dice.ChallengeDie.MODES.ADVANTAGE;
					break;
				case "disadvantage":
					roll.options.advantageMode = CONFIG.Dice.ChallengeDie.MODES.DISADVANTAGE;
					break;
				case "normal":
					roll.options.advantageMode = CONFIG.Dice.ChallengeDie.MODES.NORMAL;
					break;
			}
			roll.configureRoll();
			rolls.push(roll);
		}
		return rolls;
	}
}

/**
 * Roll configuration dialog for Damage Rolls.
 */
class DamageRollConfigurationDialog extends BasicRollConfigurationDialog {
	/** @override */
	static PARTS = {
		...super.PARTS,
		formulas: {
			template: "systems/black-flag/templates/dice/damage-formulas.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static get rollType() {
		return CONFIG.Dice.DamageRoll;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _prepareButtonsContext(context, options) {
		context.buttons = {
			critical: {
				icon: '<i class="fa-solid fa-bomb"></i>',
				label: game.i18n.localize("BF.Roll.Action.Critical.Label")
			},
			normal: {
				icon: '<i class="fa-solid fa-dice"></i>',
				label: game.i18n.localize("BF.Roll.Action.Normal.Label")
			}
		};
		if (this.config.critical?.allow === false) delete context.buttons.critical;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareFormulasContext(context, options) {
		context = await super._prepareFormulasContext(context, options);
		const allTypes = foundry.utils.mergeObject(CONFIG.BlackFlag.damageTypes, CONFIG.BlackFlag.healingTypes, {
			inplace: false
		});
		context.rolls = context.rolls.map(({ roll }) => ({
			roll,
			damageConfig: allTypes[roll.options.damageType] ?? allTypes[roll.options.damageTypes?.first()],
			damageTypes: roll.options.damageTypes
				? Object.entries(allTypes).reduce((obj, [key, config]) => {
						if (roll.options.damageTypes.has(key)) {
							obj[key] = game.i18n.localize(config.label);
						}
						return obj;
					}, {})
				: null
		}));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Roll Handling            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_buildConfig(config, formData, index) {
		config = super._buildConfig(config, formData, index);

		const damageType = formData?.get(`roll.${index}.damageType`);
		if (damageType) config.options.damageType = damageType;

		return config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_finalizeRolls(action) {
		const rolls = [];
		for (const roll of this.rolls) {
			roll.options.isCritical = action === "critical";
			roll.configureRoll({ critical: this.config.critical });
			rolls.push(roll);
		}
		return rolls;
	}
}

/**
 * @typedef {BasicRollConfigurationDialogOptions} SkillRollConfigurationDialogOptions
 * @property {boolean} chooseAbility - Should the ability be selectable?
 */

/**
 * Extended roll configuration dialog that allows selecting abilities.
 */
class SkillRollConfigurationDialog extends ChallengeRollConfigurationDialog {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareConfigurationContext(context, options) {
		context = await super._prepareConfigurationContext(context, options);
		if (this.options.chooseAbility)
			context.fields.unshift({
				field: new foundry.data.fields.StringField({ label: game.i18n.localize("BF.Ability.Label[one]") }),
				name: "ability",
				options: CONFIG.BlackFlag.abilities.localizedOptions,
				value: this.rolls[0]?.data.abilityId
			});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Roll Handling            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_buildConfig(config, formData, index) {
		config = super._buildConfig(config, formData, index);
		if (!this.options.buildConfig) return config;

		const { rollConfig, rollNotes } = this.options.buildConfig(this.config, config, formData, index);
		this.notes = rollNotes;
		return rollConfig;
	}
}

var _module$k = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BasicRollConfigurationDialog: BasicRollConfigurationDialog,
	ChallengeConfigurationDialog: ChallengeRollConfigurationDialog,
	DamageRollConfigurationDialog: DamageRollConfigurationDialog,
	SkillRollConfigurationDialog: SkillRollConfigurationDialog
});

/**
 * Sheet upon which all other item sheets are based.
 */
class BaseItemSheet extends DocumentSheetMixin(ItemSheet) {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			dragDrop: [{ dropSelector: "form" }]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fields that will be enriched during data preparation.
	 * @type {object}
	 */
	static enrichedFields = {
		description: "system.description.value"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.CONFIG = CONFIG.BlackFlag;
		context.flags = this.document.flags;
		context.name = this.modes.editing ? this.document._source.name : this.document.name;
		context.system = this.document.system;
		context.source = this.modes.editing ? this.document.toObject().system : context.system;

		const enrichmentContext = {
			relativeTo: this.item,
			rollData: this.item.getRollData(),
			secrets: this.item.isOwner,
			async: true
		};
		context.enriched = await Object.entries(this.constructor.enrichedFields).reduce(async (enriched, [key, path]) => {
			enriched[key] = await TextEditor.enrichHTML(foundry.utils.getProperty(context, path), enrichmentContext);
			return enriched;
		}, {});

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async activateEditor(name, options = {}, initialContent = "") {
		options.relativeLinks = true;
		options.plugins = {
			menu: ProseMirror.ProseMirrorMenu.build(ProseMirror.defaultSchema, {
				compact: true,
				destroyOnSave: true,
				onSave: () => this.saveEditor(name, { remove: true })
			})
		};
		return super.activateEditor(name, options, initialContent);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll("[data-action]")) {
			element.addEventListener("click", this._onAction.bind(this));
		}

		if (this.form && this.isEditable && !this.modes.editing) this._disableFields(this.form);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_disableFields(form) {
		super._disableFields(form);
		form.querySelectorAll("blackflag-multiselect").forEach(e => (e.disabled = true));
		form.querySelectorAll('[data-action="view"], .interface-only').forEach(b => (b.disabled = false));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a click on an action link.
	 * @param {ClickEvent} event - Triggering click event.
	 * @returns {Promise}
	 */
	async _onAction(event) {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_canDragDrop() {
		return this.isEditable;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onDrop(event) {
		const { data } = DragDrop$1.getDragData(event);

		// Forward dropped items to the advancement element
		// TODO: Handle folders
		if (data.type === "Advancement") {
			const advancementElement = this.element[0].querySelector("blackFlag-advancement");
			return advancementElement?._onDrop(event);
		}

		const isSpell = data.type === "Item" && fromUuidSync(data.uuid, { strict: false })?.type === "spell";
		if (data.type === "Activity" || isSpell) {
			const activitiesElement = this.element[0].querySelector("blackFlag-activities");
			return activitiesElement?._onDrop(event);
		}

		super._onDrop(event);
	}
}

/**
 * Compendium with added support for item containers.
 */
class BlackFlagItemCompendium extends (foundry.applications?.sidebar?.apps?.Compendium ?? Compendium) {
	/** @inheritDoc */
	async _onRender(context, options) {
		await super._onRender(context, options);
		let items = this.collection;
		if (this.collection.index) {
			if (!this.collection._reindexing) this.collection._reindexing = this.collection.getIndex();
			await this.collection._reindexing;
			items = this.collection.index;
		}
		for (const item of items) {
			if (items.has(item.system.container)) {
				this._element?.querySelector(`[data-entry-id="${item._id}"]`)?.remove();
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _render(...args) {
		await super._render(...args);
		let items = this.collection;
		if (this.collection.index) {
			if (!this.collection._reindexing) this.collection._reindexing = this.collection.getIndex();
			await this.collection._reindexing;
			items = this.collection.index;
		}
		for (const item of items) {
			if (items.has(item.system.container)) {
				this._element?.[0].querySelector(`[data-entry-id="${item._id}"]`)?.remove();
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _handleDroppedEntry(target, data) {
		// Obtain the dropped Document
		let item = await Item.fromDropData(data);
		if (!item) return;

		// Create item and its contents if it doesn't already exist here
		if (!this._entryAlreadyExists(item)) {
			const contents = await item.system.contents;
			if (contents?.size) {
				const toCreate = await BlackFlagItem.createWithContents([item], {
					transformAll: item => item.toCompendium(item)
				});
				const folder = target?.closest("[data-folder-id]")?.dataset.folderId;
				if (folder) toCreate.map(d => (d.folder = folder));
				[item] = await BlackFlagItem.createDocuments(toCreate, { pack: this.collection.collection, keepId: true });
			}
		}

		// Otherwise, if it is within a container, take it out
		else if (item.system.container) await item.update({ "system.container": null });

		// Let parent method perform sorting
		super._handleDroppedEntry(target, item.toDragData());
	}
}

/**
 * Items sidebar with added support for item containers.
 */
class BlackFlagItemDirectory extends (foundry.applications?.sidebar?.tabs?.ItemDirectory ??
	ItemDirectory) {
	/** @inheritDoc */
	async _handleDroppedEntry(target, data) {
		// Obtain the dropped Document
		let item = await this._getDroppedEntryFromData(data);
		if (!item) return;

		// Create item and its contents if it doesn't already exist here
		if (!this._entryAlreadyExists(item)) {
			const toCreate = await BlackFlagItem.createWithContents([item]);
			const folder = target?.closest("[data-folder-id]")?.dataset.folderId;
			if (folder) toCreate.map(d => (d.folder = folder));
			[item] = await BlackFlagItem.createDocuments(toCreate, { keepId: true });
		}

		// Otherwise, if it is within a container, take it out
		else if (item.system.container) await item.update({ "system.container": null });

		// Let parent method perform sorting
		super._handleDroppedEntry(target, item.toDragData());
	}
}

class ConceptSheet extends BaseItemSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "concept", "item", "sheet"],
			dragDrop: [{ dropSelector: "form" }],
			tabs: [
				{
					group: "primary",
					navSelector: 'nav[data-group="primary"]',
					contentSelector: ".tab-area",
					initial: "advancement"
				}
			],
			template: "systems/black-flag/templates/item/concept.hbs",
			width: 810,
			height: 900
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static enrichedFields = foundry.utils.mergeObject(
		super.enrichedFields,
		{
			short: "system.description.short"
		},
		{ inplace: false }
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);
		context.advancement = AdvancementElement.prepareContext(this.item.system.advancement);
		context.showClassSelector = context.editable && this.item.type === "subclass";
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onAction(event) {
		const { action } = event.currentTarget.dataset;
		switch (action) {
			case "journal-link":
				return await this.submit({ updateData: { "system.description.journal": "" } });
		}
		return super._onAction(event);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onDrop(event) {
		event.preventDefault();
		const data = TextEditor.getDragEventData(event);

		switch (data.type) {
			case "Advancement":
				const advancement = (await fromUuid(data.uuid)).toObject() ?? data.data;
				return AdvancementElement.dropAdvancement(event, this.item, [advancement]);
			case "Item":
				const item = await Item.implementation.fromDropData(data);
				return AdvancementElement.dropItems(event, this.item, [item]);
			case "JournalEntry":
			case "JournalEntryPage":
				if (data.uuid) return await this.submit({ updateData: { "system.description.journal": data.uuid } });
		}

		return super._onDrop(event);
	}
}

class EquipmentSheet extends BaseItemSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "equipment", "item", "sheet"],
			tabs: [{ navSelector: ".tabs", contentSelector: ".sheet-body", initial: "description" }],
			scrollY: ["[data-tab] > section"],
			width: 600,
			height: 500
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get template() {
		return `systems/black-flag/templates/item/${this.document.type}.hbs`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.effects = EffectsElement.prepareItemContext(this.item.effects);

		// Category
		if (context.system.validCategories?.localized)
			context.categories = {
				options: context.system.validCategories.localized,
				blank: ""
			};

		// Type
		if (this.item.type === "weapon") {
			context.types = { options: CONFIG.BlackFlag.weaponTypes.localized };
		}

		// Base
		const category = context.system.validCategories?.[context.source.type.category];
		if (category?.children)
			context.baseItems = {
				options: sortObjectEntries(
					Object.entries(category.children).reduce((obj, [key, config]) => {
						if (
							!foundry.utils.hasProperty(this.item, "system.type.value") ||
							!config.type ||
							config.type === context.source.type.value
						)
							obj[key] = makeLabel(config);
						return obj;
					}, {})
				),
				blank: ""
			};

		const has = (data, key) => data.includes?.(key) ?? data.has?.(key);

		context.options = Object.entries(context.system.validOptions ?? {}).reduce((obj, [k, o]) => {
			obj[k] = { label: game.i18n.localize(o.label), selected: has(context.source.options, k) };
			return obj;
		}, {});

		context.attunementOptions = [
			{ value: "", label: game.i18n.localize("BF.Attunement.Type.None") },
			{ value: "optional", label: game.i18n.localize("BF.Attunement.Type.Optional") },
			{ value: "required", label: game.i18n.localize("BF.Attunement.Type.Required") }
		];
		context.proficiencyOptions = [
			{ value: null, label: game.i18n.localize("BF.Proficiency.Override.Auto") },
			{ value: true, label: game.i18n.localize("BF.Proficiency.Override.Always") },
			{ value: false, label: game.i18n.localize("BF.Proficiency.Override.Never") }
		];

		context.properties = Object.entries(context.system.validProperties ?? {}).reduce((obj, [k, label]) => {
			obj[k] = { label, selected: has(context.source.properties, k) };
			return obj;
		}, {});

		// Hack for armor to get around handlebars' weird behavior when calling methods
		context.modifierHint = context.system.modifierHint?.();

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getSubmitData(updateData = {}) {
		const data = foundry.utils.expandObject(super._getSubmitData(updateData));

		if (foundry.utils.hasProperty(data, "system.options")) {
			data.system.options = filteredKeys(data.system.options);
		}

		if (foundry.utils.hasProperty(data, "system.properties")) {
			data.system.properties = filteredKeys(data.system.properties);
		}

		if (foundry.utils.hasProperty(data, "system.overrides.proficiency")) {
			if (data.system.overrides.proficiency === "null") data.system.overrides.proficiency = null;
		}

		return foundry.utils.flattenObject(data);
	}
}

class ContainerSheet extends EquipmentSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "container", "equipment", "item", "sheet"],
			dragDrop: [{ dragSelector: null, dropSelector: "form" }],
			tabs: [{ navSelector: ".tabs", contentSelector: ".sheet-body", initial: "contents" }],
			scrollY: ["[data-tab] > section"],
			width: 600,
			height: 500
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * IDs for items on the sheet that have their descriptions expanded in-line.
	 * @type {Set<string>}
	 */
	expanded = new Set();

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.items = Array.from(await this.item.system.contents);
		context.itemContext = {};

		// TODO: Calculate capacity

		for (const item of context.items) {
			const ctx = (context.itemContext[item.id] ??= {});
			if (this.expanded.has(item.id)) ctx.expanded = await item.getSummaryContext({ secrets: this.item.isOwner });
			ctx.totalWeight = (await item.system.totalWeight).toNearest(0.1);
		}
		context.isContainer = true;

		await this.prepareItems(context);

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the items for display on the sheet.
	 * @param {object} context - Context object for rendering the sheet. **Will be mutated.**
	 * @abstract
	 */
	async prepareItems(context) {
		context.itemContext ??= {};
		context.sections = await InventoryElement.organizeItems(this.item, context.items, {
			callback: async (item, section) => {
				const itemContext = (context.itemContext[item.id] ??= {});
				const totalWeight = await item.system.totalWeight;
				itemContext.weight = totalWeight
					? numberFormat(totalWeight.toNearest(0.1), { unit: item.system.weight.units })
					: "â€”";
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _onDrop(event) {
		const { data } = DragDrop$1.getDragData(event);

		// Forward dropped items to the inventory element
		// TODO: Handle folders
		if (data.type === "Item") {
			InventoryElement.dropItems(event, this.item, [await Item.implementation.fromDropData(data)]);
			return;
		}

		return false;
	}
}

class CurrencySheet extends BaseItemSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "currency", "item", "sheet"],
			tabs: [{ navSelector: ".tabs", contentSelector: ".sheet-body", initial: "description" }],
			scrollY: ["[data-tab] > section"],
			template: "systems/black-flag/templates/item/currency.hbs",
			width: 600,
			height: 450
		});
	}
}

const { BooleanField: BooleanField$k, DocumentUUIDField: DocumentUUIDField$7, NumberField: NumberField$B, SetField: SetField$q, StringField: StringField$S } = foundry.data.fields;

/**
 * Configuration dialog for feature & talent prerequisites.
 */
class PrerequisiteConfig extends BFDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		actions: {
			addCustom: PrerequisiteConfig.#addCustom,
			deleteCustom: PrerequisiteConfig.#deleteCustom
		},
		classes: ["prerequisite", "standard-form", "form-list"],
		form: {
			submitOnChange: true
		},
		position: {
			width: 480
		},
		sheetConfig: false
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		general: {
			template: "systems/black-flag/templates/shared/fieldset.hbs"
		},
		items: {
			template: "systems/black-flag/templates/item/config/prerequisite-config-items.hbs"
		},
		abilities: {
			template: "systems/black-flag/templates/item/config/prerequisite-config-abilities.hbs"
		},
		spellcasting: {
			template: "systems/black-flag/templates/shared/fieldset.hbs"
		},
		proficiencies: {
			template: "systems/black-flag/templates/shared/fieldset.hbs"
		},
		traits: {
			template: "systems/black-flag/templates/shared/fieldset.hbs"
		},
		custom: {
			template: "systems/black-flag/templates/item/config/prerequisite-config-custom.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Restriction filters currently set.
	 * @type {FilterDescription[]}
	 */
	get filters() {
		return this.document.system.restriction.filters;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return game.i18n.localize("BF.Prerequisite.Config.Title");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		context.filters = this.filters.reduce((obj, f) => {
			obj[f._id] = f;
			return obj;
		}, {});
		context.source = this.document.system._source;
		context.system = this.document.system;
		context.restrictionFields = this.document.system.schema.fields.restriction.fields;
		context.custom = (context.source.restriction.custom ?? []).map((value, index) => ({
			field: context.restrictionFields.custom.element,
			name: `system.restriction.custom.${index}`,
			value
		}));
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "abilities":
				return this._prepareAbilitiesContext(context, options);
			case "general":
				return this._prepareGeneralContext(context, options);
			case "items":
				return this._prepareItemsContext(context, options);
			case "proficiencies":
				return this._prepareProficienciesContext(context, options);
			case "spellcasting":
				return this._prepareSpellcastingContext(context, options);
			case "traits":
				return this._prepareTraitsContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare abilities rendering context.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	_prepareAbilitiesContext(context, options) {
		context.abilities = {};
		for (const [key, ability] of Object.entries(CONFIG.BlackFlag.abilities)) {
			context.abilities[key] = {
				label: ability.labels.abbreviation,
				value: context.filters[`ability-${key}`]?.v ?? ""
			};
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare general rendering context.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	_prepareGeneralContext(context, options) {
		context.fields = [
			{
				classes: "label-hinted",
				field: context.restrictionFields.requireAll,
				localize: true,
				name: "system.restriction.requireAll",
				value: context.source.restriction.requireAll
			}
		];
		context.legend = game.i18n.localize("BF.Prerequisite.Config.Details");
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare items rendering context.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	_prepareItemsContext(context, options) {
		context.field = new SetField$q(new DocumentUUIDField$7({ type: "Item" }), {
			label: game.i18n.localize("BF.Prerequisite.Items.Label")
		});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare proficiencies rendering context.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	_prepareProficienciesContext(context, options) {
		const prepareProficiency = (trait$1, label) => ({
			field: new SetField$q(new StringField$S(), { label: game.i18n.localize(label) }),
			name: `proficiencies.${trait$1}`,
			options: choices(trait$1, { any: true, category: true, priority: "localization" }).formOptions(),
			value: new Set([
				...(context.filters[`${trait$1}Proficiency`]?.v ?? []).map(s => s._key ?? s),
				...(context.filters[`${trait$1}Categories`]?.v ?? []).map(s => `${s}:*`)
			])
		});
		context.fields = [
			prepareProficiency("armor", "BF.Item.Type.Armor[one]"),
			prepareProficiency("weapons", "BF.Item.Type.Weapon[one]"),
			prepareProficiency("tools", "BF.Item.Type.Tool[one]"),
			prepareProficiency("skills", "BF.Skill.Label[one]")
		];
		context.legend = game.i18n.localize("BF.Proficiency.Label[other]");
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare spellcasting rendering context.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	_prepareSpellcastingContext(context, options) {
		context.fields = [
			{
				field: new BooleanField$k({ label: game.i18n.localize("BF.Prerequisite.SpellcastingFeature.ConfigLabel") }),
				name: "spellcasting.feature",
				value: context.filters.spellcastingFeature?.v
			},
			{
				field: new StringField$S({ label: game.i18n.localize("BF.Prerequisite.SpellcastingCircle.ConfigLabel") }),
				name: "spellcasting.circle",
				options: [
					{ value: "", label: "" },
					...CONFIG.BlackFlag.spellCircles({ formOptions: true, includeCantrip: false })
				],
				value: context.filters.spellCircle?.v
			},
			{
				field: new BooleanField$k({ label: game.i18n.localize("BF.Prerequisite.SpellcastingCantrip.ConfigLabel") }),
				name: "spellcasting.cantrip",
				value: context.filters.hasCantrips?.v
			},
			{
				field: new BooleanField$k({ label: game.i18n.localize("BF.Prerequisite.SpellcastingDamage.ConfigLabel") }),
				name: "spellcasting.damage",
				value: context.filters.hasDamagingSpells?.v
			}
		];
		context.legend = game.i18n.localize("BF.Spellcasting.Label");
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare traits context.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	_prepareTraitsContext(context, options) {
		const level = {};
		if (context.filters.characterLevel) {
			level.value = context.filters.characterLevel.v;
		} else if (context.filters.classLevel) {
			level.class = context.filters.classLevel._class;
			level.value = context.filters.classLevel.v;
		}
		context.fields = [
			{
				field: new NumberField$B({
					label: game.i18n.localize(`BF.Prerequisite.Level${level.class ? "Class" : "Character"}.ConfigLabel`)
				}),
				name: "traits.level.value",
				options: [
					{ value: "", label: "" },
					...Object.entries(CONFIG.BlackFlag.levels()).map(([value, label]) => ({ value, label }))
				],
				value: level.value
			},
			level.value
				? {
						field: new StringField$S({ label: game.i18n.localize("BF.Advancement.FIELDS.level.classIdentifier.label") }),
						name: "traits.level.class",
						options: [
							{ value: "", label: "" },
							...Object.entries(CONFIG.BlackFlag.registration.list("class")).map(([value, { name }]) => ({
								value,
								label: name
							}))
						],
						value: level.class
					}
				: null,
			{
				field: new StringField$S({ label: game.i18n.localize("BF.Size.Label") }),
				name: "traits.size",
				options: [{ value: "", label: "" }, ...CONFIG.BlackFlag.sizes.localizedOptions],
				value: context.filters.creatureSize?.v
			}
		];
		context.legend = game.i18n.localize("BF.Trait.Label[other]");
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle adding a new custom entry.
	 * @this {PrerequisiteConfig}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #addCustom(event, target) {
		const custom = this.document.system.toObject().restriction.custom ?? [];
		this.submit({
			updateData: {
				"system.restriction.custom": [...custom, ""]
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle removing a custom entry.
	 * @this {PrerequisiteConfig}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static #deleteCustom(event, target) {
		const custom = this.document.system.toObject().restriction.custom ?? [];
		custom.splice(target.closest("[data-index]").dataset.index, 1);
		this.submit({
			updateData: {
				"system.restriction.custom": custom
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processFormData(event, form, formData) {
		const data = super._processFormData(event, form, formData);
		const filters = this.filters;

		const updateFilter = (_id, k, v, o, d = {}) => {
			const existingIdx = filters.findIndex(f => f._id === _id);
			if (v) {
				const value = { _id, k, v, o, ...d };
				if (existingIdx !== -1) filters[existingIdx] = value;
				else filters.push(value);
			} else if (existingIdx !== -1) filters.splice(existingIdx, 1);
		};

		// Abilities
		Object.entries(data.abilities).forEach(([k, v]) =>
			updateFilter(`ability-${k}`, `system.abilities.${k}.value`, v, "gte")
		);

		// Proficiencies
		const updateProficiency = (trait, extended) => {
			const [proficiencies, categories] = (data.proficiencies?.[trait] ?? []).reduce(
				(arr, k) => {
					if (k.endsWith(":*")) arr[1].push(k.replace(":*", ""));
					else arr[0].push(k);
					return arr;
				},
				[[], []]
			);
			updateFilter(
				`${trait}Proficiency`,
				extended ? undefined : `system.proficiencies.${trait}.value`,
				proficiencies.length
					? extended
						? proficiencies.map(_key => ({
								k: `system.proficiencies.${trait}.${_key}.proficiency.multiplier`,
								o: "gte",
								v: 1,
								_key
							}))
						: proficiencies
					: false,
				extended ? "OR" : "hasAny"
			);
			updateFilter(
				`${trait}Categories`,
				`system.proficiencies.${trait}.categories`,
				categories.length ? categories : false,
				"hasAny"
			);
		};
		updateProficiency("armor");
		updateProficiency("weapons");
		updateProficiency("tools", true);
		updateProficiency("skills", true);

		// Spellcasting
		updateFilter(
			"hasCantrips",
			undefined,
			data.spellcasting?.cantrip
				? [
						{ k: "system.spellcasting.spells.cantrips", v: 1, o: "gte" },
						{ k: "system.spellcasting.spells.knowable.cantrips", v: 1, o: "gte" }
					]
				: false,
			"OR"
		);
		updateFilter("spellCircle", "system.spellcasting.maxCircle", data.spellcasting?.circle, "gte");
		updateFilter("hasDamagingSpells", "system.spellcasting.spells.damaging", Number(data.spellcasting?.damage), "gte");
		updateFilter("spellcastingFeature", "system.spellcasting.hasSpellcastingAdvancement", data.spellcasting?.feature);

		// Traits
		if (data.traits?.level?.class) {
			updateFilter("characterLevel");
			updateFilter(
				"classLevel",
				`system.progression.classes.${data.traits.level.class}.levels`,
				data.traits?.level?.value,
				"gte",
				{ _class: data.traits.level.class }
			);
		} else {
			updateFilter("characterLevel", "system.progression.level", data.traits?.level?.value, "gte");
			updateFilter("classLevel");
		}
		updateFilter("creatureSize", "system.traits.size", data.traits?.size);

		foundry.utils.setProperty(data, "system.restriction.filters", filters);
		return data;
	}
}

class FeatureSheet extends BaseItemSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "feature", "item", "sheet"],
			tabs: [{ navSelector: ".tabs", contentSelector: ".sheet-body", initial: "description" }],
			width: 600,
			height: 500
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get template() {
		return `systems/black-flag/templates/item/${this.document.type}.hbs`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.advancement = AdvancementElement.prepareContext(this.item.system.advancement);
		context.effects = EffectsElement.prepareItemContext(this.item.effects);
		context.type = {};

		if (this.document.type === "feature") {
			context.type.categories = CONFIG.BlackFlag.featureCategories.localized;

			const featureCategory = CONFIG.BlackFlag.featureCategories[context.source.type.category];
			const id = new Set([context.source.identifier.associated]);
			if (featureCategory?.sources)
				context.type.categorySources = CONFIG.BlackFlag.registration.groupedOptions(featureCategory.sources, id);
			const featureType = featureCategory?.children?.[context.source.type.value];
			if (featureType?.sources)
				context.type.typeSources = CONFIG.BlackFlag.registration.groupedOptions(featureType.sources, id);

			if (
				(featureCategory && ["class", "lineage", "heritage"].includes(context.source.type.category)) ||
				featureCategory?.children
			) {
				context.type.types = {
					label: game.i18n.format("BF.Feature.Type.LabelSpecific", {
						type: game.i18n.localize(`${featureCategory.localization}[one]`)
					}),
					options: featureCategory?.children?.localized ?? null,
					selected: context.source.type.value || context.source.identifier.associated
				};
			}

			if (context.source.type.category === "class" && (featureType || context.source.identifier.associated)) {
				context.type.displayLevel = featureType?.level !== false;
				context.type.fixedLevel = featureType?.level;
			}
		} else if (this.document.type === "talent") {
			context.talentCategories = CONFIG.BlackFlag.talentCategories.localized;
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll('[data-action="effect"]')) {
			element.addEventListener("click", BlackFlagActiveEffect.onEffectAction.bind(this));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onAction(event) {
		const { action, ...properties } = event.currentTarget.dataset;
		switch (action) {
			case "config":
				switch (properties.type) {
					case "prerequisite":
						return new PrerequisiteConfig({ document: this.document }).render({ force: true });
				}
		}
		return super._onAction(event);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_updateObject(event, formData) {
		const update = foundry.utils.expandObject(formData);

		// Figure out where to save the value of Feature Type
		if (this.document.type === "feature" && foundry.utils.hasProperty(update, "system.type.category")) {
			const category = foundry.utils.getProperty(update, "system.type.category");
			const type = foundry.utils.getProperty(update, "system.type.value");
			let identifier = foundry.utils.getProperty(update, "system.identifier.associated");
			const categoryConfig = CONFIG.BlackFlag.featureCategories[category];
			const typeConfig = categoryConfig?.children?.[type];

			// If no type config, set type to blank
			if (!typeConfig) {
				identifier ??= type;
				foundry.utils.setProperty(update, "system.type.value", "");
			}

			const validSources = CONFIG.BlackFlag.registration.groupedOptions(
				new Set([...(categoryConfig?.sources ?? []), ...(typeConfig?.sources ?? [])])
			);
			foundry.utils.setProperty(
				update,
				"system.identifier.associated",
				validSources.set.has(identifier) ? identifier : ""
			);
		}

		super._updateObject(event, foundry.utils.flattenObject(update));
	}
}

class SpellSheet extends BaseItemSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["black-flag", "spell", "item", "sheet"],
			tabs: [{ navSelector: ".tabs", contentSelector: ".sheet-body", initial: "description" }],
			scrollY: ["[data-tab] > section"],
			template: "systems/black-flag/templates/item/spell.hbs",
			width: 600,
			height: 500
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);

		context.effects = EffectsElement.prepareItemContext(this.item.effects);

		const has = (data, key) => data?.includes?.(key) ?? data?.has?.(key);

		context.components = Object.entries(CONFIG.BlackFlag.spellComponents).reduce((obj, [k, p]) => {
			obj[k] = { label: game.i18n.localize(p.label), selected: has(context.source.components.required, k) };
			return obj;
		}, {});

		context.tags = Object.entries(CONFIG.BlackFlag.spellTags).reduce((obj, [k, p]) => {
			obj[k] = { label: game.i18n.localize(p.label), selected: has(context.source.tags, k) };
			return obj;
		}, {});

		context.data = {
			range: context.source.range,
			target: context.source.target
		};
		context.activationOptions = CONFIG.BlackFlag.activationOptions({ chosen: context.source.casting.type });
		context.durationOptions = CONFIG.BlackFlag.durationOptions({
			chosen: context.source.duration.units,
			isSpell: true
		});
		context.originOptions = [
			{ value: "", label: "" },
			...Object.entries(CONFIG.BlackFlag.registration.list("class")).map(([value, data]) => ({
				value,
				label: data.name,
				group: game.i18n.localize("BF.Item.Type.Class[other]")
			})),
			...Object.entries(CONFIG.BlackFlag.registration.list("subclass")).map(([value, data]) => ({
				value,
				label: data.name,
				group: game.i18n.localize("BF.Item.Type.Subclass[other]")
			}))
		];
		context.rangeOptions = [
			{ value: "", label: "" },
			{ rule: true },
			...CONFIG.BlackFlag.rangeTypes.localizedOptions,
			...CONFIG.BlackFlag.distanceUnits.localizedOptions.map(o => ({
				...o,
				group: game.i18n.localize("BF.Distance.Label")
			}))
		];
		context.spellCircles = CONFIG.BlackFlag.spellCircles();

		context.showConfiguration = this.item.isEmbedded && !this.item.getFlag(game.system.id, "cachedFor");

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getSubmitData(updateData = {}) {
		const data = foundry.utils.expandObject(super._getSubmitData(updateData));

		if (foundry.utils.hasProperty(data, "system.components.required")) {
			data.system.components.required = filteredKeys(data.system.components.required);
		}

		if (foundry.utils.hasProperty(data, "system.tags")) {
			data.system.tags = filteredKeys(data.system.tags);
		}

		return foundry.utils.flattenObject(data);
	}
}

var _module$j = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BaseItemSheet: BaseItemSheet,
	BlackFlagItemCompendium: BlackFlagItemCompendium,
	BlackFlagItemDirectory: BlackFlagItemDirectory,
	ConceptSheet: ConceptSheet,
	ContainerSheet: ContainerSheet,
	CurrencySheet: CurrencySheet,
	EquipmentSheet: EquipmentSheet,
	FeatureSheet: FeatureSheet,
	PrerequisiteConfig: PrerequisiteConfig,
	SpellSheet: SpellSheet
});

/**
 * Object describing the proficiency for a specific ability or skill.
 *
 * @param {number} [proficiency=0] - Actor's flat proficiency bonus based on their current level.
 * @param {number} [multiplier=0] - Value by which to multiply the actor's base proficiency value.
 * @param {string} [rounding=down] - Should half-values be rounded up or down?
 */
class Proficiency {
	constructor(proficiency, multiplier, rounding) {
		this.#baseProficiency = Number(proficiency ?? 0);
		this.multiplier = Number(multiplier ?? 0);
		this.rounding = rounding ?? "down";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate an actor's proficiency modifier based on level or CR.
	 * @param {number} level - Level or CR To use for calculating proficiency modifier.
	 * @returns {number} - Proficiency modifier.
	 */
	static calculateMod(level) {
		return Math.floor((level + 7) / 4);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Base proficiency value of the actor.
	 * @type {number}
	 * @private
	 */
	#baseProficiency;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Value by which to multiply the actor's base proficiency value.
	 * @type {number}
	 */
	multiplier;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Direction decimal results should be rounded ("up" or "down").
	 * @type {string}
	 */
	rounding;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Flat proficiency value regardless of proficiency mode.
	 * @type {number}
	 */
	get flat() {
		const roundMethod = this.rounding === "down" ? Math.floor : Math.ceil;
		return roundMethod(this.multiplier * this.#baseProficiency);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Dice-based proficiency value regardless of proficiency mode.
	 * @type {string}
	 */
	get dice() {
		if (this.#baseProficiency === 0 || this.multiplier === 0) return "0";
		const roundTerm = this.rounding === "down" ? "floor" : "ceil";
		if (this.multiplier === 0.5) {
			return `${roundTerm}(1d${this.#baseProficiency * 2} / 2)`;
		} else {
			return `${this.multiplier}d${this.#baseProficiency * 2}`;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Proficiency term to use in dice rolls.
	 * @type {string}
	 */
	get term() {
		return game.settings.get(game.system.id, "proficiencyMode") === "dice" ? this.dice : String(this.flat);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Whether the proficiency is greater than zero.
	 * @type {boolean}
	 */
	get hasProficiency() {
		return this.#baseProficiency > 0 && this.multiplier > 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Label based on the current proficiency mode.
	 * @type {string}
	 */
	get label() {
		return game.i18n.localize(
			{
				0: "BF.Proficiency.Level.None",
				0.5: "BF.Proficiency.Level.Half",
				1: "BF.Proficiency.Level.Proficient",
				2: "BF.Proficiency.Level.Expertise"
			}[this.multiplier]
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Override the default `toString` method to return flat proficiency for backwards compatibility in formula.
	 * @returns {string} - Flat proficiency value.
	 */
	toString() {
		return this.term;
	}
}

/**
 * @typedef JournalEditorConfiguration
 * @property {string} textKeyPath  The path to the specific HTML field being edited.
 */

/**
 * Pop out ProseMirror editor window for journal entries with multiple text areas that need editing.
 * @extends {DocumentSheet5e<ApplicationConfiguration & JournalEditorConfiguration>}
 */
class JournalEditor extends BFDocumentSheet {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["journal-editor"],
		form: {
			submitOnChange: true
		},
		position: {
			width: 600,
			height: 640
		},
		sheetConfig: false,
		textKeyPath: null,
		window: {
			resizable: true
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		editor: {
			template: "systems/black-flag/templates/journal/journal-editor.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get title() {
		return this.options.window.title || this.document.name;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		const rawText = foundry.utils.getProperty(this.document, this.options.textKeyPath) ?? "";
		return foundry.utils.mergeObject(context, {
			document: this.document,
			enriched: await TextEditor.enrichHTML(rawText, {
				relativeTo: this.document,
				secrets: this.document.isOwner
			}),
			keyPath: this.options.textKeyPath,
			source: rawText
		});
	}
}

/**
 * Journal entry page that displays an automatically generated summary of a class along with additional description.
 */
class ClassPageSheet extends JournalPageSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		const options = foundry.utils.mergeObject(super.defaultOptions, {
			dragDrop: [{ dropSelector: ".drop-target" }],
			height: "auto",
			width: 500,
			submitOnChange: true
		});
		options.classes.push("class-editor");
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get template() {
		return `systems/black-flag/templates/journal/${this.type}-page-${this.isEditable ? "edit" : "view"}.hbs`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Whether this page represents a class or subclass.
	 * @type {string}
	 */
	get type() {
		return this.document.system.metadata.type;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	toc = {};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options = {}) {
		const context = await super.getData(options);
		context.system = context.document.system;

		context.title = Object.fromEntries(
			Array.fromRange(4, 1).map(n => [
				`level${n}`,
				(context.data.system.headingLevel || context.data.title.level) + n - 1
			])
		);

		context.internalHeadingLevels = {
			...context.headingLevels,
			4: game.i18n.format("JOURNALENTRYPAGE.Level", { level: 4 })
		};

		const linked = await fromUuid(this.document.system.item);
		const subclasses =
			this.type === "class" ? await Promise.all(this.document.system.subclasses.map(s => fromUuid(s))) : [];

		if (!linked) return context;
		context.linked = {
			document: linked,
			name: linked.name,
			lowercaseName: linked.name.toLowerCase()
		};

		const features = await this._prefetchFeatures([linked, ...subclasses]);

		context.advancement = this._getAdvancement(linked);
		context.enriched = await this._getDescriptions(context.document);
		context.table = await this._getTable(linked, { features });
		context.features = await this._getFeatures(linked, { features });
		if (subclasses.length)
			context.subclasses = (await this._getSubclasses(subclasses, { features })).sort((lhs, rhs) =>
				lhs.name.localeCompare(rhs.name)
			);

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Pre-fetch all features associated with the provided items through grant & choose features advancements.
	 * @param {BlackFlagItem[]} items - Items from which the features should be fetched.
	 * @param {boolean} [subfeatures=true] - Should the fetching process repeat for found features?
	 * @returns {Collection<string, BlackFlagItem>} - Mapping of UUIDs to feature items.
	 * @internal
	 */
	async _prefetchFeatures(items, subfeatures = true) {
		const uuidsToFetch = items
			.filter(i => i)
			.map(i => {
				const advancements = i.system.advancement
					?.byType("grantFeatures")
					.concat(i.system.advancement?.byType("chooseFeatures"))
					.filter(a => !a.getFlag(game.system.id, "hideOnClassTable"));
				return advancements.flatMap(a => a.configuration.pool.map(p => p.uuid));
			})
			.flat();

		const fetched = new Collection(await Promise.all(uuidsToFetch.map(async uuid => [uuid, await fromUuid(uuid)])));

		if (subfeatures) (await this._prefetchFeatures(fetched, false)).forEach(f => fetched.set(f.uuid, f));

		return fetched;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare features granted by various advancement types.
	 * @param {BlackFlagItem} item - Class item belonging to this journal.
	 * @returns {object} - Prepared advancement section.
	 * @internal
	 */
	_getAdvancement(item) {
		const advancement = {};

		const hp = item.system.advancement.byType("hitPoints")[0];
		if (hp) {
			advancement.hp = {
				hitDice: `1d${hp.configuration.denomination}`,
				max: hp.configuration.denomination,
				average: hp.average
			};
		}

		const traits = item.system.advancement.byType("trait");
		const makeTrait = type => {
			const advancement = traits.find(a => a.bestGuessTrait() === type);
			// TODO: Probably need to filter this by `level = 1` && `classRestriction !== "multiclass"`
			if (!advancement) return game.i18n.localize("BF.Proficiency.None");
			return localizedList(advancement.configuration.grants, advancement.configuration.choices, {
				choiceMode: advancement.configuration.choiceMode
			});
		};
		advancement.traits = {
			armor: makeTrait("armor"),
			weapons: makeTrait("weapons"),
			tools: makeTrait("tools"),
			saves: makeTrait("saves"),
			skills: makeTrait("skills")
		};

		const equipment = item.system.advancement.byType("equipment")[0];
		if (equipment) advancement.equipment = equipment.summaryForLevel();

		return advancement;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Enrich all of the entries within the descriptions object on the sheet's system data.
	 * @param {JournalEntryPage} page - Journal page being enriched.
	 * @returns {Promise<object>} - Object with enriched descriptions.
	 * @internal
	 */
	async _getDescriptions(page) {
		return Object.fromEntries(
			await Promise.all(
				Object.entries(page.system.description ?? {}).map(async ([id, text]) => {
					const enriched = await TextEditor.enrichHTML(text, {
						relativeTo: this.object,
						secrets: this.object.isOwner,
						async: true
					});
					return [id, enriched];
				})
			)
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare table based on Grant Features advancement & Scale Value advancement.
	 * @param {BlackFlagItem} item - Class item belonging to this journal.
	 * @param {object} options
	 * @param {Collection<BlackFlagItem>} options.features - Pre-fetched feature items.
	 * @param {number} [options.initialLevel=1] - Level at which the table begins.
	 * @returns {object} - Prepared table data.
	 * @internal
	 */
	async _getTable(item, { features, initialLevel = 1 }) {
		const hasFeatures = !!item.system.advancement.byType("grantFeatures");
		const scaleValues = this._getScaleValues(item, { features });
		const spellProgression = await item.system.advancement.byType("spellcasting")[0]?.generateSpellcastingTable();

		const headers = [[{ content: game.i18n.localize("BF.Level.Label[one]") }]];
		if (item.type === "class") headers[0].push({ content: game.i18n.localize("BF.Proficiency.Bonus.Abbreviation") });
		if (hasFeatures) headers[0].push({ content: game.i18n.localize("BF.Item.Type.Feature[other]") });
		headers[0].push(...scaleValues.column.map(a => ({ content: a.title })));
		if (spellProgression) {
			if (spellProgression.headers.length > 1) {
				headers[0].forEach(h => (h.rowSpan = 2));
				headers[0].push(...spellProgression.headers[0]);
				headers[1] = spellProgression.headers[1];
			} else {
				headers[0].push(...spellProgression.headers[0]);
			}
		}

		const cols = [{ class: "level", span: 1 }];
		if (item.type === "class") cols.push({ class: "prof", span: 1 });
		if (hasFeatures) cols.push({ class: "features", span: 1 });
		if (scaleValues.column.length) cols.push({ class: "scale", span: scaleValues.column.length });
		if (spellProgression) cols.push(...spellProgression.cols);

		const featuresInTable = new Set();

		const rows = [];
		for (const level of Array.fromRange(CONFIG.BlackFlag.maxLevel - initialLevel + 1, initialLevel)) {
			const features = {};

			for (const advancement of item.system.advancement.byLevel(level)) {
				if (advancement.getFlag(game.system.id, "hideOnClassTable")) continue;
				switch (advancement.constructor.typeName) {
					case "grantFeatures":
						advancement.configuration.pool.forEach(d => (features[d.uuid] = linkForUUID(d.uuid, { element: true })));
						break;
					case "expandedTalentList":
					case "improvement":
						features[advancement.uuid] = advancement.titleForLevel({ character: level, class: level });
						break;
				}
			}
			Object.keys(features).forEach(uuid => featuresInTable.add(uuid));

			for (const uuid of featuresInTable) {
				const scales = scaleValues.grouped.get(uuid)?.filter(s => s.configuration.scale[level]);
				if (!scales?.length) continue;
				const values = scales.map(s => s.valueForLevel(level).display);
				features[uuid] ??= linkForUUID(uuid, { element: true });
				features[uuid].innerHTML += ` (${game.i18n.getListFormatter({ type: "unit" }).format(values)})`;
			}

			if (item.type === "class" && level === CONFIG.BlackFlag.subclassLevel) {
				features.subclass = game.i18n.format("BF.Subclass.LabelSpecific", { class: item.name });
			} else if (item.type === "class" && CONFIG.BlackFlag.subclassFeatureLevels.includes(level)) {
				features.subclass = game.i18n.localize("BF.Feature.Category.Subclass[one]");
			}

			// Level & proficiency bonus
			const cells = [{ class: "level", content: numberFormat(level, { ordinal: true }) }];
			if (item.type === "class") cells.push({ class: "prof", content: `+${Proficiency.calculateMod(level)}` });
			if (hasFeatures)
				cells.push({
					class: "features",
					content: Object.values(features)
						.map(f => (foundry.utils.getType(f) === "string" ? f : f.outerHTML))
						.join(", ")
				});
			scaleValues.column.forEach(s => cells.push({ class: "scale", content: s.valueForLevel(level)?.display ?? "â€”" }));
			const spellCells = spellProgression?.rows[level - 1];
			if (spellCells) cells.push(...spellCells);

			// Skip empty rows on subclasses
			const hasContent = !foundry.utils.isEmpty(features) || scaleValues.length || spellCells;
			if (item.type !== "subclass" || (level >= CONFIG.BlackFlag.subclassLevel && hasContent)) {
				rows.push(cells);
			}
		}

		return { headers, cols, rows };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Sort scale values into ones displayed in their own column versus ones grouped with features.
	 * @param {BlackFlagItem} item - Class or subclass item being prepared.
	 * @param {object} options
	 * @param {Collection<BlackFlagItem>} options.features - Pre-fetched feature items.
	 * @returns {{column: ScaleValueAdvancement[], grouped: Collection<ScaleValueAdvancement[]>}}
	 */
	_getScaleValues(item, { features }) {
		const filter = a => a.filter(a => !a.getFlag(game.system.id, "hideOnClassTable"));
		return {
			column: filter(item.system.advancement.byType("scaleValue")),
			grouped: features.reduce((collection, feature) => {
				collection.set(feature.uuid, filter(feature.system.advancement.byType("scaleValue")));
				return collection;
			}, new Collection())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch data for each class feature listed.
	 * @param {BlackFlagItem} item - Class or subclass item belonging to this journal.
	 * @param {object} options
	 * @param {Collection<BlackFlagItem>} options.features - Pre-fetched feature items.
	 * @returns {object[]}   Prepared features.
	 */
	async _getFeatures(item, { features }) {
		const makeTag = levels => {
			if (foundry.utils.getType(levels) !== "Array") levels = [levels];
			return game.i18n.format("BF.Feature.Tag", {
				level: game.i18n
					.getListFormatter()
					.format(levels.sort((lhs, rhs) => lhs - rhs).map(l => numberFormat(l, { ordinal: true }))),
				owner: item.name,
				type: game.i18n.localize("BF.Item.Type.Feature[one]")
			});
		};

		let prepared = [];
		for (const advancement of item.system.advancement.byType("grantFeatures")) {
			const level = advancement.level.value;
			prepared.push(
				...advancement.configuration.pool.map(async d => {
					const doc = features.get(d.uuid);
					if (!doc) return;
					const levels = doc.system.advancement?.levels ?? [];
					if (!levels.includes(level)) levels.unshift(level);
					return {
						level,
						document,
						name: doc.name,
						description: await TextEditor.enrichHTML(doc.system.description.value, {
							relativeTo: doc,
							secrets: false,
							async: true
						}),
						tag: makeTag(levels)
					};
				})
			);
		}

		if (item.system.advancement.byType("improvement").length) {
			const levels = item.system.advancement.byType("improvement").map(a => a.level.value);
			const first = item.system.advancement.byType("improvement")[0];
			prepared.push({
				level: first.level.value,
				name: first.titleForLevel(),
				document: first,
				description: first.journalSummary(),
				tag: makeTag(levels)
			});
		}

		if (item.type === "class")
			prepared.push({
				level: CONFIG.BlackFlag.subclassLevel,
				name: game.i18n.format("BF.Subclass.LabelSpecific", { class: item.name }),
				description: this.document.system.description.subclassAdvancement
					? await TextEditor.enrichHTML(this.document.system.description.subclassAdvancement, {
							relativeTo: item,
							secrets: false,
							async: true
						})
					: game.i18n.localize("BF.JournalPage.Class.Subclass.AdvancementDescription.Placeholder"),
				tag: makeTag(CONFIG.BlackFlag.subclassFeatureLevels)
			});

		if (item.type === "subclass") {
			const advancement = item.system.advancement.byType("expandedTalentList")[0];
			if (advancement)
				prepared.push({
					level: CONFIG.BlackFlag.subclassLevel,
					name: advancement.titleForLevel(),
					document: advancement,
					description: await advancement.journalSummary(),
					tag: makeTag(CONFIG.BlackFlag.subclassLevel)
				});
		}

		return (await Promise.all(prepared)).sort((lhs, rhs) => lhs.level - rhs.level);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the context for any linked subclasses.
	 * @param {BlackFlagItem[]} subclasses - Subclasses to prepare.
	 * @param {object} options
	 * @param {Collection<BlackFlagItem>} options.features - Pre-fetched feature items.
	 * @returns {object[]} - Prepared subclasses.
	 */
	async _getSubclasses(subclasses, { features }) {
		return await Promise.all(
			subclasses
				.filter(s => s)
				.map(async document => {
					return {
						document,
						name: document.name,
						description: await TextEditor.enrichHTML(document.system.description.value, {
							relativeTo: document,
							secrets: false,
							async: true
						}),
						features: await this._getFeatures(document, { features }),
						table: await this._getTable(document, { features, initialLevel: CONFIG.BlackFlag.subclassLevel })
					};
				})
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _renderInner(...args) {
		const html = await super._renderInner(...args);
		this.toc = JournalEntryPage.buildTOC(html.get());
		return html;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const html = jQuery[0];

		for (const element of html.querySelectorAll("[data-action]")) {
			element.addEventListener("click", this._onAction.bind(this));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle an action.
	 * @param {Event} event - Triggering click event.
	 * @returns {Promise}
	 */
	async _onAction(event) {
		const { action, ...properties } = event.currentTarget.dataset;
		switch (action) {
			case "delete":
				const container = event.currentTarget.closest("[data-item-uuid]");
				const uuidToDelete = container?.dataset.itemUuid;
				if (!uuidToDelete) return;
				switch (container.dataset.itemType) {
					case "linked":
						await this.document.update({ "system.item": "" });
						return this.render();
					case "subclass":
						const subclassCollection = this.document.system.subclasses;
						subclassCollection.delete(uuidToDelete);
						await this.document.update({ "system.subclasses": Array.from(subclassCollection) });
						return this.render();
				}
				break;
			case "launch-text-editor":
				const label = event.target.closest("label");
				return new JournalEditor({
					document: this.document,
					textKeyPath: properties.target,
					window: {
						title: label?.querySelector("span")?.innerText
					}
				}).render({ force: true });
			default:
				return log(`Unrecognized action: ${action}`, { level: "warn" });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_canDragDrop() {
		return this.isEditable;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _onDrop(event) {
		const data = TextEditor.getDragEventData(event);

		if (data?.type !== "Item") return false;
		const item = await Item.implementation.fromDropData(data);
		const type = this.type === item.type ? "linked" : item.type;
		switch (type) {
			case "linked":
				await this.document.update({ "system.item": item.uuid });
				return this.render();
			case "subclass":
				const subclassCollection = this.document.system.subclasses;
				subclassCollection.add(item.uuid);
				await this.document.update({ "system.subclasses": Array.from(subclassCollection) });
				return this.render();
			default:
				return false;
		}
	}
}

/**
 * Variant of the standard journal sheet to handle custom TOC numbering.
 */
class BlackFlagJournalSheet extends JournalSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.classes.push("black-flag-journal");
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_getPageData() {
		const pageData = super._getPageData();

		let adjustment = 0;
		for (const page of pageData) {
			const pageDocument = this.document.pages.get(page._id);
			let needsAdjustment = true;
			const numbering = pageDocument.system.adjustTOCNumbering?.(page.number);
			if (numbering) {
				page.number = numbering.number;
				adjustment += numbering.adjustment ?? 0;
				needsAdjustment = false;
			}
			if (needsAdjustment) page.number += adjustment;
		}

		return pageData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add Black Flag class to individual journal pages.
	 * @param {JournalPageSheet} page - The journal page application.
	 * @param {jQuery} jQuery - The rendered Application HTML.
	 * @param {object} context - Rendering context provided.
	 */
	static onRenderJournalPageSheet(page, jQuery, context) {
		if (page.object.parent.sheet instanceof BlackFlagJournalSheet) {
			let element;
			if (context.editable) element = jQuery[0];
			else element = jQuery[0].parentElement;
			element?.classList.add("black-flag-journal");
		}
	}
}

/**
 * Journal entry page to display a special map marker.
 */
class MapLocationPageSheet extends JournalTextPageSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.classes.push("black-flag", "map");
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get template() {
		return `templates/journal/page-text-${this.isEditable ? "edit" : "view"}.html`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _renderInner(...args) {
		const jQuery = await super._renderInner(...args);
		const editingHeader = jQuery[0].querySelector(".journal-header");
		const viewingHeader = jQuery[0].querySelector(":is(h1, h2, h3)");

		if (editingHeader) {
			const input = document.createElement("input");
			input.name = "system.code";
			input.type = "text";
			input.value = this.document.system.code ?? "";
			editingHeader.insertAdjacentElement("afterbegin", input);
		} else if (viewingHeader && this.document.system.code) {
			viewingHeader.dataset.mapLocationCode = this.document.system.code;
		}

		return jQuery;
	}
}

/**
 * Journal entry page that displays a controls for editing rule page tooltip & type.
 */
class JournalRulePageSheet extends JournalTextPageSheet {
	/** @inheritdoc */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.classes.push("rule");
		options.includeTOC = false;
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritdoc */
	get template() {
		return this.isEditable
			? "systems/black-flag/templates/journal/rule-page-edit.hbs"
			: "templates/journal/page-text-view.html";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritdoc */
	async getData(options) {
		const context = await super.getData(options);
		context.CONFIG = CONFIG.BlackFlag;
		context.enrichedTooltip = await TextEditor.enrichHTML(this.object.system.tooltip, {
			relativeTo: this.object,
			secrets: this.object.isOwner,
			async: true
		});
		return context;
	}
}

/**
 * Journal entry page the displays a list of spells.
 */
class JournalSpellListPageSheet extends JournalPageSheet {
	/** @inheritDoc */
	static get defaultOptions() {
		const options = foundry.utils.mergeObject(super.defaultOptions, {
			dragDrop: [{ dropSelector: "form" }],
			scrollY: [".right.spell-list"],
			submitOnChange: true,
			width: 700,
			grouping: null
		});
		options.classes.push("spell-list");
		return options;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Currently selected grouping mode.
	 * @type {string|null}
	 */
	grouping = null;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get template() {
		return `systems/black-flag/templates/journal/spell-list-page-${this.isEditable ? "edit" : "view"}.hbs`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async getData(options) {
		const context = super.getData(options);
		context.CONFIG = CONFIG.BlackFlag;
		context.fields = this.document.system.schema.fields;
		context.system = context.document.system;

		context.title = Object.fromEntries(
			Array.fromRange(4, 1).map(n => [
				`level${n}`,
				context.data.system.headingLevel || context.data.title.level + n - 1
			])
		);

		context.headingLevelOptions = Array.fromRange(6, 1).map(level => ({
			value: level,
			label: game.i18n.format("JOURNALENTRYPAGE.Level", { level })
		}));

		context.enriched = {};
		for (const key of ["conclusion", "introduction"]) {
			context.enriched[key] = await TextEditor.enrichHTML(context.system.description[key], { relativeTo: this });
			if (context.enriched[key] === "<p></p>") context.enriched[key] = "";
		}

		context.groupingOptions = Object.entries(this.document.system.constructor.GROUPING_MODES).map(([value, label]) => ({
			value,
			label: game.i18n.localize(label)
		}));
		context.grouping = this.grouping || this.options.grouping || context.system.grouping;

		context.spells = await this.prepareSpells(context.grouping);

		context.sections = {};
		const spellCircles = context.CONFIG.spellCircles();
		for (const data of context.spells) {
			const spell = data.spell ?? data.unlinked;
			let section;
			switch (context.grouping) {
				case "alphabetical":
					const letter = spell.name.slice(0, 1).toLowerCase();
					section = context.sections[letter] ??= { header: letter.toUpperCase(), spells: [] };
					break;
				case "circle":
					const circle = spell.system.circle.base;
					section = context.sections[circle] ??= { header: spellCircles[circle], spells: [] };
					break;
				case "school":
					const school = spell.system.school;
					section = context.sections[school] ??= { header: context.CONFIG.spellSchools.localized[school], spells: [] };
					break;
				default:
					continue;
			}
			section.spells.push(data);
		}
		context.sections = Object.values(context.sections);
		if (context.grouping === "school") {
			context.sections = context.sections.sort((lhs, rhs) => lhs.header.localeCompare(rhs.header, game.i18n.lang));
		}

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Load indices with necessary information for spells.
	 * @param {string} grouping - Grouping mode to respect.
	 * @returns {object[]}
	 */
	async prepareSpells(grouping) {
		const fields = ["system.circle.base", "system.description.short", "system.school"];
		const uuids = new Set(this.document.system.spells);

		// TODO: Remove when https://github.com/foundryvtt/foundryvtt/issues/11991 is resolved
		const parseUuid = uuid => {
			const parsed = foundry.utils.parseUuid(uuid);
			const remappedUuid = uuid.startsWith("Compendium")
				? [
						"Compendium",
						parsed.collection.metadata.id,
						parsed.primaryType ?? parsed.documentType,
						parsed.primaryId ?? parsed.documentId,
						...parsed.embedded
					].join(".")
				: uuid;
			return { ...parsed, remappedUuid };
		};

		let collections = new Collection();
		const remappedUuids = new Set();
		for (const uuid of uuids) {
			const { collection, remappedUuid } = parseUuid(uuid);
			remappedUuids.add(remappedUuid);
			if (collection && !collections.has(collection)) {
				if (collection instanceof Items) collections.set(collection, collection);
				else collections.set(collection, collection.getIndex({ fields }));
			}
		}

		const spells = (await Promise.all(collections.values())).flatMap(c => c.filter(s => remappedUuids.has(s.uuid)));

		return spells
			.map(spell => {
				const data = {
					anchor: linkForUUID(spell.uuid, {
						tooltip: '<section class="loading"><i class="fas fa-spinner fa-spin-pulse"></i></section>'
					}),
					name: spell.name,
					school: CONFIG.BlackFlag.spellSchools.localized[spell.system.school],
					spell
				};
				return data;
			})
			.sort((a, b) => a.name.localeCompare(b.name, game.i18n.lang));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(jQuery) {
		super.activateListeners(jQuery);
		const [html] = jQuery;

		html.querySelector('[name="grouping"]')?.addEventListener("change", event => {
			this.grouping = event.target.value === this.document.system.grouping ? null : event.target.value;
			this.object.parent.sheet.render();
		});
		html.querySelectorAll("[data-action]").forEach(e => {
			e.addEventListener("click", this._onAction.bind(this));
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing an action.
	 * @param {PointerEvent} event - This triggering click event.
	 */
	async _onAction(event) {
		event.preventDefault();
		const { action } = event.target.dataset;

		const { itemUuid } = event.target.closest(".item")?.dataset ?? {};
		switch (action) {
			case "delete":
				if (itemUuid) {
					const spellSet = this.document.system.spells.filter(s => s !== itemUuid);
					await this.document.update({ "system.spells": Array.from(spellSet) });
				}
				this.render();
				break;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Drag & Drop             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_canDragDrop() {
		return this.isEditable;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onDrop(event) {
		const data = TextEditor.getDragEventData(event);
		let spells;
		switch (data?.type) {
			case "Folder":
				spells = (await Folder.implementation.fromDropData(data))?.contents;
				break;
			case "Item":
				spells = [await Item.implementation.fromDropData(data)];
				break;
			default:
				return false;
		}

		const spellUuids = this.document.system.spells;
		spells = spells.filter(item => item.type === "spell" && !spellUuids.has(item.uuid));
		if (!spells.length) return false;

		spells.forEach(i => spellUuids.add(i.uuid));
		await this.document.update({ "system.spells": Array.from(spellUuids) });
		this.render();
	}
}

/**
 * Compendium that renders pages as a table of contents.
 */
class TableOfContentsCompendium extends (foundry.applications?.sidebar?.apps?.Compendium ?? Compendium) {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["table-of-contents"],
		window: {
			resizable: true,
			contentTag: "article"
		},
		position: {
			width: 800,
			height: 950
		},
		actions: {
			activateEntry: this.prototype._onClickLink
		}
	};

	/** @inheritDoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["table-of-contents"],
			template: "systems/black-flag/templates/journal/table-of-contents.hbs",
			width: 800,
			height: 950,
			resizable: true,
			contextMenuSelector: "[data-entry-id]",
			dragDrop: [{ dragSelector: "[data-document-id]", dropSelector: "article" }]
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		article: {
			root: true,
			template: "systems/black-flag/templates/journal/table-of-contents.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Position of pages based on type.
	 * @enum {number}
	 */
	static TYPES = {
		chapter: 0,
		appendix: 100
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_configureRenderParts(options) {
		// Skip normal compendium render parts logic.
		return foundry.utils.deepClone(this.constructor.PARTS);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_createContextMenus() {
		foundry.applications.ui.ContextMenu.create(this, this.element, "[data-entry-id]", this._getEntryContextOptions(), {
			jQuery: false,
			fixed: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onRender(context, options) {
		await super._onRender(context, options);
		new DragDrop({
			dragSelector: "[data-document-id]",
			dropSelector: "article",
			permissions: {
				dragstart: this._canDragStart.bind(this),
				drop: this._canDragDrop.bind(this)
			},
			callbacks: {
				dragstart: this._onDragStart.bind(this),
				drop: this._onDrop.bind(this)
			}
		}).bind(this.element);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		const context = await super._prepareContext(options);
		return this._getData(context);
	}

	/** @inheritDoc */
	async getData(options) {
		const context = await super.getData(options);
		return this._getData(context);
	}

	/**
	 * Shared context preparation between V12 & V13.
	 * @param {object} context
	 * @returns {object}
	 */
	async _getData(context) {
		const documents = await this.collection.getDocuments();

		context.chapters = [];
		const specialEntries = [];
		for (const entry of documents) {
			const flags = entry.flags?.[game.system.id];
			if (!flags) continue;
			const type = flags.type ?? "chapter";

			if (type === "header") {
				const page = entry.pages.contents[0];
				context.header = {
					title: flags.title ?? page?.name,
					content: page?.text.content
				};
				continue;
			}

			const data = {
				type,
				flags,
				id: entry.id,
				name: flags.title ?? entry.name,
				pages: Array.from(entry.pages).map(({ flags, id, name, sort, title }) => ({
					id,
					sort,
					flags,
					level: title.level,
					name: flags[game.system.id]?.title ?? name,
					entryId: entry.id
				}))
			};

			if (type === "special") {
				data.showPages = flags.showPages ?? !flags.append;
				specialEntries.push(data);
			} else {
				data.order = (this.constructor.TYPES[type] ?? 200) + (flags.position ?? 0);
				data.showPages = flags.showPages !== false && (flags.showPages === true || type === "chapter");
				context.chapters.push(data);
			}
		}

		context.chapters.sort((lhs, rhs) => lhs.order - rhs.order);
		for (const entry of specialEntries) {
			const append = entry.flags.append;
			const order = entry.flags.order;
			if (append) {
				context.chapters[append - 1].pages.push({ ...entry, sort: order, entry: true });
			} else {
				context.chapters.push(entry);
			}
		}

		const handlePages = (chapter, _d = 0) => {
			for (const chapter of context.chapters) {
				chapter.pages.sort((lhs, rhs) => lhs.sort - rhs.sort);
				for (const page of chapter.pages) {
					const classes = [`level-${page.level}`];
					if (page.showPages && page.pages?.length) {
						classes.push("child-pages");
						if (_d < 2) handlePages(page, _d + 1);
					}
					if (page.entry) classes.push("special-entry");
					page.classes = classes.join(" ");
				}
			}
		};
		context.chapters.forEach(c => handlePages());

		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _renderFrame(options) {
		const frame = await super._renderFrame(options);
		frame.dataset.compendiumId = this.collection.metadata.id;
		return frame;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find("[data-action='activateEntry']").on("click", this._onClickLink.bind(this));
		this.element[0].dataset.compendiumId = this.collection.metadata.id;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle clicking a link to a journal entry or page.
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 * @protected
	 */
	async _onClickLink(event, target) {
		target ??= event.currentTarget;
		const entryId = target.closest("[data-entry-id]")?.dataset.entryId;
		if (!entryId) return;
		const entry = await this.collection.getDocument(entryId);
		entry?.sheet.render(true, {
			pageId: target.closest("[data-page-id]")?.dataset.pageId
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onDragStart(event) {
		let dragData;
		if (ui.context) ui.context.close({ animate: false });
		dragData = this._getEntryDragData(event.target.dataset.documentId);
		if (!dragData) return;
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}
}

var _module$i = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BlackFlagJournalSheet: BlackFlagJournalSheet,
	JournalClassPageSheet: ClassPageSheet,
	JournalEditor: JournalEditor,
	JournalSpellListPageSheet: JournalSpellListPageSheet,
	MapLocationPageSheet: MapLocationPageSheet,
	RulePageSheet: JournalRulePageSheet,
	TableOfContentsCompendium: TableOfContentsCompendium
});

const { BooleanField: BooleanField$j, NumberField: NumberField$A, StringField: StringField$R } = foundry.data.fields;

/**
 * Base application for configuring system settings.
 */
class BaseSettingsConfig extends BFApplication {
	/** @override */
	static DEFAULT_OPTIONS = {
		tag: "form",
		classes: ["black-flag", "standard-form", "form-list"],
		position: {
			width: 500
		},
		form: {
			closeOnSubmit: true,
			handler: BaseSettingsConfig.#onCommitChanges
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		config: {
			template: "systems/black-flag/templates/setting/base-config.hbs"
		},
		footer: {
			template: "templates/generic/form-footer.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		context.fields = [];
		context.buttons = [
			{
				type: "submit",
				cssClass: "light-button",
				icon: "fa-solid fa-save",
				label: "BF.Action.SaveChanges"
			}
		];
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create the field data for a specific setting.
	 * @param {string} name - Setting key within the dnd5e namespace.
	 * @returns {object}
	 */
	createSettingField(name) {
		const setting = game.settings.settings.get(`${game.system.id}.${name}`);
		if (!setting) throw new Error(`Setting \`${game.system.id}.${name}\` not registered.`);
		const Field = { [Boolean]: BooleanField$j, [Number]: NumberField$A, [String]: StringField$R }[setting.type];
		if (!Field) throw new Error("Automatic field generation only available for Boolean, Number, or String types");
		const data = {
			field: new Field({ label: game.i18n.localize(setting.name), hint: game.i18n.localize(setting.hint) }),
			name,
			value: game.settings.get(game.system.id, name)
		};
		if (setting.choices)
			data.options = Object.entries(setting.choices).map(([value, label]) => ({
				value,
				label: game.i18n.localize(label)
			}));
		return data;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Commit settings changes.
	 * @this {BaseSettingsConfig}
	 * @param {SubmitEvent} event - The submission event.
	 * @param {HTMLFormElement} form - The submitted form element.
	 * @param {FormDataExtended} formData - The submitted form data.
	 * @returns {Promise}
	 */
	static async #onCommitChanges(event, form, formData) {
		let requiresClientReload = false;
		let requiresWorldReload = false;
		for (const [key, value] of Object.entries(foundry.utils.expandObject(formData.object))) {
			const current = game.settings.get(game.system.id, key);
			if (foundry.utils.getType(value) === "Object") {
				if (foundry.utils.objectsEqual(value, current)) continue;
			} else if (current === value) continue;
			await game.settings.set(game.system.id, key, value);

			const s = game.settings.settings.get(`${game.system.id}.${key}`);
			requiresClientReload ||= s.scope === "client" && s.requiresReload;
			requiresWorldReload ||= s.scope === "world" && s.requiresReload;
		}
		if (requiresClientReload || requiresWorldReload) SettingsConfig.reloadConfirm({ world: requiresWorldReload });
	}
}

const { BooleanField: BooleanField$i } = foundry.data.fields;

/**
 * A data model that contains various optional rules that can be enabled.
 */
class RulesSetting extends foundry.abstract.DataModel {
	/** @override */
	static defineSchema() {
		return {
			firearms: new BooleanField$i({ label: "BF.Settings.Rules.Firearms.Label", hint: "BF.Settings.Rules.Firearms.Hint" })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mapping of rules and the modules that require them.
	 * @type {Map<string, Package[]>}
	 */
	static #requiredRules = new Map();

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Rules that are required.
	 * @type {Record<string, boolean>}
	 */
	get required() {
		return Object.fromEntries(Object.keys(this.schema.fields).map(k => [k, !!RulesSetting.#requiredRules.get(k)]));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Register a rule as required by a package.
	 * @param {string} rule - Name of required rule.
	 * @param {Module|System|World} manifest - Manifest of the package requiring the rule.
	 */
	static addRequiredRule(rule, manifest) {
		if (!RulesSetting.#requiredRules.has(rule)) RulesSetting.#requiredRules.set(rule, []);
		RulesSetting.#requiredRules.get(rule).push(manifest);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * List of package names that require a certain rule.
	 * @param {string} rule - Name of required rule.
	 * @returns {string[]|void}
	 */
	requiredSources(rule) {
		return RulesSetting.#requiredRules.get(rule)?.map(p => p.title);
	}
}

/**
 * An application for configuring variant rules.
 */
class RulesSettingsConfig extends BaseSettingsConfig {
	/** @override */
	static DEFAULT_OPTIONS = {
		window: {
			title: "BF.Settings.Rules.Label"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		const fields = RulesSetting.schema.fields;
		const source = game.settings.get(game.system.id, "rulesConfiguration");
		for (const [name, field] of Object.entries(fields)) {
			const data = { field, name: `rulesConfiguration.${name}`, value: source[name], localize: true };
			if (source.required[name]) {
				data.disabled = true;
				data.value = true;
				const sources = game.i18n.getListFormatter().format(source.requiredSources(name));
				data.hint = `${game.i18n.localize(field.hint)} ${game.i18n.format("BF.Settings.Rules.Required", { sources })}`;
			}
			context.fields.push(data);
		}
		return context;
	}
}

var _module$h = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BaseSettingsConfig: BaseSettingsConfig,
	RulesSettingsConfig: RulesSettingsConfig
});

const REMOTE_PATH = "https://koboldpress.github.io/black-flag-docs/assets/json/official-modules.json";
const LOCAL_PATH = "systems/black-flag/json/official-modules.json";

/**
 * Application that displays important links and official module information on first starting a new world.
 */
class WelcomeDialog extends BFApplication {
	/** @override */
	static DEFAULT_OPTIONS = {
		classes: ["welcome"],
		window: {
			title: "BF.WELCOME.Title",
			icon: "fa-solid fa-flag-checkered"
		},
		actions: {
			openDocumentation: WelcomeDialog.#openDocumentation
		},
		position: {
			width: 720,
			top: 100
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static PARTS = {
		tabs: {
			template: "templates/generic/tab-navigation.hbs"
		},
		main: {
			template: "systems/black-flag/templates/welcome-main.hbs"
		},
		modules: {
			template: "systems/black-flag/templates/welcome-modules.hbs"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	tabGroups = {
		sheet: "main"
	};

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {object} OfficialModules
	 * @property {OfficialModuleDetails[]} core - Core rules modules (e.g. Player's Guide or Monster Vault).
	 * @property {OfficialModuleDetails[]} adventures - Adventure modules.
	 */

	/**
	 * @typedef {OfficialModuleDetails}
	 * @property {string} id - Foundry ID for the module.
	 * @property {string} name - Display name in the interface.
	 * @property {string} description - Brief description in HTML.
	 * @property {string} img - Path to the artwork.
	 */

	/**
	 * Cached version of the module JSON.
	 * @type {Promise<OfficialModules|void>}
	 */
	static #modules;

	/**
	 * Information on the official modules to display.
	 * @type {Promise<OfficialModules>}
	 */
	get modules() {
		const grab = path =>
			fetch(path).then(response => {
				if (!response.ok) throw Error(`HTTP Error: ${response.status}`);
				return response.json();
			});
		if (!WelcomeDialog.#modules) WelcomeDialog.#modules = grab(REMOTE_PATH).catch(err => grab(LOCAL_PATH).catch());
		return WelcomeDialog.#modules;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mapping of modules that have had their enabled status changed.
	 * @type {Map<string, boolean>}
	 */
	get toggledModules() {
		const status = new Map();
		for (const checkbox of this.element.querySelectorAll('input[type="checkbox"]')) {
			if (checkbox.checked !== game.modules.get(checkbox.name)?.active) {
				status.set(checkbox.name, checkbox.checked);
			}
		}
		return status;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareContext(options) {
		return {
			...(await super._prepareContext(options)),
			modules: await this.modules,
			tabs: this._getTabs()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preparePartContext(partId, context, options) {
		context = await super._preparePartContext(partId, context, options);
		switch (partId) {
			case "main":
				return this._prepareMainContext(context, options);
			case "modules":
				return this._prepareModulesContext(context, options);
		}
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the main tab.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareMainContext(context, options) {
		context.tab = context.tabs.main;
		context.message = `
			${game.i18n.localize("BF.WELCOME.Message.Introduction")}
			<ul>
			  <li>${game.i18n.localize("BF.WELCOME.Message.Documentation")}</li>
				<li>${game.i18n.localize("BF.WELCOME.Message.Content")}</li>
				<li>${game.i18n.localize("BF.WELCOME.Message.Bugs")}</li>
			</ul>
		`.replace(
			/<documentation-link>(?<content>[^<]+)<\/documentation-link>/i,
			`
			<button type="button" class="link-button" data-action="openDocumentation">
				$<content>
			</button>
		`
		);
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare rendering context for the modules tab.
	 * @param {ApplicationRenderContext} context - Context being prepared.
	 * @param {HandlebarsRenderOptions} options - Options which configure application rendering behavior.
	 * @returns {Promise<ApplicationRenderContext>}
	 * @protected
	 */
	async _prepareModulesContext(context, options) {
		context.tab = context.tabs.modules;
		if (!context.modules) return context;
		context.modules = foundry.utils.deepClone(context.modules);
		for (const category of Object.values(context.modules)) {
			for (const module of category) {
				const config = game.modules.get(module.id);
				module.installed = !!config;
				module.enabled = config?.active === true;
			}
		}
		context.disabled = !game.user.isGM;
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the tab information for the sheet.
	 * @returns {Record<string, Partial<ApplicationTab>>}
	 * @protected
	 */
	_getTabs() {
		const tabs = {
			main: {
				id: "main",
				group: "sheet",
				icon: "fa-solid fa-face-grin-stars",
				label: "BF.WELCOME.SECTION.Main"
			},
			modules: {
				id: "modules",
				group: "sheet",
				icon: "fa-solid fa-play",
				label: "BF.WELCOME.SECTION.Modules"
			}
		};
		for (const v of Object.values(tabs)) {
			v.active = this.tabGroups[v.group] === v.id;
			v.cssClass = v.active ? "active" : "";
		}
		return tabs;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Life-Cycle Handlers         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preClose(options) {
		await super._preClose(options);
		game.settings.set(game.system.id, "_firstRun", false);
		const toggled = this.toggledModules;
		if (toggled.size) {
			const moduleConfiguration = game.modules.values().reduce((obj, config) => {
				obj[config.id] = toggled.get(config.id) ?? config.active;
				return obj;
			}, {});
			await game.settings.set("core", "moduleConfiguration", moduleConfiguration);
			SettingsConfig.reloadConfirm({ world: true });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle displaying the documentation browser.
	 * @this {WelcomeDialog}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #openDocumentation(event, target) {
		new FrameViewer("https://koboldpress.github.io/black-flag-docs/", {
			classes: ["black-flag", "documentation"],
			title: "BF.WELCOME.Documentation"
		}).render(true);
	}
}

/**
 * Automatically register Document sheets using category information from config or metadata in SystemDataModels.
 * @param {typeof Document} documentType - Type of document to register (e.g. Actor or Item).
 * @param {{[key: string]: CategoryConfiguration}} [categories] - Categories to register.
 */
function registerSheets(documentType, categories) {
	log(`Registering ${documentType.name} sheets`, { level: "groupCollapsed" });
	const models = CONFIG[documentType.name].dataModels;
	categories = CONFIG[documentType.name].categories ?? {};
	const registered = new Set();
	for (const [key, category] of Object.entries(categories)) {
		if (!category.sheet) continue;
		const filtered = category.types.filter(t => !t.metadata?.sheet).map(f => f.fullType);
		filtered.forEach(f => registered.add(f));
		(foundry.applications?.apps?.DocumentSheetConfig ?? DocumentSheetConfig).registerSheet(
			documentType,
			game.system.id,
			category.sheet.application,
			{
				types: Array.from(filtered),
				makeDefault: true,
				label: category.sheet.label
			}
		);
		log(`Registered ${key} sheet for: ${filtered.join(", ")}`);
	}
	for (const type of new Set(Object.keys(models)).difference(registered)) {
		const metadata = models[type]?.metadata?.sheet;
		if (!metadata) continue;
		registered.add(type);
		(foundry.applications?.apps?.DocumentSheetConfig ?? DocumentSheetConfig).registerSheet(
			documentType,
			game.system.id,
			metadata.application,
			{
				types: [type],
				makeDefault: true,
				label: metadata.label
			}
		);
		log(`Registered ${type} sheet`);
	}
	(foundry.applications?.apps?.DocumentSheetConfig ?? DocumentSheetConfig).unregisterSheet(
		documentType,
		"core",
		{ name: `${documentType.name}Sheet` },
		{ types: Array.from(registered) }
	);
	console.groupEnd();
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register any custom elements on the page.
 */
function registerCustomElements() {
	log("Registering custom elements");
	window.customElements.define("blackflag-actions", ActionsElement);
	window.customElements.define("blackflag-activities", ActivitiesElement);
	window.customElements.define("blackflag-advancement", AdvancementElement);
	window.customElements.define("blackflag-attackresult", AttackResultElement);
	window.customElements.define("blackflag-consumption", ConsumptionElement);
	window.customElements.define("blackflag-copyable", CopyableElement);
	window.customElements.define("blackflag-currency", CurrencyElement);
	window.customElements.define("blackflag-damageapplication", DamageApplicationElement);
	window.customElements.define("blackflag-damagelist", DamageListElement);
	window.customElements.define("blackflag-deathsaves", DeathSavesElement);
	window.customElements.define("blackflag-effectapplication", EffectApplicationElement);
	window.customElements.define("blackflag-effects", EffectsElement);
	window.customElements.define("blackflag-filter", FilterElement);
	window.customElements.define("blackflag-filters", FiltersElement);
	window.customElements.define("blackflag-icon", IconElement);
	window.customElements.define("blackflag-inventory", InventoryElement);
	window.customElements.define("blackflag-messageluck", MessageLuckElement);
	window.customElements.define("blackflag-multiselect", MultiSelectElement);
	window.customElements.define("blackflag-sorting", SortingElement);
	window.customElements.define("blackflag-tray", ChatTrayElement);
	window.customElements.define("blackflag-uses", UsesElement);
	window.customElements.define("blackflag-xpbar", XPBarElement);
}

var applications = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BlackFlagChatLog: BlackFlagChatLog,
	BlackFlagCombatTracker: BlackFlagCombatTracker,
	BlackFlagContextMenu: BlackFlagContextMenu,
	BlackFlagDialog: BlackFlagDialog,
	DragDrop: DragDrop$1,
	IdentityConfig: SourceConfig,
	NotificationTooltip: NotificationTooltip,
	WelcomeDialog: WelcomeDialog,
	activity: _module$n,
	actor: _module$p,
	advancement: _module$m,
	api: _module$l,
	components: _module$o,
	dice: _module$k,
	item: _module$j,
	journal: _module$i,
	registerCustomElements: registerCustomElements,
	registerSheets: registerSheets,
	settings: _module$h
});

/**
 * Custom control icon used to display Map Location journal page pins on a map.
 */
class MapLocationControlIcon extends PIXI.Container {
	constructor({ code, size = 40, ...style } = {}, ...args) {
		super(...args);

		this.code = code;
		this.size = size;
		this.style = style;

		this.renderMarker();
		this.refresh();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform the actual rendering of the marker.
	 */
	renderMarker() {
		this.radius = this.size / 2;
		this.circle = [this.radius, this.radius, this.radius + 8];
		this.backgroundColor = this.style.backgroundColor;
		this.borderColor = this.style.borderHoverColor;

		// Define hit area
		this.eventMode = "static";
		this.interactiveChildren = false;
		this.hitArea = new PIXI.Circle(...this.circle);
		this.cursor = "pointer";

		// Drop Shadow
		this.shadow = this.addChild(new PIXI.Graphics());
		this.shadow
			.clear()
			.beginFill(this.style.shadowColor, 0.65)
			.drawCircle(this.radius + 8, this.radius + 8, this.radius + 10)
			.endFill();
		this.shadow.filters = [new PIXI.filters.BlurFilter(16)];

		// 3D Effect
		this.extrude = this.addChild(new PIXI.Graphics());
		this.extrude
			.clear()
			.beginFill(this.style.borderColor, 1.0)
			.drawCircle(this.radius + 2, this.radius + 2, this.radius + 9)
			.endFill();

		// Background
		this.bg = this.addChild(new PIXI.Graphics());
		this.bg
			.clear()
			.beginFill(this.backgroundColor, 1.0)
			.lineStyle(2, this.style.borderColor, 1.0)
			.drawCircle(...this.circle)
			.endFill();

		// Text
		this.text = new PreciseText(this.code, this._getTextStyle(this.code.length, this.size));
		this.text.anchor.set(0.5, 0.5);
		this.text.position.set(this.radius, this.radius);
		this.addChild(this.text);

		// Border
		this.border = this.addChild(new PIXI.Graphics());
		this.border.visible = false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Code text to be rendered.
	 * @type {string}
	 */
	code;

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	refresh({ visible, iconColor, borderColor, borderVisible } = {}) {
		if (borderColor) this.borderColor = borderColor;
		this.border
			.clear()
			.lineStyle(2, this.borderColor, 1.0)
			.drawCircle(...this.circle)
			.endFill();
		if (borderVisible !== undefined) this.border.visible = borderVisible;
		if (visible !== undefined) this.visible = visible;
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Define PIXI TestStyle object for rendering the map location code.
	 * @param {number} characterCount - Number of characters in the code.
	 * @param {number} size - Size of the icon in the Scene.
	 * @returns {PIXI.TextStyle}
	 * @protected
	 */
	_getTextStyle(characterCount, size) {
		const style = CONFIG.canvasTextStyle.clone();
		style.dropShadow = false;
		style.fill = Color.from(this.style.textColor);
		style.strokeThickness = 0;
		style.fontFamily = ["Signika"];
		if (this.style.fontFamily) style.fontFamily.unshift(this.style.fontFamily);
		style.fontSize = characterCount > 2 ? size * 0.5 : size * 0.6;
		return style;
	}
}

/**
 * Add support for drawing custom control icons based on linked journal page type.
 */
class BlackFlagNote extends (foundry.canvas?.placeables?.Note ?? Note) {
	/** @inheritDoc */
	_drawControlIcon() {
		const tint = Color.from(this.document.texture.tint || null);
		const systemIcon = this.page?.system?.getControlIcon?.({ size: this.size, tint });
		if (!systemIcon) return super._drawControlIcon();
		systemIcon.x -= this.size / 2;
		systemIcon.y -= this.size / 2;
		return systemIcon;
	}
}

/**
 * Configuration information for a token placement operation.
 *
 * @typedef {object} TokenPlacementConfiguration
 * @property {PrototypeToken[]} tokens  Prototype token information for rendering.
 */

/**
 * Data for token placement on the scene.
 *
 * @typedef {object} PlacementData
 * @property {PrototypeToken} prototypeToken
 * @property {object} index
 * @property {number} index.total             Index of the placement across all placements.
 * @property {number} index.unique            Index of the placement across placements with the same original token.
 * @property {number} x
 * @property {number} y
 * @property {number} rotation
 */

/**
 * Class responsible for placing one or more tokens onto the scene.
 * @param {TokenPlacementConfiguration} config - Configuration information for placement.
 */
class TokenPlacement {
	constructor(config) {
		this.config = config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration information for the placements.
	 * @type {TokenPlacementConfiguration}
	 */
	config;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Index of the token configuration currently being placed in the scene.
	 * @param {number}
	 */
	#currentPlacement = -1;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Track the bound event handlers so they can be properly canceled later.
	 * @type {object}
	 */
	#events;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Track the timestamp when the last mouse move event was captured.
	 * @type {number}
	 */
	#moveTime = 0;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Placements that have been generated.
	 * @type {PlacementData[]}
	 */
	#placements;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Preview tokens. Should match 1-to-1 with placements.
	 * @type {Token[]}
	 */
	#previews;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the system currently being throttled to the next animation frame?
	 * @type {boolean}
	 */
	#throttle = false;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Placement              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform the placement, asking player guidance when necessary.
	 * @param {TokenPlacementConfiguration} config
	 * @returns {Promise<PlacementData[]>}
	 */
	static place(config) {
		const placement = new this(config);
		return placement.place();
	}

	/**
	 * Perform the placement, asking player guidance when necessary.
	 * @returns {Promise<PlacementData[]>}
	 */
	async place() {
		this.#createPreviews();
		try {
			const placements = [];
			let total = 0;
			const uniqueTokens = new Map();
			while (this.#currentPlacement < this.config.tokens.length - 1) {
				this.#currentPlacement++;
				const obj = canvas.tokens.preview.addChild(this.#previews[this.#currentPlacement].object);
				await obj.draw();
				obj.eventMode = "none";
				const placement = await this.#requestPlacement();
				if (placement) {
					const actorId = placement.prototypeToken.parent.id;
					uniqueTokens.set(actorId, (uniqueTokens.get(actorId) ?? -1) + 1);
					placement.index = { total: total++, unique: uniqueTokens.get(actorId) };
					placements.push(placement);
				} else obj.clear();
			}
			return placements;
		} finally {
			this.#destroyPreviews();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create token previews based on the prototype tokens in config.
	 */
	#createPreviews() {
		this.#placements = [];
		this.#previews = [];
		for (const prototypeToken of this.config.tokens) {
			const tokenData = prototypeToken.toObject();
			tokenData.sight.enabled = false;
			tokenData._id = foundry.utils.randomID();
			if (tokenData.randomImg) tokenData.texture.src = prototypeToken.actor.img;
			const cls = getDocumentClass("Token");
			const doc = new cls(tokenData, { parent: canvas.scene });
			this.#placements.push({ prototypeToken, x: 0, y: 0, rotation: tokenData.rotation ?? 0 });
			this.#previews.push(doc);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Clear any previews from the scene.
	 */
	#destroyPreviews() {
		this.#previews.forEach(p => p.object.destroy());
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Activate listeners for the placement preview.
	 * @returns {Promise<PlacementData|false>} - A promise that resolves with the final placement if created,
	 *                                           or false if the placement was skipped.
	 */
	#requestPlacement() {
		return new Promise((resolve, reject) => {
			this.#events = {
				confirm: this.#onConfirmPlacement.bind(this),
				move: this.#onMovePlacement.bind(this),
				resolve,
				reject,
				rotate: this.#onRotatePlacement.bind(this),
				skip: this.#onSkipPlacement.bind(this)
			};

			// Activate listeners
			canvas.stage.on("mousemove", this.#events.move);
			canvas.stage.on("mousedown", this.#events.confirm);
			canvas.app.view.oncontextmenu = this.#events.skip;
			canvas.app.view.onwheel = this.#events.rotate;
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Shared code for when token placement ends by being confirmed or canceled.
	 * @param {Event} event - Triggering event that ended the placement.
	 */
	async #finishPlacement(event) {
		canvas.stage.off("mousemove", this.#events.move);
		canvas.stage.off("mousedown", this.#events.confirm);
		canvas.app.view.oncontextmenu = null;
		canvas.app.view.onwheel = null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Move the token preview when the mouse moves.
	 * @param {Event} event - Triggering mouse event.
	 */
	#onMovePlacement(event) {
		event.stopPropagation();
		if (this.#throttle) return;
		this.#throttle = true;
		const idx = this.#currentPlacement;
		const preview = this.#previews[idx];
		const clone = preview.object;
		const local = event.data.getLocalPosition(canvas.tokens);
		local.x = local.x - clone.w / 2;
		local.y = local.y - clone.h / 2;
		const dest = !event.shiftKey ? clone.getSnappedPosition(local) : local;
		preview.updateSource({ x: dest.x, y: dest.y });
		this.#placements[idx].x = preview.x;
		this.#placements[idx].y = preview.y;
		canvas.tokens.preview.children[this.#currentPlacement]?.refresh();
		requestAnimationFrame(() => (this.#throttle = false));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Rotate the token preview by 3Ëš increments when the mouse wheel is rotated.
	 * @param {Event} event - Triggering mouse event.
	 */
	#onRotatePlacement(event) {
		if (event.ctrlKey) event.preventDefault(); // Avoid zooming the browser window
		event.stopPropagation();
		const delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;
		const snap = event.shiftKey ? delta : 5;
		const preview = this.#previews[this.#currentPlacement];
		this.#placements[this.#currentPlacement].rotation += snap * Math.sign(event.deltaY);
		preview.updateSource({ rotation: this.#placements[this.#currentPlacement].rotation });
		canvas.tokens.preview.children[this.#currentPlacement]?.refresh();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Confirm placement when the left mouse button is clicked.
	 * @param {Event} event - Triggering mouse event.
	 */
	async #onConfirmPlacement(event) {
		await this.#finishPlacement(event);
		this.#events.resolve(this.#placements[this.#currentPlacement]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Skip placement when the right mouse button is clicked.
	 * @param {Event} event - Triggering mouse event.
	 */
	async #onSkipPlacement(event) {
		await this.#finishPlacement(event);
		this.#events.resolve(false);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Adjust the appended number on an unlinked token to account for multiple placements.
	 * @param {BlackFlagTokenDocument|object} tokenDocument - Document or data object to adjust.
	 * @param {PlacementData} placement - Placement data associated with this token document.
	 */
	static adjustAppendedNumber(tokenDocument, placement) {
		const regex = new RegExp(/\((\d+)\)$/);
		const match = tokenDocument.name?.match(regex);
		if (!match) return;
		const name = tokenDocument.name.replace(regex, `(${Number(match[1]) + placement.index.unique})`);
		if (tokenDocument instanceof TokenDocument) tokenDocument.updateSource({ name });
		else tokenDocument.name = name;
	}
}

/**
 * Configuration data for abilities.
 *
 * @typedef {object} AbilityConfiguration
 * @property {string} abbreviation - Shortened version of the ability used for conversion from dnd5e & other features.
 * @property {object} labels
 * @property {string} labels.full - Localization key for the ability's full name.
 * @property {string} labels.abbreviation - Localization key for the ability's abbreviation.
 * @property {string} [type] - Type of ability (usually "physical" or "mental").
 * @property {string} [reference] - UUID of a journal entry with details on this ability.
 */

/**
 * The set of Abilities used within the system.
 * @enum {AbilityConfiguration}
 */
const abilities = {
	strength: {
		abbreviation: "str",
		labels: {
			full: "BF.Ability.Strength.Label",
			abbreviation: "BF.Ability.Strength.Abbreviation"
		},
		type: "physical"
	},
	dexterity: {
		abbreviation: "dex",
		labels: {
			full: "BF.Ability.Dexterity.Label",
			abbreviation: "BF.Ability.Dexterity.Abbreviation"
		},
		type: "physical"
	},
	constitution: {
		abbreviation: "con",
		labels: {
			full: "BF.Ability.Constitution.Label",
			abbreviation: "BF.Ability.Constitution.Abbreviation"
		},
		type: "physical"
	},
	intelligence: {
		abbreviation: "int",
		labels: {
			full: "BF.Ability.Intelligence.Label",
			abbreviation: "BF.Ability.Intelligence.Abbreviation"
		},
		type: "mental"
	},
	wisdom: {
		abbreviation: "wis",
		labels: {
			full: "BF.Ability.Wisdom.Label",
			abbreviation: "BF.Ability.Wisdom.Abbreviation"
		},
		type: "mental"
	},
	charisma: {
		abbreviation: "cha",
		labels: {
			full: "BF.Ability.Charisma.Label",
			abbreviation: "BF.Ability.Charisma.Abbreviation"
		},
		type: "mental"
	}
};
localizeConfig(abilities, { labelKeyPath: "labels.full", sort: false });
localizeConfig(abilities, { labelKeyPath: "labels.abbreviation", propertyName: "localizedAbbreviations", sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for ability assignment methods.
 *
 * @typedef {object} AbilityAssignmentConfiguration
 * @property {string} abbreviation - Shortened version of the ability used for conversion from dnd5e & other features.
 * @property {object} labels
 * @property {string} labels.full - Localization key for the ability's full name.
 * @property {string} labels.abbreviation - Localization key for the ability's abbreviation.
 */

/**
 * Information on ability assignment.
 * @type {{
 *   methods: {[key: string]: AbilityAssignmentConfiguration},
 *   rolling: {{bonuses: number[], formula: string, max: number}},
 *   pointBuy: {points: number, costs: {[key: number]: number}}
 *   standardArray: {number[]}
 * }}
 */
const abilityAssignment = {
	methods: {
		rolling: {
			label: "BF.AbilityAssignment.Method.Rolling.Label",
			hint: "BF.AbilityAssignment.Method.Rolling.Hint",
			icon: "systems/black-flag/artwork/interface/ability-assignment-rolling.svg"
		},
		"point-buy": {
			label: "BF.AbilityAssignment.Method.PointBuy.Label",
			hint: "BF.AbilityAssignment.Method.PointBuy.Hint",
			icon: "systems/black-flag/artwork/interface/ability-assignment-point-buy.svg"
		},
		"standard-array": {
			label: "BF.AbilityAssignment.Method.StandardArray.Label",
			hint: "BF.AbilityAssignment.Method.StandardArray.Hint",
			icon: "systems/black-flag/artwork/interface/ability-assignment-standard-array.svg"
		}
	},
	rolling: {
		bonuses: [2, 1],
		formula: "4d6dl",
		max: 18
	},
	pointBuy: {
		points: 32,
		costs: {
			8: 0,
			9: 1,
			10: 2,
			11: 3,
			12: 4,
			13: 5,
			14: 7,
			15: 9,
			16: 11,
			17: 13,
			18: 16
		}
	},
	standardArray: [16, 14, 14, 13, 10, 8]
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Default abilities used throughout the system.
 * @enum {string}
 */
const defaultAbilities = {
	armor: "dexterity",
	hitPoints: "constitution",
	initiative: "dexterity",
	meleeAttack: "strength",
	rangedAttack: "dexterity"
};

var abilities$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	abilities: abilities,
	abilityAssignment: abilityAssignment,
	defaultAbilities: defaultAbilities
});

/**
 * Configuration for currencies.
 *
 * @typedef {object} CurrencyConfiguration
 * @property {string} label - Localizable name for the currency.
 * @property {string} abbreviation - Abbreviation of the unit.
 * @property {number} conversion - Multiplier used to convert between various units.
 * @property {boolean} [default] - Standard currency that should be displayed in the add menu on character sheets.
 */

/**
 * Currency denominations that can be used. Will be replaced upon registration load with registered currencies
 * if any exist. User defined currencies only need to be added to this list if they need to be available in the
 * "Add Currency" dialog on sheets, otherwise any currency item in a compendium is loaded.
 * @enum {CurrencyConfiguration}
 */
const currencies = {
	pp: {
		label: "BF.Currency.Denomination.Platinum.Label",
		abbreviation: "BF.Currency.Denomination.Platinum.Abbreviation",
		conversion: 0.1,
		default: true
	},
	gp: {
		label: "BF.Currency.Denomination.Gold.Label",
		abbreviation: "BF.Currency.Denomination.Gold.Abbreviation",
		conversion: 1,
		default: true
	},
	sp: {
		label: "BF.Currency.Denomination.Silver.Label",
		abbreviation: "BF.Currency.Denomination.Silver.Abbreviation",
		conversion: 10,
		default: true
	},
	cp: {
		label: "BF.Currency.Denomination.Copper.Label",
		abbreviation: "BF.Currency.Denomination.Copper.Abbreviation",
		conversion: 100,
		default: true
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configure currencies once registration is complete.
 */
Hooks.once("blackFlag.registrationComplete", function () {
	const currencies = CONFIG.BlackFlag.registration.list("currency") ?? {};
	if (foundry.utils.isEmpty(currencies)) return;
	for (const [abbreviation, { name: label, cached }] of Object.entries(currencies)) {
		CONFIG.BlackFlag.currencies[abbreviation] = foundry.utils.mergeObject(
			CONFIG.BlackFlag.currencies[abbreviation] ?? {},
			{
				label,
				abbreviation,
				conversion: cached.system.conversion.value,
				uuid: cached.uuid
			}
		);
	}
	for (const [key, config] of Object.entries(CONFIG.BlackFlag.currencies)) {
		if (!config.uuid) delete CONFIG.BlackFlag.currencies[key];
	}
	CONFIG.BlackFlag.currencies = sortObjectEntries(CONFIG.BlackFlag.currencies, {
		sortKey: "conversion",
		reverse: true
	});
});

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Handle a currency being created.
 */
Hooks.on("blackFlag.registrationCreated", function (identifier, item) {
	if (item.type !== "currency") return;
	CONFIG.BlackFlag.currencies[identifier] = {
		label: item.name,
		abbreviation: identifier,
		conversion: item.system.conversion.value
	};
	CONFIG.BlackFlag.currencies = sortObjectEntries(CONFIG.BlackFlag.currencies, {
		sortKey: "conversion",
		reverse: true
	});
});

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Handle a currency being updated.
 */
Hooks.on("blackFlag.registrationUpdated", function (identifier, item) {
	if (item.type !== "currency") return;
	const currency = CONFIG.BlackFlag.currencies[identifier];
	if (currency) {
		currency.label = item.name;
		currency.abbreviation = item.identifier;
		currency.conversion = item.system.conversion.value;
	}
	CONFIG.BlackFlag.currencies = sortObjectEntries(CONFIG.BlackFlag.currencies, {
		sortKey: "conversion",
		reverse: true
	});
});

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Handle a currency being deleted.
 */
Hooks.on("blackFlag.registrationDeleted", function (identifier, item) {
	if (item.type !== "currency") return;
	delete CONFIG.BlackFlag.currencies[identifier];
});

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration for system various units.
 *
 * @typedef {LocalizedConfiguration} UnitConfiguration
 * @property {string} abbreviation - Abbreviation of the unit.
 * @property {number} conversion - Multiplier used to convert between various units.
 * @property {string} [counted] - Localization path for counted plural forms. Only necessary if non-supported unit or
 *                                using a non-standard name for a supported unit.
 * @property {string} [formattingUnit] - Unit formatting value as supported by javascript's internationalization system:
 *                                       https://tc39.es/ecma402/#table-sanctioned-single-unit-identifiers. Only
 *                                       required if the formatting name doesn't match the unit key.
 * @property {string} [system] - Measurement system with which this unit is associated (e.g. imperial or metric).
 */

/**
 * Units that can be used for measuring distances.
 * @enum {UnitConfiguration}
 */
const distanceUnits = {
	foot: {
		label: "BF.UNITS.DISTANCE.Foot.Label",
		localization: "BF.Distance.Unit.Foot.Label",
		abbreviation: "BF.UNITS.DISTANCE.Foot.Abbreviation",
		conversion: 1,
		formattingUnit: "foot",
		system: "imperial"
	},
	mile: {
		label: "BF.UNITS.DISTANCE.Mile.Label",
		localization: "BF.Distance.Unit.Mile.Label",
		abbreviation: "BF.UNITS.DISTANCE.Mile.Abbreviation",
		conversion: 5280,
		formattingUnit: "mile",
		system: "imperial"
	}
};
localizeConfig(distanceUnits);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Units used to measure travel pace. Note that the formatting units here will automatically be appended with
 * the appropriate time period (e.g. `mile-per-hour` and `mile-per-day`) before being displayed.
 * @enum {UnitConfiguration}
 */
const paceUnits = {
	mph: {
		label: "BF.UNITS.PACE.MilePerHour.Label",
		abbreviation: "BF.UNITS.PACE.MilePerHour.Abbreviation",
		formattingUnit: "mile",
		conversion: 1,
		system: "imperial"
	}
};
localizeConfig(paceUnits);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Time periods usable by the system, split into combat periods and otherwise.
 * @type {{
 *   combat: {Record<string, UnitConfiguration>},
 *   time: {Record<string, UnitConfiguration>}
 * }}
 */
const timeUnits = {
	combat: {
		label: "BF.Time.Category.Combat.Label",
		scalar: true,
		children: {
			turn: {
				label: "BF.UNITS.TIME.Turn.Label",
				abbreviation: "BF.UNITS.TIME.Turn.Abbreviation",
				localization: "BF.Time.Unit.Turn.Label",
				counted: "BF.UNITS.TIME.Turn.Counted"
			},
			round: {
				label: "BF.UNITS.TIME.Round.Label",
				abbreviation: "BF.UNITS.TIME.Round.Abbreviation",
				localization: "BF.Time.Unit.Round.Label",
				counted: "BF.UNITS.TIME.Round.Counted",
				conversion: 6
			},
			encounter: {
				label: "BF.UNITS.TIME.Encounter.Label",
				abbreviation: "BF.UNITS.TIME.Encounter.Abbreviation",
				localization: "BF.Time.Unit.Encounter.Label",
				counted: "BF.UNITS.TIME.Encounter.Counted"
			}
		}
	},
	time: {
		label: "BF.Time.Category.Time.Label",
		scalar: true,
		children: {
			minute: {
				label: "BF.UNITS.TIME.Minute.Label",
				abbreviation: "BF.UNITS.TIME.Minute.Abbreviation",
				localization: "BF.Time.Unit.Minute.Label",
				conversion: 1
			},
			hour: {
				label: "BF.UNITS.TIME.Hour.Label",
				abbreviation: "BF.UNITS.TIME.Hour.Abbreviation",
				localization: "BF.Time.Unit.Hour.Label",
				conversion: 60
			},
			day: {
				label: "BF.UNITS.TIME.Day.Label",
				abbreviation: "BF.UNITS.TIME.Day.Abbreviation",
				localization: "BF.Time.Unit.Day.Label",
				conversion: 1_440
			},
			month: {
				label: "BF.UNITS.TIME.Month.Label",
				abbreviation: "BF.UNITS.TIME.Month.Abbreviation",
				localization: "BF.Time.Unit.Month.Label",
				conversion: 43_200
			},
			year: {
				label: "BF.UNITS.TIME.Year.Label",
				abbreviation: "BF.UNITS.TIME.Year.Abbreviation",
				localization: "BF.Time.Unit.Year.Label",
				conversion: 525_600
			}
		}
	}
};
localizeConfig(timeUnits, { flatten: true });
localizeConfig(timeUnits.time.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Units that can represent volume in the system.
 * @enum {UnitConfiguration}
 */
const volumeUnits = {
	cubicFoot: {
		label: "BF.UNITS.VOLUME.CubicFoot.Label",
		abbreviation: "BF.UNITS.VOLUME.CubicFoot.Abbreviation",
		counted: "BF.UNITS.VOLUME.CubicFoot.Counted",
		conversion: 1,
		system: "imperial"
	}
};
localizeConfig(volumeUnits);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Units that can represent weight in the system.
 * @enum {UnitConfiguration}
 */
const weightUnits = {
	pound: {
		label: "BF.UNITS.WEIGHT.Pound.Label",
		localization: "BF.Weight.Unit.Pound.Label",
		abbreviation: "BF.UNITS.WEIGHT.Pound.Abbreviation",
		conversion: 1,
		system: "imperial"
	},
	ounce: {
		label: "BF.UNITS.WEIGHT.Ounce.Label",
		localization: "BF.Weight.Unit.Ounce.Label",
		abbreviation: "BF.UNITS.WEIGHT.Ounce.Abbreviation",
		conversion: 0.0625,
		system: "imperial"
	},
	ton: {
		label: "BF.UNITS.WEIGHT.Ton.Label",
		localization: "BF.Weight.Unit.Ton.Label",
		abbreviation: "BF.UNITS.WEIGHT.Ton.Abbreviation",
		counted: "BF.UNITS.WEIGHT.Ton.Counted",
		conversion: 2_000,
		system: "imperial"
	}
};
localizeConfig(weightUnits);

var units = /*#__PURE__*/Object.freeze({
	__proto__: null,
	currencies: currencies,
	distanceUnits: distanceUnits,
	paceUnits: paceUnits,
	timeUnits: timeUnits,
	volumeUnits: volumeUnits,
	weightUnits: weightUnits
});

/**
 * Types of actions that can be used to activate features.
 * @enum {NestedTypeConfiguration}
 */
const actionTypes = {
	standard: {
		label: "BF.ACTIVATION.Category.Standard",
		children: {
			action: {
				localization: "BF.ACTIVATION.Type.Action"
			},
			bonus: {
				localization: "BF.ACTIVATION.Type.BonusAction"
			},
			reaction: {
				localization: "BF.ACTIVATION.Type.Reaction"
			},
			free: {
				localization: "BF.ACTIVATION.Type.FreeAction"
			}
		}
	},
	monster: {
		label: "BF.ACTIVATION.Category.Monster",
		children: {
			lair: {
				localization: "BF.ACTIVATION.Type.Lair"
			},
			legendary: {
				localization: "BF.ACTIVATION.Type.Legendary",
				scalar: true
			}
		}
	},
	combat: {
		label: "BF.ACTIVATION.Category.Combat",
		children: {
			encounter: {
				label: "BF.ACTIVATION.Type.Encounter"
			},
			roundStart: {
				label: "BF.ACTIVATION.Type.RoundStart"
			},
			roundEnd: {
				label: "BF.ACTIVATION.Type.RoundEnd"
			}
		}
	},
	rest: {
		label: "BF.ACTIVATION.Category.Rest",
		children: {
			short: {
				label: "BF.ACTIVATION.Type.ShortRest"
			},
			long: {
				label: "BF.ACTIVATION.Type.LongRest"
			}
		}
	}
};
localizeConfig(actionTypes, { flatten: true, keepCategories: false, pluralRule: "other", sort: false });
localizeConfig(actionTypes.standard.children);
localizeConfig(actionTypes.monster.children);
localizeConfig(actionTypes.combat.children);
localizeConfig(actionTypes.rest.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a list of activation options using a set of categories.
 * @param {object} [options={}]
 * @param {string[]} [options.categories] - Categories to include, or blank for all categories.
 * @param {string} [options.chosen] - Currently selected option.
 * @param {string[]} [options.pluralRule] - Pluralization rule to use with localization value.
 * @returns {SelectChoices}
 */
function activationOptions({ categories, chosen, pluralRule } = {}) {
	const time = { time: timeUnits.time };
	const selectChoices = _createOptions([actionTypes, time], { chosen, pluralRule });
	if (categories) selectChoices.exclude(new Set(categories));
	return selectChoices;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Non-scalar durations that can be used.
 * @enum {NestedTypeConfiguration}
 */
const durations = {
	perm: {
		label: "BF.DURATION.Type.Permanent",
		children: {
			destroyed: {
				label: "BF.DURATION.Value.UntilDestroyedDispelled",
				spellOnly: true
			},
			dispelled: {
				label: "BF.DURATION.Value.UntilDispelled",
				spellOnly: true
			},
			triggered: {
				label: "BF.DURATION.Value.UntilDispelledTriggered",
				spellOnly: true
			},
			permanent: {
				label: "BF.DURATION.Value.Permanent"
			}
		}
	},
	special: {
		label: "BF.DURATION.Type.Special",
		children: {
			instantaneous: {
				label: "BF.DURATION.Value.Instantaneous"
			},
			special: {
				label: "BF.DURATION.Value.Special"
			}
		}
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a list of duration options using a set of categories.
 * @param {object} [options={}]
 * @param {string[]} [options.categories] - Categories to include, or blank for all categories.
 * @param {string} [options.chosen] - Currently selected option.
 * @param {string[]} [options.pluralRule] - Pluralization rule to use with localization value.
 * @param {boolean} [options.isSpell] - Should spell-only durations be displayed?
 * @returns {SelectChoices}
 */
function durationOptions({ categories, chosen, pluralRule, isSpell } = {}) {
	const selectChoices = _createOptions([timeUnits, durations], { chosen, pluralRule, isSpell });
	if (categories) selectChoices.exclude(new Set(categories));
	return selectChoices;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a list of options using a set of categories.
 * @param {object[]} categories - Categories to use when generating the list.
 * @param {object} options
 * @param {string} [options.chosen] - Currently selected option.
 * @param {string[]} [options.pluralRule] - Pluralization rule to use with localization value.
 * @param {boolean} [options.isSpell] - Should spell-only durations be displayed?
 * @returns {SelectChoices}
 */
function _createOptions(categories, { chosen, pluralRule, isSpell }) {
	const selectChoices = new SelectChoices();
	categories.forEach(c => selectChoices.merge(new SelectChoices(c)));
	for (const [key, category] of Object.entries(selectChoices)) {
		category.label = makeLabel(category, { pluralRule });
		category.scalar = category.scalar;
		for (const [k, v] of Object.entries(category.children)) {
			v.label = makeLabel(v, { pluralRule });
			v.scalar ??= category.scalar || v.scalar;
			v.chosen = k === chosen;
			if (v.spellOnly && !isSpell) delete category.children[k];
		}
	}
	return selectChoices;
}

var activation = /*#__PURE__*/Object.freeze({
	__proto__: null,
	actionTypes: actionTypes,
	activationOptions: activationOptions,
	durationOptions: durationOptions,
	durations: durations
});

/**
 * @typedef {BasicRollConfigurationDialogOptions} AttackRollConfigurationDialogOptions
 * @property {FormSelectOption[]} ammunitionOptions - Ammunition that can be used with the attack.
 * @property {FormSelectOption[]} attackModes - Options for the attack mode.
 * @property {Function} buildConfig - Method for re-building roll after configuration changes.
 */

/**
 * Roll configuration dialog for Attack Rolls.
 *
 * @param {AttackRollProcessConfiguration} [config={}] - Initial roll configuration.
 * @param {BasicRollMessageConfiguration} [message={}] - Message configuration.
 * @param {AttackRollConfigurationDialogOptions} [options={}] - Dialog rendering options.
 */
class AttackRollConfigurationDialog extends ChallengeRollConfigurationDialog {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _prepareConfigurationContext(context, options) {
		context = await super._prepareConfigurationContext(context, options);
		if (this.options.attackModes?.length)
			context.fields.unshift({
				field: new foundry.data.fields.StringField({ label: game.i18n.localize("BF.ATTACK.Mode.Label") }),
				name: "attackMode",
				options: this.options.attackModes,
				value: this.config.attackMode
			});
		if (this.options.ammunitionOptions?.length)
			context.fields.unshift({
				field: new foundry.data.fields.StringField({ label: game.i18n.localize("BF.Item.Type.Ammunition[one]") }),
				name: "ammunition",
				options: [{ value: "", label: "" }, ...this.options.ammunitionOptions],
				value: this.config.ammunition
			});
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Roll Handling            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_buildConfig(config, formData, index) {
		config = super._buildConfig(config, formData, index);
		if (!this.options.buildConfig) return config;

		const { rollConfig, rollNotes } = this.options.buildConfig(this.config, config, formData, index);
		this.notes = rollNotes;
		return rollConfig;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_handleFormChanges(formData) {
		super._handleFormChanges(formData);
		if (formData.has("ammunition")) this.config.ammunition = formData.get("ammunition");
		if (formData.has("attackMode")) this.config.attackMode = formData.get("attackMode");
	}
}

const { BooleanField: BooleanField$h, EmbeddedDataField: EmbeddedDataField$2, NumberField: NumberField$z, SchemaField: SchemaField$S, SetField: SetField$p, StringField: StringField$Q } = foundry.data.fields;

/**
 * Field for storing damage data.
 */
class DamageField extends EmbeddedDataField$2 {
	constructor({ simple = false, ...options } = {}) {
		super(simple ? SimpleDamageData : ExtendedDamageData, { label: "BF.DAMAGE.Label", ...options });
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Simple version of damage data used in weapons with just the die count, denomination, and damage type.
 *
 * @property {number} number - Number of dice to roll.
 * @property {number} denomination - Die denomination to roll.
 * @property {string} type - Damage type.
 * @property {Set<string>} additionalTypes - If damage type is "variable", damage types that can be chosen.
 */
class SimpleDamageData extends foundry.abstract.DataModel {
	/** @override */
	static defineSchema() {
		return {
			number: new NumberField$z({ min: 0, integer: true, label: "BF.Die.Number.Label" }),
			denomination: new NumberField$z({ min: 0, integer: true, label: "BF.Die.Denomination.Label" }),
			type: new StringField$Q({ label: "BF.DAMAGE.Type.Label" }),
			additionalTypes: new SetField$p(new StringField$Q(), { required: false })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Formula for this damage.
	 * @type {string}
	 */
	get formula() {
		return this.number && this.denomination ? `${this.number}d${this.denomination}` : "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Scale the damage by a certain amount using its built-in scaling configuration.
	 * @param {number|Scaling} increase - Number of steps above base damage to scale.
	 * @returns {string}
	 */
	scaledFormula(increase) {
		return this.formula;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Extended version of damage data used in activities with support for bonuses, custom formulas, and scaling.
 *
 * @property {string} bonus - Bonus added to the damage.
 * @property {object} custom
 * @property {boolean} custom.enabled - Should the custom formula be used?
 * @property {string} custom.formula - Custom damage formula.
 * @property {object} scaling
 * @property {string} scaling.mode - How the damage scales in relation with levels.
 * @property {number} scaling.number - Number of dice to add per scaling level.
 * @property {string} scaling.formula - Arbitrary scaling formula which will be multiplied by scaling increase.
 */
class ExtendedDamageData extends SimpleDamageData {
	/** @override */
	static defineSchema() {
		return {
			...super.defineSchema(),
			bonus: new FormulaField({ label: "BF.DAMAGE.Bonus.Label" }),
			custom: new SchemaField$S(
				{
					enabled: new BooleanField$h(),
					formula: new FormulaField({ label: "BF.Formula.Custom.Label" })
				},
				{ required: false }
				// TODO: Figure out why "required: false" is needed here to avoid issues with HealingActivity
			),
			scaling: new SchemaField$S(
				{
					mode: new StringField$Q({ label: "BF.DAMAGE.Scaling.Mode.Label" }),
					number: new NumberField$z({ initial: 1, min: 0, integer: true, label: "BF.DAMAGE.Scaling.Dice.Label" }),
					formula: new FormulaField()
				},
				{ required: false }
			)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get formula() {
		if (this.custom?.enabled) return this.custom?.formula ?? "";
		const formula = super.formula;
		return formula ? (this.bonus ? `${formula} + ${this.bonus}` : formula) : this.bonus;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	scaledFormula(increase) {
		if (increase instanceof Scaling) increase = increase.increase;

		let formula = this.formula;
		switch (this.scaling?.mode) {
			case "whole":
				break;
			case "half":
				increase = Math.floor(increase * 0.5);
				break;
			default:
				return formula;
		}
		if (!increase) return formula;

		// If dice count scaling, increase the count on the first die rolled
		if (this.scaling?.number) {
			if (this.custom?.enabled) {
				formula = formula.replace(/^(\d)+d/, (match, number) => `${Number(number) + this.scaling.number * increase}d`);
			} else if (this.denomination) {
				formula = `${this.number + this.scaling.number * increase}d${this.denomination}`;
				if (this.bonus) formula = `${formula} + ${this.bonus}`;
			}
		}

		// If custom scaling included, modify to match increase and append for formula
		if (this.scaling?.formula) {
			let roll = new Roll(this.scaling.formula);
			roll = roll.alter(increase, 0, { multiplyNumeric: true });
			formula = formula ? `${formula} + ${roll.formula}` : roll.formula;
		}

		return formula;
	}
}

const { DocumentIdField: DocumentIdField$8, SchemaField: SchemaField$R } = foundry.data.fields;

/**
 * Data for effects that can be applied.
 *
 * @typedef {object} EffectApplicationData
 * @property {string} _id  ID of the effect to apply.
 */

/**
 * Field for storing an active effects applied by an activity.
 *
 * @property {string} _id  ID of the effect to apply.
 */
class AppliedEffectField extends SchemaField$R {
	constructor(fields = {}, options = {}) {
		super(
			{
				_id: new DocumentIdField$8(),
				...fields
			},
			options
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	initialize(value, model, options = {}) {
		const obj = super.initialize(value, model, options);
		const item = model.parent.item;

		Object.defineProperty(obj, "effect", {
			get() {
				return item?.effects.get(this._id);
			},
			configurable: true
		});

		return obj;
	}
}

const { ArrayField: ArrayField$m, BooleanField: BooleanField$g, NumberField: NumberField$y, SchemaField: SchemaField$Q, StringField: StringField$P } = foundry.data.fields;

/**
 * Configuration data for the attack activity.
 *
 * @property {object} attack
 * @property {string} attack.ability - Ability used with the attack if not automatically calculated.
 * @property {string} attack.bonus - Bonus added to the attack to hit.
 * @property {object} attack.critical
 * @property {number} attack.critical.threshold - Minimum value on the challenge die to roll a critical hit.
 * @property {boolean} attack.flat - Should only the bonus be used for calculating to hit?
 * @property {object} attack.type
 * @property {string} attack.type.value - Is this a melee or ranged attack?
 * @property {string} attack.type.classification - Is this a weapon or spell attack?
 * @property {object} damage
 * @property {object} damage.critical
 * @property {string} damage.critical.bonus - Extra damage applied when a critical is rolled, added to the base damage
 *                                            or the first damage part.
 * @property {boolean} damage.includeBase - Should a item's base damage be included with any other damage parts?
 * @property {ExtendedDamageData[]} damage.parts - Parts of damage to include.
 * @property {EffectApplicationData[]} effects - Effects to be applied.
 */
class AttackData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.DAMAGE", "BF.ATTACK"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			attack: new SchemaField$Q({
				ability: new StringField$P(),
				bonus: new FormulaField(),
				critical: new SchemaField$Q({
					threshold: new NumberField$y()
				}),
				flat: new BooleanField$g(),
				type: new SchemaField$Q({
					value: new StringField$P(),
					classification: new StringField$P()
				})
			}),
			damage: new SchemaField$Q({
				critical: new SchemaField$Q({
					bonus: new FormulaField()
				}),
				includeBase: new BooleanField$g({ initial: true }),
				parts: new ArrayField$m(new DamageField())
				// TODO: Add conditions support to damage parts
			}),
			effects: new ArrayField$m(new AppliedEffectField())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Proficiency to include with the attack roll.
	 * @type {Proficiency|null}
	 */
	get attackProficiency() {
		const ability = this.actor?.system.abilities?.[this.ability];
		if (ability?.proficient === true) return null;
		return this.item.system.proficiency?.hasProficiency ? this.item.system.proficiency ?? null : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Abilities that could potentially be used with this attack.
	 * @type {Set<string>}
	 */
	get availableAbilities() {
		if (this.item.system.availableAbilities) return this.item.system.availableAbilities;
		if (this.attack.type.classification === "spell")
			return new Set(
				[
					this.actor?.system.spellcasting?.ability,
					...Object.values(this.actor?.system.spellcasting?.origins ?? {}).map(o => o.ability)
				].filter(a => a)
			);

		const melee = CONFIG.BlackFlag.defaultAbilities.meleeAttack;
		const ranged = CONFIG.BlackFlag.defaultAbilities.rangedAttack;
		if (this.actor?.type === "npc") return new Set([melee, ranged]);
		return new Set([this.attack.type.value === "ranged" ? ranged : melee]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return a string describing the result if the default ability is selected for this activity.
	 * @type {string|null}
	 */
	get defaultAbility() {
		if (this.attack.type.classification === "spell") return game.i18n.localize("BF.Spellcasting.Label");

		const labels = CONFIG.BlackFlag.abilities.localized;
		const available = this.availableAbilities;
		if (available?.size)
			return Array.from(available)
				.map(a => labels[a])
				.join("/");

		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		// Added in ???
		if (foundry.utils.getType(source.damage?.parts) === "Array") {
			source.damage.parts.forEach(p => BaseActivity._migrateCustomDamageFormula(p));
		}
		// Added in 0.10.042
		if ("ability" in source) foundry.utils.setProperty(source, "attack.ability", source.ability);
		if ("type" in source) {
			if ("value" in source.type) foundry.utils.setProperty(source, "attack.type.value", source.type.value);
			if ("classification" in source.type) {
				foundry.utils.setProperty(source, "attack.type.classification", source.type.classification);
			}
		}
		if ("damage" in source) {
			if ("includeBaseDamage" in source.damage) {
				foundry.utils.setProperty(source, "damage.includeBase", source.damage.includeBaseDamage);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		this.applyShims();
		this.parent.setProperty("system.attack.type.value", "system.type.value");
		this.parent.setProperty("system.attack.type.classification", "system.type.classification");
		this.attack.type.value ??= "melee";
		this.attack.type.classification ??= "weapon";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		if (this.damage.includeBase && this.item.system.damage?.base?.formula) {
			const basePart = this.item.system.damage.base.clone();
			basePart.base = true;
			basePart.locked = true;
			this.damage.parts.unshift(basePart);
		}

		Object.defineProperty(this, "toHit", {
			value: this.parent.getAttackDetails().formula,
			configurable: true,
			enumerable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Shims                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add shims for removed properties.
	 */
	applyShims() {
		Object.defineProperty(this, "type", {
			get() {
				foundry.utils.logCompatibilityWarning("The `type` properties on `AttackData` has been moved to `attack.type`", {
					since: "Black Flag 0.10.042",
					until: "Black Flag 0.10.047"
				});
				return this.attack.type;
			},
			configurable: true
		});
		Object.defineProperty(this.damage, "includeBaseDamage", {
			get() {
				foundry.utils.logCompatibilityWarning(
					"The `damage.includeBaseDamage` property on `AttackData` has been moved to `damage.includeBase`",
					{ since: "Black Flag 0.10.042", until: "Black Flag 0.10.047" }
				);
				return this.damage.includeBase;
			},
			configurable: true
		});
	}
}

/**
 * Activity for rolling attacks and damage.
 */
class AttackActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "attack",
				dataModel: AttackData,
				icon: "systems/black-flag/artwork/activities/attack.svg",
				title: "BF.ATTACK.Label",
				hint: "BF.ATTACK.Hint",
				usage: {
					actions: {
						rollAttack: AttackActivity.#rollAttack,
						rollDamage: AttackActivity.#rollDamage
					}
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get ability() {
		if (this.system.attack.ability === "none") return null;
		if (this.system.attack.ability) return this.system.attack.ability;
		if (this.item.system.ability) return this.item.system.ability;
		const availableAbilities = this.system.availableAbilities;
		const abilities = this.actor?.system.abilities ?? {};
		return availableAbilities.reduce(
			(largest, ability) =>
				(abilities[ability]?.mod ?? -Infinity) > (abilities[largest]?.mod ?? -Infinity) ? ability : largest,
			availableAbilities.first()
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Ability used to make attack rolls for this activity.
	 * @type {string|null}
	 */
	get attackAbility() {
		foundry.utils.logCompatibilityWarning(
			"The `attackAbility` property on `AttackActivity` has been moved to `ability`",
			{ since: "Black Flag 0.10.042", until: "Black Flag 0.10.047" }
		);
		return this.system.ability;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contents of the challenge column in the action table.
	 * @type {string}
	 */
	get challengeColumn() {
		const layout = document.createElement("div");
		layout.classList.add("layout");
		layout.innerHTML = numberFormat(this.system.toHit, { sign: true });
		return layout.outerHTML;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get hasDamage() {
		return super.hasDamage || (this.system.damage.includeBase && !!this.item.system.damage?.base?.formula);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get modifierData() {
		return {
			type: "attack",
			kind: "attack",
			ability: this.ability,
			...super.modifierData
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_activationChatButtons() {
		const buttons = [
			{
				label: game.i18n.localize("BF.ATTACK.Label"),
				icon: '<i class="blackFlag-icon" data-src="systems/black-flag/artwork/traits/weapons.svg" inert></i>',
				dataset: {
					action: "rollAttack"
				}
			}
		];
		if (this.hasDamage)
			buttons.push({
				label: game.i18n.localize("BF.DAMAGE.Label"),
				icon: '<i class="fa-solid fa-burst" inert></i>',
				dataset: {
					action: "rollDamage"
				}
			});
		return buttons.concat(super._activationChatButtons());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _triggerSubsequentActions(config, results) {
		this.rollAttack(
			{ event: config.event },
			{},
			{ data: { "flags.black-flag.originatingMessage": results.message?.id } }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Rolls                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {ChallengeRollProcessConfiguration} AttackRollProcessConfiguration
	 * @property {string} attackMode - Method used for the attack (e.g. "oneHanded", "twoHanded", "offhand", "thrown").
	 */

	/**
	 * @typedef {ChallengeRollDialogConfiguration} AttackRollDialogConfiguration
	 * @property {AttackRollConfigurationDialogOptions} [options] - Configuration options.
	 */

	/**
	 * @typedef {object} AmmunitionUpdate
	 * @property {string} id        ID of the ammunition item to update.
	 * @property {boolean} destroy  Will the ammunition item be deleted?
	 * @property {number} quantity  New quantity after the ammunition is spent.
	 */

	/**
	 * Roll an attack.
	 * @param {AttackRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {AttackRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollAttack(config = {}, dialog = {}, message = {}) {
		if (!this.item.isEmbedded || this.item.pack) return;

		const targets = getTargetDescriptors();
		const flagKey = `relationship.last.${this.id}`;

		let ammunitionOptions;
		if (this.item.system.properties?.has("ammunition") && this.actor)
			ammunitionOptions = this.actor.items
				.filter(
					i =>
						i.type === "ammunition" &&
						(!this.item.system.ammunition?.type || i.system.type.category === this.item.system.ammunition?.type)
				)
				.map(i => ({
					value: i.id,
					label: `${i.name} (${numberFormat(i.system.quantity)})`,
					disabled: !i.system.quantity
				}))
				.sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));

		const prepareAttackRoll = (process, rollConfig, formData, index) => {
			const { parts, data } = this.getAttackDetails(process);
			if (rollConfig.data?.situational) {
				parts.push("@situational");
				data.situational = rollConfig.data.situational;
			}

			const modifierData = foundry.utils.mergeObject(this.modifierData, {
				attackMode: process.attackMode
			});

			const threshold = Math.min(
				this.actor?.system.mergeModifiers?.(this.actor?.system.getModifiers?.(modifierData, "critical-threshold"), {
					mode: "smallest",
					rollData: data
				}) ?? Infinity,
				this.system.attack.critical.threshold ?? Infinity
			);

			foundry.utils.mergeObject(rollConfig, {
				data,
				parts,
				options: {
					minimum: this.actor?.system.buildMinimum?.(this.actor?.system.getModifiers?.(modifierData, "min"), {
						rollData: data
					})
				}
			});
			if (Number.isFinite(threshold)) rollConfig.options.criticalSuccess = threshold;
			if (targets.length === 1) rollConfig.options.target = targets[0].ac;

			return { rollConfig, rollNotes: this.actor?.system.getModifiers?.(modifierData, "note") };
		};

		const useAmmo = config.ammunition !== false && ammunitionOptions?.length;
		const rollConfig = foundry.utils.mergeObject(
			{
				ammunition: useAmmo
					? this.item.getFlag(game.system.id, `${flagKey}.ammunition`) ?? ammunitionOptions[0].value
					: undefined,
				attackMode: this.item.getFlag(game.system.id, `${flagKey}.attackMode`) ?? this.item.system.attackModes[0]?.value
			},
			config
		);
		const { rollConfig: roll, rollNotes } = prepareAttackRoll(rollConfig, {});
		rollConfig.subject = this;
		rollConfig.rolls = [roll].concat(config.rolls ?? []);

		const dialogConfig = foundry.utils.mergeObject(
			{
				applicationClass: AttackRollConfigurationDialog,
				options: {
					ammunitionOptions: rollConfig.ammunition !== false ? ammunitionOptions : undefined,
					attackModes: this.item.system.attackModes,
					buildConfig: prepareAttackRoll,
					rollNotes,
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type: this.name })
				}
			},
			dialog
		);

		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${this.name}: ${this.item.actor?.name ?? ""}`,
					flavor: this.name,
					speaker: ChatMessage.getSpeaker({ actor: this.item.actor }),
					flags: {
						[game.system.id]: {
							...this.messageFlags,
							messageType: "roll",
							roll: { type: "attack" },
							targets
						}
					}
				},
				preCreate: (rolls, config, message) => {
					let attackMode = config.attackMode;
					const modes = this.item.system.attackModes;
					if (modes.length && !attackMode) attackMode = modes[0].value;
					if (attackMode) {
						rollConfig.attackMode = attackMode;
						foundry.utils.setProperty(message, `data.flags.${game.system.id}.roll.attackMode`, attackMode);
						if (attackMode in CONFIG.BlackFlag.attackModes)
							message.data.flavor = `${message.data.flavor} (${CONFIG.BlackFlag.attackModes.localized[
								attackMode
							].toLowerCase()})`;
					}
					rollConfig.ammunition = config.ammunition;
					if (config.ammunition) {
						foundry.utils.setProperty(message, `data.flags.${game.system.id}.roll.ammunition`, config.ammunition);
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before an attack is rolled.
		 * @function blackFlag.preRollAttack
		 * @memberof hookEvents
		 * @param {AttackRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {AttackRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollAttack", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);
		if (!rolls?.length) return;

		const flags = {};
		const ammo = this.actor?.items.get(rollConfig.ammunition);
		let ammoUpdate = null;
		if (ammo) {
			ammoUpdate = { id: ammo.id, quantity: Math.max(0, ammo.system.quantity - 1) };
			flags.ammunition = ammo.id;
		}
		if (rollConfig.attackMode) flags.attackMode = rollConfig.attackMode;
		if (!foundry.utils.isEmpty(flags) && this.actor.items.has(this.item.id)) {
			await this.item.setFlag(game.system.id, flagKey, flags);
		}

		/**
		 * A hook event that fires after an attack has been rolled, but before ammunition is updated.
		 * @function blackFlag.rollAttack
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} [data]
		 * @param {AmmunitionUpdate|null} [data.ammoUpdate] - Any updates related to ammo consumption for the attack.
		 * @param {Activity} [data.subject] - Activity for which the roll was performed.
		 */
		Hooks.callAll("blackFlag.rollAttack", rolls, { ammoUpdate, subject: this });

		if (ammoUpdate)
			await this.actor?.updateEmbeddedDocuments("Item", [
				{ _id: ammoUpdate.id, "system.quantity": ammoUpdate.quantity }
			]);

		/**
		 * A hook event that fires after an attack has been rolled.
		 * @function blackFlag.postRollAttack
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} [data]
		 * @param {Activity} [data.subject] - Activity for which the roll was performed.
		 */
		Hooks.callAll("blackFlag.postRollAttack", rolls, { subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing an attack roll.
	 * @this {AttackActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static #rollAttack(event, target, message) {
		this.rollAttack({ event });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing a damage roll.
	 * @this {AttackActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static #rollDamage(event, target, message) {
		const lastAttack = message.getAssociatedRolls("attack").pop();
		const attackMode = lastAttack?.getFlag(game.system.id, "roll.attackMode");

		// Fetch ammunition used with last attack roll
		let ammunition;
		const actor = lastAttack?.getAssociatedActor();
		if (actor) ammunition = actor.items.get(lastAttack.getFlag(game.system.id, "roll.ammunition"));

		this.rollDamage({ ammunition, attackMode, event });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Attack details for this activity.
	 * @param {Partial<AttackRollProcessConfiguration>} [config={}] - Attack roll configuration.
	 * @returns {{parts: string[], data: object, formula: string, activity: Activity}|null}
	 */
	getAttackDetails(config = {}) {
		const ability = this.actor?.system.abilities?.[this.ability];
		const ammunition = this.actor?.items.get(config.ammunition);
		const rollData = this.item.getRollData();
		const { parts, data } = buildRoll(
			this.system.attack.flat
				? { toHit: this.system.attack.bonus }
				: {
						mod: ability?.adjustedMod ?? ability?.mod,
						prof: this.system.attackProficiency?.term,
						bonus: this.system.attack.bonus,
						weaponMagic: this.item.system.attackMagicalBonus,
						ammoMagic: ammunition?.system.attackMagicalBonus,
						actorBonus: this.actor?.system.buildBonus?.(this.actor?.system.getModifiers?.(this.modifierData), {
							rollData
						})
					},
			rollData
		);
		return {
			activity: this,
			data,
			formula: simplifyFormula(Roll.replaceFormulaData(parts.join(" + "), data), { deterministic: true }),
			parts
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {AttackDamageRollProcessConfiguration} [config={}]
	 * @property {BlackFlagItem} ammunition                               Ammunition used with the attack.
	 * @property {"oneHanded"|"twoHanded"|"offhand"|"thrown"} attackMode  Attack mode.
	 */

	/**
	 * Get the roll parts used to create the damage rolls.
	 * @param {Partial<AttackDamageRollProcessConfiguration>} [config={}]
	 * @returns {AttackDamageRollProcessConfiguration}
	 */
	getDamageConfig(config = {}) {
		const rollConfig = super.getDamageConfig(config);

		// Handle ammunition
		const ammo = config.ammunition?.system;
		if (ammo) {
			// TODO: Set magical property on damage parts once supported

			// Add the ammunition's damage
			if (ammo.damage.base.formula) {
				const basePartIndex = rollConfig.rolls.findIndex(i => i.base);
				const damage = ammo.damage.base.clone(ammo.damage.base);
				const rollData = this.getRollData();

				// If mode is "replace" and base part is present, replace the base part
				if (ammo.damage.replace && basePartIndex !== -1) {
					damage.base = true;
					const index = basePartIndex;
					rollConfig.rolls.splice(index, 1, this._processDamagePart(damage, config, rollData, { index }));
				}

				// Otherwise stick the ammo damage after base part (or as first part)
				else {
					damage.ammo = true;
					const index = basePartIndex + 1;
					rollConfig.rolls.splice(index, 0, this._processDamagePart(damage, rollConfig, rollData, { index }));
				}
			}
		}

		if (this.system.damage.critical.bonus) {
			rollConfig.critical ??= {};
			rollConfig.critical.bonusDamage ??= this.system.damage.critical.bonus;
		}

		return rollConfig;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_processDamagePart(damage, rollConfig, rollData, { modifierData = {}, ...config } = {}) {
		if (!damage.base) return super._processDamagePart(damage, rollConfig, rollData, { ...config, modifierData });

		// Swap base damage for versatile if two-handed attack is made on versatile weapon
		if (this.item.system.properties?.has("versatile") && rollConfig.attackMode === "twoHanded") {
			damage = this.item.system.versatileDamage ?? damage;
		}

		const roll = super._processDamagePart(damage, rollConfig, rollData, {
			...config,
			modifierData: { ...modifierData, baseDamage: true }
		});
		roll.base = true;

		if (this.item.type === "weapon") {
			// Add `@mod` unless it is an off-hand attack with a positive modifier
			if (!["offhand", "thrownOffhand"].includes(rollConfig.attackMode) || roll.data.mode < 0) roll.parts.push("@mod");

			// Add magical bonus
			if (this.item.system.damageMagicalBonus) {
				roll.data.weaponMagic = this.item.system.damageMagicalBonus;
				roll.parts.push("@weaponMagic");
			}

			// Add ammunition bonus
			const ammo = rollConfig.ammunition?.system;
			if (ammo?.damageMagicalBonus) {
				roll.data.ammoMagic = ammo.damageMagicalBonus;
				roll.parts.push("@ammoMagic");
			}
		}

		foundry.utils.setProperty(
			roll,
			"options.critical.bonusDice",
			this.actor?.system.mergeModifiers?.(this.actor?.system.getModifiers?.(roll.modifierData, "critical-dice"), {
				deterministic: true,
				rollData
			})
		);

		return roll;
	}
}

const { ArrayField: ArrayField$l, BooleanField: BooleanField$f, SchemaField: SchemaField$P, SetField: SetField$o, StringField: StringField$O } = foundry.data.fields;

/**
 * Configuration data for the check activity.
 *
 * @property {object} check
 * @property {string} check.ability - Ability used with the check.
 * @property {Set<string>} check.associated - Skills, tools, or vehicles that can contribute to the check.
 * @property {object} check.dc
 * @property {string} check.dc.calculation - Method or ability used to calculate the difficulty class of the check.
 * @property {string} check.dc.formula - Custom DC formula or flat value.
 * @property {boolean} check.visible - Should the check rolls be visible to all players?
 * @property {EffectApplicationData[]} effects - Effects to be applied.
 */
class CheckData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.CHECK"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			check: new SchemaField$P({
				ability: new StringField$O(),
				associated: new SetField$o(new StringField$O()),
				dc: new SchemaField$P({
					calculation: new StringField$O(),
					formula: new FormulaField({ deterministic: true })
				}),
				visible: new BooleanField$f({ initial: true })
			}),
			effects: new ArrayField$l(new AppliedEffectField())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return a string describing the result if the default ability is selected for this activity.
	 * @type {string|null}
	 */
	get defaultAbility() {
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		const rollData = this.getRollData({ deterministic: true });
		super.prepareFinalData();

		if (this.check.ability === "spellcasting") this.check.ability = this.spellcastingAbility;

		let ability;
		if (this.check.dc.calculation) ability = this.ability;
		else this.check.dc.value = simplifyBonus(this.check.dc.formula, rollData);
		if (ability)
			this.check.dc.value =
				this.actor?.system.abilities?.[ability]?.dc ?? 8 + (this.actor?.system.attributes?.prof ?? 0);

		if (!this.check.dc.value) this.check.dc.value = null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the ability to use with an associated value.
	 * @param {string} associated - Skill, tool, or vehicle key.
	 * @returns {string|null} - Ability to use, if found.
	 */
	getAbility(associated) {
		if (this.check.ability) return this.check.ability;
		const source =
			this.actor?.system.proficiencies?.skills?.[associated] ??
			this.actor?.system.proficiencies?.tools?.[associated] ??
			this.actor?.system.proficiencies?.vehicles?.[associated];
		if (source?.ability) return source?.ability;
		if (associated in CONFIG.BlackFlag.skills) return CONFIG.BlackFlag.skills[associated].ability;
		return null;
	}
}

class CheckActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "check",
				dataModel: CheckData,
				icon: "systems/black-flag/artwork/activities/check.svg",
				title: "BF.CHECK.Title",
				hint: "BF.CHECK.Hint",
				usage: {
					actions: {
						rollCheck: CheckActivity.#rollCheck
					}
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_activationChatButtons() {
		const buttons = [];
		const dc = this.system.check.dc.value;

		const SKILLS = CONFIG.BlackFlag.skills.localized;
		const TOOLS = CONFIG.BlackFlag.tools.localized;
		const VEHICLES = CONFIG.BlackFlag.vehicles.localizedPlural;

		const createButton = (abilityKey, associated) => {
			const ability = CONFIG.BlackFlag.abilities.localized[abilityKey];
			const checkType =
				associated in SKILLS ? "skill" : associated in TOOLS ? "tool" : associated in VEHICLES ? "vehicle" : "ability";
			const dataset = {
				ability: abilityKey,
				action: "rollCheck",
				visibility: this.system.check.visible ? "all" : undefined
			};
			if (dc) dataset.dc = dc;
			if (checkType !== "ability") dataset[checkType] = associated;

			let label = ability;
			let type;
			if (checkType === "skill") type = SKILLS[associated];
			else if (checkType === "tool") type = TOOLS[associated];
			else if (checkType === "vehicle") type = VEHICLES[associated];
			if (type) label = game.i18n.format("BF.Enricher.Check.Specific", { ability, type });

			buttons.push({
				label: dc
					? `
					<span class="visible-dc">${game.i18n.format("BF.Enricher.DC.Phrase", { dc, check: wrap(label) })}</span>
					<span class="hidden-dc">${wrap(label)}</span>
				`
					: wrap(label),
				icon:
					checkType === "tool"
						? '<i class="fa-solid fa-hammer" inert></i>'
						: '<i class="blackFlag-icon" data-src="systems/black-flag/artwork/activities/check.svg" inert></i>',
				dataset
			});
		};
		const wrap = check => game.i18n.format("BF.Enricher.Check.Short", { check });

		const associated = Array.from(this.system.check.associated);
		if (!associated.length && this.item.type === "tool") associated.push(this.item.system.type.base);
		if (associated.length)
			associated.forEach(a => {
				// TODO: Allow rolling without proper ability
				const ability = this.system.getAbility(a);
				if (ability) createButton(ability, a);
			});
		else if (this.system.check.ability) createButton(this.system.check.ability);

		return buttons.concat(super._activationChatButtons());
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing a check.
	 * @this {CheckActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static async #rollCheck(event, target, message) {
		const targets = this.getActionTargets();
		if (!targets.length) return; // TODO: Display UI warning here
		let { ability, dc, skill, tool, vehicle } = target.dataset;
		dc = parseInt(dc);
		const rollConfig = { ability, event, target: Number.isFinite(dc) ? dc : this.system.check.dc.value };
		const dialogConfig = {};
		const messageConfig = { data: {} };

		for (const token of targets) {
			messageConfig.data.speaker = ChatMessage.getSpeaker({ scene: canvas.scene, token: token.document });
			if (skill) {
				await token.actor.rollSkill({ ...rollConfig, skill }, dialogConfig, messageConfig);
			} else if (tool) {
				await token.actor.rollTool({ ...rollConfig, tool }, dialogConfig, messageConfig);
			} else if (vehicle) {
				await token.actor.rollVehicle({ ...rollConfig, vehicle }, dialogConfig, messageConfig);
			} else {
				await token.actor.rollAbilityCheck(rollConfig, dialogConfig, messageConfig);
			}
		}
	}
}

const { ArrayField: ArrayField$k, BooleanField: BooleanField$e, SchemaField: SchemaField$O } = foundry.data.fields;

/**
 * Configuration data for the damage activity.
 *
 * @property {object} damage
 * @property {object} damage.critical
 * @property {boolean} damage.critical.allow - Can critical damage be rolled?
 * @property {string} damage.critical.bonus - Extra damage applied to the first damage part when a critical is rolled.
 * @property {ExtendedDamageData[]} damage.parts - Parts of damage to include.
 * @property {EffectApplicationData[]} effects - Effects to be applied.
 */
class DamageData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.DAMAGE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			damage: new SchemaField$O({
				critical: new SchemaField$O({
					allow: new BooleanField$e(),
					bonus: new FormulaField()
				}),
				parts: new ArrayField$k(new DamageField())
			}),
			effects: new ArrayField$k(new AppliedEffectField())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		// Added in 0.10.042
		if ("damage" in source) {
			if ("allowCritical" in source.damage) {
				foundry.utils.setProperty(source, "damage.critical.allow", source.damage.allowCritical);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		this.applyShims();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Shims                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add shims for removed properties.
	 */
	applyShims() {
		Object.defineProperty(this.damage, "allowCritical", {
			get() {
				foundry.utils.logCompatibilityWarning(
					"The `damage.allowCritical` property on `DamageData` has been moved to `damage.critical.allow`",
					{ since: "Black Flag 0.10.042", until: "Black Flag 0.10.047" }
				);
				return this.damage.critical.allow;
			},
			configurable: true
		});
	}
}

/**
 * Activity for rolling damage.
 */
class DamageActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "damage",
				dataModel: DamageData,
				icon: "systems/black-flag/artwork/activities/damage.svg",
				title: "BF.DAMAGE.Label",
				hint: "BF.DAMAGE.Hint",
				usage: {
					actions: {
						rollDamage: DamageActivity.#rollDamage
					}
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_activationChatButtons() {
		const buttons = [];
		if (this.hasDamage)
			buttons.push({
				label: game.i18n.localize("BF.DAMAGE.Label"),
				icon: '<i class="fa-solid fa-burst" inert></i>',
				dataset: {
					action: "rollDamage"
				}
			});
		return buttons.concat(super._activationChatButtons());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _triggerSubsequentActions(config, results) {
		this.rollDamage(
			{ event: config.event },
			{},
			{ data: { "flags.black-flag.originatingMessage": results.message?.id } }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing a damage roll.
	 * @this {DamageActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static #rollDamage(event, target, message) {
		this.rollDamage({ event });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getDamageConfig(config = {}) {
		const rollConfig = super.getDamageConfig(config);

		rollConfig.critical ??= {};
		rollConfig.critical.allow ??= this.system.damage.critical.allow;
		rollConfig.critical.bonusDamage ??= this.system.damage.critical.bonus;

		return rollConfig;
	}
}

const { DocumentIdField: DocumentIdField$7, SchemaField: SchemaField$N } = foundry.data.fields;

/**
 * Configuration data for the Forward activity.
 * @property {object} linked
 * @property {string} linked.id  ID of the activity to forward to.
 */
class ForwardData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.FORWARD"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			linked: new SchemaField$N({
				id: new DocumentIdField$7()
			})
		};
	}
}

/**
 * Activity for triggering another activity with alternate consumption.
 */
class ForwardActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "forward",
				dataModel: ForwardData,
				icon: "systems/black-flag/artwork/activities/forward.svg",
				title: "BF.FORWARD.Title",
				hint: "BF.FORWARD.Hint"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async activate(usage = {}, dialog = {}, message = {}) {
		const activationConfig = foundry.utils.mergeObject(
			{
				cause: {
					activity: this.relativeUUID
				},
				consume: {
					resources: false,
					spellSlot: false
				}
			},
			usage
		);

		const activity = this.item.system.activities.get(this.system.linked.id);
		if (!activity) ui.notifications.error("BF.FORWARD.Warning.NoActivity", { localize: true });
		return activity?.activate(activationConfig, dialog, message);
	}
}

/**
 * Special case StringField that includes automatic validation for identifiers.
 */
class IdentifierField extends foundry.data.fields.StringField {
	static get _defaults() {
		return foundry.utils.mergeObject(super._defaults, {
			label: "BF.Identifier.Label",
			hint: "BF.Identiifer.Hint"
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_validateType(value) {
		if (!isValidIdentifier(value)) {
			throw new Error(game.i18n.localize("BF.Identifier.Error.Invalid"));
		}
	}
}

const { DocumentIdField: DocumentIdField$6, FilePathField, NumberField: NumberField$x, ObjectField: ObjectField$3, SchemaField: SchemaField$M, StringField: StringField$N } = foundry.data.fields;

/**
 * Base data model for advancement.
 */
class BaseAdvancement extends foundry.abstract.DataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.Advancement"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Base type information for an advancement.
	 *
	 * @typedef {PseudoDocumentsMetadata} BaseAdvancementMetadata
	 * @property {string} type - Type of the advancement.
	 */

	/**
	 * @type {BaseAdvancementMetadata}
	 */
	static metadata = Object.freeze({
		name: "Advancement",
		collection: "advancement",
		label: "BF.Advancement.Label",
		type: "base"
	});

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Name of this advancement type that will be stored in config and used for lookups.
	 * @type {string}
	 * @protected
	 */
	static get typeName() {
		return this.metadata.type ?? this.name.replace(/Advancement$/, "");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	static defineSchema() {
		return {
			_id: new DocumentIdField$6({ initial: () => foundry.utils.randomID() }),
			configuration: new TypeField(
				{
					modelLookup: type => this.metadata.dataModels?.configuration ?? null
				},
				{ required: true }
			),
			flags: new MappingField(new ObjectField$3()),
			hint: new StringField$N(),
			icon: new FilePathField({ categories: ["IMAGE"], base64: false }),
			identifier: new IdentifierField(),
			level: new SchemaField$M({
				value: new NumberField$x({ integer: true, initial: this.metadata?.multiLevel ? undefined : null, min: 0 }),
				classIdentifier: new IdentifierField(),
				classRestriction: new StringField$N({ choices: ["original", "multiclass"] })
			}),
			title: new StringField$N(),
			type: new StringField$N({
				required: true,
				readOnly: true,
				initial: this.typeName,
				validate: v => v === this.typeName,
				validationError: `must be the same as the Advancement type name ${this.typeName}`
			})
		};
	}
}

/**
 * Field that automatically prepares advancements in an {@link AdvancementCollection}.
 */
class AdvancementField extends MappingField {
	constructor(options) {
		super(
			new TypeField({
				determineType: value => value?.type,
				modelLookup: type => CONFIG.Advancement.types[type]?.documentClass ?? null
			}),
			options
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static hierarchical = true;
	// TODO: Rework this to be more like EmbeddedCollection

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	initialize(value, model, options) {
		return new AdvancementCollection(model, super.initialize(value, model, options));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	migrateSource(sourceData, fieldData) {
		for (const value of Object.values(fieldData ?? {})) {
			this.model.migrateSource(sourceData, value);
		}
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Specialized collection type for retrieving advancement pseudo-documents.
 * @param {DataModel} model - The parent DataModel to which this AdvancementCollection belongs.
 * @param {Advancement[]} entries - Initialized advancement pseudo-documents.
 */
class AdvancementCollection extends Collection {
	constructor(model, entries) {
		super();
		this.#model = model;
		for (const [id, entry] of Object.entries(entries)) {
			if (!(entry instanceof BaseAdvancement)) continue;
			this.set(id, entry);
			if (!this.#types.has(entry.type)) this.#types.set(entry.type, []);
			this.#types.get(entry.type).push(entry);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The parent DataModel to which this AdvancementCollection instance belongs.
	 * @type {DataModel}
	 * @private
	 */
	#model;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Pre-filtered arrays of advancements per-type.
	 * @type {Map<string, Advancement[]>}
	 * @private
	 */
	#types = new Map();

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Cached store of advancements by level.
	 * @type {Map<string, Advancement[]>}
	 * @private
	 */
	#_levels;

	/**
	 * Pre-filtered and -sorted arrays of advancements per-level.
	 * @type {Map<string, Advancement[]>}
	 * @private
	 */
	get #levels() {
		if (!this.#_levels) {
			this.#_levels = new Map();
			for (const advancement of this) {
				for (const level of advancement.levels) {
					if (!this.#_levels.has(level)) this.#_levels.set(level, []);
					this.#_levels.get(level).push(advancement);
				}
			}
			for (let [level, data] of this.#_levels.entries()) {
				const levelData = { character: Number(level), class: Number(level) };
				data.sort((a, b) => a.sortingValueForLevel(levelData).localeCompare(b.sortingValueForLevel(levelData)));
			}
		}
		return this.#_levels;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Levels represented by the advancements in this collection.
	 * @type {number[]}
	 */
	get levels() {
		return Array.from(this.#levels.keys()).map(l => Number(l));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Cached store of like advancement types.
	 * @type {Map<string, string[]>}
	 * @private
	 */
	static #_like;

	/**
	 * Relationship between base types and types like them.
	 * @type {Map<string, string[]>}
	 * @private
	 */
	static get #like() {
		if (!this.#_like) {
			this.#_like = new Map();
			for (const [type, config] of Object.entries(CONFIG.Advancement.types)) {
				const like = config.documentClass?.metadata?.like;
				if (like) {
					if (!this.#_like.has(like)) this.#_like.set(like, []);
					this.#_like.get(like).push(type);
				}
			}
		}
		return this.#_like;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return array of advancements filtered by the provided type.
	 * @param {string} type
	 * @returns {Advancement[]}
	 */
	byType(type) {
		return [
			...(this.#types.get(type) ?? []),
			...(this.constructor.#like.get(type) ?? []).flatMap(t => this.#types.get(t) ?? [])
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return array of advancements filtered by level.
	 * @param {number} level
	 * @returns {Advancement[]}
	 */
	byLevel(level) {
		return this.#levels.get(level) ?? [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Convert the AdvancementCollection to an array of simple objects.
	 * @param {boolean} [source=true] - Draw data for contained Documents from the underlying data source?
	 * @returns {object[]} - The extracted array of primitive objects.
	 */
	toObject(source = true) {
		return this.map(doc => doc.toObject(source));
	}
}

/**
 * Data field that selects the appropriate advancement value data model if available, otherwise defaults to generic
 * `ObjectField` to prevent issues with custom types that aren't currently loaded.
 */
class AdvancementValueField extends foundry.data.fields.ObjectField {
	initialize(value, model, options = {}) {
		const obj = foundry.utils.deepClone(value);
		for (const [itemID, values] of Object.entries(obj)) {
			const item = model.parent?.items?.get(itemID);
			if (!item) continue;
			for (const [advancementID, advancementValue] of Object.entries(values ?? {})) {
				const advancement = item.system.advancement?.get(advancementID);
				const dataModel = advancement?.metadata.dataModels?.value;
				if (!dataModel) continue;
				obj[itemID][advancementID] = new dataModel(advancementValue, { parent: model, ...options });
			}
		}
		return obj;
	}
}

const { ArrayField: ArrayField$j, SetField: SetField$n, StringField: StringField$M } = foundry.data.fields;

/**
 * Field for storing proficiency.
 * @param {object} fields - Additional fields to add, or set a value to `false` to remove a default fields.
 * @param {object} options - Options that will be merged with default options.
 */
class CreatureTypeField extends foundry.data.fields.SchemaField {
	constructor(fields = {}, options = {}) {
		fields = {
			value: new StringField$M({ initial: "humanoid", label: "BF.CreatureType.Type.Label" }),
			tags: new SetField$n(new StringField$M(), { label: "BF.CreatureType.Tag.Label" }),
			custom: new ArrayField$j(new StringField$M(), { label: "BF.CreatureType.Custom.Label" }),
			swarm: new StringField$M({ label: "BF.CreatureType.Swarm.Label", hint: "BF.CreatureType.Swarm.Hint" }),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, { label: "BF.CreatureType.Label", ...options });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	initialize(value, model, options = {}) {
		const obj = super.initialize(value, model, options);

		Object.defineProperty(obj, "label", {
			get() {
				if (!this.value) return game.i18n.localize("None");
				const key = CONFIG.BlackFlag.creatureTypes[this.value]?.localization;
				let type = game.i18n.localize(`${key}[${this.swarm ? "other" : "one"}]`);
				if (this.swarm)
					type = game.i18n.format("BF.CreatureType.Swarm.Phrase", {
						size: game.i18n.localize(CONFIG.BlackFlag.sizes[this.swarm].label),
						type
					});
				const tags = [...Array.from(this.tags).map(t => CONFIG.BlackFlag.creatureTags.localized[t]), ...this.custom]
					.filter(t => t)
					.map(t => t.toLowerCase());
				if (tags.length) type += ` (${game.i18n.getListFormatter({ style: "short" }).format(tags)})`;
				return type;
			},
			enumerable: false
		});
		Object.defineProperty(obj, "config", {
			get() {
				return {
					label: CONFIG.BlackFlag.creatureTypes.localized[obj.value],
					plural: CONFIG.BlackFlag.creatureTypes.localizedPlural[obj.value]
				};
			}
		});

		return obj;
	}
}

/**
 * Field that stores one or more filtering operators.
 */
class FilterField extends foundry.data.fields.ArrayField {
	constructor(options) {
		super(new foundry.data.fields.ObjectField(), options);
	}
}

/**
 * @typedef {object} Modifier
 * @property {string} type - Type of modifier (e.g. "bonus", "min", "critical-dice", "critical-threshold", "note").
 * @property {FilterDescription[]} filter - Filter used to limit when this modifier is used.
 * @property {string} [formula] - If relevant, a formula.
 * @property {object} [note]
 * @property {number} [note.rollMode] - For "note" modifiers, which roll mode should be applied.
 * @property {string} [note.text] - For "note" modifiers, what note will be displayed during rolling.
 */

/**
 * Field that represents a set of actor modifiers.
 */
class ModifierField extends foundry.data.fields.ArrayField {
	constructor(options) {
		super(
			new foundry.data.fields.SchemaField({
				type: new foundry.data.fields.StringField(),
				filter: new FilterField(),
				formula: new FormulaField({ required: false, initial: undefined }),
				note: new foundry.data.fields.SchemaField(
					{
						rollMode: new foundry.data.fields.NumberField(),
						text: new foundry.data.fields.HTMLField()
					},
					{ required: false, initial: undefined }
				)
			}),
			options
		);
	}
}

const { NumberField: NumberField$w, StringField: StringField$L } = foundry.data.fields;

/**
 * Field for storing proficiency.
 */
class ProficiencyField extends foundry.data.fields.SchemaField {
	constructor(fields = {}, options = {}) {
		fields = {
			multiplier: new NumberField$w({ min: 0, max: 2, initial: 0, step: 0.5, label: "BF.Proficiency.Multiplier" }),
			rounding: new StringField$L({ initial: "down", choices: ["down", "up"], label: "BF.Proficiency.Rounding" }),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, { label: "BF.Proficiency.Label[one]", ...options });
	}
}

/**
 * Field that stores rolls as serialized JSON.
 */
class RollField extends foundry.data.fields.JSONField {
	initialize(value, model, options = {}) {
		value = super.initialize(value, model, options);
		return value ? Roll.fromData(value) : value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	toObject(value) {
		if (value instanceof Roll) value = value.toJSON();
		return super.toObject(value);
	}
}

const { SchemaField: SchemaField$L, StringField: StringField$K } = foundry.data.fields;

/**
 * @typedef {object} SourceData
 * @property {string} book - ID of the book in which this document originated.
 * @property {string} fallback - Localized fallback name if the ID isn't found in config.
 * @property {string} page - Page or section in which this document can be found.
 */

/**
 * Field for storing information about an actor or item's source book.
 *
 * @param {object} [fields={}] - Additional fields to add or, if value is `false`, default fields to remove.
 * @param {object} [options={}] - Additional options in addition to the default label.
 */
class SourceField extends SchemaField$L {
	constructor(fields = {}, options = {}) {
		fields = {
			book: new StringField$K(),
			fallback: new StringField$K(),
			page: new StringField$K(),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the source label.
	 * @this {SourceData}
	 * @param {string} uuid - Compendium source or document UUID.
	 */
	static prepareData(uuid) {
		const pkg = SourceField.getPackage(uuid);
		this.bookPlaceholder = SourceField.getModuleBook(pkg) ?? "";
		if (!this.book) this.book = this.bookPlaceholder;

		if (this.fallback) this.label = this.fallback;
		else {
			const page = Number.isNumeric(this.page)
				? game.i18n.format("BF.SOURCE.Display.Page", { page: this.page })
				: this.page ?? "";
			this.label = game.i18n.format("BF.SOURCE.Display.Full", { book: this.book, page }).trim();
		}

		this.value = this.book || (pkg?.title ?? "");
		this.slug = this.value.slugify({ strict: true });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Check if the provided package has any source books registered in its manifest. If it has only one, then return
	 * that book's key.
	 * @param {ClientPackage} pck - The package.
	 * @returns {string|null}
	 */
	static getModuleBook(pck) {
		if (!pck) return null;
		const sourceBooks = pck.flags?.[game.system.id]?.sourceBooks;
		const keys = Object.keys(sourceBooks ?? {});
		if (keys.length !== 1) return null;
		return keys[0];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get the package associated with the given UUID, if any.
	 * @param {string} uuid - The UUID.
	 * @returns {ClientPackage|null}
	 */
	static getPackage(uuid) {
		const pack = foundry.utils.parseUuid(uuid)?.collection?.metadata;
		switch (pack?.packageType) {
			case "module":
				return game.modules.get(pack.packageName);
			case "system":
				return game.system;
			case "world":
				return game.world;
		}
		return null;
	}
}

/**
 * Field for storing client and server time.
 */
class TimeField extends foundry.data.fields.SchemaField {
	constructor(options) {
		super(
			{
				client: new foundry.data.fields.NumberField({ initial: () => Date.now() }),
				world: new foundry.data.fields.NumberField({ initial: () => game.time.worldTime })
			},
			options
		);
	}
}

/**
 * Monkey-patch existing `DataField` types with active effect application methods. This is a temporary patch until
 * https://github.com/foundryvtt/foundryvtt/issues/6631 is implemented.
 */
function applyEffectApplicationPatches() {
	// Note: OVERRIDE and CUSTOM are always supported modes, _bfSupportedModes defines other modes that can be used
	const MODES = CONST.ACTIVE_EFFECT_MODES;
	const ALL = [MODES.MULTIPLY, MODES.ADD, MODES.DOWNGRADE, MODES.UPGRADE];

	foundry.data.fields.ArrayField._bfSupportedModes = [MODES.ADD];
	foundry.data.fields.BooleanField._bfSupportedModes = ALL;
	foundry.data.fields.DocumentIdField._bfSupportedModes = [];
	foundry.data.fields.FilePathField._bfSupportedModes = [];
	foundry.data.fields.NumberField._bfSupportedModes = ALL;
	foundry.data.fields.StringField._bfSupportedModes = [MODES.ADD];
}

var _module$g = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActivationField: ActivationField,
	ActivityCollection: ActivityCollection,
	ActivityField: ActivityField,
	AdvancementCollection: AdvancementCollection,
	AdvancementField: AdvancementField,
	AdvancementValueField: AdvancementValueField,
	CreatureTypeField: CreatureTypeField,
	DamageField: DamageField,
	ExtendedDamageData: ExtendedDamageData,
	FilterField: FilterField,
	FormulaField: FormulaField,
	IdentifierField: IdentifierField,
	LocalDocumentField: LocalDocumentField,
	MappingField: MappingField,
	ModifierField: ModifierField,
	ProficiencyField: ProficiencyField,
	RangeField: RangeField,
	RollField: RollField,
	SimpleDamageData: SimpleDamageData,
	SourceField: SourceField,
	TargetField: TargetField,
	TimeField: TimeField,
	TypeField: TypeField,
	UsesField: UsesField,
	applyEffectApplicationPatches: applyEffectApplicationPatches
});

const { ArrayField: ArrayField$i } = foundry.data.fields;

/**
 * Configuration data for the Heal activity.
 * @property {EffectApplicationData[]} effects - Effects to be applied.
 * @property {ExtendedDamageData} healing - Healing value.
 */
class HealData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.HEAL"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			effects: new ArrayField$i(new AppliedEffectField()),
			healing: new DamageField({ initial: { type: "normal" } })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return a string describing the result if the default ability is selected for this activity.
	 * @type {string|null}
	 */
	get defaultAbility() {
		if (this.isSpell) return game.i18n.localize("BF.Spellcasting.Label");
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		if ("healing" in source) BaseActivity._migrateCustomDamageFormula(source.healing);
	}
}

/**
 * Activity for performing healing.
 */
class HealActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "heal",
				dataModel: HealData,
				icon: "systems/black-flag/artwork/activities/heal.svg",
				title: "BF.HEAL.Title",
				hint: "BF.HEAL.Hint",
				usage: {
					actions: {
						rollHealing: HealActivity.#rollHealing
					}
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get ability() {
		if (this.system.ability) return this.system.ability;
		return super.ability;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get damageFlavor() {
		return game.i18n.localize("BF.Healing.Label");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get hasDamage() {
		return this.system.healing?.formula;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get modifierData() {
		return {
			kind: "heal",
			...super.modifierData
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_activationChatButtons() {
		const buttons = [];
		if (this.system.healing?.formula) {
			const config = CONFIG.BlackFlag.healingTypes[this.system.healing.type];
			buttons.push({
				label: game.i18n.localize("BF.HEAL.Title"),
				icon: config?.icon ? `<i class="blackFlag-icon" data-src="${config.icon}" inert></i>` : null,
				dataset: {
					action: "rollHealing"
				}
			});
		}
		return buttons.concat(super._activationChatButtons());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _triggerSubsequentActions(config, results) {
		this.rollDamage(
			{ event: config.event },
			{},
			{ [`data.flags.${game.system.id}.originatingMessage`]: results.message?.id }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Rolls                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async rollDamage(config = {}, dialog = {}, message = {}) {
		const messageConfig = foundry.utils.mergeObject(
			{
				[`data.flags.${game.system.id}.roll.type`]: "healing"
			},
			message
		);
		return super.rollDamage(config, dialog, messageConfig);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing a healing roll.
	 * @this {HealActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static #rollHealing(event, target, message) {
		this.rollDamage({ event });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getDamageConfig(config = {}) {
		if (!this.hasDamage) return foundry.utils.mergeObject({ rolls: [] }, config);

		const rollConfig = foundry.utils.mergeObject({ critical: { allow: false } }, config);
		const rollData = this.getRollData();
		rollConfig.rolls = [
			this._processDamagePart(this.system.healing, rollConfig, rollData, { modifierData: { type: "healing" } })
		].concat(config.rolls ?? []);

		return rollConfig;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Healing formula and activity.
	 * @param {object} [options={}] - Additional options that might affect fetched data.
	 * @returns {{rolls: DamageRollConfiguration[], activity: Activity}|null}
	 */
	getDamageDetails(options = {}) {
		return { rolls: this.getDamageConfig().rolls, activity: this };
	}
}

const { ArrayField: ArrayField$h, SchemaField: SchemaField$K, SetField: SetField$m, StringField: StringField$J } = foundry.data.fields;

/**
 * Configuration data for the save activity.
 *
 * @property {object} damage
 * @property {ExtendedDamageData[]} damage.parts - Parts of damage to include.
 * @property {EffectApplicationData[]} effects - Effects to be applied.
 * @property {object} save
 * @property {string} save.ability - Abilities required when rolling a saving throw.
 * @property {object} save.dc
 * @property {string} save.dc.ability - Ability used to calculate the DC if not automatically calculated.
 * @property {string} save.dc.formula - DC formula if manually set.
 */
class SaveData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SAVE", "BF.DAMAGE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			damage: new SchemaField$K({ parts: new ArrayField$h(new DamageField()) }),
			effects: new ArrayField$h(new AppliedEffectField()),
			save: new SchemaField$K({
				ability: new SetField$m(new StringField$J()),
				dc: new SchemaField$K({
					ability: new StringField$J(),
					formula: new FormulaField({ deterministic: true })
				})
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Return a string describing the result if the default ability is selected for this activity.
	 * @type {string|null}
	 */
	get defaultAbility() {
		if (this.isSpell) return game.i18n.localize("BF.Spellcasting.Label");
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		// Added in ???
		if (foundry.utils.getType(source.damage?.parts) === "Array") {
			source.damage.parts.forEach(p => BaseActivity._migrateCustomDamageFormula(p));
		}

		// Added in 0.10.046
		if (!("save" in source)) {
			if ("ability" in source && !foundry.utils.hasProperty(source, "save.ability")) {
				foundry.utils.setProperty(source, "save.ability", source.ability);
			}
			if ("dc" in source) {
				if ("value" in source.dc && !foundry.utils.hasProperty(source, "save.dc.ability")) {
					foundry.utils.setProperty(source, "save.dc.ability", source.dc.ability);
				}
				if ("formula" in source.dc && !foundry.utils.hasProperty(source, "save.dc.formula")) {
					foundry.utils.setProperty(source, "save.dc.formula", source.dc.formula);
				}
			}
		}

		// Added in 0.10.049
		if (foundry.utils.getType(source.save?.ability) === "string") {
			if (source.save.ability) source.save.ability = [source.save.ability];
			else source.save.ability = [];
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		this.applyShims();
		if (!this.isSpell && !this.save.dc.ability) this.save.dc.ability = "custom";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		const rollData = this.getRollData({ deterministic: true });
		if (this.save.dc.ability === "custom") this.save.dc.final = simplifyBonus(this.save.dc.formula, rollData);
		else if (this.actor?.system.spellcasting?.dc && !this.save.dc.ability) {
			if (this.isSpell && this.item.system.associatedClass) {
				this.save.dc.final = this.actor.system.spellcasting.origins[this.item.system.associatedClass.identifier]?.dc;
			} else {
				this.save.dc.final = this.actor.system.spellcasting.dc;
			}
		} else this.save.dc.final = rollData.abilities?.[this.parent.dcAbility]?.dc;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Shims                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add shims for removed properties.
	 */
	applyShims() {
		Object.defineProperty(this, "dc", {
			get() {
				foundry.utils.logCompatibilityWarning("The `dc` properties on `SaveData` has been moved to `save.dc`", {
					since: "Black Flag 0.10.046",
					until: "Black Flag 0.10.051"
				});
				return this.save.dc;
			},
			configurable: true
		});
	}
}

/**
 * Activity for making saving throws and rolling damage.
 */
class SaveActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "save",
				dataModel: SaveData,
				icon: "systems/black-flag/artwork/activities/save.svg",
				title: "BF.SAVE.Title",
				hint: "BF.SAVE.Hint",
				usage: {
					actions: {
						rollDamage: SaveActivity.#rollDamage,
						rollSave: SaveActivity.#rollSave
					}
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contents of the challenge column in the action table.
	 * @type {string}
	 */
	get challengeColumn() {
		if (!this.system.save.dc.final) return "";
		const layout = document.createElement("div");
		layout.classList.add("layout");
		layout.innerHTML = `<span class="dc">${numberFormat(this.system.save.dc.final)}</span>`;
		const abilities = Array.from(this.system.save.ability).map(
			k => CONFIG.BlackFlag.abilities.localizedAbbreviations[k]
		);
		if (abilities.length)
			layout.innerHTML += `<span class="ability">${game.i18n
				.getListFormatter({ style: "narrow" })
				.format(abilities)}</span>`;
		return layout.outerHTML;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Ability used to determine the DC of this ability.
	 * @type {string|null}
	 */
	get dcAbility() {
		if (this.system.save.dc.ability === "custom") return null;
		if (this.system.save.dc.ability && this.system.save.dc.ability !== "spellcasting") {
			return this.system.save.dc.ability;
		}

		let ability = this.item.system.ability;
		if (!ability && this.actor && (this.isSpell || this.system.save.dc.ability === "spellcasting")) {
			const abilities = Object.values(this.actor.system.spellcasting?.origins ?? {}).reduce((set, o) => {
				set.add(o.ability);
				return set;
			}, new Set());
			ability = this.actor.system.selectBestAbility?.(abilities);
		}
		return ability ?? (this.isSpell ? "intelligence" : null);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get modifierData() {
		return {
			kind: "save",
			...super.modifierData
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_activationChatButtons() {
		const buttons = [];

		const makeButton = abilityId => {
			const ability = CONFIG.BlackFlag.abilities.localizedAbbreviations[abilityId] ?? "";
			const dc = game.i18n.format("BF.Enricher.DC.Phrase", { dc: this.system.save.dc.final, check: ability });
			buttons.push({
				label: `
					<span class="visible-dc">${game.i18n.format("BF.Enricher.Save.Long", { save: dc })}</span>
					<span class="hidden-dc">${game.i18n.format("BF.Enricher.Save.Long", { save: ability })}</span>
				`,
				icon: '<i class="fa-solid fa-shield-heart" inert></i>',
				dataset: {
					dc: this.system.save.dc.final,
					ability: abilityId,
					action: "rollSave",
					visibility: "all"
				}
			});
		};
		this.system.save.ability.forEach(a => makeButton(a));
		if (!this.system.save.ability.size) makeButton();

		if (this.hasDamage)
			buttons.push({
				label: game.i18n.localize("BF.DAMAGE.Label"),
				icon: '<i class="fa-solid fa-burst" inert></i>',
				dataset: {
					action: "rollDamage"
				}
			});

		return buttons.concat(super._activationChatButtons());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display an activation chat message for this activity.
	 * @param {ActivityMessageConfiguration} message - Configuration info for the created message.
	 * @returns {Promise<ChatMessage|ActivityMessageConfiguration>}
	 */
	async createActivationMessage(message = {}) {
		const messageConfig = foundry.utils.mergeObject(
			{
				"data.flags.black-flag.save": {
					dc: this.system.save.dc.final
				}
			},
			message
		);

		return super.createActivationMessage(messageConfig);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing a damage roll.
	 * @this {SaveActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static #rollDamage(event, target, message) {
		this.rollDamage({ event });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle performing an saving throw.
	 * @this {SaveActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static async #rollSave(event, target, message) {
		const targets = this.getActionTargets();
		if (!targets.length) return; // TODO: Display UI warning here
		const dc = parseInt(target.dataset.dc);
		for (const token of targets) {
			const speaker = ChatMessage.getSpeaker({ scene: canvas.scene, token: token.document });
			await token.actor.rollAbilitySave(
				{
					ability: target.dataset.ability ?? this.system.save.ability.first(),
					event,
					target: Number.isFinite(dc) ? dc : this.system.save.dc.final
				},
				{
					data: { speaker }
				}
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getDamageConfig(config = {}) {
		const rollConfig = super.getDamageConfig(config);

		rollConfig.critical ??= {};
		rollConfig.critical.allow ??= false;

		return rollConfig;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Save ability, dc, and activity for the default save this item might have.
	 * @param {object} [options={}] - Additional options that might affect fetched data.
	 * @returns {{ability: string, dc: string, activity: Activity}|null}
	 */
	getSaveDetails(options = {}) {
		const rollData = this.item.getRollData({ deterministic: true });
		const ability = rollData.abilities?.[this.dcAbility];
		if (ability) rollData.mod = ability.mod;
		const dc =
			this.system.save.dc.ability === "custom" ? simplifyBonus(this.system.save.dc.formula, rollData) : ability?.dc;
		return { ability: this.system.save.ability, dc, activity: this };
	}
}

const { ArrayField: ArrayField$g, BooleanField: BooleanField$d, DocumentIdField: DocumentIdField$5, NumberField: NumberField$v, SchemaField: SchemaField$J, SetField: SetField$l, StringField: StringField$I } =
	foundry.data.fields;

/**
 * Information for a single summoned creature.
 *
 * @typedef {object} SummonsProfile
 * @property {string} _id         Unique ID for this profile.
 * @property {string} count       Formula for the number of creatures to summon.
 * @property {string} cr          Formula for the CR of summoned creatures if in CR mode.
 * @property {object} level
 * @property {number} level.min   Minimum level at which this profile can be used.
 * @property {number} level.max   Maximum level at which this profile can be used.
 * @property {string} name        Display name for this profile if it differs from actor's name.
 * @property {Set<string>} types  Types of summoned creatures if in CR mode.
 * @property {string} uuid        UUID of the actor to summon if in default mode.
 */

/**
 * Configuration data for the Summon activity.
 *
 * @property {object} bonuses
 * @property {string} bonuses.ac - Formula for armor class bonus on summoned actor.
 * @property {string} bonuses.hp - Formula for bonus hit points to add to each summoned actor.
 * @property {string} bonuses.attackDamage - Formula for bonus added to damage for attacks.
 * @property {string} bonuses.saveDamage - Formula for bonus added to damage for saving throws.
 * @property {string} bonuses.healing - Formula for bonus added to healing.
 * @property {Set<string>} creatureSizes - Set of creature sizes that will be set on summoned creature.
 * @property {Set<string>} creatureTypes - Set of creature types that will be set on summoned creature.
 * @property {EffectApplicationData[]} effects - Effects to be applied to summoned creature.
 * @property {object} match
 * @property {boolean} match.attacks - Match the to hit values on summoned actor's attack to the summoner.
 * @property {boolean} match.proficiency - Match proficiency on summoned actor to the summoner.
 * @property {boolean} match.saves - Match the save DC on summoned actor's abilities to the summoner.
 * @property {SummonsProfile[]} profiles - Information on creatures that can be summoned.
 * @property {object} summon
 * @property {string} summon.identifier - Class identifier that will be used to determine applicable level.
 * @property {""|"cr"} summon.mode - Method of determining what type of creature is summoned.
 * @property {boolean} summon.prompt - Should the player be prompted to place the summons?
 */
class SummonData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SUMMON"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			bonuses: new SchemaField$J({
				ac: new FormulaField(),
				hp: new FormulaField(),
				attackDamage: new FormulaField(),
				saveDamage: new FormulaField(),
				healing: new FormulaField()
			}),
			creatureSizes: new SetField$l(new StringField$I()),
			creatureTypes: new SetField$l(new StringField$I()),
			effects: new ArrayField$g(new AppliedEffectField()),
			match: new SchemaField$J({
				attacks: new BooleanField$d(),
				proficiency: new BooleanField$d(),
				saves: new BooleanField$d()
			}),
			profiles: new ArrayField$g(
				new SchemaField$J({
					_id: new DocumentIdField$5({ initial: () => foundry.utils.randomID() }),
					count: new FormulaField(),
					cr: new FormulaField({ deterministic: true }),
					level: new SchemaField$J({
						min: new NumberField$v({ integer: true, min: 0 }),
						max: new NumberField$v({ integer: true, min: 0 })
					}),
					name: new StringField$I(),
					types: new SetField$l(new StringField$I()),
					uuid: new StringField$I()
				})
			),
			summon: new SchemaField$J({
				identifier: new IdentifierField(),
				mode: new StringField$I(),
				prompt: new BooleanField$d({ initial: true })
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static localize() {
		super.localize();
		localizeSchema(this.schema.fields.profiles.element, ["BF.SUMMON.FIELDS.profiles"]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get applicableEffects() {
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Summons that can be performed based on character or class level or spell circle.
	 * @type {SummonsProfile[]}
	 */
	get availableProfiles() {
		const level = this.relevantLevel;
		return this.profiles.filter(e => (e.level.min ?? -Infinity) <= level && level <= (e.level.max ?? Infinity));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine the level used to determine profile limits, based on the spell circle for spells or either the
	 * character or class level, depending on whether `classIdentifier` is set.
	 * @type {number}
	 */
	get relevantLevel() {
		const keyPath =
			this.item.type === "spell" && this.item.system.circle.base > 0
				? "item.circle.base"
				: this.summon.identifier
					? `progression.classes.${this.summon.identifier}.levels`
					: "details.level";
		return foundry.utils.getProperty(this.getRollData(), keyPath) ?? 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Creatures summoned by this activity.
	 * @type {BlackFlagActor[]}
	 */
	get summonedCreatures() {
		if (!this.actor) return [];
		return BlackFlag.registry.summons
			.creatures(this.actor)
			.filter(i => i?.getFlag(game.system.id, "summon.origin") === this.uuid);
	}
}

/**
 * Activity for summoning creatures.
 */
class SummonActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "summon",
				dataModel: SummonData,
				icon: "systems/black-flag/artwork/activities/summon.svg",
				title: "BF.SUMMON.Title",
				hint: "BF.SUMMON.Hint",
				usage: {
					actions: {
						placeSummons: SummonActivity.#placeSummons
					},
					dialog: SummonActivationDialog
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does the user have permissions to summon?
	 * @type {boolean}
	 */
	get canSummon() {
		return game.user.can("TOKEN_CREATE") && (game.user.isGM || game.settings.get(game.system.id, "allowSummoning"));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {ActivityActivationConfiguration} SummonActivationConfiguration
	 * @property {object|false} create
	 * @property {string} create.summons                    Should a summoned creature be created?
	 * @property {Partial<SummoningConfiguration>} summons  Options for configuring summoning behavior.
	 */

	/**
	 * @typedef {object} SummoningConfiguration
	 * @property {string} profile         ID of the summoning profile to use.
	 * @property {string} [creatureSize]  Selected creature size if multiple are available.
	 * @property {string} [creatureType]  Selected creature type if multiple are available.
	 */

	/**
	 * @typedef {ActivityActivationResults} SummonUsageResults
	 * @property {BlackFlagToken[]} summoned  Summoned tokens.
	 */

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_prepareActivationConfig(config) {
		config = super._prepareActivationConfig(config);
		const summons = this.system.availableProfiles;

		config.create ??= {};
		config.create.summons ??= this.canSummon && canvas.scene && summons.length && this.system.summon.prompt;

		config.summons ??= {};
		config.summons.profile ??= summons[0]?._id ?? null;
		config.summons.creatureSize ??= this.system.creatureSizes.first() ?? null;
		config.summons.creatureType ??= this.system.creatureTypes.first() ?? null;

		return config;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_activationChatButtons(message) {
		if (!this.system.availableProfiles.length) return super._activationChatButtons(message);
		return [
			{
				label: game.i18n.localize("BF.SUMMON.Action.Summon"),
				icon: '<i class="fa-solid fa-spaghetti-monster-flying" inert></i>',
				dataset: {
					action: "placeSummons"
				}
			}
		].concat(super._activationChatButtons(message));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	shouldHideChatButton(button, message) {
		if (button.dataset.action === "placeSummons") return !this.canSummon;
		return super.shouldHideChatButton(button, message);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _finalizeActivation(config, results) {
		await super._finalizeActivation(config, results);
		if (config.create?.summons) {
			try {
				results.summoned = await this.placeSummons(config.summons);
			} catch (err) {
				results.summoned = [];
				Hooks.onError("SummonActivity#activate", err, { log: "error", notify: "error" });
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Summoning              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Process for summoning actor to the scene.
	 * @param {SummoningConfiguration} options - Configuration data for summoning behavior.
	 * @returns {BlackFlagToken[]|void}
	 */
	async placeSummons(options) {
		if (!canvas.scene) throw new Error(game.i18n.localize("BF.SUMMON.Warning.NoScene"));
		if (!this.canSummon) throw new Error(game.i18n.localize("BF.SUMMON.Warning.CreateToken"));

		// Retrieve profile information
		const profile = this.system.profiles.find(p => p._id === options?.profile);
		if (!profile)
			throw new Error(
				game.i18n.format("BF.SUMMONG.Warning.NoProfile", { profileId: options?.profile, item: this.item.name })
			);

		// TODO: Hook

		// Fetch the actor that will be summoned
		const summonUuid = this.system.summon.mode === "cr" ? await this.queryActor(profile) : profile.uuid;
		if (!summonUuid) return;
		const actor = await this.fetchActor(summonUuid);

		// Verify ownership of actor
		if (!actor.isOwner) throw new Error(game.i18n.format("BF.SUMMON.Warning.NoOwnership", { actor: actor.name }));

		const tokensData = [];
		const minimized = !this.actor?.sheet._minimized;
		await this.actor?.sheet.minimize();
		try {
			// Figure out where to place the summons
			const placements = await this.getPlacement(actor.prototypeToken, profile, options);

			for (const placement of placements) {
				// Prepare changes to actor data, re-calculating per-token for potentially random values
				const tokenUpdateData = {
					actor,
					placement,
					...(await this.getChanges(actor, profile, options))
				};

				// TODO: Hook

				// Create a token document and apply updates
				const tokenData = await this.getTokenData(tokenUpdateData);

				// TODO: Hook

				tokensData.push(tokenData);
			}
		} finally {
			if (minimized) this.actor?.sheet.maximize();
		}

		const createdTokens = await canvas.scene.createEmbeddedDocuments("Token", tokensData);

		// TODO: Hook

		return createdTokens;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * If actor to be summoned is in a compendium, create a local copy or use an already imported version if present.
	 * @param {string} uuid - UUID of actor that will be summoned.
	 * @returns {BlackFlagActor} - Local copy of actor.
	 */
	async fetchActor(uuid) {
		const actor = await fromUuid(uuid);
		if (!actor) throw new Error(game.i18n.format("BF.SUMMON.Warning.NoActor", { uuid }));

		const actorLink = actor.prototypeToken.actorLink;
		if (!actor.pack && (!actorLink || actor.getFlag(game.system.id, "summon.origin") === this.uuid)) return actor;

		// Search world actors to see if any usable summoned actor instances are present from prior summonings.
		// Linked actors must match the summoning origin (activity) to be considered.
		const localActor = game.actors.find(
			a =>
				// Has been cloned for summoning use
				a.getFlag(game.system.id, "summonedCopy") &&
				// Sourced from the desired actor UUID
				a._stats?.compendiumSource === uuid &&
				// Unlinked or created from this activity specifically
				(a.getFlag(game.system.id, "summon.origin") === this.uuid || !a.prototypeToken.actorLink)
		);
		if (localActor) return localActor;

		// Check permissions to create actors before importing
		if (!game.user.can("ACTOR_CREATE")) throw new Error(game.i18n.localize("BF.SUMMON.Warning.CreateActor"));

		// No suitable world actor was found, create a new actor for this summoning instance.
		if (actor.pack) {
			// Template actor resides only in compendium, import the actor into the world and set the flag.
			return game.actors.importFromCompendium(game.packs.get(actor.pack), actor.id, {
				[`flags.${game.system.id}.summonedCopy`]: true
			});
		} else {
			// Template actor (linked) found in world, create a copy for this user's item.
			return actor.clone(
				{
					[`flags.${game.system.id}.summonedCopy`]: true,
					"_stats.compendiumSource": actor.uuid
				},
				{ save: true }
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Request a specific actor to summon from the player.
	 * @param {SummonsProfile} profile - Profile used for summoning.
	 * @returns {Promise<string|null>} - UUID of the concrete actor to summon or `null` if canceled.
	 */
	async queryActor(profile) {
		// TODO: Complete once Compendium Browser is implemented
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the updates to apply to the summoned actor and its token.
	 * @param {BlackFlagActor} actor - Actor that will be modified.
	 * @param {SummonsProfile} profile - Summoning profile used to summon the actor.
	 * @param {SummoningConfiguration} options - Configuration data for summoning behavior.
	 * @returns {Promise<{actorUpdates: object, tokenUpdates: object}>} - Changes that will be applied to the actor,
	 *                                                                    its items, and its token.
	 */
	async getChanges(actor, profile, options) {
		const actorUpdates = { effects: [], items: [] };
		const tokenUpdates = {};
		const rollData = { ...this.getRollData(), summon: actor.getRollData() };
		const prof = rollData.attributes?.proficiency ?? 0;

		// Add flags
		actorUpdates[`flags.${game.system.id}.summon`] = {
			level: this.relevantLevel,
			mod: rollData.mod,
			origin: this.uuid,
			profile: profile._id
		};

		// Match proficiency
		if (this.system.match.proficiency) {
			const proficiencyEffect = new ActiveEffect({
				_id: staticID("bfMatchProficiency"),
				changes: [
					{
						key: "system.attributes.proficiency",
						mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						value: prof
					}
				],
				disabled: false,
				icon: "icons/skills/targeting/crosshair-bars-yellow.webp",
				name: game.i18n.localize("BF.SUMMON.FIELDS.match.proficiency.label")
			});
			actorUpdates.effects.push(proficiencyEffect.toObject());
		}

		// Add bonus to AC
		if (this.system.bonuses.ac) {
			const acBonus = new Roll(this.system.bonuses.ac, rollData);
			await acBonus.evaluate();
			if (acBonus.total) {
				// If override is set, increase it directly
				if (actor.system.attributes.ac.override) {
					actorUpdates["system.attributes.ac.override"] = actor.system.attributes.ac.override + acBonus.total;
				}

				// Otherwise create an active effect with an armor class bonus modifier
				else
					actorUpdates.effects.push(
						new ActiveEffect({
							_id: staticID("bfACBonus"),
							changes: [
								{
									key: "system.modifiers",
									mode: CONST.ACTIVE_EFFECT_MODES.ADD,
									value: JSON.stringify({
										type: "bonus",
										filter: [{ k: "type", v: "armor-class" }],
										formula: acBonus.total
									})
								}
							],
							disabled: false,
							icon: "icons/magic/defensive/shield-barrier-blue.webp",
							name: game.i18n.localize("BF.SUMMON.FIELDS.bonuses.ac.label")
						}).toObject()
					);
			}
		}

		// Add bonus to HP
		if (this.system.bonuses.hp) {
			const hpBonus = new Roll(this.system.bonuses.hp, rollData);
			await hpBonus.evaluate();

			// If non-zero hp bonus, apply as needed for this actor.
			// Note: Only unlinked NPCs will have their current HP set to their new max HP
			if (hpBonus.total) {
				// Helper function for modifying max HP ('bonuses.overall' or 'max')
				const maxHPEffect = hpField => {
					return new ActiveEffect({
						_id: staticID("bfHPBonus"),
						changes: [
							{
								key: `system.attributes.hp.${hpField}`,
								mode: CONST.ACTIVE_EFFECT_MODES.ADD,
								value: hpBonus.total
							}
						],
						disabled: false,
						icon: "icons/magic/life/heart-glowing-red.webp",
						name: game.i18n.localize("BF.SUMMON.FIELDS.bonuses.hp.label")
					}).toObject();
				};

				// PCs without an HP override get an effect targeting overall bonus or override, if set
				if (actor.type === "pc")
					actorUpdates.effects.push(
						maxHPEffect(actor._source.system.attributes.hp.override ? "override" : "bonuses.overall")
					);
				// Linked NPCs get a boost to their max, but no change to their current HP
				else if (actor.prototypeToken.actorLink) actorUpdates.effects.push(maxHpEffect("max"));
				// Unlinked NPCs get direct changes to their max and current HP
				else {
					actorUpdates["system.attributes.hp.max"] = actor.system.attributes.hp.max + hpBonus.total;
					actorUpdates["system.attributes.hp.value"] = actor.system.attributes.hp.value + hpBonus.total;
				}
			}
		}

		// Change creature size
		if (this.system.creatureSizes.size) {
			const size = this.system.creatureSizes.has(options.creatureSize)
				? options.creatureSize
				: this.system.creatureSizes.first();
			const config = CONFIG.BlackFlag.sizes[size];
			if (config) {
				actorUpdates["system.traits.size"] = size;
				tokenUpdates.width = config.scale ?? 1;
				tokenUpdates.height = config.scale ?? 1;
			}
		}

		// Change creature type
		if (this.system.creatureTypes.size) {
			const type = this.system.creatureTypes.has(options.creatureType)
				? options.creatureType
				: this.system.creatureTypes.first();
			actorUpdates["system.traits.type.value"] = type;
		}

		const damageBonuses = {
			attack: "attackDamage",
			save: "saveDamage",
			heal: "healing"
		};
		for (const [key, field] of Object.entries(damageBonuses)) {
			const bonus = Roll.replaceFormulaData(this.system.bonuses[field] ?? "", rollData);
			if (!bonus) continue;
			actorUpdates.effects.push(
				new ActiveEffect({
					_id: staticID(`bf${key.capitalize()}DamageBonus`),
					changes: [
						{
							key: "system.modifiers",
							mode: CONST.ACTIVE_EFFECT_MODES.ADD,
							value: JSON.stringify({
								type: "bonus",
								filter: [
									{ k: "type", v: "damage" },
									{ k: "kind", v: key }
								],
								formula: bonus
							})
						}
					],
					disabled: false,
					icon: "icons/skills/melee/strike-slashes-orange.webp",
					name: game.i18n.localize(`BF.SUMMON.FIELDS.bonuses.${field}.label`)
				}).toObject()
			);
		}

		for (const item of actor.items) {
			if (!item.system.activities?.size) continue;
			const changes = [];

			// Match attacks
			if (this.system.match.attacks && item.system.activities?.byType("attack")?.length) {
				changes.push({
					key: "activities[attack].system.attack.flat",
					mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
					value: true
				});
				for (const activity of item.system.activities.byType("attack")) {
					const { parts, data } = buildRoll(
						{
							mod: this.actor.system.abilities?.[activity.ability]?.mod,
							prof: rollData.prof?.term,
							actorBonus: this.actor?.system.buildBonus?.(
								this.actor?.system.getModifiers?.({ ...activity.modifierData, class: this.modifierData.class }),
								{ rollData }
							)
						},
						rollData
					);
					changes.push({
						key: `system.activities.${activity.id}.system.attack.bonus`,
						mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						value: simplifyFormula(Roll.replaceFormulaData(parts.join(" + "), data))
					});
				}
			}

			// Match saves
			if (this.system.match.saves && item.system.activities?.byType("save")?.length) {
				const dc =
					this.actor.system.spellcasting?.origins[this.item.system.associatedClass?.identifier]?.dc ??
					rollData.spellcasting?.dc ??
					8;
				changes.push(
					{
						key: "activities[save].system.save.dc.ability",
						mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						value: "custom"
					},
					{
						key: "activities[save].system.save.dc.formula",
						mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						value: dc
					}
				);
			}

			if (changes.length) {
				const effect = new ActiveEffect({
					_id: staticID("bfItemChanges"),
					changes,
					disabled: false,
					icon: "icons/skills/melee/strike-slashes-orange.webp",
					name: game.i18n.localize("BF.SUMMON.ItemChanges.Label"),
					origin: this.uuid,
					type: "enchantment"
				}).toObject();
				actorUpdates.items.push({ _id: item.id, effects: [effect] });
			}
		}

		// Add applied effects
		actorUpdates.effects.push(...this.system.effects.map(e => e.effect?.toObject()).filter(e => e));

		return { actorUpdates, tokenUpdates };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine where the summons should be placed on the scene.
	 * @param {PrototypeToken} token - Token to be placed.
	 * @param {SummonsProfile} profile - Profile used for summoning.
	 * @param {SummoningConfiguration} options - Additional summoning options.
	 * @returns {Promise<PlacementData[]>}
	 */
	async getPlacement(token, profile, options) {
		// Ensure the token matches the final size
		if (this.system.creatureSizes.size) {
			const size = this.system.creatureSizes.has(options.creatureSize)
				? options.creatureSize
				: this.system.creatureSizes.first();
			const config = CONFIG.BlackFlag.sizes[size];
			if (config) token = token.clone({ width: config.scale ?? 1, height: config.scale ?? 1 });
		}

		const rollData = this.getRollData();
		const count = new Roll(profile.count || "1", rollData);
		await count.evaluate();
		return TokenPlacement.place({ tokens: Array(parseInt(count.total)).fill(token) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration for creating a modified token.
	 *
	 * @typedef {object} TokenUpdateData
	 * @property {BlackFlagActor} actor - Original actor from which the token will be created.
	 * @property {PlacementData} placement - Information on the location to summon the token.
	 * @property {object} tokenUpdates - Additional updates that will be applied to token data.
	 * @property {object} actorUpdates - Updates that will be applied to actor delta.
	 */

	/**
	 * Create token data ready to be summoned.
	 * @param {config} TokenUpdateData - Configuration for creating a modified token.
	 * @returns {object}
	 */
	async getTokenData({ actor, placement, tokenUpdates, actorUpdates }) {
		if (actor.prototypeToken.randomImg && !game.user.can("FILES_BROWSE")) {
			tokenUpdates.texture ??= {};
			tokenUpdates.texture.src ??= actor.img;
			ui.notifications.warn("BF.SUMMON.Warning.Wildcard", { localize: true });
		}

		delete placement.prototypeToken;
		const tokenDocument = await actor.getTokenDocument(foundry.utils.mergeObject(placement, tokenUpdates));

		// Linked summons require more explicit updates before token creation.
		// Unlinked summons can take actor delta directly.
		if (tokenDocument.actorLink) {
			const { effects, items, ...rest } = actorUpdates;
			await tokenDocument.actor.update(rest);
			await tokenDocument.actor.updateEmbeddedDocuments("Item", items);

			const { newEffects, oldEffects } = effects.reduce(
				(acc, curr) => {
					const target = tokenDocument.actor.effects.get(curr._id) ? "oldEffects" : "newEffects";
					acc[target].push(curr);
					return acc;
				},
				{ newEffects: [], oldEffects: [] }
			);

			await tokenDocument.actor.updateEmbeddedDocuments("ActiveEffect", oldEffects);
			await tokenDocument.actor.createEmbeddedDocuments("ActiveEffect", newEffects, { keepId: true });
		} else {
			tokenDocument.delta.updateSource(actorUpdates);
			if (actor.prototypeToken.appendNumber) TokenPlacement.adjustAppendedNumber(tokenDocument, placement);
		}

		return tokenDocument.toObject();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle placing a summons from the chat card.
	 * @this {SummonActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static async #placeSummons(event, target, message) {
		if (!canvas.scene) {
			ui.notifications.error("BF.SUMMON.Warning.NoScene", { localize: true });
			return;
		}

		const config = {
			create: { summons: true },
			summons: {}
		};
		let needsConfiguration = false;

		// No profile specified and only one profile on item, use that one
		const profiles = this.system.availableProfiles;
		if (profiles.length === 1) config.summons.profile = profiles[0]._id;
		else needsConfiguration = true;

		// More than one creature size or type requires configuration
		if (this.system.creatureSizes.size > 1 || this.system.creatureTypes.size > 1) needsConfiguration = true;

		if (needsConfiguration) {
			try {
				await SummonActivationDialog.create(this, config, {
					button: {
						icon: "fa-solid fa-spaghetti-monster-flying",
						label: "BF.SUMMON.Action.Summon"
					},
					display: {
						all: false,
						create: { summons: true }
					}
				});
			} catch (err) {
				return;
			}
		}

		try {
			await this.placeSummons(config.summons);
		} catch (err) {
			Hooks.onError("SummonsActivity#placeSummons", err, { log: "error", notify: "error" });
		}
	}
}

const { ArrayField: ArrayField$f, BooleanField: BooleanField$c, SchemaField: SchemaField$I, StringField: StringField$H } = foundry.data.fields;

/**
 * Configuration data for the Utility activity.
 * @property {EffectApplicationData[]} effects - Effects to be applied.
 * @property {object} roll
 * @property {string} roll.formula - Arbitrary formula that can be rolled.
 * @property {string} roll.name - Label for the rolling button.
 * @property {boolean} roll.prompt - Should the roll configuration dialog be displayed?
 * @property {boolean} roll.visible - Should the rolling button be visible to all players?
 */
class UtilityData extends ActivityDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.UTILITY"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			effects: new ArrayField$f(new AppliedEffectField()),
			roll: new SchemaField$I({
				formula: new FormulaField(),
				name: new StringField$H(),
				prompt: new BooleanField$c(),
				visible: new BooleanField$c()
			})
		};
	}
}

/**
 * Activity for arbitrary rolls and everything else.
 */
class UtilityActivity extends Activity {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "utility",
				dataModel: UtilityData,
				icon: "systems/black-flag/artwork/activities/utility.svg",
				title: "BF.UTILITY.Title",
				hint: "BF.UTILITY.Hint",
				usage: {
					actions: {
						rollFormula: UtilityActivity.#rollFormula
					}
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Activation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_activationChatButtons() {
		const buttons = [];
		if (this.system.roll.formula)
			buttons.push({
				label: this.system.roll.name || game.i18n.localize("BF.Roll.Action.RollGeneric"),
				icon: '<i class="fa-solid fa-dice" inert></i>',
				dataset: {
					action: "rollFormula",
					visibility: this.system.roll.visible ? "all" : undefined
				}
			});
		return buttons.concat(super._activationChatButtons());
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Rolls                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll formula.
	 * @param {BasicRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {BasicRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<DamageRoll[]|void>}
	 */
	async rollFormula(config = {}, dialog = {}, message = {}) {
		if (!this.item.isEmbedded || this.item.pack) return;
		if (!this.system.roll.formula) {
			console.warn(`No formula defined for the activity ${this.name} on ${this.item.name} (${this.uuid}).`);
			return;
		}

		const rollConfig = foundry.utils.deepClone(config);
		rollConfig.subject = this;
		rollConfig.rolls = [{ parts: [this.system.roll.formula], data: this.getRollData() }].concat(config.rolls ?? []);

		const dialogConfig = foundry.utils.mergeObject({
			configure: this.system.roll.prompt,
			options: {
				rollNotes: this.actor?.system.getModifiers?.(rollConfig.modifierData, "note"),
				title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type: this.name })
			}
		});

		const messageConfig = foundry.utils.mergeObject(
			{
				create: true,
				data: {
					flavor: this.name,
					flags: {
						[game.system.id]: {
							...this.messageFlags,
							type: "roll",
							roll: { type: "roll" }
						}
					},
					speaker: ChatMessage.getSpeaker({ actor: this.item.actor })
				}
			},
			message
		);

		/**
		 * A hook event that fires before the formula is rolled.
		 * @function blackFlag.preRollFormula
		 * @memberof hookEvents
		 * @param {BasicRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {BasicRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return false to prevent the roll from being performed.
		 */
		if (Hooks.call("blackFlag.preRollFormula", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.BasicRoll.build(rollConfig, dialogConfig, messageConfig);
		if (!rolls) return;

		/**
		 * A hook event that fires after the formula has been rolled.
		 * @function blackFlag.postRollFormula
		 * @memberof hookEvents
		 * @param {BasicRoll[]} rolls - The resulting rolls.
		 * @param {object} [data]
		 * @param {Activity} [data.subject] - Activity for which the roll was performed.
		 */
		Hooks.callAll("blackFlag.postRollFormula", rolls, { subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle rolling the formula attached to this utility.
	 * @this {UtilityActivity}
	 * @param {PointerEvent} event - Triggering click event.
	 * @param {HTMLElement} target - The capturing HTML element which defined a [data-action].
	 * @param {BlackFlagChatMessage} message - Message associated with the activation.
	 */
	static #rollFormula(event, target, message) {
		this.rollFormula({ event });
	}
}

var _module$f = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Activity: Activity,
	AttackActivity: AttackActivity,
	CastActivity: CastActivity,
	CheckActivity: CheckActivity,
	DamageActivity: DamageActivity,
	ForwardActivity: ForwardActivity,
	HealActivity: HealActivity,
	SaveActivity: SaveActivity,
	SummonActivity: SummonActivity,
	UtilityActivity: UtilityActivity
});

/**
 * Configuration data for activity types.
 *
 * @typedef {object} ActivityTypeConfig
 * @property {typeof Activity} documentClass - Main document class that defines activity's behavior.
 * @property {object} sheetClasses
 * @property {typeof ActivitySheet} sheetClasses.config - Configuration sheet.
 */

/**
 * Activity types that can be added to items.
 * @enum {ActivityTypeConfig}
 */
const _activityTypes = {
	base: {
		documentClass: Activity,
		sheetClasses: {
			config: ActivitySheet
		}
	},
	attack: {
		documentClass: AttackActivity,
		sheetClasses: {
			config: AttackSheet
		}
	},
	cast: {
		documentClass: CastActivity,
		sheetClasses: {
			config: CastSheet
		}
	},
	check: {
		documentClass: CheckActivity,
		sheetClasses: {
			config: CheckSheet
		}
	},
	damage: {
		documentClass: DamageActivity,
		sheetClasses: {
			config: DamageSheet
		}
	},
	forward: {
		documentClass: ForwardActivity,
		sheetClasses: {
			config: ForwardSheet
		}
	},
	heal: {
		documentClass: HealActivity,
		sheetClasses: {
			config: HealSheet
		}
	},
	save: {
		documentClass: SaveActivity,
		sheetClasses: {
			config: SaveSheet
		}
	},
	summon: {
		documentClass: SummonActivity,
		sheetClasses: {
			config: SummonSheet
		}
	},
	utility: {
		documentClass: UtilityActivity,
		sheetClasses: {
			config: UtilitySheet
		}
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Different classifications of attack types.
 * @enum {string}
 */
const attackTypes = {
	weapon: "BF.WEAPON.Label[one]",
	spell: "BF.Item.Type.Spell[one]"
};
localizeConfig(attackTypes);

var activity = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_activityTypes: _activityTypes,
	attackTypes: attackTypes
});

/**
 * Configuration data for creature types.
 *
 * @typedef {LabeledConfiguration} CreatureTypeConfiguration
 * @property {string} [reference] - UUID of a journal entry with details on this creature type.
 */

/**
 * Possible creature types.
 * @enum {CreatureTypeConfiguration}
 */
const creatureTypes = {
	aberration: {
		localization: "BF.CreatureType.Type.Aberration",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.FdTfsFN2mEaH0dh0"
	},
	beast: {
		localization: "BF.CreatureType.Type.Beast",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.4CRbAERqSRQQ8rWM"
	},
	celestial: {
		localization: "BF.CreatureType.Type.Celestial",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.YihanG6MWJtWuXRH"
	},
	construct: {
		localization: "BF.CreatureType.Type.Construct",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.bU3uHbUTyEKCvMdw"
	},
	dragon: {
		localization: "BF.CreatureType.Type.Dragon",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.a3m05Htjwsr81ciO"
	},
	elemental: {
		localization: "BF.CreatureType.Type.Elemental",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.KuitTyCuiyPJx7Yx"
	},
	fey: {
		localization: "BF.CreatureType.Type.Fey",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.GUU2PMiIVdkj302g"
	},
	fiend: {
		localization: "BF.CreatureType.Type.Fiend",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.SuJnNFNcErG2SWlu"
	},
	giant: {
		localization: "BF.CreatureType.Type.Giant",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.CU2Aok5lj6Srf6p5"
	},
	humanoid: {
		localization: "BF.CreatureType.Type.Humanoid",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.q74G8dHvaT2iSKiR"
	},
	monstrosity: {
		localization: "BF.CreatureType.Type.Monstrosity",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.UIu4g5LNxbDlh1xl"
	},
	ooze: {
		localization: "BF.CreatureType.Type.Ooze",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ADqhMsVaa0L9DF7h"
	},
	plant: {
		localization: "BF.CreatureType.Type.Plant",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.aIRHqfydG0iAyZuK"
	},
	undead: {
		localization: "BF.CreatureType.Type.Undead",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.OuEGHqtpQB57PxW7"
	}
};
localizeConfig(creatureTypes);
localizeConfig(creatureTypes, { propertyName: "localizedPlural", pluralRule: "other" });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Tags that can be associated with creature types.
 * @enum {NestedTypeConfiguration}
 */
const creatureTags = {
	animal: {
		localization: "BF.CreatureType.Tag.Animal",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.wIVbWmvn1dq8vc68"
	},
	golem: {
		localization: "BF.CreatureType.Tag.Golem",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.g8KIFr6a9FXbDVeX"
	},
	outsider: {
		localization: "BF.CreatureType.Tag.Outsider",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ynBgOpaDVZ1Ofxx4",
		children: {
			angel: {
				localization: "BF.CreatureType.Tag.Angel"
			},
			demon: {
				localization: "BF.CreatureType.Tag.Demon"
			},
			devil: {
				localization: "BF.CreatureType.Tag.Devil"
			}
		}
	},
	shapechanger: {
		localization: "BF.CreatureType.Tag.Shapechanger",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.lt1UiK4eCG5W4Htw",
		children: {
			lycanthrope: {
				localization: "BF.CreatureType.Tag.Lycanthrope"
			}
		}
	},
	anyLineage: {
		label: "BF.CreatureType.Tag.AnyLineage"
	}
};
localizeConfig(creatureTags, { flatten: true });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration information for death saves.
 * @type {object}
 */
const deathSave = {
	target: 10,
	successThreshold: 3,
	failureThreshold: 3
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Encumbrance configuration data.
 *
 * @typedef {object} EncumbranceConfiguration
 * @property {Record<string, object>} effects - Data used to create encumbrance-related Active Effects.
 * @property {Record<string, Record<string, number>} threshold - Amount to multiply strength to get given capacity
 *                                                               threshold.
 * @property {Record<string, Record<string, number>} speedReduction - Speed reduction caused by encumbered status.
 * @property {Record<string, Record<string, string>>} baseUnits - Base units used to calculate carrying weight.
 */

/**
 * Configuration for various aspects of encumbrance calculation.
 * @type {EncumbranceConfiguration}
 */
const encumbrance = {
	effects: {
		encumbered: {
			name: "EFFECT.BF.Encumbered",
			icon: "systems/black-flag/artwork/statuses/encumbered.svg"
		},
		heavilyEncumbered: {
			name: "EFFECT.BF.HeavilyEncumbered",
			icon: "systems/black-flag/artwork/statuses/heavily-encumbered.svg"
		},
		exceedingCarryingCapacity: {
			name: "EFFECT.BF.ExceedingCarryingCapacity",
			icon: "systems/black-flag/artwork/statuses/exceeding-carrying-capacity.svg"
		}
	},
	threshold: {
		encumbered: {
			imperial: 5
		},
		heavilyEncumbered: {
			imperial: 10
		},
		maximum: {
			imperial: 15
		}
	},
	speedReduction: {
		encumbered: {
			imperial: 10
		},
		heavilyEncumbered: {
			imperial: 20
		},
		exceedingCarryingCapacity: {
			imperial: 5
		}
	},
	baseUnits: {
		default: {
			imperial: "pound"
		}
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for luck points.
 * @type {{
 *   costs: {[key: string]: number},
 *   rerollFormula: string,
 *   max: number,
 *   validRollTypes: Set<string>
 * }}
 */
const luck = {
	costs: {
		bonus: 1,
		reroll: 3
	},
	max: 5,
	rerollFormula: "1d4",
	validRollTypes: new Set(["ability-check", "ability-save", "attack", "death-save", "skill"])
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                       Movement                        */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Movement types that can be used by actors.
 * @enum {LabeledConfiguration}
 */
const movementTypes = {
	walk: {
		label: "BF.MOVEMENT.Type.Walk"
	},
	climb: {
		label: "BF.MOVEMENT.Type.Climb",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.CdBLKsrlKHR5HvDr"
	},
	fly: {
		label: "BF.MOVEMENT.Type.Fly",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.CHNmwHjrIZtXEsf4"
	},
	swim: {
		label: "BF.MOVEMENT.Type.Swim",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.nzj83NdxpPZQoW6Z"
	},
	burrow: {
		label: "BF.MOVEMENT.Type.Burrow",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.jzO6qMcEroDupZDD"
	}
};
localizeConfig(movementTypes, { sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Tags the describe additional details of a character's movement.
 * @enum {TraitTagConfiguration}
 */
const movementTags = {
	animalDrawn: {
		label: "BF.MOVEMENT.Tag.AnimalDrawn.Label",
		display: "BF.MOVEMENT.Tag.AnimalDrawn.Display",
		type: "appended",
		validTypes: new Set(["vehicle"])
	},
	hover: {
		label: "BF.MOVEMENT.Tag.Hover.Label",
		display: "BF.MOVEMENT.Tag.Hover.Display",
		type: "associated",
		association: "fly"
	},
	maneuverable: {
		label: "BF.MOVEMENT.Tag.Maneuverable.Label",
		display: "BF.MOVEMENT.Tag.Maneuverable.Display",
		type: "associated",
		association: "walk",
		validTypes: new Set(["vehicle"])
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                        Resting                        */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for a rest type.
 *
 * @typedef {object} RestConfiguration
 * @property {Record<string, RestTypeConfiguration>} types - Rest types supported.
 * @property {number} hitPointsRecoveryPercentage - Percentage of hit points recovered during a rest.
 * @property {number} hitDiceRecoveryPercentage - Percentage of hit dice recovered during a rest.
 */

/**
 * Configuration data for a rest type.
 *
 * @typedef {LabeledConfiguration} RestTypeConfiguration
 * @property {string} hint - Localizable hint about the rest.
 * @property {string} resultMessages - Prefix for any result messages. A "Base" message must be provided,
 *                                     with optional "Full", "HitDice", & "HitPoints" variants depending
 *                                     on what resources can be recovered.
 * @property {typeof BaseRestDialog} dialogClass - Dialog used when performing the rest.
 * @property {string[]} [activationPeriods] - Activation types that should be displayed in the chat card.
 * @property {boolean} [recoverHitDice=false] - Should hit dice be recovered?
 * @property {boolean} [recoverHitPoints=false] - Should hit points be recovered?
 * @property {string[]} [recoverPeriods] - Recovery periods as defined in `CONFIG.BlackFlag.recoveryPeriods` that
 *                                         should be applied when this rest is taken. The ordering of the periods
 *                                         determines which is applied if more that one recovery profile is found.
 * @property {Set<string>} [recoverSpellSlotTypes] - Types of spellcasting slots that are recovered on this rest.
 */

/**
 * Types of rests an actor can take.
 * @type {RestConfiguration}
 */
const rest = {
	types: {
		short: {
			label: "BF.Rest.Type.Short.Label",
			hint: "BF.Rest.Type.Short.Hint",
			resultMessages: "BF.Rest.Result.Short",
			dialogClass: ShortRestDialog,
			activationPeriods: ["short"],
			recoverPeriods: ["shortRest"],
			recoverSpellSlotTypes: new Set(["pact"])
		},
		long: {
			label: "BF.Rest.Type.Long.Label",
			hint: "BF.Rest.Type.Long.Hint",
			resultMessages: "BF.Rest.Result.Long",
			dialogClass: LongRestDialog,
			activationPeriods: ["long"],
			recoverHitPoints: true,
			recoverHitDice: true,
			recoverPeriods: ["longRest", "dawn", "day", "dusk", "shortRest"],
			recoverSpellSlotTypes: new Set(["leveled", "pact"])
		}
	},
	hitPointsRecoveryPercentage: 1,
	hitDiceRecoveryPercentage: 0.5
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                        Senses                         */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Sense types that can be used by actors.
 * @enum {LabeledConfiguration}
 */
const senses = {
	darkvision: {
		label: "BF.SENSES.Type.Darkvision",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.wdYu7KK3IEKJ8lte"
	},
	keensense: {
		label: "BF.SENSES.Type.Keensense",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.gueujRnHAjOZxT6g"
	},
	tremorsense: {
		label: "BF.SENSES.Type.Tremorsense",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.iGH9wAnloILFHmX8"
	},
	truesight: {
		label: "BF.SENSES.Type.Truesight",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.rGryrzkJD8x0LNkT"
	}
};
localizeConfig(senses);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Tags the describe additional details of a character's senses.
 * @enum {TraitTagConfiguration}
 */
const senseTags = {
	cantSense: {
		label: "BF.SENSES.Tag.CantSense.Label",
		display: "BF.SENSES.Tag.CantSense.Display",
		type: "associated",
		association: "keensense"
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                         Sizes                         */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for creature sizes.
 *
 * @typedef {LabeledConfiguration} SizeConfiguration
 * @property {number|{width: number, height: number}} scale - Default token scale for a creature of this size.
 * @property {number} [capacityMultiplier] - Multiplier used to calculate carrying capacities.
 */

/**
 * Creature sizes defined by the system.
 * @enum {SizeConfiguration}
 */
const sizes = {
	tiny: {
		label: "BF.Size.Tiny",
		scale: 0.5,
		capacityMultiplier: 0.5
	},
	small: {
		label: "BF.Size.Small",
		scale: 1
	},
	medium: {
		label: "BF.Size.Medium",
		scale: 1
	},
	large: {
		label: "BF.Size.Large",
		scale: 2,
		capacityMultiplier: 2
	},
	huge: {
		label: "BF.Size.Huge",
		scale: 3,
		capacityMultiplier: 4
	},
	gargantuan: {
		label: "BF.Size.Gargantuan",
		scale: 4,
		capacityMultiplier: 8
	}
};
localizeConfig(sizes, { sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                          XP                           */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Table for XP values for each CR.
 * @type {number[]}
 */
const xpForCR = [
	10, // CR 0
	25, // CR â…›
	50, // CR Â¼
	100, // CR Â½
	200, // CR 1
	450, // CR 2
	700, // CR 3
	1100, // CR 4
	1800, // CR 5
	2300, // CR 6
	2900, // CR 7
	3900, // CR 8
	5000, // CR 9
	5900, // CR 10
	7200, // CR 11
	8400, // CR 12
	10000, // CR 13
	11500, // CR 14
	13000, // CR 15
	15000, // CR 16
	18000, // CR 17
	20000, // CR 18
	22000, // CR 19
	25000, // CR 20
	33000, // CR 21
	41000, // CR 22
	50000, // CR 23
	62000, // CR 24
	75000, // CR 25
	90000, // CR 26
	105000, // CR 27
	120000, // CR 28
	135000, // CR 29
	155000 // CR 30
];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                         Flags                         */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {ActorFlagConfiguration}
 * @property {Set<string>} actorTypes - Types of actors to which this flag can be applied.
 * @property {DataField} field - Foundry data field that controls the data format.
 */

/**
 * Special actor flags.
 * @enum {ActorFlagConfiguration}
 */
const actorFlags = {
	unrestrictedTalents: {
		actorTypes: new Set(["pc"]),
		field: new foundry.data.fields.BooleanField({
			label: "BF.FLAG.UnrestrictedTalents.label",
			hint: "BF.FLAG.UnrestrictedTalents.hint"
		})
	}
};

var actors = /*#__PURE__*/Object.freeze({
	__proto__: null,
	actorFlags: actorFlags,
	creatureTags: creatureTags,
	creatureTypes: creatureTypes,
	deathSave: deathSave,
	encumbrance: encumbrance,
	luck: luck,
	movementTags: movementTags,
	movementTypes: movementTypes,
	rest: rest,
	senseTags: senseTags,
	senses: senses,
	sizes: sizes,
	xpForCR: xpForCR
});

const { ArrayField: ArrayField$e, BooleanField: BooleanField$b, DocumentIdField: DocumentIdField$4, DocumentUUIDField: DocumentUUIDField$6, NumberField: NumberField$u, SchemaField: SchemaField$H, StringField: StringField$G } =
	foundry.data.fields;

/**
 * Configuration data for choice levels.
 *
 * @typedef {object} ChoiceLevelConfiguration
 * @property {number} count         Number of items a player can select at this level.
 * @property {boolean} replacement  Can a player replace previous selections at this level?
 */

/**
 * Configuration data for the Choose Features advancement.
 *
 * @property {boolean} allowDrops - Allow player to drop items not in the pool.
 * @property {Record<number, ChoiceLevelConfiguration>} choices - Choices presented at each level.
 * @property {FeatureGrantConfiguration[]} pool - Items to present as choices.
 * @property {object} restriction
 * @property {string} restriction.category - Category of allowed items (e.g. class or race).
 * @property {string} restriction.type - Subtype of allowed items (e.g. martialTalent or channelDivinity).
 * @property {string} type - General item type to support (e.g. feature or talent).
 */
class ChooseFeaturesConfigurationData extends AdvancementDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.Advancement.ChooseFeatures"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			allowDrops: new BooleanField$b({ initial: true }),
			choices: new MappingField(
				new SchemaField$H({
					count: new NumberField$u({ min: 1, integer: true }),
					replacement: new BooleanField$b()
				})
			),
			pool: new ArrayField$e(new SchemaField$H({ uuid: new DocumentUUIDField$6() })),
			restriction: new SchemaField$H({
				category: new StringField$G(),
				type: new StringField$G()
			}),
			type: new StringField$G({ blank: false, initial: "feature" })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		// Added in 0.10.051
		if ("choices" in source)
			Object.entries(source.choices).forEach(([k, c]) => {
				if (foundry.utils.getType(c) === "number") source.choices[k] = { count: c };
			});
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Value data for replaced features.
 *
 * @typedef {object} ReplacedFeatureData
 * @property {number} level - Level that feature that was replaced was originally added.
 * @property {string} original - ID of the original feature to be replaced.
 * @property {string} replacement - ID of the replacing feature.
 */

/**
 * Value data for the Choose Features advancement.
 *
 * @property {Record<number, GrantedFeatureData[]>} added - Features chosen at each level.
 * @property {Record<number, ReplacedFeatureData>} replaced - Information on items replaced at each level.
 */
class ChooseFeaturesValueData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			added: new MappingField(
				new ArrayField$e(
					new SchemaField$H({
						document: new LocalDocumentField(foundry.documents.BaseItem),
						uuid: new DocumentUUIDField$6()
					})
				),
				{ required: false, initial: undefined }
			),
			replaced: new MappingField(
				new SchemaField$H({
					level: new NumberField$u({ integer: true, min: 0 }),
					original: new DocumentIdField$4(),
					replacement: new DocumentIdField$4()
				})
			)
		};
	}
}

const { ArrayField: ArrayField$d, BooleanField: BooleanField$a, DocumentUUIDField: DocumentUUIDField$5, EmbeddedDataField: EmbeddedDataField$1, SchemaField: SchemaField$G, SetField: SetField$k, StringField: StringField$F } =
	foundry.data.fields;

/**
 * Configuration data for the Grant Spells advancement.
 *
 * @property {SpellConfigurationData} spell - Configuration data for granted spells.
 */
class GrantSpellsConfigurationData extends AdvancementDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.Advancement.SpellConfig", "BF.Advancement.GrantSpells"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			pool: new ArrayField$d(new SchemaField$G({ uuid: new DocumentUUIDField$5() })),
			spell: new EmbeddedDataField$1(SpellConfigurationData)
		};
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Value data for granted spells.
 *
 * @typedef {GrantedFeatureData} GrantedSpellData
 * @property {boolean} modified - Was an existing item on the actor modified rather than a new one created?
 */

/**
 * Value data for the Grant Spells advancement.
 *
 * @property {string} ability - Ability to assign if applicable.
 * @property {GrantedSpellData[]} added - Spells added or updated.
 */
class GrantSpellsValueData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			ability: new StringField$F(),
			added: new ArrayField$d(
				new SchemaField$G({
					document: new LocalDocumentField(foundry.documents.BaseItem),
					modified: new BooleanField$a(),
					uuid: new DocumentUUIDField$5()
				}),
				{ required: false, initial: undefined }
			)
		};
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for spells that can be granted.
 *
 * @property {Set<string>} ability - One or more abilities that will be used for the provided spell.
 * @property {boolean} alwaysPrepared - Should this spell be always prepared?
 * @property {string} mode - Spell preparation mode to set.
 * @property {string} origin - Identifier of a class or subclass to associated with these spells.
 * @property {string} source - Source the granted spell will be treated as, regardless of original source.
 * @property {object} uses
 * @property {number} uses.max - Limited usage to apply to the spell.
 * @property {string} uses.period - Recovery period for applied limited uses.
 * @property {boolean} uses.requireSlot - Is a spell slot required even when using the limited uses?
 */
class SpellConfigurationData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			ability: new SetField$k(new StringField$F()),
			alwaysPrepared: new BooleanField$a(),
			mode: new StringField$F({ initial: "standard" }),
			origin: new IdentifierField(),
			source: new StringField$F(),
			uses: new SchemaField$G({
				max: new FormulaField({ deterministic: true }),
				period: new StringField$F({ initial: "longRest" }),
				requireSlot: new BooleanField$a()
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply spell
	 * @param {object} spell - Spell data to modify.
	 * @param {object} [data={}] - Data from the advancement process.
	 * @returns {object}
	 */
	applyChanges(spell, data = {}) {
		foundry.utils.setProperty(spell, "flags.black-flag.relationship.mode", this.mode);
		foundry.utils.setProperty(spell, "flags.black-flag.relationship.alwaysPrepared", this.alwaysPrepared);
		if (this.ability.size)
			foundry.utils.setProperty(
				spell,
				"flags.black-flag.relationship.origin.ability",
				this.ability.has(data.ability) ? data.ability : this.ability.first()
			);
		if (this.origin) foundry.utils.setProperty(spell, "flags.black-flag.relationship.origin.identifier", this.origin);
		if (this.source) foundry.utils.setProperty(spell, "flags.black-flag.relationship.origin.source", this.source);

		if (this.uses.max) {
			foundry.utils.setProperty(spell, "system.uses.max", this.uses.max);
			spell.system.uses.recovery ??= [];
			spell.system.uses.recovery.push({ period: this.uses.period, type: "recoverAll" });

			const preparationConfig =
				CONFIG.BlackFlag.spellPreparationModes[foundry.utils.getProperty(spell, "flags.black-flag.relationship.mode")];
			const createForwardActivity = preparationConfig?.scalable && !this.uses.requireSlot;

			for (const activity of Object.values(spell.system.activities ?? {})) {
				if (!activity.activation?.primary) continue;

				// Create a forward activity
				if (createForwardActivity) {
					const newActivity = {
						_id: foundry.utils.randomID(),
						consumption: {
							targets: [{ type: "item", target: "", value: "1" }]
						},
						flags: {
							[game.system.id]: {
								fromAdvancement: true
							}
						},
						name: `${
							activity.name ?? game.i18n.localize(CONFIG.Activity.types[activity.type]?.documentClass.metadata.title)
						} (${game.i18n.localize("BF.Advancement.SpellConfig.FreeCasting").toLowerCase()})`,
						sort: (activity.sort ?? 0) + 1,
						system: {
							linked: {
								id: activity._id
							}
						},
						type: "forward"
					};
					foundry.utils.setProperty(spell, `system.activities.${newActivity._id}`, newActivity);
				}

				// Modify existing activity
				else {
					const activityData = foundry.utils.deepClone(activity);
					activityData.consumption.targets ??= [];
					activityData.consumption.targets.push({ type: "item", target: "", value: "1" });
					foundry.utils.setProperty(spell, `system.activities.${activityData._id}`, activityData);
				}
			}
		}

		return spell;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Changes needed to reverse a modification to an existing spell.
	 * @param {BlackFlagItem} spell - The existing spell to reverse changes upon.
	 * @param {object} [data={}] - Data from the advancement process.
	 * @returns {object}
	 */
	getReverseChanges(spell, data = {}) {
		const updates = {};
		if (this.alwaysPrepared) updates["flags.black-flag.relationship.alwaysPrepared"] = false;
		if (this.ability.size) updates["flags.black-flag.relationship.origin.-=ability"] = null;
		if (this.origin) updates["flags.black-flag.relationship.origin.-=identifier"] = null;
		if (this.source) updates["flags.black-flag.relationship.origin.-=source"] = null;

		if (this.uses.max) {
			updates["system.uses.max"] = "";
			updates["system.uses.recovery"] = spell.system.uses.recovery.filter(r => r.period !== this.uses.period);

			const preparationConfig =
				CONFIG.BlackFlag.spellPreparationModes[foundry.utils.getProperty(spell, "flags.black-flag.relationship.mode")];
			const deleteForwardActivity = preparationConfig?.scalable && !this.uses.requireSlot;

			for (const activity of spell.system.activities) {
				if (deleteForwardActivity) {
					if (activity.flags[game.system.id]?.fromAdvancement) updates[`system.activities.-=${activity.id}`] = null;
				} else if (activity.activation?.primary) {
					updates[`system.activities.${activity.id}.consumption.targets`] = activity.consumption.targets.filter(
						t => t.type !== "item"
					);
				}
			}
		}

		return updates;
	}
}

const {
	ArrayField: ArrayField$c,
	BooleanField: BooleanField$9,
	DocumentIdField: DocumentIdField$3,
	DocumentUUIDField: DocumentUUIDField$4,
	EmbeddedDataField,
	NumberField: NumberField$t,
	SchemaField: SchemaField$F,
	StringField: StringField$E
} = foundry.data.fields;

/**
 * Configuration data for the Choose Spells advancement.
 *
 * @property {boolean} allowDrops - Allow player to drop spells not in the pool.
 * @property {Record<number, ChoiceLevelConfiguration>} choices - Choices presented at each level.
 * @property {FeatureGrantConfiguration[]} pool - Spells to present as choices.
 * @property {object} restriction
 * @property {boolean} restriction.allowCantrips - Allow cantrips to be selected if "Any Circle" is set.
 * @property {boolean} restriction.allowRituals - Allow rituals to be selected.
 * @property {number} restriction.circle - Circle allowed for choosing spells or `-1` to represent any circle
 *                                         available to the character.
 * @property {boolean} restriction.exactCircle - Does the circle need to be exact, or are lower circle spells allowed?
 * @property {string} restriction.source - Source of magic required for to select spells.
 * @property {SpellConfigurationData} spell - Configuration data for granted spells.
 */
class ChooseSpellsConfigurationData extends AdvancementDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = [
		...super.LOCALIZATION_PREFIXES,
		"BF.Advancement.SpellConfig",
		"BF.Advancement.ChooseSpells"
	];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			allowDrops: new BooleanField$9({ initial: true }),
			choices: new MappingField(
				new SchemaField$F({
					count: new NumberField$t({ min: 1, integer: true }),
					replacement: new BooleanField$9()
				})
			),
			pool: new ArrayField$c(new SchemaField$F({ uuid: new DocumentUUIDField$4() })),
			restriction: new SchemaField$F({
				allowCantrips: new BooleanField$9(),
				allowRituals: new StringField$E(),
				circle: new NumberField$t({ initial: -1 }),
				exactCircle: new BooleanField$9({ initial: true }),
				source: new StringField$E()
			}),
			spell: new EmbeddedDataField(SpellConfigurationData)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item type that can be chosen.
	 * @type {string}
	 */
	get type() {
		return "spell";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		// Added in 0.9.037
		if (foundry.utils.getType(source.restriciton?.allowRituals) === "boolean") {
			source.restriction.allowRituals = source.restriction.allowRituals ? "allow" : "";
		}

		// Added in 0.10.051
		if ("choices" in source)
			Object.entries(source.choices).forEach(([k, c]) => {
				if (foundry.utils.getType(c) === "number") source.choices[k] = { count: c };
			});
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Value data for the Choose Spells advancement.
 *
 * @property {string} ability - Ability to assign if applicable.
 * @property {Record<number, GrantedSpellData[]>} added - Spells chosen at each level.
 * @property {Record<number, ReplacedFeatureData>} replaced - Information on items replaced at each level.
 */
class ChooseSpellsValueData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			ability: new StringField$E(),
			added: new MappingField(
				new ArrayField$c(
					new SchemaField$F({
						document: new LocalDocumentField(foundry.documents.BaseItem),
						modified: new BooleanField$9(),
						uuid: new DocumentUUIDField$4()
					})
				),
				{ required: false, initial: undefined }
			),
			replaced: new MappingField(
				new SchemaField$F({
					level: new NumberField$t({ integer: true, min: 0 }),
					original: new DocumentIdField$3(),
					replacement: new DocumentIdField$3()
				})
			)
		};
	}
}

const { ArrayField: ArrayField$b, BooleanField: BooleanField$8, DocumentUUIDField: DocumentUUIDField$3, SchemaField: SchemaField$E } = foundry.data.fields;

/**
 * Configuration data for an individual item entry in grant features.
 *
 * @typedef {object} FeatureGrantConfiguration
 * @property {string} uuid - UUID of the item to grant.
 */

/**
 * Configuration data for the Grant Features advancement.
 *
 * @property {boolean} enabled - Should the features be enabled by default when added?
 * @property {FeatureGrantConfiguration[]} pool - Items to grant.
 */
class GrantFeaturesConfigurationData extends AdvancementDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.Advancement.GrantFeatures"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			enabled: new BooleanField$8({ initial: true }),
			pool: new ArrayField$b(new SchemaField$E({ uuid: new DocumentUUIDField$3() }))
		};
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Value data for granted features.
 *
 * @typedef {object} GrantedFeatureData
 * @property {string} document - Linked document on the actor.
 * @property {string} uuid - Source UUID for the original document.
 */

/**
 * Value data for the Grant Features advancement.
 *
 * @property {GrantedFeatureData[]} added - Features added.
 */
class GrantFeaturesValueData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			added: new ArrayField$b(
				new SchemaField$E({
					document: new LocalDocumentField(foundry.documents.BaseItem),
					uuid: new DocumentUUIDField$3()
				}),
				{ required: false, initial: undefined }
			)
		};
	}
}

const { JSONField, NumberField: NumberField$s } = foundry.data.fields;

/**
 * Configuration data for the Hit Points advancement.
 *
 * @property {string} denomination - Size of hit die available.
 */
class HitPointsConfigurationData extends AdvancementDataModel {
	static defineSchema() {
		return {
			denomination: new NumberField$s({ initial: 4, label: "BF.HitDice.Label[one]" })
		};
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Value data for the Hit Points advancement.
 *
 * @property {{[key: number]: object}} granted - Hit points granted at various levels. This is stored as stringified
 *                                               JSON containing either a serialized roll or a string indicating that
 *                                               the "avg" or "max" values were taken for a level.
 */
class HitPointsValueData extends foundry.abstract.DataModel {
	static defineSchema() {
		return {
			granted: new MappingField(new JSONField(), { required: false, initial: undefined })
		};
	}
}

const { DocumentUUIDField: DocumentUUIDField$2, SchemaField: SchemaField$D, SetField: SetField$j, StringField: StringField$D } = foundry.data.fields;

/**
 * Configuration data for the Improvement advancement.
 *
 * @property {Set<string>} talentList - One or more talent list from which the player can choose.
 */
class ImprovementConfigurationData extends AdvancementDataModel {
	static defineSchema() {
		return {
			talentList: new SetField$j(new StringField$D(), {
				label: "BF.Advancement.Improvement.TalentList.Label"
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		if (foundry.utils.getType(source.talentList) === "string") {
			source.talentList = [source.talentList];
		}
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Value data for the Improvement advancement.
 *
 * @property {object} ability - Which ability scores were improved?
 * @property {string} ability.one
 * @property {string} ability.two
 * @property {object} talent
 * @property {BlackFlagItem} talent.document - Local document added.
 * @property {string} talent.uuid - Origin UUID of the added document.
 */
class ImprovementValueData extends foundry.abstract.DataModel {
	static defineSchema() {
		return {
			ability: new SchemaField$D({
				one: new StringField$D({ required: false, initial: undefined }),
				two: new StringField$D({ required: false, initial: undefined })
			}),
			talent: new SchemaField$D(
				{
					document: new LocalDocumentField(foundry.documents.BaseItem),
					uuid: new DocumentUUIDField$2()
				},
				{ required: false, initial: undefined }
			)
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		if (foundry.utils.getType(source.ability) === "string") {
			source.ability = { one: source.ability };
		}
	}
}

const { SetField: SetField$i, StringField: StringField$C } = foundry.data.fields;

/**
 * Configuration data for the Key Ability advancement.
 */
class KeyAbilityConfigurationData extends AdvancementDataModel {
	static defineSchema() {
		return {
			options: new SetField$i(new StringField$C(), {
				label: "BF.Advancement.KeyAbility.Options.Label",
				hint: "BF.Advancement.KeyAbility.Options.Hint"
			})
		};
	}
}

const { ArrayField: ArrayField$a, NumberField: NumberField$r, SchemaField: SchemaField$C, StringField: StringField$B } = foundry.data.fields;

/**
 * Configuration data for the Property advancement.
 */
class PropertyConfigurationData extends AdvancementDataModel {
	static defineSchema() {
		return {
			changes: new ArrayField$a(
				new SchemaField$C({
					key: new StringField$B({ required: true, label: "EFFECT.ChangeKey" }),
					value: new StringField$B({ required: true, label: "EFFECT.ChangeValue" }),
					mode: new NumberField$r({
						integer: true,
						initial: CONST.ACTIVE_EFFECT_MODES.ADD,
						label: "EFFECT.ChangeMode"
					}),
					priority: new NumberField$r()
				})
			)
		};
	}
}

const { ObjectField: ObjectField$2, StringField: StringField$A } = foundry.data.fields;

/**
 * Data model for the Scale Value advancement type.
 *
 * @property {object} scale - Sparse scale value data for each level.
 * @property {string} type - Type of data represented by this scale value.
 */
class ScaleValueConfigurationData extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			scale: new ObjectField$2(),
			type: new StringField$A({
				initial: "string",
				label: "BF.Advancement.ScaleValue.Type.Label"
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		Object.values(source.scale ?? {}).forEach(v =>
			CONFIG.Advancement.types.scaleValue.dataTypes[source.type]?.migrateData(v)
		);
	}
}

const { StringField: StringField$z } = foundry.data.fields;

/**
 * Base scale value data type that stores generic string values.
 */
class ScaleTypeString extends foundry.abstract.DataModel {
	constructor(data = {}, options = {}) {
		const explicitKeys = filteredKeys(data);
		super(data, options);
		Object.defineProperty(this, "_explicitKeys", {
			value: explicitKeys,
			writable: false,
			enumerable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			value: new StringField$z({ blank: false })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Information on how a scale value of this type is configured.
	 *
	 * @typedef {object} ScaleValueTypeMetadata
	 * @property {string} label - Name of this type.
	 * @property {string} hint - Hint for this type shown in the scale value configuration.
	 * @property {string} input - What input interface should be displayed. Default values are "string", "number", "dice",
	 *                            and "distance".
	 */

	/**
	 * Configuration information for this scale value type.
	 * @type {ScaleValueTypeMetadata}
	 */
	static metadata = Object.freeze({
		label: "BF.Advancement.ScaleValue.Type.String.Label",
		hint: "BF.Advancement.ScaleValue.Type.String.Hint",
		input: "string"
	});

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Attempt to convert another scale value type to this one.
	 * @param {ScaleValueType} original - Original type to attempt to convert.
	 * @param {object} [options] - Options which affect DataModel construction.
	 * @returns {ScaleValueType|null}
	 */
	static convertFrom(original, options) {
		return new this({ value: original.formula }, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * For scale values with multiple properties, have missing properties inherit from earlier filled-in values.
	 * @param {ScaleTypeString} value - The primary value.
	 * @param {ScaleTypeString} lastValue - The previous value.
	 * @returns {ScaleTypeString}
	 */
	static merge(value, lastValue) {
		Object.keys(lastValue ?? {}).forEach(k => (value[k] ??= lastValue[k]));
		return value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * This scale value formatted for display.
	 * @type {string|null}
	 */
	get display() {
		return this.formula;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this value currently considered empty?
	 * @type {boolean}
	 */
	get empty() {
		return !Object.values(this).some(v => !!v);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * This scale value prepared to be used in roll formulas.
	 * @type {string}
	 */
	get formula() {
		return this.value ? `${this.value}` : "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Format this object as a placeholder for display in the config form.
	 * @returns {object}
	 */
	get placeholder() {
		const placeholder = {};
		this._explicitKeys.forEach(k => (placeholder[k] = this[k]));
		placeholder.value ??= "";
		return placeholder;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Shortcut to the prepared value when used in roll formulas.
	 * @returns {string}
	 */
	toString() {
		return this.formula;
	}
}

const { NumberField: NumberField$q } = foundry.data.fields;

/**
 * Scale value data type that stores numeric values.
 */
class ScaleTypeNumber extends ScaleTypeString {
	/** @inheritDoc */
	static defineSchema() {
		return {
			value: new NumberField$q({ required: true })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				label: "BF.Advancement.ScaleValue.Type.Number.Label",
				hint: "BF.Advancement.ScaleValue.Type.Number.Hint",
				input: "number"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static convertFrom(original, options) {
		const value = Number(original.formula);
		if (Number.isNaN(value)) return null;
		return new this({ value }, options);
	}
}

const { NumberField: NumberField$p } = foundry.data.fields;

/**
 * Scale value data type that stores challenge ratings.
 */
class ScaleTypeCR extends ScaleTypeNumber {
	/** @inheritDoc */
	static defineSchema() {
		return {
			value: new NumberField$p({ required: true, min: 0 })
			// TODO: Convert to CRField that stores the value as a decimal (0.5) and coverts to and from
			// fractions ("1/2" or "Â½") for display
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				label: "BF.Advancement.ScaleValue.Type.CR.Label",
				hint: "BF.Advancement.ScaleValue.Type.CR.Hint"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get display() {
		let value = super.display;
		switch (this.value) {
			case 0.125:
				value = "&frac18;";
			case 0.25:
				value = "&frac14;";
			case 0.5:
				value = "&frac12;";
		}
		return game.i18n.format("BF.ChallengeRating.Specific", { value });
	}
}

const { NumberField: NumberField$o } = foundry.data.fields;

/**
 * Scale value data type that stores dice values.
 */
class ScaleTypeDice extends ScaleTypeString {
	/** @inheritDoc */
	static defineSchema() {
		return {
			number: new NumberField$o({ nullable: true, initial: null, integer: true, positive: true }),
			denomination: new NumberField$o({ required: true, initial: 6, integer: true, positive: true })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				label: "BF.Advancement.ScaleValue.Type.Dice.Label",
				hint: "BF.Advancement.ScaleValue.Type.Dice.Hint",
				input: "dice"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static convertFrom(original, options) {
		const [number, denomination] = (original.formula ?? "").split("d");
		if (!denomination || !Number.isNumeric(number) || !Number.isNumeric(denomination)) return null;
		return new this({ number: Number(number) || null, denomination: Number(denomination) }, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The die value to be rolled with the leading "d" (e.g. "d4").
	 * @type {string}
	 */
	get die() {
		if (!this.denomination) return "";
		return `d${this.denomination}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get formula() {
		if (!this.denomination) return null;
		return `${this.number ?? ""}${this.die}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get placeholder() {
		const placeholder = super.placeholder;
		placeholder.number ??= "";
		placeholder.denomination = placeholder.denomination ? `d${placeholder.denomination}` : "";
		return placeholder;
	}
}

const { StringField: StringField$y } = foundry.data.fields;

/**
 * Scale value data type that stores distance values.
 */
class ScaleValueTypeDistance extends ScaleTypeNumber {
	/** @inheritDoc */
	static defineSchema() {
		return {
			...super.defineSchema(),
			units: new StringField$y({ initial: "foot", label: "BF.UNITS.DISTANCE.Label" })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				label: "BF.Advancement.ScaleValue.Type.Distance.Label",
				hint: "BF.Advancement.ScaleValue.Type.Distance.Hint",
				input: "distance"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get display() {
		return formatDistance(this.value, this.units ?? "foot");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get placeholder() {
		const placeholder = super.placeholder;
		placeholder.units = CONFIG.BlackFlag.distanceUnits.localized[placeholder.units] ?? "";
		return placeholder;
	}
}

const { BooleanField: BooleanField$7, NumberField: NumberField$n, StringField: StringField$x } = foundry.data.fields;

/**
 * Scale value data that stores a feature's usage number.
 */
class ScaleTypeUsage extends ScaleTypeNumber {
	/** @inheritDoc */
	static defineSchema() {
		return {
			value: new NumberField$n({ nullable: true, integer: true, min: 0 }),
			per: new StringField$x({ blank: false, initial: "sr" }),
			infinite: new BooleanField$7({ required: false })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				label: "BF.Advancement.ScaleValue.Type.Usage.Label",
				hint: "BF.Advancement.ScaleValue.Type.Usage.Hint",
				input: "usage"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static convertFrom(original, options) {
		let value = parseInt(original.formula);
		if (Number.isNaN(value)) return null;
		if (value < 1) value = 1;
		return new this({ value }, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get display() {
		const value = this.infinite ? "âˆž" : this.value;
		const abbr = CONFIG.BlackFlag.recoveryPeriods.localizedAbbreviations[this.per];
		return [value, abbr].filter(v => v).join("/");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get formula() {
		return this.infinite ? Infinity : super.formula;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get placeholder() {
		const placeholder = super.placeholder;
		placeholder.per = CONFIG.BlackFlag.recoveryPeriods.localized[placeholder.per ?? "sr"] ?? "";
		return placeholder;
	}
}

var _module$e = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ScaleTypeCR: ScaleTypeCR,
	ScaleTypeDice: ScaleTypeDice,
	ScaleTypeDistance: ScaleValueTypeDistance,
	ScaleTypeNumber: ScaleTypeNumber,
	ScaleTypeString: ScaleTypeString,
	ScaleTypeUsage: ScaleTypeUsage,
	ScaleValueConfigurationData: ScaleValueConfigurationData
});

const { SetField: SetField$h, StringField: StringField$w } = foundry.data.fields;

/**
 * Configuration data for the Size advancement.
 */
class SizeConfigurationData extends AdvancementDataModel {
	static defineSchema() {
		return {
			options: new SetField$h(new StringField$w(), {
				initial: ["medium"],
				label: "BF.Advancement.Size.Options.Label",
				hint: "BF.Advancement.Size.Options.Hint"
			})
		};
	}
}

/**
 * Value data for the Size advancement.
 */
class SizeValueData extends foundry.abstract.DataModel {
	static defineSchema() {
		return {
			selected: new StringField$w({ label: "BF.Size.Label" })
		};
	}
}

const { ArrayField: ArrayField$9, BooleanField: BooleanField$6, DocumentIdField: DocumentIdField$2, NumberField: NumberField$m, SchemaField: SchemaField$B, SetField: SetField$g, StringField: StringField$v } =
	foundry.data.fields;

/**
 * Configuration data for the Spellcasting advancement.
 *
 * @property {string} ability - Spellcasting ability if not class's key ability.
 * @property {object} cantrips
 * @property {string} cantrips.scale - ID of scale value that represents number of cantrips known.
 * @property {string} progression - Specific progression within selected type (e.g. "full", "half", "third").
 * @property {object} rituals
 * @property {string} rituals.scale - ID of scale value that represents number of rituals known.
 * @property {boolean} rituals.restricted - Should ritual selection be restricted to a single source?
 * @property {object} slots
 * @property {string} slots.scale - ID of the scale value that represents the number of spell slots.
 * @property {string} source - Source of magic used by spellcasting (e.g. "arcane", "divine").
 * @property {object} spells
 * @property {string} spells.scale - ID of scale value that represents number of spells known.
 * @property {string} spells.mode - Method of learning spells (e.g. "all", "limited", "spellbook").
 * @property {boolean} spells.replacement - Can caster replace spell choice from previous level when leveling up?
 * @property {Set<string} spells.schools - Schools from which chosen spells must be selected.
 * @property {boolean} spells.special - Does one of the first level learned spells ignore normal restrictions?
 * @property {object} spells.spellbook
 * @property {number} spells.spellbook.firstLevel - Number of free spells written in spellbook at level one.
 * @property {number} spells.spellbook.otherLevels - Number of free spells for spellbook at subsequent levels.
 * @property {string} type - General spellcasting type (e.g. "leveled", "pact").
 */
class SpellcastingConfigurationData extends AdvancementDataModel {
	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.Spellcasting"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			ability: new StringField$v({ blank: false, initial: "intelligence" }),
			cantrips: new SchemaField$B({
				scale: new DocumentIdField$2()
			}),
			progression: new StringField$v(),
			rituals: new SchemaField$B({
				scale: new DocumentIdField$2(),
				restricted: new BooleanField$6({ initial: true })
			}),
			slots: new SchemaField$B({
				scale: new DocumentIdField$2()
			}),
			source: new StringField$v(),
			spells: new SchemaField$B({
				scale: new DocumentIdField$2(),
				mode: new StringField$v(),
				replacement: new BooleanField$6(),
				schools: new SetField$g(new StringField$v()),
				special: new BooleanField$6(),
				spellbook: new SchemaField$B({
					firstLevel: new NumberField$m({ integer: true, min: 0 }),
					otherLevels: new NumberField$m({ integer: true, min: 0 })
				})
			}),
			type: new StringField$v({ initial: "leveled" })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Summary label for this spellcasting configuration.
	 * @type {string}
	 */
	get label() {
		const source = CONFIG.BlackFlag.spellSources[this.source]?.label;
		const prepared = this.preparation ? "BF.Spellcasting.Preparation.Trait" : null;
		const typeConfig = CONFIG.BlackFlag.spellcastingTypes[this.type];
		const progression = typeConfig?.progression?.[this.progression]?.trait ?? typeConfig?.trait;
		return game.i18n
			.format("BF.Spellcasting.Trait.Display", {
				source: source ? game.i18n.localize(source) : "",
				prepared: prepared ? game.i18n.localize(prepared) : "",
				progression: progression ? game.i18n.localize(progression) : ""
			})
			.trim();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The max circle available for this advancement in this class or subclass.
	 * @type {number|null}
	 */
	get maxCircle() {
		const item = this.parent.item;
		if (!item.actor?.system.progression?.classes) return null;
		const identifier = item.type === "class" ? item.identifier : item.system.identifier.class;
		return this.parent.computeMaxCircle(item.actor.system.progression.classes[identifier].levels);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The ability used for spellcasting.
	 * @type {string|null}
	 */
	get spellcastingAbility() {
		if (this.ability) return this.ability;

		let parent = this.parent.item;
		if (parent?.type === "subclass" && parent.isEmbedded) {
			parent = parent.actor.system.progression?.classes[parent.system.identifier.class]?.document;
		}

		const keyAbility = parent?.system.advancement.byType("keyAbility")[0];
		return keyAbility?.value?.selected ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		if ("circle" in source) source.source = source.circle;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		const item = this.parent.item;
		const scaleValues = item.system?.advancement.byType("scaleValue") ?? [];
		const spellcastingValues = item.system?.advancement.byType("spellcastingValue") ?? [];

		const prepareScale = (obj, identifier) => {
			Object.defineProperty(obj, "scaleValue", {
				get() {
					return (
						item.system?.advancement.get(obj.scale) ??
						scaleValues?.find(s => s.identifier === identifier) ??
						spellcastingValues?.find(s => s.identifier === identifier)
					);
				},
				configurable: true,
				enumerable: false
			});
			Object.defineProperty(obj, identifier === "spell-slots" ? "max" : "known", {
				get() {
					const scaleValue = obj.scaleValue;
					if (!scaleValue) return 0;
					return simplifyBonus(
						`@scale.${scaleValue.parentIdentifier}.${scaleValue.identifier}`,
						item.getRollData({ deterministic: true })
					);
				},
				configurable: true,
				enumerable: false
			});
		};

		prepareScale(this.cantrips, "cantrips-known");
		prepareScale(this.rituals, "rituals-known");
		prepareScale(this.slots, "spell-slots");
		prepareScale(this.spells, "spells-known");
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {GrantedFeatureData} LearnedSpellData
 * @property {string} slot - Type of slot this fills (e.g. "normal", "cantrip", "ritual", "special", "free").
 */

/**
 * @typedef {ReplacedFeatureData} ReplacedSpellData
 * @property {string} slot - Type of slot replaced.
 */

/**
 * Value data for the Spellcasting advancement.
 *
 * @property {Record<string, LearnedSpellData[]>} added - Spells added at a given level.
 * @property {Record<string, ReplacedFeatureData>} replaced - Spells replaced at a given level.
 */
class SpellcastingValueData extends foundry.abstract.DataModel {
	static defineSchema() {
		return {
			added: new MappingField(
				new ArrayField$9(
					new SchemaField$B({
						document: new LocalDocumentField(foundry.documents.BaseItem),
						slot: new StringField$v(),
						uuid: new StringField$v() // TODO: Replace with UUIDField when available
					})
				),
				{ required: false, initial: undefined }
			),
			replaced: new MappingField(
				new SchemaField$B({
					level: new NumberField$m({ integer: true, min: 0 }),
					original: new DocumentIdField$2(),
					replacement: new DocumentIdField$2(),
					slot: new StringField$v()
				})
			)
		};
	}
}

const { ObjectField: ObjectField$1 } = foundry.data.fields;

/**
 * Data model for the Scale Value advancement type.
 *
 * @property {object} scale - Sparse scale value data for each level.
 */
class SpellcastingValueConfigurationData extends ScaleValueConfigurationData {
	/** @inheritDoc */
	static defineSchema() {
		return {
			scale: new ObjectField$1()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Type of data represented by this scale value.
	 * @type {string}
	 */
	get type() {
		return "number";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		Object.values(source.scale ?? {}).forEach(v => CONFIG.Advancement.types.scaleValue.dataTypes.number.migrateData(v));
	}
}

const { ArrayField: ArrayField$8, NumberField: NumberField$l, SchemaField: SchemaField$A, SetField: SetField$f, StringField: StringField$u } = foundry.data.fields;

/**
 * Configuration data for the Trait advancement.
 */
class TraitConfigurationData extends AdvancementDataModel {
	static defineSchema() {
		return {
			choiceMode: new StringField$u({
				initial: "inclusive",
				label: "BF.Advancement.Trait.Choice.Mode.Label",
				hint: "BF.Advancement.Trait.Choice.Mode.Hint"
			}),
			choices: new ArrayField$8(
				new SchemaField$A({
					count: new NumberField$l({
						initial: 1,
						positive: true,
						integer: true,
						label: "BF.Advancement.Trait.Count.Label"
					}),
					pool: new SetField$f(new StringField$u())
				}),
				{ label: "BF.Advancement.Trait.Choices.Label", hint: "BF.Advancement.Trait.Choices.Hint" }
			),
			grants: new SetField$f(new StringField$u(), {
				label: "BF.Advancement.Trait.Guaranteed.Label",
				hint: "BF.Advancement.Trait.Guaranteed.Hint"
			}),
			mode: new StringField$u({ initial: "default" })
		};
	}
}

/**
 * Value data for the Trait advancement.
 */
class TraitValueData extends foundry.abstract.DataModel {
	static defineSchema() {
		return {
			selected: new SetField$f(new StringField$u(), {
				required: false,
				initial: undefined
			})
		};
	}
}

var _module$d = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BaseAdvancement: BaseAdvancement,
	ChooseFeaturesConfigurationData: ChooseFeaturesConfigurationData,
	ChooseFeaturesValueData: ChooseFeaturesValueData,
	ChooseSpellsConfigurationData: ChooseSpellsConfigurationData,
	ChooseSpellsValueData: ChooseSpellsValueData,
	EquipmentConfigurationData: EquipmentConfigurationData,
	EquipmentEntryData: EquipmentEntryData,
	EquipmentValueData: EquipmentValueData,
	GrantFeaturesConfigurationData: GrantFeaturesConfigurationData,
	GrantFeaturesValueData: GrantFeaturesValueData,
	GrantSpellsConfigurationData: GrantSpellsConfigurationData,
	GrantSpellsValueData: GrantSpellsValueData,
	HitPointsConfigurationData: HitPointsConfigurationData,
	HitPointsValueData: HitPointsValueData,
	ImprovementConfigurationData: ImprovementConfigurationData,
	ImprovementValueData: ImprovementValueData,
	KeyAbilityConfigurationData: KeyAbilityConfigurationData,
	PropertyConfigurationData: PropertyConfigurationData,
	SizeConfigurationData: SizeConfigurationData,
	SizeValueData: SizeValueData,
	SpellConfigurationData: SpellConfigurationData,
	SpellcastingConfigurationData: SpellcastingConfigurationData,
	SpellcastingValueConfigurationData: SpellcastingValueConfigurationData,
	SpellcastingValueData: SpellcastingValueData,
	TraitConfigurationData: TraitConfigurationData,
	TraitValueData: TraitValueData,
	scaleValue: _module$e
});

/**
 * @typedef {object} AdvancementLevels
 *
 * @property {number} character - Character levels for advancement being applied.
 * @property {number} class - Levels in whatever class was advanced at current level.
 * @property {string} [identifier] - Class identifier if relevant.
 */

/**
 * Error that can be thrown during the advancement update preparation process.
 */
class AdvancementError extends Error {
	constructor(...args) {
		super(...args);
		this.name = "AdvancementError";
	}
}

/**
 * Abstract base class which various advancement types can subclass.
 * @param {object} [data={}] - Raw data stored in the advancement object.
 * @param {object} [options={}] - Options which affect DataModel construction.
 * @abstract
 */
class Advancement extends PseudoDocumentMixin(BaseAdvancement) {
	static ERROR = AdvancementError;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Information on how an advancement type is configured.
	 *
	 * @typedef {BaseAdvancementMetadata} AdvancementMetadata
	 * @property {string} [like] - Similar advancement type. Advancement of this type will be grouped with others
	 *                             of their "like" type when fetching from the item. Like types should generally have
	 *                             shared inheritance and similar APIs to avoid issues.
	 * @property {object} [dataModels]
	 * @property {DataModel} [dataModels.configuration] - Data model used for validating configuration data.
	 * @property {DataModel} [dataModels.value] - Data model used for validating value data.
	 * @property {number} order - Number used to determine default sorting order of advancement items.
	 * @property {string} icon - Icon used for this advancement type if no user icon is specified.
	 * @property {string} title - Title to be displayed if no user title is specified.
	 * @property {string} hint - Description of this type shown in the advancement selection dialog.
	 * @property {object} identifier
	 * @property {boolean} identifier.configurable - Should this identifier be customizable for this advancement type?
	 * @property {string} identifier.hint - Hint that is shown with the identifier.
	 * @property {boolean} configurableHint - Should the advancement hint be configurable?
	 * @property {boolean} multiLevel - Can this advancement affect more than one level? If this is set to true,
	 *                                  the level selection control in the configuration window is hidden and the
	 *                                  advancement should provide its own implementation of `Advancement#levels`
	 *                                  and potentially its own level configuration interface.
	 * @property {boolean} singleton - Only allow a single advancement of this type on an item.
	 */

	/**
	 * Configuration information for this advancement type.
	 * @type {AdvancementMetadata}
	 */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				order: 100,
				icon: "icons/svg/upgrade.svg",
				title: "BF.Advancement.Core.Title",
				hint: "",
				identifier: {
					configurable: false,
					hint: ""
				},
				configurableHint: false,
				multiLevel: false,
				singleton: false
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform the pre-localization of this data model.
	 */
	static localize() {
		Localization.localizeDataModel(this);
		this.metadata.dataModels?.configuration?.localize?.();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * List of levels in which this advancement object should be displayed. Will be a list of class levels if this
	 * advancement is being applied to classes or subclasses, otherwise a list of character levels.
	 * @returns {number[]}
	 */
	get levels() {
		return ![null, undefined].includes(this.level?.value) ? [this.level.value] : [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Minimum level that can be set for a specific advancement based on its item type.
	 * @type {number}
	 */
	get minimumLevel() {
		switch (this.item.type) {
			case "class":
				return 1;
			case "subclass":
				return 3;
			default:
				return this.level.classIdentifier ? 1 : 0;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Value data for this advancement stored on an actor.
	 * @type {DataModel|object}
	 */
	get value() {
		const value = foundry.utils.getProperty(this.actor ?? {}, this.valueKeyPath) ?? {};
		const DataModel = this.metadata.dataModels?.value;
		if (!DataModel || value instanceof DataModel) return value;
		return new DataModel(value, { parent: this });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Key path under which the value data is stored on the actor.
	 * @type {string}
	 */
	get valueKeyPath() {
		return `system.progression.advancement.${this.relativeID}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareData() {
		this.title = this.title || game.i18n.localize(this.metadata.title);
		this.icon = this.icon || this.metadata.icon;
		this.identifier = this.identifier || this.title.slugify({ strict: true });
		if (!this.metadata.multiLevel) this.level.value ??= this.minimumLevel;
		if (foundry.utils.getType(this.configuration?.prepareData) === "function") this.configuration.prepareData();
		if (foundry.utils.getType(this.value?.prepareData) === "function") this.value.prepareData();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_preCreate(data) {
		if (foundry.utils.hasProperty(data, "level") || this.metadata.multiLevel) return;
		this.updateSource({ "level.value": this.minimumLevel });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a warning key for the specified level.
	 * @param {AdvancementLevels} levels
	 * @returns {string}
	 */
	warningKey(levels) {
		return `${this.relativeID}.${this.relavantLevel(levels)}.warning`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare any warnings that should be displayed on the actor.
	 * @param {AdvancementLevels} levels - Levels for which the warning should be generated.
	 * @param {NotificationCollection} notifications - Collection into which notifications should be set.
	 * @abstract
	 */
	prepareWarnings(levels, notifications) {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Has the player made choices for this advancement at the specified level?
	 * @param {AdvancementLevels} levels - Level for which to check configuration.
	 * @returns {boolean} - Have any available choices been made?
	 */
	configuredForLevel(levels) {
		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Value used for sorting this advancement at a certain level.
	 * @param {AdvancementLevels} levels - Level for which this entry is being sorted.
	 * @returns {string} - String that can be used for sorting.
	 */
	sortingValueForLevel(levels) {
		return `${this.metadata.order.paddedString(4)} ${this.titleForLevel(levels)}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Title displayed in advancement list for a specific level.
	 * @param {AdvancementLevels} levels - Level for which to generate a title.
	 * @param {object} [options={}]
	 * @param {object} [options.flow=false] - Is this title being used in an advancement flow?
	 * @returns {string} - HTML title with any level-specific information.
	 */
	titleForLevel(levels, { flow = false } = {}) {
		return this.title;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbedContents(config, options) {
		const p = document.createElement("p");
		p.innerText = this.hint ?? "";
		return p;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Summary content displayed beneath the title in the advancement list.
	 * @param {AdvancementLevels} levels - Level for which to generate the summary.
	 * @param {object} [options={}]
	 * @param {object} [options.flow=false] - Is this summary being used in an advancement flow?
	 * @returns {string} - HTML content of the summary.
	 */
	summaryForLevel(levels, { flow = false } = {}) {
		return "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Editing Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static _validateDocumentCreation(data, context) {
		const c = CONFIG.Advancement.types[data.type];
		if (!c?.validItemTypes.has(context.parent.type) || !c?.documentClass.availableForItem(context.parent)) {
			throw new Error(`${data.type} advancement cannot be added to ${context.parent.name}`);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Update this advancement's value data stored on the actor.
	 * @param {object} [updates={}] - A differential data object.
	 * @param {DocumentModificationContext} [context={}] - Additional context which customizes the update workflow.
	 * @returns {Promise<Advancement>} - Updated advancement instance.
	 */
	async updateValue(updates = {}, context = {}) {
		if (!this.parent.isEmbedded) throw new Error("Cannot update values for an advancement not stored on an actor.");
		await this.parent.actor.update({ [`system.progression.advancement.${this.valueID}`]: updates }, context);
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can an advancement of this type be added to the provided item?
	 * @param {BlackFlagItem} item - Item to check against.
	 * @returns {boolean} - Should this be enabled as an option on the {@link AdvancementSelection} dialog?
	 */
	static availableForItem(item) {
		return this.metadata.singleton ? !item.system.advancement.byType(this.metadata.type).length : true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a new flow application for this advancement.
	 * @param {BlackFlagActor} actor - Actor to which the advancement is being applied.
	 * @param {AdvancementLevels} levels - Level for which to configure this flow.
	 * @param {object} [options={}] - Application rendering options.
	 * @returns {AdvancementFlow}
	 */
	flow(actor, levels, options) {
		const FlowClass =
			CONFIG.Advancement.types[this.type]?.sheetClasses?.flow ??
			CONFIG.Advancement.types[CONST.BASE_DOCUMENT_TYPE].sheetClasses.flow;
		return new FlowClass(actor, this, levels, options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Dynamic changes this advancement applies to the actor during data preparation. Changes will be made
	 * after base data is prepared any before active effects are applied using a mechanism similar to active
	 * effects. By default changes will be made in advancement order, but if priority is provided it can be
	 * used to adjust the order.
	 * @param {AdvancementLevels} levels - Levels being applied.
	 * @returns {EffectChangeData[]}
	 * @abstract
	 */
	changes(levels) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Locally apply this advancement to the actor.
	 * @param {AdvancementLevels} levels - Levels being advanced.
	 * @param {*} [data] - Data from the advancement form.
	 * @param {object} [options={}]
	 * @param {boolean} [options.initial=false] - Is this the initial application?
	 * @param {boolean} [options.render=true] - Should the update re-render the actor?
	 * @abstract
	 */
	async apply(levels, data, { initial = false, render = true } = {}) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Locally remove this advancement's changes from the actor.
	 * @param {AdvancementLevels} levels - Levels being removed.
	 * @param {*} [data] - Data that might guide the reversing process.
	 * @param {object} [options={}]
	 * @param {boolean} [options.render=true] - Should the update re-render the actor?
	 * @abstract
	 */
	async reverse(levels, data, { render = true } = {}) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch and item and create a clone with the proper flags.
	 * @param {string} uuid - UUID of the item to fetch.
	 * @param {object} [options={}]
	 * @param {object} [options.changes={}] - Additional changes to apply when creating the clone.
	 * @param {object} [options.data] - Data from the advancement process.
	 * @param {string} [options.id] - Optional ID to use instead of a random one.
	 * @param {number} [options.index=0] - If advancement grants more than one item, position of this particular item.
	 *                                     Helps determine proper sorting order.
	 * @returns {object|null}
	 */
	async createItemData(uuid, { changes = {}, data, id, index = 0 } = {}) {
		const source = await fromUuid(uuid);
		if (!source) return null;
		id ??= foundry.utils.randomID();
		const advancementOrigin = `${this.item.id}.${this.id}`;
		const ultimateOrigin = this.item.getFlag("black-flag", "ultimateOrigin");
		const updates = SortingHelpers.performIntegerSort(source, {
			target: ultimateOrigin && ultimateOrigin !== advancementOrigin ? this.item : undefined,
			siblings: this.item.actor.items
		});
		let sort = updates.find(u => u.target._id === source.id)?.update?.sort ?? null;
		if (sort !== null) sort += (index * CONST.SORT_INTEGER_DENSITY) / 100;
		const { _stats } = game.items.fromCompendium(source);
		return source
			.clone(
				foundry.utils.mergeObject(
					{
						_id: id,
						_stats,
						folder: null,
						sort,
						"flags.black-flag.sourceId": uuid,
						"flags.black-flag.advancementOrigin": advancementOrigin,
						"flags.black-flag.ultimateOrigin": this.item.getFlag("black-flag", "ultimateOrigin") ?? advancementOrigin
					},
					changes
				),
				{ keepId: true }
			)
			.toObject();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Helper Methods            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Select the relevant level from the provided levels data, or return null if not applicable.
	 * @param {AdvancementLevels} levels
	 * @returns {number|null}
	 */
	relavantLevel(levels) {
		if (levels.character === 0 || levels.class === 0) return 0;
		let identifier;

		// Classes & subclasses are always based on class level, as long as identifiers match
		if (this.item.type === "class") identifier = this.item.identifier;
		else if (this.item.type === "subclass") identifier = this.item.system.identifier.class;
		// Class level if explicit class identifier is set and it matches provided identifier
		else if (this.level.classIdentifier) identifier = this.level.classIdentifier;
		// Otherwise revert to character level
		else return levels.character;

		if (this.level.classRestriction) {
			const isOriginalClass = this.item.actor?.system.progression.classes[identifier]?.originalClass;
			if ((this.level.classRestriction === "original") !== isOriginalClass) return null;
		}

		return identifier === levels.identifier ? levels.class : !levels.identifier ? levels.character : null;
	}
}

/**
 * Advancement that automatically gives the player a set of features.
 */
class GrantFeaturesAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "grantFeatures",
				dataModels: {
					configuration: GrantFeaturesConfigurationData,
					value: GrantFeaturesValueData
				},
				order: 40,
				icon: "systems/black-flag/artwork/advancement/grant-features.svg",
				title: "BF.Advancement.GrantFeatures.Title",
				hint: "BF.Advancement.GrantFeatures.Hint",
				configurableHint: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The item types that can be granted by this advancement.
	 * @type {Set<string>}
	 */
	static VALID_TYPES = new Set(["feature"]);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return !foundry.utils.isEmpty(this.value.added);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbedContents(config, options) {
		if (config.list === false) return super.toEmbedContents(config, options);

		const list = config.style === "list";
		const h = list ? "strong" : config.header ?? "h6";

		const features = await Promise.all(
			this.configuration.pool.map(async f => {
				const item = await fromUuid(f.uuid);
				return [
					item,
					await TextEditor.enrichHTML(item.system.description.value, {
						...options,
						relativeTo: this,
						_embedDepth: (options._embedDepth ?? 0) + 1,
						async: true
					})
				];
			})
		);

		const container = document.createElement(list ? "ul" : "section");
		container.classList = config.classes ?? "embedded-features";
		for (const [item, description] of features) {
			const entry = document.createElement(list ? "li" : "div");
			const header = config.link ? `<a class="content-link" data-uuid="${item.uuid}">${item.name}</a>` : item.name;
			entry.innerHTML = `<${h}>${header}</${h}>\n${description}`;
			container.insertAdjacentElement("beforeend", entry);
		}

		return container;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		// Link to items on the actor
		if (flow)
			return (
				this.value.added
					?.map(
						data =>
							`<span class="choice-entry">${data.document?.toAnchor({ classes: ["content-link"] }).outerHTML ?? " "}</span>`
					)
					.join(" ") ?? ""
			);

		// Link to compendium items
		return this.configuration.pool.map(item => `<span class="choice-entry">${linkForUUID(item.uuid)}</span>`).join(" ");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Location where the added items are stored for the specified level.
	 * @param {number} level - Level being advanced.
	 * @returns {string}
	 */
	storagePath(level) {
		return "added";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		const added = await this.createItems(
			Object.values(this.configuration.pool).map(d => d.uuid),
			{ data }
		);
		return await this.actor.update(
			{
				[`${this.valueKeyPath}.${this.storagePath(this.relavantLevel(levels))}`]: added
			},
			{ render }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		const keyPath = this.storagePath(this.relavantLevel(levels));
		const deleteIds = (foundry.utils.getProperty(this.value, keyPath) ?? []).map(d => d.document?.id).filter(i => i);
		await this.actor.deleteEmbeddedDocuments("Item", deleteIds, { render: false });
		return await this.actor.update(
			{
				[`${this.valueKeyPath}.${keyPath.replace(/(\.|^)([\w\d]+)$/, "$1-=$2")}`]: null
			},
			{ render }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create items on the actor with the proper flags.
	 * @param {string[]} uuids - UUIDs of items to create.
	 * @param {object} [options={}]
	 * @param {object[]} [options.added=[]] - Existing granted items.
	 * @param {object} [options.data] - Data from the advancement process.
	 * @param {boolean} [options.render=false] - Should the update re-render the actor?
	 * @returns {object[]} - Array of data for storing in value.
	 */
	async createItems(uuids, { data, added = [], render = false } = {}) {
		const items = [];
		for (const [index, uuid] of uuids.entries()) {
			const itemData = await this.createItemData(uuid, { data, index });
			if (this.configuration.enabled === false) {
				foundry.utils.setProperty(itemData, "flags.black-flag.relationship.enabled", false);
			}
			if (!itemData) continue;
			items.push(itemData);
			added.push({ document: itemData._id, uuid });
		}
		await this.actor.createEmbeddedDocuments("Item", items, { keepId: true, keepRelationship: true, render });
		return added;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Helper Methods            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Has the actor reached the limit of this item? Based on whether other items from the same source ID are already
	 * on the actor and whether the item has the `allowMultipleTimes` restriction.
	 * @param {BlackFlagItem} item - Item to check.
	 * @returns {boolean}
	 */
	selectionLimitReached(item) {
		return !item.system.restriction?.allowMultipleTimes && !!this.actor?.sourcedItems.get(item.uuid)?.size;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Verify that the provided item can be used with this advancement based on the configuration.
	 * @param {BlackFlagItem} item - Item that needs to be tested.
	 * @param {object} config
	 * @param {boolean} [config.strict=true] - Should an error be thrown when an invalid type is encountered?
	 * @returns {boolean} - Is this type valid?
	 * @throws An error if the item is invalid and strict is `true`.
	 */
	_validateItemType(item, { strict = true } = {}) {
		if (this.constructor.VALID_TYPES.has(item.type)) return true;
		const type = game.i18n.localize(CONFIG.Item.typeLabels[item.type]);
		if (strict) throw new Error(game.i18n.format("BF.Advancement.Config.Warning.Invalid", { type }));
		return false;
	}
}

/**
 * Advancement that presents the player with a choice of multiple items that they can take. Keeps track of which
 * items were selected at which levels.
 */
class ChooseFeaturesAdvancement extends GrantFeaturesAdvancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "chooseFeatures",
				dataModels: {
					configuration: ChooseFeaturesConfigurationData,
					value: ChooseFeaturesValueData
				},
				order: 50,
				icon: "systems/black-flag/artwork/advancement/choose-features.svg",
				title: "BF.Advancement.ChooseFeatures.Title",
				hint: "BF.Advancement.ChooseFeatures.Hint",
				multiLevel: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static VALID_TYPES = new Set(["feature", "talent"]);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return Object.keys(this.configuration.choices).map(k => Number(k));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	warningKey(levels) {
		return `${this.relativeID}.${this.relavantLevel(levels)}.choice-required`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		const choicesNeeded = this.choicesRequired(this.relavantLevel(levels));
		if (choicesNeeded <= 0) return;
		const pluralRules = new Intl.PluralRules(game.i18n.lang);
		notifications.set(this.warningKey(levels), {
			category: `level-${levels.character}`,
			section: "progression",
			level: "warn",
			message: game.i18n.format(`BF.Advancement.ChooseFeatures.Notification[${pluralRules.select(choicesNeeded)}]`, {
				title: this.title,
				number: choicesNeeded
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Number of choices that still need to be made for the specified level.
	 * @param {number} level
	 * @returns {number}
	 */
	choicesRequired(level) {
		return (this.configuration.choices[level]?.count ?? 0) - (this.value.added?.[level]?.length ?? 0);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return this.choicesRequired(this.relavantLevel(levels)) <= 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	titleForLevel(levels, { flow = false } = {}) {
		const data = this.configuration.choices[this.relavantLevel(levels)] ?? {};
		let tag;
		if (data.count) tag = game.i18n.format("BF.Advancement.ChooseFeatures.Choose", { number: data.count });
		else if (data.replacement) tag = game.i18n.localize("BF.Advancement.ChooseFeatures.Replacement.Title");
		else return this.title;
		return `${this.title} <span class="choice-count">(${tag.toLowerCase()})</span>`;
		// TODO: Use type & restriction to auto-generate title
		// Then display as "Choose _" in advancement list and "_ (choose 1)" in flow
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		const items = this.value.added?.[this.relavantLevel(levels)];
		if (!items || !flow) return this.hint ?? "";
		return Object.values(items).reduce((html, data) => html + linkForUUID(data.uuid), "");
		// TODO: Cross out replaced features
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	storagePath(level) {
		return `added.${level}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		if (initial || !data?.choices?.length) return;
		const level = this.relavantLevel(levels);

		const existing = foundry.utils.getProperty(this.value._source, this.storagePath(level)) ?? [];
		const added = await this.createItems(data.choices, { added: existing });
		const valueData = { [`${this.valueKeyPath}.${this.storagePath(level)}`]: added };

		if (!this.configuration.choices[level]?.replacement) data.replaces = null;
		const original = this.actor.items.get(data.replaces);
		if (added.length && original) {
			const replacedLevel = Object.entries(this.value.added)
				.reverse()
				.reduce((level, [l, added]) => {
					if (added.find(a => a.document === original) && Number(l) > level) return Number(l);
					return level;
				}, -Infinity);
			if (Number.isFinite(replacedLevel)) {
				await this.actor.deleteEmbeddedDocuments("Item", [data.replaces], { render: false });
				valueData[`${this.valueKeyPath}.replaced.${level}`] = {
					level: replacedLevel,
					original: original.id,
					replacement: added[0].document
				};
			}
		}

		return await this.actor.update(valueData, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async reverse(levels, data, { render = true } = {}) {
		if (!data) return super.reverse(levels);
		const level = this.relavantLevel(levels);

		const keyPath = this.storagePath(level);
		const addedCollection = foundry.utils.getProperty(this.value._source, keyPath).filter(a => a.document !== data);
		await this.actor.deleteEmbeddedDocuments("Item", [data], { render: false });
		const valueData = { [`${this.valueKeyPath}.${keyPath}`]: addedCollection };

		const replaced = this.value.replaced[level];
		const uuid = this.value._source.added?.[replaced?.level]?.find(d => d.document === replaced.original)?.uuid;
		if (uuid) {
			const itemData = await this.createItemData(uuid, { data, id: replaced.original });
			await this.actor.createEmbeddedDocuments("Item", [itemData], { keepId: true, render: false });
			valueData[`${this.valueKeyPath}.replaced.-=${level}`] = null;
		}

		return await this.actor.update(valueData, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Helper Methods            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Verify that the provided item can be used with this advancement based on the configuration.
	 * @param {BlackFlagItem} item - Item that needs to be tested.
	 * @param {object} config
	 * @param {boolean} [config.flow=false] - Is this restriction being done during the flow process?
	 * @param {string} [config.type] - Type restriction on this advancement.
	 * @param {object} [config.restriction] - Additional restrictions to be applied.
	 * @param {boolean} [config.strict=true] - Should an error be thrown when an invalid type is encountered?
	 * @returns {boolean} - Is this type valid?
	 * @throws An error if the item is invalid and strict is `true`.
	 */
	_validateItemType(item, { flow = false, type, restriction, strict = true } = {}) {
		super._validateItemType(item, { strict });
		type ??= this.configuration.type;
		restriction ??= this.configuration.restriction;

		// Type restriction is set and the item type does not match the selected type
		if (type && type !== item.type) {
			const typeLabel = game.i18n.localize(CONFIG.Item.typeLabels[type]);
			if (strict) throw new Error(game.i18n.format("BF.Advancement.ChooseFeatures.Warning.Type", { type: typeLabel }));
			return false;
		}

		// If additional type restrictions applied, make sure they are valid
		if (type === "feature" && restriction.category) {
			const categoryConfig = CONFIG.BlackFlag.featureCategories[restriction.category];
			const typeConfig = categoryConfig.types?.[restriction.type];
			let errorLabel;
			if (restriction.category !== item.system.type.category) errorLabel = categoryConfig.localization;
			else if (typeConfig && restriction.type !== item.system.type.value) errorLabel = typeConfig.localization;
			if (errorLabel) {
				if (strict)
					throw new Error(
						game.i18n.format("BF.Advancement.ChooseFeatures.Warning.Type", {
							type: game.i18n.localize(`${errorLabel}[other]`).toLowerCase()
						})
					);
				return false;
			}
		}

		// Check restrictions defined by the dropped item
		if (this.actor && flow) {
			const messages = item.system.validatePrerequisites(this.actor);
			if (messages !== true && messages !== null) {
				if (strict) {
					const listFormatter = new Intl.ListFormat(game.i18n.lang, { type: "conjunction", style: "long" });
					throw new Error(
						game.i18n.format("BF.Prerequisite.Warning.Failure", {
							name: this.actor.name,
							requirements: listFormatter.format(messages),
							type: game.i18n.localize(CONFIG.Item.typeLabels[item.type]).toLowerCase()
						})
					);
				}
				return false;
			}
		}

		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Produce a list of items that can be chosen.
	 * @returns {BlackFlagItem[]}
	 */
	async choices() {
		const choices = [];
		for (const c of Object.values(this.configuration.pool)) {
			const item = await fromUuid(c.uuid);
			if (!item) {
				log(`Choice document could not be found: ${uuid}`, { level: "warn" });
				continue;
			}
			if (!this.selectionLimitReached(item)) choices.push(item);
		}
		return choices;
	}
}

/**
 * Advancement that automatically gives the player a set of spells.
 */
class GrantSpellsAdvancement extends GrantFeaturesAdvancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "grantSpells",
				dataModels: {
					configuration: GrantSpellsConfigurationData,
					value: GrantSpellsValueData
				},
				order: 45,
				icon: "systems/black-flag/artwork/advancement/grant-spells.svg",
				title: "BF.Advancement.GrantSpells.Title",
				hint: "BF.Advancement.GrantSpells.Hint"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static VALID_TYPES = new Set(["spell"]);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	warningKey(levels) {
		return `${this.relativeID}.${levels.class}.no-spellcasting-ability`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		if (this.configuredForLevel(levels)) return;
		notifications.set(this.warningKey(levels), {
			category: `level-${levels.character}`,
			section: "progression",
			level: "warn",
			message: game.i18n.localize("BF.Advancement.GrantSpells.Notification.Ability")
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	configuredForLevel(levels) {
		return this.configuration.spell.ability.size <= 1 || this.value.ability;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data = {}, { initial = false, render = true } = {}) {
		if (initial && this.configuration.spell.ability.size > 1 && !data?.ability) return;
		data.ability ??= this.configuration.spell.ability.first();
		const addUuids = new Set();
		const updateIds = new Set();
		const mode = this.configuration.spell.mode;
		for (const { uuid } of Object.values(this.configuration.pool)) {
			const existing = this.actor.sourcedItems.get(uuid);
			const match = existing?.find(e => e.getFlag("black-flag", "relationship.mode") === mode);
			if (match) updateIds.add(match.id);
			else addUuids.add(uuid);
		}
		const added = [...(await this.createItems(addUuids, { data })), ...(await this.updateItems(updateIds, { data }))];
		return await this.actor.update(
			{
				[this.valueKeyPath]: {
					ability: data.ability,
					[this.storagePath(this.relavantLevel(levels))]: added
				}
			},
			{ render }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		const keyPath = this.storagePath(this.relavantLevel(levels));
		const deleteIds = [];
		const updates = [];
		for (const added of foundry.utils.getProperty(this.value, keyPath) ?? []) {
			if (!added.document) continue;
			if (added.modified)
				updates.push({
					_id: added.document.id,
					...this.configuration.spell.getReverseChanges(added.document, data)
				});
			else deleteIds.push(added.document.id);
		}
		await this.actor.deleteEmbeddedDocuments("Item", deleteIds, { render: false });
		await this.actor.updateEmbeddedDocuments("Item", updates, { render: false });
		return await this.actor.update(
			{
				[this.valueKeyPath]: {
					ability: null,
					[keyPath.replace(/(\.|^)([\w\d]+)$/, "$1-=$2")]: null
				}
			},
			{ render }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async createItemData(uuid, options = {}) {
		return this.configuration.spell.applyChanges(await super.createItemData(uuid, options), options.data);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Update existing spells on the actor with the proper flags.
	 * @param {string[]} ids - IDs of items to update.
	 * @param {object} [options={}]
	 * @param {object} [options.data] - Data from the advancement process.
	 * @param {boolean} [options.render=false] - Should the update re-render the actor?
	 * @returns {object[]} - Array of data for storing in value.
	 */
	async updateItems(ids, { data, render = false } = {}) {
		const items = [];
		const updated = [];
		for (const id of ids) {
			const item = this.actor.items.get(id);
			const sourceId = item.flags["black-flag"]?.sourceId ?? item._stats.compendiumSource ?? item.flags.core?.sourceId;
			items.push(this.configuration.spell.applyChanges(item.toObject(), data));
			updated.push({ document: id, modified: true, uuid: sourceId });
		}
		await this.actor.updateEmbeddedDocuments("Item", items, { render });
		return updated;
	}
}

/**
 * Advancement that presents the player with a choice of multiple spells that they can take. Keeps track of which
 * spells were selected at which levels.
 */
class ChooseSpellsAdvancement extends ChooseFeaturesAdvancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "chooseSpells",
				dataModels: {
					configuration: ChooseSpellsConfigurationData,
					value: ChooseSpellsValueData
				},
				order: 55,
				icon: "systems/black-flag/artwork/advancement/choose-spells.svg",
				title: "BF.Advancement.ChooseSpells.Title",
				hint: "BF.Advancement.ChooseSpells.Hint"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static VALID_TYPES = new Set(["spell"]);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	configuredForLevel(levels) {
		return (this.configuration.spell.ability.size <= 1 || this.value.ability) && super.configuredForLevel(levels);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data = {}, { initial = false, render = true } = {}) {
		if (initial) {
			if (this.configuration.spell.ability.size === 1) {
				await this.actor.update({ [this.valueKeyPath]: { ability: this.configuration.spell.ability.first() } });
			}
			return;
		}

		data.ability ??= this.value.ability;
		if (!data.ability) {
			if (this.configuration.spell.ability.size > 1) return;
			data.ability = this.configuration.spell.ability.first();
		}

		const level = this.relavantLevel(levels);
		const existing = foundry.utils.getProperty(this.value._source, this.storagePath(level)) ?? [];

		const addUuids = new Set();
		const updateIds = new Set();
		const mode = this.configuration.spell.mode;
		for (const uuid of data.choices ?? []) {
			const existing = this.actor.sourcedItems.get(uuid);
			const match = existing?.find(e => e.getFlag("black-flag", "relationship.mode") === mode);
			if (match) updateIds.add(match.id);
			else addUuids.add(uuid);
		}
		const added = [
			...(await this.createItems(Array.from(addUuids), { added: existing, data })),
			...(await GrantSpellsAdvancement.prototype.updateItems.call(this, updateIds, { data }))
		];
		const valueData = { [this.valueKeyPath]: { ability: data.ability, [this.storagePath(level)]: added } };

		if (!this.configuration.choices[level]?.replacement) data.replaces = null;
		const original = this.actor.items.get(data.replaces);
		if (added.length && original) {
			const replacedLevel = Object.entries(this.value.added)
				.reverse()
				.reduce((level, [l, added]) => {
					if (added.find(a => a.document === original) && Number(l) > level) return Number(l);
					return level;
				}, -Infinity);
			if (Number.isFinite(replacedLevel)) {
				const entry = this.value._source.added[replacedLevel];
				if (entry.modified)
					await this.actor.updateEmbeddedDocuments(
						"Item",
						[
							{
								_id: data.replaces,
								...this.configuration.spell.getReverseChanges(original, data)
							}
						],
						{ render: false }
					);
				else await this.actor.deleteEmbeddedDocuments("Item", [data.replaces], { render: false });
				valueData[`${this.valueKeyPath}.replaced.${level}`] = {
					level: replacedLevel,
					original: original.id,
					replacement: added[0].document
				};
			}
		}

		return await this.actor.update(valueData, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async reverse(levels, data, { render = true } = {}) {
		if (!data) return GrantSpellsAdvancement.prototype.reverse.call(this, levels);
		const level = this.relavantLevel(levels);

		const keyPath = this.storagePath(level);
		let addedCollection = foundry.utils.getProperty(this.value._source, keyPath);
		const entry = addedCollection.find(a => a.document === data);
		addedCollection = addedCollection.filter(a => a.document !== data);
		if (entry.modified) {
			await this.actor.updateEmbeddedDocuments(
				"Item",
				[
					{
						_id: data,
						...this.configuration.spell.getReverseChanges(entry.document, data)
					}
				],
				{ render: false }
			);
		} else {
			await this.actor.deleteEmbeddedDocuments("Item", [data], { render: false });
		}
		const valueData = { [`${this.valueKeyPath}.${keyPath}`]: addedCollection };

		const replaced = this.value.replaced[level];
		const replacedEntry = this.value._source.added?.[replaced?.level]?.find(d => d.document === replaced.original);
		if (replacedEntry) {
			const existing = this.actor.items.get(replacedEntry.document);
			if (existing) {
				await GrantSpellsAdvancement.prototype.updateItems.call(this, [replacedEntry.document], {
					data: { ability: this.value.ability }
				});
			} else {
				const itemData = await this.createItemData(replacedEntry.uuid, { data, id: replaced.original });
				await this.actor.createEmbeddedDocuments("Item", [itemData], { keepId: true, render: false });
			}
			valueData[`${this.valueKeyPath}.replaced.-=${level}`] = null;
		}

		return await this.actor.update(valueData, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async createItemData(uuid, options = {}) {
		return this.configuration.spell.applyChanges(await super.createItemData(uuid, options), options.data);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Helper Methods            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_validateItemType(item, { type, restriction, strict = true } = {}) {
		GrantFeaturesAdvancement.prototype._validateItemType.call(this, item, { strict });
		restriction ??= this.configuration.restriction;
		restriction.circle = Number(restriction.circle);

		// No specific circle restriction, check max circle for class/character
		const circles = CONFIG.BlackFlag.spellCircles();
		if (restriction.circle === -1 && this.actor) {
			const classIdentifier =
				this.item.type === "class"
					? this.item.identifier
					: this.item.type === "subclass"
						? this.item.system.identifier.class
						: this.level.classIdentifier;
			const maxCircle =
				this.actor.system.spellcasting?.origins?.[classIdentifier]?.spellcasting.maxCircle ??
				this.actor.system.spellcasting?.maxCircle ??
				1;

			// Spell's circle is higher than max circle that can be cast
			if (item.system.circle.base > maxCircle) {
				if (strict)
					throw new Error(
						game.i18n.format("BF.Advancement.ChooseSpells.Warning.CircleMaximum", { circle: circles[maxCircle] })
					);
				return false;
			}
		}

		// Specific circle restriction
		else if (restriction.circle !== -1) {
			// Spell's circle is not equal to the specified circle
			if ((restriction.exactCircle || restriction.circle === 0) && item.system.circle.base !== restriction.circle) {
				if (strict)
					throw new Error(
						game.i18n.format(
							`BF.Advancement.ChooseSpells.Warning.${!restriction.circle ? "OnlyCantrips" : "CircleSpecific"}`,
							{ circle: circles[restriction.circle] }
						)
					);
				return false;
			}

			// Spell's circle is higher than specified circle
			else if (!restriction.exactCircle && item.system.circle.base > restriction.circle) {
				if (strict)
					throw new Error(
						game.i18n.format("BF.Advancement.ChooseSpells.Warning.CircleMaximum", {
							circle: circles[restriction.circle]
						})
					);
				return false;
			}
		}

		// Check ritual restriction
		if (restriction.circle !== 0) {
			if (restriction.allowRituals === "only" && !item.system.tags.has("ritual")) {
				if (strict) throw new Error(game.i18n.localize("BF.Advancement.ChooseSpells.Warning.OnlyRituals"));
				return false;
			} else if (!restriction.allowRituals && item.system.tags.has("ritual")) {
				if (strict) throw new Error(game.i18n.localize("BF.Advancement.ChooseSpells.Warning.NoRituals"));
				return false;
			}
		}

		// Check cantrip restriction
		if (!restriction.allowCantrips && item.system.circle.base === 0 && restriction.circle !== 0) {
			if (strict) throw new Error(game.i18n.localize("BF.Advancement.ChooseSpells.Warning.NoCantrips"));
			return false;
		}

		// Check source restriction
		if (restriction.source && !item.system.source.has(restriction.source)) {
			const source = CONFIG.BlackFlag.spellSources.localized[restriction.source];
			if (strict) throw new Error(game.i18n.format("BF.Advancement.ChooseSpells.Warning.Source", { source }));
			return false;
		}

		return true;
	}
}

/**
 * Advancement that gives a character their starting equipment.
 */
class EquipmentAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "equipment",
				dataModels: {
					configuration: EquipmentConfigurationData,
					value: EquipmentValueData
				},
				order: 32,
				icon: "systems/black-flag/artwork/advancement/equipment.svg",
				title: "BF.Advancement.Equipment.Title",
				hint: "BF.Advancement.Equipment.Hint",
				configurableHint: true,
				singleton: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can starting equipment be selected (e.g. does the actor have a class and a background)?
	 * @type {boolean}
	 */
	get canConfigure() {
		return this.actor.system.progression.background && this.actor.system.progression.levels[1]?.class;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return [this.item.type === "class" ? 1 : 0];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_preCreate(data) {
		super._preCreate(data);
		this.updateSource({ "level.classRestriction": "original" });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		if (this.configuredForLevel(levels) || !this.canConfigure) return;
		notifications.set(this.warningKey(levels), {
			category: `level-${levels.character}`,
			section: "progression",
			level: "warn",
			message: game.i18n.localize("BF.Advancement.Equipment.Notification")
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return (
			!foundry.utils.isEmpty(this.value.added) ||
			this.actor.system.progression.levels[1]?.class?.system.advancement.byType("equipment")[0]?.value.wealth
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbedContents(config, options) {
		const p = document.createElement("p");
		p.innerHTML = this.summaryForLevel();
		return p;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		if (this.hint) return this.hint;
		const labels = this.configuration.pool
			.filter(e => !e.group)
			.map(p => p.label)
			.filter(l => l);
		return labels.length ? `<ul>${labels.map(l => `<li>${l}</li>`).join("")}</ul>` : "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		let value;
		const toCreate = [];
		const toUpdate = [];

		// Starting equipment
		if (data?.assignments?.length) {
			value = {
				added: (await Promise.all(data.assignments.map(a => fromUuid(a.uuid).then(item => ({ ...a, item }))))).filter(
					i => i
				),
				contained: []
			};
			for (const addData of value.added) {
				const itemData = await BlackFlagItem.createWithContents([addData.item]);
				delete addData.item;
				const firstItem = itemData.shift();
				addData.document = firstItem._id;
				foundry.utils.setProperty(firstItem, "system.quantity", addData.count ?? 1);
				toCreate.push(firstItem);
				itemData.forEach(d => {
					value.contained.push(d._id);
					toCreate.push(d);
				});
			}
		}

		// Starting wealth
		else if (data?.wealth) {
			const currency = CONFIG.BlackFlag.startingWealth.currency;
			value = { wealth: data.wealth };

			// Check to see if existing currency exists to update
			const existingItem = this.actor.items.find(i => i.type === "currency" && i.identifier === currency);
			if (existingItem) {
				toUpdate.push({ _id: existingItem.id, "system.quantity": existingItem.system.quantity + data.wealth });
			}

			// Otherwise add a new item
			else {
				const uuid = CONFIG.BlackFlag.currencies[currency]?.uuid;
				const itemData = (await fromUuid(uuid)).toObject();
				itemData.system.quantity = data.wealth;
				toCreate.push(itemData);
			}
		}

		if (value) {
			if (toCreate.length) await this.actor.createEmbeddedDocuments("Item", toCreate, { keepId: true, render });
			if (toUpdate.length) await this.actor.updateEmbeddedDocuments("Item", toUpdate, { render });
			return await this.actor.update({ [this.valueKeyPath]: value });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		const toDelete = [...this.value.added.map(d => d.document?.id), ...this.value.contained].filter(id =>
			this.actor.items.has(id)
		);
		const toUpdate = [];

		if (this.item.type === "class" && this.value.wealth) {
			const currency = CONFIG.BlackFlag.startingWealth.currency;
			const existingItem = this.actor.items.find(i => i.type === "currency" && i.identifier === currency);
			if (existingItem) {
				const updatedQuantity = existingItem.system.quantity - this.value.wealth;
				if (updatedQuantity <= 0) toDelete.push(existingItem.id);
				else toUpdate.push({ _id: existingItem.id, "system.quantity": updatedQuantity });
			}
		}

		if (toDelete.length) await this.actor.deleteEmbeddedDocuments("Item", toDelete, { render: false });
		if (toUpdate.length) await this.actor.updateEmbeddedDocuments("Item", toUpdate, { render });
		return await this.actor.update({ [this.valueKeyPath]: { added: [], contained: [], wealth: null } });
	}
}

/**
 * Advancement that allows player to access a second talent list when taking an improvement.
 * **Can only be added to subclasses and each subclass can only have one.**
 */
class ExpandedTalentListAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "expandedTalentList",
				dataModels: {
					configuration: ImprovementConfigurationData
				},
				order: 45,
				icon: "systems/black-flag/artwork/advancement/improvement.svg",
				title: "BF.Advancement.ExpandedTalentList.Title",
				hint: "BF.Advancement.ExpandedTalentList.Hint",
				singleton: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return [3];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		const entries = Array.from(this.configuration.talentList).map(
			e =>
				`<span class="choice-entry"><span class="choice-name">${CONFIG.BlackFlag.talentCategories.localizedPlural[e]}</span></span>`
		);
		return entries.join("\n");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Summary that is used in class journal pages.
	 * @returns {string}
	 */
	async journalSummary() {
		const classDocument = await CONFIG.BlackFlag.registration.getSource("class", this.item.system.identifier.class);
		if (!classDocument) return "";

		const classImprovement = classDocument.system.advancement.byType("improvement")[0];
		const lists = Array.from(
			new Set([...(classImprovement?.configuration.talentList ?? []), ...this.configuration.talentList])
		)
			.map(t => CONFIG.BlackFlag.talentCategories.localizedDescription[t])
			.filter(t => t);

		return `<p>${game.i18n.format("BF.Advancement.ExpandedTalentList.JournalDescription", {
			class: classDocument.name,
			classLowercase: classDocument.name.toLowerCase(),
			talentLists: game.i18n.getListFormatter({ type: "disjunction", style: "short" }).format(lists)
		})}</p>`;
	}
}

/**
 * Advancement that presents the player with the option to roll hit points at each level or select the average value.
 * Keeps track of player hit point rolls or selection for each level. **Can only be added to classes and each
 * class can only have one.**
 */
class HitPointsAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "hitPoints",
				dataModels: {
					configuration: HitPointsConfigurationData,
					value: HitPointsValueData
				},
				order: 10,
				icon: "systems/black-flag/artwork/advancement/hit-points.svg",
				title: "BF.Advancement.HitPoints.Title",
				hint: "BF.Advancement.HitPoints.Hint",
				multiLevel: true,
				singleton: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Hit points granted if the average amount is taken.
	 * @type {number}
	 */
	get average() {
		return this.configuration.denomination / 2 + 1;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return Array.fromRange(CONFIG.BlackFlag.maxLevel, 1);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Total hit points provided by this advancement.
	 * @type {number}
	 */
	get total() {
		return Object.keys(this.value.granted ?? {}).reduce((t, l) => t + this.valueForLevel(parseInt(l)), 0);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	warningKey(levels) {
		return `${this.relativeID}.${levels.class}.hit-points-not-configured`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		if (this.configuredForLevel(levels)) return;
		notifications.set(this.warningKey(levels), {
			category: `level-${levels.character}`,
			section: "progression",
			level: "warn",
			message: game.i18n.localize("BF.Advancement.HitPoints.Notification")
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return this.valueForLevel(this.relavantLevel(levels)) !== null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	titleForLevel(levels, { flow = false } = {}) {
		const hp = this.valueForLevel(this.relavantLevel(levels));
		if (!hp || !flow) return this.title;
		return `${this.title}: <strong>${hp}</strong>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Hit points given at the provided level.
	 * @param {number} level - Level for which to get hit points.
	 * @returns {number|null} - Hit points for level or null if none have been taken.
	 */
	valueForLevel(level) {
		return this.constructor.valueForLevel(this.value.granted ?? {}, this.configuration.denomination, level);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Hit points given at the provided level.
	 * @param {object} data - Contents of `value` used to determine this value.
	 * @param {number} denomination - Face value of the hit die used by this advancement.
	 * @param {number} level - Level for which to get hit points.
	 * @returns {number|null} - Hit points for level or null if none have been taken.
	 */
	static valueForLevel(data, denomination, level) {
		const value = data[level];
		if (value === "max") return denomination;
		if (value === "avg") return denomination / 2 + 1;
		if (value?.total) return value.total;
		if (Number.isNumeric(value)) return Number(value);
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add the ability modifier and any bonuses to the provided hit points value to get the number to apply.
	 * @param {number} value - Hit points taken at a given level.
	 * @returns {number} - Hit points adjusted with ability modifier and per-level bonuses.
	 * @internal
	 */
	_getApplicableValue(value) {
		const abilityId = CONFIG.BlackFlag.defaultAbilities.hitPoints || "constitution";
		value = Math.max(value + (this.actor.system.abilities[abilityId]?.mod ?? 0), 1);
		value += simplifyBonus(this.actor.system.attributes.hp.bonuses.level, this.actor.getRollData());
		return value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Total hit points taking the provided ability modifier into account, with a minimum of 1 per level.
	 * This method is designed to ensure no level provides negative HP even if the constitution modifier is negative.
	 * @param {number} mod - Modifier to add per level.
	 * @returns {number} - Total hit points plus modifier.
	 */
	getAdjustedTotal(mod) {
		return Object.keys(this.value.granted ?? {}).reduce((total, level) => {
			return total + Math.max(this.valueForLevel(parseInt(level)) + mod, 1);
		}, 0);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		const level = this.relavantLevel(levels);
		if (initial) {
			data ??= this.value.granted ?? {};
			const previousLevel = this.actor.system.progression.levels[levels.character - 1];
			const previous = previousLevel?.class?.system.advancement.byType("hitPoints")[0];

			// If 1st character level, always use max HP
			if (levels.character === 1) data[level] = "max";
			// If previously level used average, use that again
			else if (previous?.value.granted?.[previousLevel?.levels.class] === "avg") data[level] = "avg";
			// Otherwise user intervention is required
			else return;
		}

		let value = this.constructor.valueForLevel(data, this.configuration.denomination, level);
		if (value === undefined) return;

		return await this.actor.update(
			{
				"system.attributes.hp.value": (this.actor.system.attributes.hp.value ?? 0) + this._getApplicableValue(value),
				[`${this.valueKeyPath}.granted`]: data
			},
			{ render }
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		const level = this.relavantLevel(levels);
		let value = this.valueForLevel(level);
		if (value === undefined) return;

		return await this.actor.update(
			{
				"system.attributes.hp.value": this.actor.system.attributes.hp.value - this._getApplicableValue(value),
				[`${this.valueKeyPath}.granted.-=${level}`]: null
			},
			{ render }
		);
	}
}

/**
 * Advancement that allows player to increase one ability score and select a talent from a specific talent list.
 * **Can only be added to classes and each class can only have one.**
 */
class ImprovementAdvancement extends GrantFeaturesAdvancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "improvement",
				dataModels: {
					configuration: ImprovementConfigurationData,
					value: ImprovementValueData
				},
				order: 45,
				icon: "systems/black-flag/artwork/advancement/improvement.svg",
				title: "BF.Advancement.Improvement.Title",
				hint: "BF.Advancement.Improvement.Hint"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static VALID_TYPES = new Set(["talent"]);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	warningKey(levels) {
		return `${this.relativeID}.${levels.class}.no-improvement-*`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		const baseKey = this.warningKey(levels).replace("-*", "");
		if (this.configuredForLevel(levels)) return;
		if (!this.value.ability)
			notifications.set(`${baseKey}-ability`, {
				category: `level-${levels.character}`,
				section: "progression",
				level: "warn",
				message: game.i18n.localize("BF.Advancement.Improvement.Notification.Ability")
			});
		if (foundry.utils.isEmpty(this.value.talent))
			notifications.set(`${baseKey}-talent`, {
				category: `level-${levels.character}`,
				section: "progression",
				level: "warn",
				message: game.i18n.localize("BF.Advancement.Improvement.Notification.Talent")
			});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	_preCreate(data) {
		if (foundry.utils.hasProperty(data, "level")) return;
		this.updateSource({ "level.value": 4 });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return (
			(this.value.ability.one && this.value.ability.two) ||
			((this.value.ability.one || this.value.ability.two) && !foundry.utils.isEmpty(this.value.talent))
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		const p1 = numberFormat(1, { sign: true });
		const p2 = numberFormat(2, { sign: true });

		if (flow) {
			const choices = [];
			const pushAbility = (value, number, key = "ability") =>
				choices.push([
					`<span class="choice-name">${CONFIG.BlackFlag.abilities.localized[value]} ${number}</span>`,
					key
				]);
			if (this.value.ability.one && this.value.ability.one === this.value.ability.two) {
				pushAbility(this.value.ability.one, p2);
			} else {
				if (this.value.ability.one)
					pushAbility(this.value.ability.one, p1, this.value.ability.two ? "ability.one" : undefined);
				if (this.value.ability.two)
					pushAbility(this.value.ability.two, p1, this.value.ability.one ? "ability.two" : undefined);
			}
			if (this.value.talent?.document) choices.push([linkForUUID(this.value.talent.document.uuid), "talent"]);
			const displayDelete = this.actor.sheet.modes.editing || !this.configuredForLevel(levels);
			return choices
				.map(
					([label, key]) =>
						`<span class="choice-entry">${label}${
							displayDelete
								? `
								<button type="button" class="link-button" data-action="remove-choice" data-key="${key}"
								        data-tooltip="BF.Advancement.Improvement.Action.Revert"
												aria-label="${game.i18n.localize("BF.Advancement.Improvement.Action.Revert")}">
									<i class="fa-solid fa-trash" inert></i>
								</button>
								`
								: ""
						}</span>`
				)
				.join(" ");
		} else {
			const choices = [
				`${game.i18n.localize("BF.Ability.Label[one]")} ${p1}`,
				...Array.from(this.configuration.talentList).map(e => CONFIG.BlackFlag.talentCategories.localizedPlural[e])
			];
			return choices.map(c => `<span class="choice-entry"><span class="choice-name">${c}</span></span>`).join(" ");
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Summary that is used in class journal pages.
	 * @returns {string}
	 */
	journalSummary() {
		let lists = Array.from(this.configuration.talentList).map(
			t => CONFIG.BlackFlag.talentCategories.localizedDescription[t]
		);
		return game.i18n.format("BF.Advancement.Improvement.Journal.Description", {
			talentList: game.i18n.format(
				`BF.Advancement.Improvement.Journal.TalentList[${getPluralRules().select(lists.length)}]`,
				{
					lists: game.i18n.getListFormatter({ type: "disjunction" }).format(lists)
				}
			)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	storagePath(level) {
		return "talent";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	changes(levels) {
		const changes = [];
		if (this.value.ability.one)
			changes.push({
				key: `system.abilities.${this.value.ability.one}.value`,
				mode: CONST.ACTIVE_EFFECT_MODES.ADD,
				value: 1
			});
		if (this.value.ability.two)
			changes.push({
				key: `system.abilities.${this.value.ability.two}.value`,
				mode: CONST.ACTIVE_EFFECT_MODES.ADD,
				value: 1
			});
		if (changes.length) return changes;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		if (initial) return;

		if (data.ability) {
			const ability = data.ability;
			data.ability = {};
			if (!this.value.ability?.one) data.ability.one = ability;
			else if (!this.value.ability?.two) data.ability.two = ability;
		}

		if (data.talent?.choice) {
			const added = await this.createItems([data.talent.choice]);
			if (added[0]) data.talent = added[0];
			else delete data.talent;
		}

		return await this.actor.update({ [`${this.valueKeyPath}`]: data }, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		const valueUpdates = {};

		if (!data?.key || data?.key === "ability") valueUpdates["-=ability"] = null;
		else if (data?.key === "ability.one") valueUpdates["ability.-=one"] = null;
		else if (data?.key === "ability.two") valueUpdates["ability.-=two"] = null;

		if (!data?.key || data?.key === "talent") {
			await this.value.talent?.document?.delete();
			valueUpdates["-=talent"] = null;
		}

		return await this.actor.update({ [`${this.valueKeyPath}`]: valueUpdates }, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Helper Methods            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Produce a list of items that can be chosen.
	 * @returns {BlackFlagItem[]}
	 */
	async choices() {
		let filters;
		if (!this.actor.getFlag(game.system.id, "unrestrictedTalents")) {
			const subclass = this.actor.system.progression.classes[this.item.identifier].subclass;
			const expandedTalentList = subclass?.system.advancement.byType("expandedTalentList")[0];
			filters = [
				{
					k: "system.type.category",
					o: "in",
					v: new Set([...this.configuration.talentList, ...(expandedTalentList?.configuration.talentList ?? [])])
				}
			];
		}
		return ((await compendiums(Item, { type: "talent", filters, index: false })) ?? []).filter(
			i => i.system.restriction?.allowMultipleTimes || !this.actor?.sourcedItems.get(i.uuid)?.size
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_validateItemType(item, { flow = false, strict = true } = {}) {
		super._validateItemType(item, { strict });

		// Check restrictions defined by the dropped item
		if (this.actor && flow) {
			const messages = item.system.validatePrerequisites(this.actor);
			if (messages !== true && messages !== null) {
				if (strict) {
					const listFormatter = new Intl.ListFormat(game.i18n.lang, { type: "conjunction", style: "long" });
					throw new Error(
						game.i18n.format("BF.Prerequisite.Warning.Failure", {
							name: this.actor.name,
							requirements: listFormatter.format(messages),
							type: game.i18n.localize(CONFIG.Item.typeLabels[item.type]).toLowerCase()
						})
					);
				}
				return false;
			}
		}

		return true;
	}
}

/**
 * Advancement that indicates one or more key abilities for a class. **Can only be added to classes and each class can
 * only have one.**
 */
class KeyAbilityAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "keyAbility",
				dataModels: {
					configuration: KeyAbilityConfigurationData
				},
				order: 15,
				icon: "systems/black-flag/artwork/advancement/key-ability.svg",
				title: "BF.Advancement.KeyAbility.Title",
				hint: "BF.Advancement.KeyAbility.Hint",
				singleton: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return [1];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	titleForLevel(levels, { flow = false } = {}) {
		const abilities = Array.from(this.configuration.options)
			.map(o => CONFIG.BlackFlag.abilities.localizedAbbreviations[o])
			.filter(a => a);
		const formatted = game.i18n.getListFormatter({ type: "conjunction", style: "short" }).format(abilities);
		return formatted ? `${this.title}: <em>${formatted}</em>` : this.title;
	}
}

/**
 * Advancement that applies arbitrary changes to the actor using an ActiveEffect-like system.
 */
class PropertyAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "property",
				dataModels: {
					configuration: PropertyConfigurationData
				},
				order: 2,
				icon: "systems/black-flag/artwork/advancement/property.svg",
				title: "BF.Advancement.Property.Title",
				hint: "BF.Advancement.Property.Hint",
				configurableHint: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	changes(levels) {
		return this.configuration.changes;
	}
}

/**
 * Advancement that represents a value that scales with class level.
 */
class ScaleValueAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "scaleValue",
				dataModels: {
					configuration: ScaleValueConfigurationData
				},
				order: 60,
				icon: "systems/black-flag/artwork/advancement/scale-value.svg",
				title: "BF.Advancement.ScaleValue.Title",
				hint: "BF.Advancement.ScaleValue.Hint",
				identifier: {
					configurable: true,
					hint: "BF.Advancement.ScaleValue.Identifier.Hint"
				},
				configurableHint: true,
				multiLevel: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Identifier under which this scale value will be grouped. Will default to the item's identifier unless
	 * the level is linked to a specific class, in which case it will use the class identifier.
	 * @type {string}
	 */
	get parentIdentifier() {
		return this.level.classIdentifier ? this.level.classIdentifier : this.item.identifier;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return Array.from(Object.keys(this.configuration.scale).map(l => Number(l)));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	titleForLevel(levels, { flow = false } = {}) {
		const value = this.valueForLevel(this.relavantLevel(levels))?.display;
		if (!value) return this.title;
		return `${this.title}: <strong>${value}</strong>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Scale value for the given level.
	 * @param {number} level - Level for which to get the scale value.
	 * @returns {ScaleValueType|null} - Scale value at the given level or null if none exists.
	 */
	valueForLevel(level) {
		const ScaleValueType = CONFIG.Advancement.types.scaleValue.dataTypes[this.configuration.type];
		const validKeys = Object.keys(new ScaleValueType());
		const data = {};
		for (const [key, value] of Object.entries(this.configuration.scale).reverse()) {
			if (Number(key) > level) continue;
			validKeys.forEach(k => (data[k] ??= value[k]));
		}
		return foundry.utils.isEmpty(data) ? null : new ScaleValueType(data);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	changes(levels) {
		const value = this.valueForLevel(this.relavantLevel(levels));
		return value
			? [
					{
						key: `system.scale.${this.parentIdentifier}.${this.identifier}`,
						mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
						value
					}
				]
			: null;
	}
}

class SizeAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "size",
				dataModels: {
					configuration: SizeConfigurationData,
					value: SizeValueData
				},
				order: 10,
				icon: "systems/black-flag/artwork/advancement/size.svg",
				title: "BF.Advancement.Size.Title",
				hint: "BF.Advancement.Size.Hint",
				configurableHint: true,
				singleton: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return [0];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	warningKey(levels) {
		return `${this.relativeID}.${this.relavantLevel(levels)}.select-size`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		if (this.configuredForLevel(levels)) return;
		notifications.set(this.warningKey(levels), {
			category: `level-${levels.character}`,
			section: "progression",
			level: "warn",
			message: game.i18n.localize("BF.Advancement.Size.Notification")
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return !!this.value.selected;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	titleForLevel(levels, { flow = false } = {}) {
		let sizes;
		if (flow && this.value.selected) {
			sizes = [game.i18n.localize(CONFIG.BlackFlag.sizes[this.value.selected].label)];
		} else if (!flow) {
			sizes = this.configuration.options.map(s => game.i18n.localize(CONFIG.BlackFlag.sizes[s].label));
		}
		if (!sizes) return this.title;
		const listFormatter = new Intl.ListFormat(game.i18n.lang, { style: "short", type: "disjunction" });
		return `${this.title}: <em>${listFormatter.format(sizes)}</em>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	changes(levels) {
		if (!this.value.selected) return;
		return [
			{
				key: "system.traits.size",
				mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
				value: this.value.selected
			}
		];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		if (initial) {
			if (this.configuration.options.size !== 1) return;
			data = this.configuration.options.first();
		}
		if (!data) return;

		return await this.actor.update({ [`${this.valueKeyPath}.selected`]: data }, { render });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		return await this.actor.update({ [`${this.valueKeyPath}.-=selected`]: null }, { render });
	}
}

const { NumberField: NumberField$k, SchemaField: SchemaField$z } = foundry.data.fields;

/**
 * Data definition template for actors with spellcasting.
 */
class SpellcastingTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			spellcasting: new SchemaField$z({
				slots: new MappingField(new SchemaField$z({
					spent: new NumberField$k({nullable: false, min: 0, initial: 0, integer: true}),
					override: new NumberField$k({integer: true, min: 0})
				}))
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate spell rings to circles.
	 * Added in 0.9.023, updated in 0.9.037
	 * @param {object} source - Candidate source data to migrate.
	 */
	static migrateCircles(source) {
		if ( "spellcasting" in source ) {
			if ( "rings" in source.spellcasting ) source.spellcasting.slots = foundry.utils.mergeObject(
				source.spellcasting.slots ?? {}, source.spellcasting.rings
			);
			if ( "circles" in source.spellcasting ) source.spellcasting.slots = foundry.utils.mergeObject(
				source.spellcasting.slots ?? {}, source.spellcasting.circles
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contribute to the actor's spellcasting progression.
	 * @param {object} progression - Spellcasting progression data. *Will be mutated.*
	 * @param {BlackFlagItem} cls - Class for which this progression is being computed.
	 * @param {object} [config={}]
	 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
	 * @param {number} [config.levels=1] - Number of levels for the class.
	 * @param {SpellcastingConfigurationData} [config.spellcasting] - Spellcasting descriptive object.
	 * @param {number} [config.count=1] - Number of classes with this type of spellcasting.
	 */
	static computeClassProgression(progression, cls, { actor, levels=1, spellcasting, count=1 }={}) {
		spellcasting = spellcasting ?? cls.system.spellcasting;
		const type = spellcasting.type;

		/**
		 * A hook event that fires while computing the spellcasting progression for each class on each actor.
		 * The actual hook names include the spellcasting type (e.g. `blackFlag.computeLeveledProgression`).
		 * @param {object} progression - Spellcasting progression data. *Will be mutated.*
		 * @param {BlackFlagItem} cls - Class for whom this progression is being computed.
		 * @param {object} config
		 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
		 * @param {number} config.levels - Number of levels for the class.
		 * @param {SpellcastingConfigurationData} config.spellcasting - Spellcasting descriptive object.
		 * @param {number} [config.count] - Number of classes with this type of spellcasting.
		 * @returns {boolean}  Explicitly return false to prevent default progression from being calculated.
		 * @function blackFlag.computeSpellcastingProgression
		 * @memberof hookEvents
		 */
		if ( Hooks.call(
			`blackFlag.compute${type.capitalize()}Progression`, progression, cls, { actor, levels, spellcasting, count }
		) === false ) return;

		if ( type === "leveled" ) this.computeLeveledProgression(progression, cls, { actor, levels, spellcasting, count });
		else if ( type === "pact" ) this.computePactProgression(progression, cls, { actor, levels, spellcasting, count });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contribute to the actor's spellcasting progression for a class with leveled spellcasting.
	 * @param {object} progression - Spellcasting progression data. *Will be mutated.*
	 * @param {BlackFlagItem} cls - Class for whom this progression is being computed.
	 * @param {object} config
	 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
	 * @param {number} [config.levels=1] - Number of levels for the class.
	 * @param {SpellcastingConfigurationData} config.spellcasting - Spellcasting descriptive object.
	 * @param {number} [config.count=1] - Number of classes with this type of spellcasting.
	 */
	static computeLeveledProgression(progression, cls, { actor, levels=1, spellcasting, count=1 }) {
		const prog = CONFIG.BlackFlag.spellcastingTypes.leveled.progression[spellcasting.progression];
		if ( prog ) {
			const roundUp = prog.roundUp !== undefined ? prog.roundUp : count === 1;
			this._computeRoundedProgression(progression, levels, prog.divisor, roundUp);
			if ( spellcasting?.cantrips.formula ) progression.cantrips = true;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contribute to the actor's spellcasting progression for a class with pact spellcasting.
	 * @param {object} progression - Spellcasting progression data. *Will be mutated.*
	 * @param {BlackFlagItem} cls - Class for whom this progression is being computed.
	 * @param {object} config
	 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
	 * @param {number} [config.levels=1] - Number of levels for the class.
	 * @param {SpellcastingConfigurationData} config.spellcasting - Spellcasting descriptive object.
	 * @param {number} [config.count=1] - Number of classes with this type of spellcasting.
	 */
	static computePactProgression(progression, cls, { actor, levels=1, spellcasting, count=1 }) {
		this._computeRoundedProgression(progression, levels, 2);
		progression.pact ??= {};
		progression.pact.circle = Math.max(progression.pact.circle ?? -Infinity, spellcasting.maxCircle);
		progression.pact.slots = Math.max(
			progression.pact.slots ?? 0,
			spellcasting.slots.scaleValue?.valueForLevel(levels) ?? 0
		);
		if ( spellcasting?.cantrips.formula ) progression.cantrips = true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Adjust the leveled count based on a divided and rounded levels value.
	 * @param {object} progression - Spellcasting progression data. *Will be mutated.*
	 * @param {number} levels - Number of levels for the class.
	 * @param {number} [divisor=1] - Amount by which to divide the levels.
	 * @param {boolean} [roundUp=false] - Should it be rounded up rather than down?
	 */
	static _computeRoundedProgression(progression, levels, divisor=1, roundUp=false) {
		const rounding = roundUp ? Math.ceil : Math.floor;
		progression.leveled += rounding(levels / divisor);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare actor's spell slots using progression data.
	 * @param {object} spells - The `system.spellcasting.slots` object within actor's data. *Will be mutated.*
	 * @param {string} type - Type of spellcasting slots being prepared.
	 * @param {object} progression - Spellcasting progression data.
	 * @param {object} [config]
	 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
	 */
	static prepareSpellcastingSlots(spells, type, progression, { actor }={}) {
		/**
		 * A hook event that fires to convert the provided spellcasting progression into spell slots.
		 * The actual hook names include the spellcasting type (e.g. `blackFlag.prepareLeveledSlots`).
		 * @param {object} spells - The `system.spells` object within actor's data. *Will be mutated.*
		 * @param {object} progression - Spellcasting progression data.
		 * @param {object} config
		 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
		 * @returns {boolean} - Explicitly return false to prevent default preparation from being performed.
		 * @function blackFlag.prepareSpellcastingSlots
		 * @memberof hookEvents
		 */
		if ( Hooks.call(`blackFlag.prepare${type.capitalize()}Slots`, spells, progression, { actor }) === false ) return;

		if ( type === "leveled" ) this.prepareLeveledSlots(spells, progression, { actor });
		else if ( type === "pact" ) this.preparePactSlots(spells, progression, { actor });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare leveled spell slots using progression data.
	 * @param {object} spells - The `system.spellcasting.slots` object within actor's data. *Will be mutated.*
	 * @param {object} progression - Spellcasting progression data.
	 * @param {object} config
	 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
	 */
	static prepareLeveledSlots(spells, progression, { actor }) {
		// Prepare cantrips
		if ( progression.cantrips ) {
			const cantrips = spells.cantrip ??= { spent: 0 };
			cantrips.max = Infinity;
			Object.defineProperty(cantrips, "level", { value: 0, enumerable: false, writable: false });
			Object.defineProperty(cantrips, "label", {
				value: CONFIG.BlackFlag.spellCircles({ plural: true })[0] ?? "", enumerable: false
			});
		}

		const levels = Math.clamp(progression.leveled, 0, CONFIG.BlackFlag.maxLevel);
		const slots = CONFIG.BlackFlag.spellSlotTable[Math.min(levels, CONFIG.BlackFlag.spellSlotTable.length)] ?? [];
		for ( const level of Array.fromRange(CONFIG.BlackFlag.maxSpellCircle, 1) ) {
			const slot = spells[`circle-${level}`] ??= { spent: 0 };
			slot.allowOverride = true;
			slot.maxPlaceholder = slots[level] ?? 0;
			slot.max = Number.isNumeric(slot.override) ? Math.max(parseInt(slot.override), 0) : slot.maxPlaceholder;
			Object.defineProperty(slot, "type", { value: "leveled", enumerable: false, writable: false });
			Object.defineProperty(slot, "circle", { value: level, enumerable: false, writable: false });
			Object.defineProperty(slot, "label", {
				value: CONFIG.BlackFlag.spellCircles({ plural: true })[level] ?? "", enumerable: false
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare pact spell slots using progression data.
	 * @param {object} spells - The `system.spellcasting.slots` object within actor's data. *Will be mutated.*
	 * @param {object} progression - Spellcasting progression data.
	 * @param {object} config
	 * @param {BlackFlagActor} [config.actor] - Actor for whom the data is being prepared.
	 */
	static preparePactSlots(spells, progression, { actor }) {
		const slot = spells.pact ??= { spent: 0 };
		slot.allowOverride = true;
		slot.maxPlaceholder = progression.pact.slots ?? 0;
		slot.max = Number.isNumeric(slot.override) ? Math.max(parseInt(slot.override), 0) : slot.maxPlaceholder;
		Object.defineProperty(slot, "type", { value: "pact", enumerable: false, writable: false });
		Object.defineProperty(slot, "circle", { value: progression.pact.circle ?? 1, enumerable: false, writable: false });
		const circle = CONFIG.BlackFlag.spellCircles({ plural: true })[slot.circle];
		Object.defineProperty(slot, "label", {
			value: game.i18n.format("BF.Spellcasting.Type.Pact.Section", { circle, circleLowercase: circle.toLowerCase() }),
			enumerable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Resting               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any spell slot recovery needed for this rest.
	 * @param {string} type - Type of spellcasting slots being recovered.
	 * @param {RestConfiguration} [config={}] - Configuration options for the rest.
	 * @param {RestResult} [result={}] - Rest result being constructed.
	 */
	getRestSpellcastingRecovery(type, config={}, result={}) {
		/**
		 * Perform any spell slot recovery needed for this rest.
		 * The actual hook names include the spellcasting type (e.g. `blackFlag.getRestLeveledRecovery`).
		 * @param {object} config
		 * @param {BlackFlagActor} config.actor - Actor being rested.
		 * @param {string} config.type - Type of spellcasting slots being recovered.
		 * @param {RestConfiguration} config.config - Configuration options for the rest.
		 * @param {RestResult} config.result - Rest result being constructed.
		 * @returns {boolean} - Explicitly return false to prevent default rest recovery from being performed.
		 * @function blackFlag.getRestRecovery
		 * @memberof hookEvents
		 */
		if ( Hooks.call(`blackFlag.getRest${type.capitalize()}Recovery`, {
			actor: this.parent, type, config, result
		}) === false ) return;

		for ( const [key, slot] of Object.entries(this.spellcasting.slots) ) {
			if ( slot.type !== type ) continue;
			result.actorUpdates[`system.spellcasting.slots.${key}.spent`] = 0;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate the cantrip scaling for a given level.
	 * @param {number} level - Player level or NPC challenge rating.
	 * @returns {number}
	 */
	static calculateCantripScale(level) {
		return Math.floor((level + 1) / 6);
	}
}

class SpellcastingAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "spellcasting",
				dataModels: {
					configuration: SpellcastingConfigurationData,
					value: SpellcastingValueData
				},
				order: 35,
				icon: "systems/black-flag/artwork/advancement/spellcasting.svg",
				title: "BF.Advancement.Spellcasting.Title",
				hint: "BF.Advancement.Spellcasting.Hint",
				singleton: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Instance Properties         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get levels() {
		return Array.fromRange(CONFIG.BlackFlag.maxLevel, 1).filter(
			level =>
				level === this.level.value ||
				(this.actor && (this.replacesSpellAt(level) || this.gainsSpellsAt(level) || this.learnsSpellsAt(level)))
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this a level where you gain a new circle of spells?
	 * @param {number} level
	 * @returns {boolean}
	 */
	gainsSpellsAt(level) {
		if (level < this.level.value) return false;
		return this.configuration.spells.mode === "all" && this.computeMaxCircle(level) > this.computeMaxCircle(level - 1);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this a level where you can learn new spells?
	 * @param {number} level
	 * @returns {boolean}
	 */
	learnsSpellsAt(level) {
		if (level < this.level.value) return false;
		if (level in (this.configuration.cantrips.scaleValue?.configuration.scale ?? {})) return true;
		if (level in (this.configuration.rituals.scaleValue?.configuration.scale ?? {})) return true;
		switch (this.configuration.spells.mode) {
			case "limited":
				return level in (this.configuration.spells.scaleValue?.configuration.scale ?? {});
			case "spellbook":
				return this.configuration.spells.spellbook[level === this.level.value ? "firstLevel" : "otherLevels"] > 0;
		}
		return false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Can a spell be replaced at this level?
	 * @param {number} level
	 * @returns {boolean}
	 */
	replacesSpellAt(level) {
		if (level <= this.level.value) return false;
		return this.configuration.spells.replacement && this.configuration.spells.mode === "limited";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		const level = this.relavantLevel(levels);
		return !!this.value.added?.[level]?.length;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Generate a table with spellcasting details for this item.
	 * @returns {object}
	 */
	generateSpellcastingTable() {
		const table = { rows: [] };

		/**
		 * A hook event that fires to generate the table for custom spellcasting types.
		 * The actual hook names include the spellcasting type (e.g. `blackFlag.buildPsionicSpellcastingTable`).
		 * @param {object} table - Table definition being built. *Will be mutated.*
		 * @param {BlackFlagItem} item - Class for which the spellcasting table is being built.
		 * @param {SpellcastingConfigurationData} spellcasting - Spellcasting configuration.
		 * @function blackFlag.buildSpellcastingTable
		 * @memberof hookEvents
		 */
		if (
			Hooks.call(`blackFlag.build${this.type.capitalize()}SpellcastingTable`, table, this.item, this.configuration) ===
			false
		)
			return table;

		const baseSlots = {};
		Array.fromRange(CONFIG.BlackFlag.maxSpellCircle, 1).forEach(l => (baseSlots[`circle-${l}`] = {}));

		let largestSlot;
		for (const level of Array.fromRange(CONFIG.BlackFlag.maxLevel, 1).reverse()) {
			const divisor = CONFIG.BlackFlag.spellcastingTypes.leveled.progression[this.configuration.progression]?.divisor;
			const progression = { leveled: 0 };
			const slots = foundry.utils.deepClone(baseSlots);
			if (level >= (divisor ?? 1)) {
				SpellcastingTemplate.computeClassProgression(progression, this.item, {
					levels: level,
					spellcasting: this.configuration
				});
				SpellcastingTemplate.prepareSpellcastingSlots(slots, "leveled", progression);
			}

			if (!largestSlot)
				largestSlot = Object.values(slots).reduce(
					(slot, data) => (data.max && data.circle > slot ? data.circle : slot),
					-1
				);

			table.rows.push(
				Array.fromRange(largestSlot, 1).map(circle => {
					return { class: "spell-slots", content: slots[`circle-${circle}`]?.max || "&mdash;" };
				})
			);
		}

		// Prepare headers & columns
		const circles = CONFIG.BlackFlag.spellCircles();
		table.headers = [Array.fromRange(largestSlot, 1).map(circle => ({ content: circles[circle] }))];
		table.cols = [{ class: "spellcasting", span: largestSlot }];
		table.rows.reverse();

		return table;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Details on how many spells of each type there are to learn for a level.
	 * @param {AdvancementLevels} levels - Level for which to get the details.
	 * @returns {Map<string, { learned: number, total: number }>}
	 */
	statsForLevel(levels) {
		const level = this.relavantLevel(levels);
		const isFirstLevel = level === this.level.value;
		const stats = new Map([
			["cantrips", {}],
			["rituals", {}],
			["spells", {}],
			["special", {}],
			["spellbook:free", {}],
			["spellbook:paid", {}],
			["replacement", {}],
			["auto", {}]
		]);
		stats.needToLearn = false;

		for (const type of ["cantrips", "rituals", "spells"]) {
			const scale = this.configuration[type].scaleValue;
			stats.get(type).total = (scale?.valueForLevel(level)?.value ?? 0) - (scale?.valueForLevel(level - 1)?.value ?? 0);
			stats.get(type).learned = 0;
			if (type === "spells" && isFirstLevel && this.configuration.spells.special) {
				stats.get(type).total -= 1;
				stats.get("special").total = 1;
			}
		}

		if (this.configuration.spells.mode === "spellbook") {
			stats.get("spellbook:free").total = isFirstLevel
				? this.configuration.spells.spellbook.firstLevel
				: this.configuration.spells.spellbook.otherLevels;
		}

		if (this.replacesSpellAt(level)) stats.get("replacement").total = 1;
		const replacedSpell = this.value.replaced?.[level]?.id;

		for (const data of this._getAddedSpells(levels)) {
			if (replacedSpell === data.document || !stats.get(data.slot)) continue;
			stats.get(data.slot).learned ??= 0;
			stats.get(data.slot).learned += 1;
		}

		for (const [type, data] of stats.entries()) {
			data.total ??= 0;
			data.learned ??= 0;
			data.toLearn = Math.max(data.total - data.learned, 0);
			if (data.toLearn && type !== "replacement") stats.needToLearn = true;
		}

		return stats;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		if (!flow) return this.configuration.label;
		const level = this.relavantLevel(levels);
		const changes = [];
		for (const spell of this._getAddedSpells(levels)) {
			const doc = this.actor.items.get(spell.document) ?? fromUuidSync(spell.uuid);
			if (doc && spell.slot !== "auto")
				changes.push({
					link: linkForUUID(doc.uuid),
					replaced: doc.id !== spell.document
				});
		}
		if (this.gainsSpellsAt(level)) {
			const circle = this.computeMaxCircle(level);
			changes.push({
				link: `<span class="choice-name">${game.i18n.format("BF.Advancement.Spellcasting.CircleSpells", {
					circle: CONFIG.BlackFlag.spellCircles()[circle]
				})}`
			});
		}
		return changes.map(c => `<span class="choice-entry${c.replaced ? " replaced" : ""}">${c.link}</span>`).join(" ");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		const level = this.relavantLevel(levels);
		const added = this._getAddedSpells(levels) ?? [];

		if (data) {
			const valueData = {};
			const toRemove = [];

			const existingReplacement = this.value.replaced?.[level];
			const replacedSlot = this.value._source.added?.[
				data.replacement?.original?.level ?? existingReplacement?.level
			]?.find(a => a.document === data.replacement?.original?.id ?? existingReplacement?.original);
			let replacementKeyPath;
			if (replacedSlot) {
				data.added ??= [];

				// If replaced spell has changed, restore previously replaced spell and remove the newly replaced spell
				if (data.replacement?.original?.id !== existingReplacement?.original) {
					if (existingReplacement?.original) toAdd.push(replacedSlot);
					if (data.replacement?.original?.id) toRemove.push(data.replacement.original.id);
				}

				// If replacement spell has changed, remove the old one and add the new one using the replaced slot type
				const existingSource = this.actor.items.get(existingReplacement?.replacement)?.system._compendiumSource;
				if (data.replacement?.replacement !== existingSource) {
					data.added.push({ uuid: data.replacement.replacement, slot: "replacement" });
					if (existingReplacement?.replacement) {
						toRemove.push(existingReplacement.replacement);
						added.findSplice(a => a.document === existingReplacement.replacement);
					}
				}

				if (data.replacement) {
					replacementKeyPath = `${this.valueKeyPath}.replaced.${level}`;
					const originalReplacedSlot =
						this.value._source.replaced?.[data.replacement?.original?.level ?? existingReplacement?.level]?.slot;
					valueData[replacementKeyPath] = {
						level: data.replacement?.original?.level ?? existingReplacement?.level,
						original: replacedSlot.document,
						slot: originalReplacedSlot ?? replacedSlot.slot
					};
				} else {
					valueData[`${this.valueKeyPath}.replaced.-=${level}`] = null;
				}
			}

			if (toRemove.length) await this.actor.deleteEmbeddedDocuments("Item", toRemove, { render: false });
			if (data.added?.length) {
				await this.createSpells(data.added ?? [], { added, data });
				valueData[`${this.valueKeyPath}.added.${level}`] = added;
				if (replacementKeyPath) {
					valueData[replacementKeyPath].replacement = added.find(a => a.slot === "replacement")?.document;
				}
			}
			return await this.actor.update(valueData, { render });
		}

		// Gain all spells of a certain circle
		else if ((initial || !data) && this.gainsSpellsAt(level)) {
			const existingSpells = this._getExistingSpells();
			const spells = await compendiums(Item, {
				type: "spell",
				filters: [
					{ k: "system.source", o: "has", v: this.configuration.source },
					{ k: "system.circle.base", v: this.computeMaxCircle(level) },
					{ o: "NOT", v: { k: "system.tags", o: "has", v: "ritual" } }
				]
			});
			await this.createSpells(
				spells.filter(s => !existingSpells.has(s.uuid)).map(s => ({ uuid: s.uuid, slot: "auto" })),
				{ added, data }
			);
			return await this.actor.update(
				{
					[`${this.valueKeyPath}.added.${level}`]: added
				},
				{ render }
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		let deleteIds;
		const level = this.relavantLevel(levels);

		// Remove a specific selected spell
		if (data) {
			if (data.deleteIds?.size) {
				await this.actor.deleteEmbeddedDocuments("Item", Array.from(data.deleteIds), { render: false });
				return await this.actor.update(
					{
						[`${this.valueKeyPath}.added.${level}`]: this._getAddedSpells(levels).filter(
							a => !data.deleteIds.has(a.document)
						)
					},
					{ render }
				);
			}
		}

		// Remove all spells for this level
		else {
			const r = this.value.replaced?.[level];
			const replacedSlot = this.value._source.added?.[r?.level]?.find(a => a.document === r?.original);
			if (replacedSlot) await this.createSpells([replacedSlot], { data });

			deleteIds = (this.value.added?.[level] ?? []).map(d => d.document?.id).filter(i => i);
			await this.actor.deleteEmbeddedDocuments("Item", deleteIds, { render: false });
			return await this.actor.update(
				{
					[`${this.valueKeyPath}.added.-=${level}`]: null,
					[`${this.valueKeyPath}.replaced.-=${level}`]: null
				},
				{ render }
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply the appropriate changes to the spells before adding them to the sheet.
	 * @param {Partial<LearnedSpellData>[]} toAdd - UUIDs of spells to create.
	 * @param {object} [options={}]
	 * @param {object[]} [options.added=[]] - Existing granted spells.
	 * @param {object} [options.data] - Data from the advancement process.
	 * @param {boolean} [options.render=false] - Should the update re-render the actor?
	 * @returns {object[]} - Array of data for storing in value.
	 */
	async createSpells(toAdd, { added = [], data, render = false } = {}) {
		const spells = [];
		for (const [index, toAddData] of toAdd.entries()) {
			const origin = { source: this.configuration.source, identifier: this.item.identifier };
			const spellData = await this.createItemData(toAddData.uuid, {
				changes: { [`flags.${game.system.id}.relationship`]: { mode: "standard", origin } },
				data,
				id: toAddData.document,
				index
			});
			if (
				foundry.utils.getProperty(spellData, "system.circle.base") > 0 &&
				!CONFIG.BlackFlag.spellLearningModes[this.configuration.spells.mode]?.prepared
			) {
				foundry.utils.setProperty(spellData, `flags.${game.system.id}.relationship.alwaysPrepared`, true);
			}
			if (!spellData) continue;
			spells.push(spellData);
			added.push({ ...toAddData, document: spellData._id });
		}
		await this.actor.createEmbeddedDocuments("Item", spells, { keepId: true, keepRelationship: true, render });
		return added;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Helper Methods            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Highest circle of spells available depending on spellcasting type and progression.
	 * @param {number} level - Class level to use for calculating the max circle.
	 * @returns {number|null}
	 */
	computeMaxCircle(level) {
		const data = { circle: null };
		const { type, progression } = this.configuration;

		/**
		 * A hook event that fires while determining the max circle available for a specific spellcasting method.
		 * @param {object} data
		 * @param {number} data.circle - The maximum allowed circle.
		 * @param {number} level - Class level to use for calculating the max circle.
		 * @param {string} progression - Spellcasting progression type.
		 * @param {SpellcastingAdvancement} spellcasting - The spellcasting advancement.
		 * @function blackFlag.computeSpellcastingMaxCircle
		 * @memberof hookEvents
		 */
		Hooks.callAll(`blackFlag.compute${type.capitalize()}MaxCircle`, data, level, progression, this);

		if (data.circle) return data.circle;

		const TABLE = CONFIG.BlackFlag.spellSlotTable;
		switch (type) {
			case "leveled":
				const divisor = CONFIG.BlackFlag.spellcastingTypes.leveled.progression[progression]?.divisor ?? 1;
				const leveledRow = TABLE[Math.clamp(Math.ceil(level / divisor), 0, TABLE.length - 1)];
				if (leveledRow?.length) data.circle = leveledRow.length - 1;
				break;
			case "pact":
				const pactRow = TABLE[Math.clamp(Math.ceil(level / 2), 0, TABLE.length - 1)];
				if (pactRow?.length) data.circle = pactRow.length - 1;
				break;
		}

		return data.circle;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get an adjusted version of the added data for a level that takes manually deleted spells into account.
	 * @param {AdvancementLevels} levels - Levels for which to fetch the data.
	 * @returns {LearnedSpellData[]}
	 */
	_getAddedSpells(levels) {
		const valueSource = foundry.utils.getProperty(this.actor?.toObject() ?? {}, this.valueKeyPath) ?? {};
		const level = this.relavantLevel(levels);
		const added = foundry.utils.deepClone(valueSource.added?.[level]);
		if (!added) return [];

		const replaced = Object.values(valueSource.replaced ?? {})
			.flat()
			.filter(r => r.level === level)
			.map(r => r.original);

		for (const a of added) {
			if (replaced.includes(a.document)) a.replaced = true;
		}

		const existing = this._getExistingSpells();
		return added.filter(a => a.replaced || existing.has(a.uuid));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine what spells are already on the sheet in standard preparation mode.
	 * @param {object} [options={}]
	 * @param {boolean} [options.identifiers=false] - Return spell identifiers, rather than UUIDs.
	 * @returns {Set<string>} - Set of spell UUIDs that already exist.
	 * @internal
	 */
	_getExistingSpells({ identifiers = false } = {}) {
		const existingSpells = new Set();
		if (!this.actor) return existingSpells;
		for (const spell of this.actor.items) {
			if (spell.type !== "spell") continue;
			const { mode } = spell.getFlag(game.system.id, "relationship") ?? {};
			if (!["standard", undefined].includes(mode)) continue;
			const sourceId =
				foundry.utils.getProperty(spell, "_stats.compendiumSource") ??
				foundry.utils.getProperty(spell, "flags.black-flag.sourceId");
			existingSpells.add(identifiers ? spell.identifier : sourceId);
		}
		return existingSpells;
	}
}

/**
 * Advancement that represents spells, rituals, or cantrips known.
 */
class SpellcastingValueAdvancement extends ScaleValueAdvancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "spellcastingValue",
				like: "scaleValue",
				dataModels: {
					configuration: SpellcastingValueConfigurationData
				},
				order: 37,
				title: "BF.Advancement.SpellcastingScale.Title",
				identifier: {
					configurable: false
				},
				configurableHint: false,
				multiLevel: true
			},
			{ inplace: false }
		)
	);
}

class TraitAdvancement extends Advancement {
	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "trait",
				dataModels: {
					configuration: TraitConfigurationData,
					value: TraitValueData
				},
				order: 30,
				icon: "systems/black-flag/artwork/advancement/trait.svg",
				title: "BF.Advancement.Trait.Title",
				hint: "BF.Advancement.Trait.Hint",
				configurableHint: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Preparation Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare data for the Advancement.
	 */
	prepareData() {
		const traitConfig = CONFIG.BlackFlag.traits[this.bestGuessTrait()];
		this.title = this.title || game.i18n.localize(traitConfig?.labels.title || this.metadata.title);
		this.icon = this.icon || traitConfig?.icon || this.metadata.icon;
		this.identifier = this.identifier || this.title.slugify({ strict: true });
		if (!this.metadata.multiLevel) this.level ??= this.minimumLevel;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	warningKey(levels) {
		return `${this.relativeID}.${this.relavantLevel(levels)}.select-${this.title.slugify()}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareWarnings(levels, notifications) {
		if (this.configuredForLevel(levels)) return;
		const { label } = this.availableChoices() ?? {};
		if (!label) return;
		notifications.set(this.warningKey(levels), {
			category: `level-${levels.character}`,
			section: "progression",
			level: "warn",
			message: label
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Display Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	configuredForLevel(levels) {
		return this.unfulfilledChoices().available.length === 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	sortingValueForLevel(levels) {
		const traitOrder = Object.keys(CONFIG.BlackFlag.traits).findIndex(k => k === this.bestGuessTrait());
		const modeOrder = Object.keys(CONFIG.BlackFlag.traitModes).findIndex(k => k === this.configuration.mode);
		const order = traitOrder + modeOrder * 100;
		return `${this.metadata.order.paddedString(4)} ${order.paddedString(4)} ${this.titleForLevel(levels)}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	summaryForLevel(levels, { flow = false } = {}) {
		if (this.hint) return `<p>${this.hint}</p>`;
		return `<p>${localizedList(this.configuration.grants, this.configuration.choices, {
			choiceMode: this.configuration.choiceMode
		})}</p>`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Application Methods         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	changes(levels) {
		if (!this.value.selected) return;
		const changes = [];
		for (const key of this.value.selected) {
			const keyPath = changeKeyPath(key);
			const existingValue = foundry.utils.getProperty(this.actor, keyPath);
			if (foundry.utils.getType(existingValue) === "Set") {
				changes.push({
					key: keyPath,
					mode: CONST.ACTIVE_EFFECT_MODES.ADD,
					value: key.split(":").pop()
				});
			} else {
				changes.push({
					key: keyPath,
					mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
					priority: Object.keys(CONFIG.BlackFlag.traitModes).findIndex(k => k === this.configuration.mode) * 10,
					value:
						this.configuration.mode === "default" || (this.configuration.mode === "upgrade" && existingValue === 0)
							? 1
							: 2
				});
			}
		}
		return changes;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async apply(levels, data, { initial = false, render = true } = {}) {
		if (initial) {
			data = new Set();

			// Any grants will be included automatically
			// this.configuration.grants.forEach(k => data.add(k));

			const { available } = this.unfulfilledChoices();
			for (const { set } of available) {
				if (set.size !== 1) continue;
				data.add(set.first());
			}
		}
		if (!data?.size) return;

		const selectedCollection = this.value.selected ?? new Set();
		data.forEach(d => selectedCollection.add(d));
		return await this.actor.update({ [`${this.valueKeyPath}.selected`]: Array.from(selectedCollection) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async reverse(levels, data, { render = true } = {}) {
		if (!this.value.selected) return;
		if (!data) return await this.actor.update({ [`${this.valueKeyPath}.-=selected`]: null });

		const selectedCollection = this.value.selected;
		selectedCollection.delete(data);
		return await this.actor.update({ [`${this.valueKeyPath}.selected`]: Array.from(selectedCollection) });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Helper Methods           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Two sets of keys based on actor data, one that is considered "selected" and thus unavailable to be chosen
	 * and another that is "available". This is based off configured advancement mode.
	 * @returns {{selected: Set<string>, available: Set<string>}}
	 */
	actorSelected() {
		const selected = new Set();
		const available = new Set();

		// If "default" mode is selected, return all traits
		// If any other mode is selected, only return traits that support expertise
		const traitTypes =
			this.configuration.mode === "default"
				? Object.keys(CONFIG.BlackFlag.traits)
				: filteredKeys(CONFIG.BlackFlag.traits, t => t.expertise);

		for (const trait$1 of traitTypes) {
			const actorValues$1 = actorValues(this.actor, trait$1);
			const choices$1 = choices(trait$1, { prefixed: true });
			for (const key of choices$1.set) {
				const value = actorValues$1[key] ?? 0;
				if (this.configuration.mode === "default") {
					if (value >= 1) selected.add(key);
					else available.add(key);
				} else {
					if (value === 2) selected.add(key);
					if (this.configuration.mode === "expertise" && value === 1) available.add(key);
					else if (this.configuration.mode !== "expertise" && value < 2) available.add(key);
				}
			}
		}

		return { selected, available };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Guess the trait type from the grants & choices on this advancement.
	 * @param {Set<string>[]} [pools] - Trait pools to use when figuring out the type.
	 * @returns {string|void}
	 */
	bestGuessTrait(pools) {
		let trait;
		pools ??= [this.configuration.grants, ...this.configuration.choices.map(c => c.pool)];
		for (const pool of pools) {
			for (const key of pool) {
				const type = key.split(":").shift();
				if (!trait) trait = type;
				if (trait !== type) return;
			}
		}
		return trait;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the list of available traits from which the player can choose.
	 * @returns {{choices: SelectChoices, label: string}|null}
	 */
	availableChoices() {
		let { available, choices } = this.unfulfilledChoices();

		// If all traits of this type are already assigned, then nothing new can be selected
		if (foundry.utils.isEmpty(choices))
			return {
				choices,
				label: game.i18n.format("BF.Advancement.Trait.Notification", {
					count: numberFormat(available.length, { spelledOut: true }),
					type: traitLabel(this.bestGuessTrait(), available.length)
				})
			};

		// Remove any grants that have no choices remaining
		available = available.filter(a => a.set.size > 0);

		const remainingSet = new Set(available.flatMap(a => Array.from(a.set)));
		choices.filter(remainingSet);

		// Simplify label if exclusive mode and more than one set of choices still available
		const simplifyNotification =
			this.configuration.choiceMode === "exclusive" && new Set(available.map(a => a._index)).size > 1;

		return {
			choices,
			label: game.i18n.format(`BF.Advancement.Trait.Notification${simplifyNotification ? "Simple" : ""}`, {
				count: numberFormat(available.length, { spelledOut: true }),
				type: traitLabel(this.bestGuessTrait(available.map(a => a.set)), available.length)
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine which of the provided grants, if any, still needs to be fulfilled.
	 * @returns {{ available: SelectChoices[], choices: SelectChoices }}
	 */
	unfulfilledChoices() {
		const actorData = this.actorSelected();
		const selected = {
			actor: actorData.selected,
			item: this.value.selected ?? new Set()
		};

		// Duplicate choices a number of times equal to their count to get numbers correct
		const choices = Array.from(this.configuration.choices.entries()).reduce((arr, [index, choice]) => {
			const set = new Set(choice.pool);
			set._index = index;
			let count = choice.count;
			while (count > 0) {
				arr.push(set);
				count -= 1;
			}
			return arr;
		}, []);

		// If everything has already been selected, no need to go further
		if (this.configuration.grants.size + choices.length <= selected.item.size) {
			return { available: [], choices: new SelectChoices() };
		}

		let available = [
			...this.configuration.grants.map(g => mixedChoices(new Set([g]))),
			...choices.map(c => {
				const choices = mixedChoices(c);
				if (c._index !== undefined) Object.defineProperty(choices, "_index", { value: c._index, enumerable: false });
				return choices;
			})
		];
		available.sort((lhs, rhs) => lhs.set.size - rhs.set.size);

		// Remove any fulfilled grants
		if (this.configuration.choiceMode === "inclusive") this.removeFullfilledInclusive(available, selected);
		else this.removeFullfilledExclusive(available, selected);

		// Merge all possible choices into a single SelectChoices
		const allChoices = mixedChoices(actorData.available);
		allChoices.exclude(new Set([...(selected.actor ?? []), ...selected.item]));
		available = available
			.map(a => {
				const filtered = allChoices.filtered(a);
				if (a._index !== undefined) Object.defineProperty(filtered, "_index", { value: a._index, enumerable: false });
				return filtered;
			})
			.filter(a => !foundry.utils.isEmpty(a));

		return { available, choices: allChoices };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove any fulfilled grants, handling choices using the "inclusive" elimination mode.
	 * @param {Set<string>[]} available - List of grant/choice pools.
	 * @param {Set<string>} selected - Currently selected trait keys.
	 */
	removeFullfilledInclusive(available, selected) {
		for (const key of selected.item) available.findSplice(grant => grant.set.has(key));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove any fulfilled grants, handling choices using the "exclusive" elimination mode.
	 * @param {Set<string>[]} available - List of grant/choice pools.
	 * @param {Set<string>} selected - Currently selected trait keys.
	 */
	removeFullfilledExclusive(available, selected) {
		const indices = new Set(available.map(a => a._index));
		for (const key of selected.item) {
			// Remove first selected grant
			const index = available.findIndex(grant => grant.set.has(key));
			const firstMatch = available[index];
			available.splice(index, 1);

			if (firstMatch?._index !== undefined) {
				for (const index of indices) {
					if (index === firstMatch._index) continue;
					// If it has an index, remove any other choices by index that don't have this choice
					const anyMatch = available.filter(a => a._index === index).some(grant => grant.set.has(key));
					if (!anyMatch) {
						let removeIndex = available.findIndex(a => a._index === index);
						while (removeIndex !== -1) {
							available.splice(removeIndex, 1);
							removeIndex = available.findIndex(a => a._index === index);
						}
						indices.delete(index);
					}
				}
			}
		}
	}
}

var _module$c = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Advancement: Advancement,
	ChooseFeaturesAdvancement: ChooseFeaturesAdvancement,
	ChooseSpellsAdvancement: ChooseSpellsAdvancement,
	EquipmentAdvancement: EquipmentAdvancement,
	ExpandedTalentListAdvancement: ExpandedTalentListAdvancement,
	GrantFeaturesAdvancement: GrantFeaturesAdvancement,
	GrantSpellsAdvancement: GrantSpellsAdvancement,
	HitPointsAdvancement: HitPointsAdvancement,
	ImprovementAdvancement: ImprovementAdvancement,
	KeyAbilityAdvancement: KeyAbilityAdvancement,
	PropertyAdvancement: PropertyAdvancement,
	ScaleValueAdvancement: ScaleValueAdvancement,
	SizeAdvancement: SizeAdvancement,
	SpellcastingAdvancement: SpellcastingAdvancement,
	SpellcastingValueAdvancement: SpellcastingValueAdvancement,
	TraitAdvancement: TraitAdvancement
});

/**
 * Configuration data for advancement types.
 *
 * @typedef {object} AdvancementTypeConfig
 * @property {typeof Advancement} type - Advancement type represented.
 * @property {Set<string>} validItemTypes - Types to which this advancement can be added.
 * @property {boolean} [hidden] - Should this advancement be hidden in the selection dialog? Hidden advancement types
 *                                can be created programmatically but not manually by users.
 */

const _ALL_ITEM_TYPES = ["background", "class", "feature", "heritage", "lineage", "subclass", "talent"];

/**
 * Advancement types that can be added to items.
 * @enum {AdvancementTypeConfig}
 */
const _advancementTypes = {
	base: {
		documentClass: Advancement,
		validItemTypes: new Set(),
		sheetClasses: {
			config: AdvancementConfig,
			flow: AdvancementFlow
		}
	},
	chooseFeatures: {
		documentClass: ChooseFeaturesAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: ChooseFeaturesConfig,
			flow: ChooseFeaturesFlow
		}
	},
	chooseSpells: {
		documentClass: ChooseSpellsAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: ChooseSpellsConfig,
			flow: ChooseSpellsFlow
		}
	},
	equipment: {
		documentClass: EquipmentAdvancement,
		validItemTypes: new Set(["background", "class"]),
		sheetClasses: {
			config: EquipmentConfig,
			flow: EquipmentFlow
		}
	},
	expandedTalentList: {
		documentClass: ExpandedTalentListAdvancement,
		validItemTypes: new Set(["subclass"]),
		sheetClasses: {
			config: ImprovementConfig
		}
	},
	grantFeatures: {
		documentClass: GrantFeaturesAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: GrantFeaturesConfig
		}
	},
	grantSpells: {
		documentClass: GrantSpellsAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: GrantSpellsConfig,
			flow: GrantSpellsFlow
		}
	},
	hitPoints: {
		documentClass: HitPointsAdvancement,
		validItemTypes: new Set(["class"]),
		sheetClasses: {
			config: HitPointsConfig,
			flow: HitPointsFlow
		}
	},
	improvement: {
		documentClass: ImprovementAdvancement,
		validItemTypes: new Set(["class"]),
		sheetClasses: {
			config: ImprovementConfig,
			flow: ImprovementFlow
		}
	},
	keyAbility: {
		documentClass: KeyAbilityAdvancement,
		validItemTypes: new Set(["class"]),
		sheetClasses: {
			config: KeyAbilityConfig
		}
	},
	property: {
		documentClass: PropertyAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: PropertyConfig
		}
	},
	scaleValue: {
		documentClass: ScaleValueAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: ScaleValueConfig
		},
		dataTypes: {
			string: ScaleTypeString,
			cr: ScaleTypeCR,
			dice: ScaleTypeDice,
			distance: ScaleValueTypeDistance,
			number: ScaleTypeNumber,
			usage: ScaleTypeUsage
		}
	},
	size: {
		documentClass: SizeAdvancement,
		validItemTypes: new Set(["lineage"]),
		sheetClasses: {
			config: SizeConfig,
			flow: SizeFlow
		}
	},
	spellcasting: {
		documentClass: SpellcastingAdvancement,
		validItemTypes: new Set(["class", "subclass"]),
		sheetClasses: {
			config: SpellcastingConfig,
			flow: SpellcastingFlow
		}
	},
	spellcastingValue: {
		documentClass: SpellcastingValueAdvancement,
		validItemTypes: new Set(["class", "subclass"]),
		sheetClasses: {
			config: SpellcastingValueConfig
		},
		hidden: true
	},
	trait: {
		documentClass: TraitAdvancement,
		validItemTypes: new Set(_ALL_ITEM_TYPES),
		sheetClasses: {
			config: TraitConfig,
			flow: TraitFlow
		}
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Number of experience points requires to gain a specific level. Array indices correspond with level.
 * @type {number[]}
 */
const experiencePoints = [
	,
	0, // Level 1
	300, // Level 2
	900, // Level 3
	2700, // Level 4
	6500, // Level 5
	14000, // Level 6
	23000, // Level 7
	34000, // Level 8
	48000, // Level 9
	64000, // Level 10
	85000, // Level 11
	100000, // Level 12
	120000, // Level 13
	140000, // Level 14
	165000, // Level 15
	195000, // Level 16
	225000, // Level 17
	265000, // Level 18
	305000, // Level 19
	355000 // Level 20
];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Valid die sizes for hit dices.
 * @type {number[]}
 */
const hitDieSizes = [4, 6, 8, 10, 12];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * List of possible levels.
 * @returns {[key: number]: string]}
 */
function levels() {
	return Array.fromRange(maxLevel, 1).reduce((obj, l) => {
		obj[l] = game.i18n.format("BF.Level.Ordinal", { number: numberFormat(l, { ordinal: true }) });
		return obj;
	}, {});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Maximum character level.
 * @type {number}
 */
const maxLevel = 20;

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Ability score threshold required to multiclass.
 * @type {number}
 */
const multiclassingAbilityThreshold = 13;

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * List of die faces that can be chosen within a dice Scale Value.
 * @type {number[]}
 */
const scaleDiceSizes = [2, 3, 4, 6, 8, 10, 12, 20, 100];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Formula for determining starting wealth if taken rather than starting equipment.
 * @type {{ formula: string, currency: string }}
 */
const startingWealth = {
	formula: "5d4 * 10",
	currency: "gp"
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Level at which classes grant subclasses.
 * @type {number}
 */
const subclassLevel = 3;

/**
 * Levels at which subclasses grant features by default.
 * @type {number[]}
 */
const subclassFeatureLevels = [3, 7, 11, 15];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Modes used within a trait advancement.
 * @enum {LabeledConfiguration}
 */
const traitModes = {
	default: {
		label: "BF.Advancement.Trait.Mode.Default.Label",
		hint: "BF.Advancement.Trait.Mode.Default.Hint"
	},
	expertise: {
		label: "BF.Advancement.Trait.Mode.Expertise.Label",
		hint: "BF.Advancement.Trait.Mode.Expertise.Hint"
	},
	forcedExpertise: {
		label: "BF.Advancement.Trait.Mode.Force.Label",
		hint: "BF.Advancement.Trait.Mode.Force.Hint"
	},
	upgrade: {
		label: "BF.Advancement.Trait.Mode.Upgrade.Label",
		hint: "BF.Advancement.Trait.Mode.Upgrade.Hint"
	}
};

var advancement = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_advancementTypes: _advancementTypes,
	experiencePoints: experiencePoints,
	hitDieSizes: hitDieSizes,
	levels: levels,
	maxLevel: maxLevel,
	multiclassingAbilityThreshold: multiclassingAbilityThreshold,
	scaleDiceSizes: scaleDiceSizes,
	startingWealth: startingWealth,
	subclassFeatureLevels: subclassFeatureLevels,
	subclassLevel: subclassLevel,
	traitModes: traitModes
});

/**
 * Types of ammunition offered by the system.
 * @enum {NestedLinkedConfiguration}
 */
const ammunition = {
	arrow: {
		localization: "BF.AMMUNITION.Type.Arrow",
		link: "Compendium.black-flag.items.Item.pLXuZs8PTiEt5PmK"
	},
	blowgunNeedle: {
		localization: "BF.AMMUNITION.Type.BlowgunNeedle",
		link: "Compendium.black-flag.items.Item.2m22nW2ojmJJm0xW"
	},
	crossbowBolt: {
		localization: "BF.AMMUNITION.Type.CrossbowBolt",
		link: "Compendium.black-flag.items.Item.cUcIM6yesvDT51kY"
	},
	paperCartridge: {
		localization: "BF.AMMUNITION.Type.PaperCartridge",
		rules: "firearms"
	},
	slingBullet: {
		localization: "BF.AMMUNITION.Type.SlingBullet",
		link: "Compendium.black-flag.items.Item.gJkNOy9ZuXqxuFYN"
	}
};
localizeConfig(ammunition);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Properties that can be applied to ammunition.
 * @type {string[]}
 */
const ammunitionProperties = ["magical"];

var ammunition$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ammunition: ammunition,
	ammunitionProperties: ammunitionProperties
});

/**
 * Configuration data for armor categories & base types.
 *
 * @typedef {NestedTypeConfiguration} ArmorTypeConfiguration
 * @property {object} [modifier]
 * @property {number} [modifier.min] - Minimum value of the modifier to be applied to this armor's calculation.
 * @property {number} [modifier.max] - Maximum value of the modifier to be applied to this armor's calculation.
 */

/**
 * Types of armor offered by the system.
 * @enum {NestedLinkedConfiguration}
 */
const armor = {
	light: {
		localization: "BF.Armor.Category.Light",
		children: {
			padded: {
				label: "BF.Armor.Type.Padded",
				link: "Compendium.black-flag.items.Item.28Zmdi4lQAr5L45X"
			},
			leather: {
				label: "BF.Armor.Type.Leather",
				link: "Compendium.black-flag.items.Item.h3Km60Kh2WNvWRoY"
			},
			studdedLeather: {
				label: "BF.Armor.Type.StuddedLeather",
				link: "Compendium.black-flag.items.Item.wltnYOTuHz96wXq5"
			},
			brigandine: {
				label: "BF.Armor.Type.Brigandine",
				link: "Compendium.black-flag.items.Item.Ignbkx9bqPp8hq90"
			}
		}
	},
	medium: {
		localization: "BF.Armor.Category.Medium",
		children: {
			hide: {
				label: "BF.Armor.Type.Hide",
				link: "Compendium.black-flag.items.Item.fN3bw7IZzSxbkcYX"
			},
			chainShirt: {
				label: "BF.Armor.Type.ChainShirt",
				link: "Compendium.black-flag.items.Item.FO53M9vYJXLrYPDs"
			},
			scaleMail: {
				label: "BF.Armor.Type.ScaleMail",
				link: "Compendium.black-flag.items.Item.lpKzUaG0LmkOqTb0"
			},
			breastplate: {
				label: "BF.Armor.Type.Breastplate",
				link: "Compendium.black-flag.items.Item.YdpLwxf7AjDtaSke"
			},
			halfPlate: {
				label: "BF.Armor.Type.HalfPlate",
				link: "Compendium.black-flag.items.Item.Hu7dZSxIN5djyyti"
			}
		},
		modifier: {
			max: 2
		}
	},
	heavy: {
		localization: "BF.Armor.Category.Heavy",
		children: {
			ringMail: {
				label: "BF.Armor.Type.RingMail",
				link: "Compendium.black-flag.items.Item.eu0rwXeQY3hIz8dq"
			},
			chainMail: {
				label: "BF.Armor.Type.ChainMail",
				link: "Compendium.black-flag.items.Item.FrdsogSzdIlz9Lmo"
			},
			splint: {
				label: "BF.Armor.Type.Splint",
				link: "Compendium.black-flag.items.Item.yvfflYNjyeKZNbew"
			},
			plate: {
				label: "BF.Armor.Type.Plate",
				link: "Compendium.black-flag.items.Item.AG4f7orze4Gsj9UO"
			}
		},
		modifier: {
			min: 0,
			max: 0
		}
	},
	shield: {
		localization: "BF.Armor.Category.Shield",
		link: "Compendium.black-flag.items.Item.eLqVG90tzGjKbWCp"
	}
};
localizeConfig(armor, { flatten: true, sort: false });
localizeConfig(armor.light.children);
localizeConfig(armor.medium.children);
localizeConfig(armor.heavy.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration for armor formulas.
 *
 * @typedef {LabeledConfiguration} ArmorFormulaConfiguration
 * @property {string} formula - The formula used for calculation.
 * @property {boolean|null} armored - Whether this formula requires armor, requires no armor, or doesn't restrict.
 * @property {boolean|null} shielded - Whether this formula requires shield, requires no shield, or doesn't restrict.
 */

/**
 * Different armor formulas provided out of the box.
 * @enum {ArmorFormulaConfiguration}
 */
const armorFormulas = {
	unarmored: {
		label: "BF.ArmorClass.Formula.Unarmored",
		formula: "10 + @abilities.dexterity.mod",
		armored: false,
		shielded: null
	},
	armored: {
		label: "BF.ArmorClass.Formula.Armored",
		formula: "@attributes.ac.armor + @attributes.ac.clamped.dexterity",
		armored: true,
		shielded: null
	},
	natural: {
		label: "BF.ArmorClass.Formula.Natural",
		formula: "@attributes.ac.flat",
		armored: null,
		shielded: null
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Properties that can be applied to armor.
 * @type {string[]}
 */
const armorProperties = ["cumbersome", "magical", "naturalMaterials", "noisy"];

var armor$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	armor: armor,
	armorFormulas: armorFormulas,
	armorProperties: armorProperties
});

/**
 * Configure list of attributes that can be consumed on an actor.
 * @internal
 */
function _configureConsumableAttributes() {
	const shared = [
		"attributes.ac.flat",
		"attributes.exhaustion",
		"attributes.hp.value",
		"attributes.hp.temp",
		...Object.keys(CONFIG.BlackFlag.movementTypes).map(key => `traits.movement.types.${key}`),
		...Object.keys(CONFIG.BlackFlag.senses).map(key => `traits.senses.types.${key}`)
	];

	CONFIG.BlackFlag.consumableResources = {
		pc: [
			// TODO: Consumable ability scores?
			...shared,
			"attributes.death.success",
			"attributes.death.failure",
			"attributes.luck.value",
			"progression.xp.value",
			// TODO: Allow targeting slot values instead
			...Array.fromRange(CONFIG.BlackFlag.maxSpellCircle, 1).map(c => `spellcasting.slots.circle-${c}.spent`),
			"spellcasting.slots.pact.spent"
		].sort(),
		npc: [
			...shared,
			// TODO: Allow targeting `attributes.legendary.value` instead
			"attributes.legendary.spent"
		].sort(),
		lair: []
	};
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configure lists of attributes to display in the token HUD and combat tracker.
 * @internal
 */
function _configureTrackableAttributes() {
	const shared = {
		bar: ["attributes.hp"],
		value: [
			"attributes.ac.value",
			"attributes.initiative.mod",
			...Object.keys(CONFIG.BlackFlag.movementTypes).map(key => `traits.movement.types.${key}`),
			...Object.keys(CONFIG.BlackFlag.senses).map(key => `traits.senses.types.${key}`)
		]
	};

	CONFIG.Actor.trackableAttributes = {
		pc: {
			bar: [
				...shared.bar,
				...Array.fromRange(CONFIG.BlackFlag.maxSpellCircle, 1).map(c => `spellcasting.slots.circle-${c}`),
				"spellcasting.slots.pact"
			],
			value: [
				...shared.value,
				...Object.keys(CONFIG.BlackFlag.abilities).map(key => `abilities.${key}.value`),
				"attributes.luck.value",
				...Object.keys(CONFIG.BlackFlag.skills).map(key => `proficiencies.skills.${key}.passive`),
				"progression.xp"
			]
		},
		npc: {
			bar: [...shared.bar, "attributes.legendary"],
			value: [
				...shared.value,
				...Object.keys(CONFIG.BlackFlag.abilities).map(ability => `abilities.${ability}.mod`),
				"attributes.cr",
				"attributes.perception",
				"attributes.stealth",
				"spellcasting.dc"
			]
		},
		lair: {
			bar: [],
			value: ["initiative"]
		}
	};
}

var attributes = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_configureConsumableAttributes: _configureConsumableAttributes,
	_configureTrackableAttributes: _configureTrackableAttributes
});

/**
 * Configuration data for a map marker style. Options not included will fall back to the value set in the `default`
 * style. Any additional styling options added will be passed into the custom marker class and be available for
 * rendering.
 *
 * @typedef {object} MapLocationMarkerStyle
 * @property {typeof PIXI.Container} [icon] - Map marker class used to render the icon.
 * @property {number} [backgroundColor] - Color of the background inside the circle.
 * @property {number} [borderColor] - Color of the border in normal state.
 * @property {number} [borderHoverColor] - Color of the border when hovering over the marker.
 * @property {string} [fontFamily] - Font used for rendering the code on the marker.
 * @property {number} [shadowColor] - Color of the shadow under the marker.
 * @property {number} [textColor] - Color of the text on the marker.
 */

/**
 * Styling profiles available for map markers. Default will be used as the basis and any other styles will be merged
 * on top of it if the `black-flag.mapMarkerStyle` flag is set to that style name on the journal page.
 * @enum {MapLocationMarkerStyle}
 */
const mapLocationMarkerStyle = {
	default: {
		icon: MapLocationControlIcon,
		backgroundColor: 0xfbf8f5,
		borderColor: 0x000000,
		borderHoverColor: 0xff5500,
		fontFamily: "Open Sans",
		shadowColor: 0x000000,
		textColor: 0x000000
	}
};

var canvas$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	mapLocationMarkerStyle: mapLocationMarkerStyle
});

/**
 * Configuration data for system conditions.
 *
 * @typedef {object} ConditionConfiguration
 * @property {string} label        Localized label for the condition.
 * @property {string} [icon]       Icon used to represent the condition on the token.
 * @property {boolean} [pseudo]    Effect that behaves like a condition but isn't an official condition.
 * @property {string} [reference]  UUID of a journal entry with details on this condition.
 * @property {string[]} [riders]   Additional effects that will be added alongside this condition.
 * @property {string} [special]    Set this condition as a special status effect under this name.
 */

/**
 * Conditions that can affect an actor.
 * @enum {ConditionConfiguration}
 */
const conditions = {
	bleeding: {
		label: "EFFECT.BF.Bleeding",
		icon: "systems/black-flag/artwork/statuses/bleeding.svg",
		pseudo: true
	},
	blinded: {
		label: "BF.Condition.Blinded.Label",
		icon: "systems/black-flag/artwork/statuses/blinded.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.xJJvm0vSgfbtS5MP",
		special: "BLIND"
	},
	charmed: {
		label: "BF.Condition.Charmed.Label",
		icon: "systems/black-flag/artwork/statuses/charmed.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.xWTun0VE6ViaNL54"
	},
	cursed: {
		label: "EFFECT.BF.Cursed",
		icon: "systems/black-flag/artwork/statuses/cursed.svg",
		pseudo: true
	},
	deafened: {
		label: "BF.Condition.Deafened.Label",
		icon: "systems/black-flag/artwork/statuses/deafened.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.40xM2nG1zWbUdVs3"
	},
	diseased: {
		label: "EFFECT.BF.Diseased",
		icon: "systems/black-flag/artwork/statuses/diseased.svg",
		pseudo: true
	},
	exhaustion: {
		label: "BF.Condition.Exhaustion.Label",
		icon: "systems/black-flag/artwork/statuses/exhaustion.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.Pk4HY4CkyTFBhFrL"
	},
	frightened: {
		label: "BF.Condition.Frightened.Label",
		icon: "systems/black-flag/artwork/statuses/frightened.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.JDnxwjUrT6foQcXs"
	},
	grappled: {
		label: "BF.Condition.Grappled.Label",
		icon: "systems/black-flag/artwork/statuses/grappled.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.MsrEhBwmMcCXQkiT"
	},
	incapacitated: {
		label: "BF.Condition.Incapacitated.Label",
		icon: "systems/black-flag/artwork/statuses/incapacitated.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.hJe9zn3JpFkD5YGY"
	},
	invisible: {
		label: "BF.Condition.Invisible.Label",
		icon: "systems/black-flag/artwork/statuses/invisible.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.J9KSv1AwJ1zod72g"
	},
	paralyzed: {
		label: "BF.Condition.Paralyzed.Label",
		icon: "systems/black-flag/artwork/statuses/paralyzed.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.0G8XVDS1Vzq1ZRFL",
		statuses: ["incapacitated"]
	},
	petrified: {
		label: "BF.Condition.Petrified.Label",
		icon: "systems/black-flag/artwork/statuses/petrified.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.jedIxHKhxgKOxpCB",
		statuses: ["incapacitated"]
	},
	poisoned: {
		label: "BF.Condition.Poisoned.Label",
		icon: "systems/black-flag/artwork/statuses/poisoned.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.6uSKn1WiqNwT8Fda"
	},
	prone: {
		label: "BF.Condition.Prone.Label",
		icon: "systems/black-flag/artwork/statuses/prone.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.pdRSRVGYPUK8Vxak"
	},
	restrained: {
		label: "BF.Condition.Restrained.Label",
		icon: "systems/black-flag/artwork/statuses/restrained.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.8o60lOgPGHKz3cLi"
	},
	silenced: {
		label: "EFFECT.BF.Silenced",
		icon: "systems/black-flag/artwork/statuses/silenced.svg",
		pseudo: true
	},
	stunned: {
		label: "BF.Condition.Stunned.Label",
		icon: "systems/black-flag/artwork/statuses/stunned.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.QguBSALg6Xd4Vmh3",
		statuses: ["incapacitated"]
	},
	surprised: {
		label: "BF.Condition.Surprised.Label",
		icon: "systems/black-flag/artwork/statuses/surprised.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.tPvSfEhj7fDkRvGj"
	},
	transformed: {
		label: "EFFECT.BF.Transformed",
		icon: "systems/black-flag/artwork/statuses/transformed.svg",
		pseudo: true
	},
	unconscious: {
		label: "BF.Condition.Unconscious.Label",
		icon: "systems/black-flag/artwork/statuses/unconscious.svg",
		reference: "Compendium.black-flag.rules.JournalEntry.yTCk697FqUQ0qzL3.JournalEntryPage.NNYMlxVAkVNRS3zH",
		riders: ["prone"],
		statuses: ["incapacitated"]
	}
};
localizeConfig(conditions);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Various effects of conditions and which conditions apply it. Either keys for the conditions,
 * and with a number appended for a level of exhaustion.
 * @enum {Set<string>}
 */
const conditionEffects = {
	noMovement: new Set(["exhaustion-5", "grappled", "paralyzed", "petrified", "restrained", "unconscious"]),
	halfMovement: new Set(["exhaustion-2"]),
	crawl: new Set(["prone", "exceedingCarryingCapacity"]),
	petrification: new Set(["petrified"]),
	halfHealth: new Set(["exhaustion-4"])
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Extra status effects not specified in `conditions`. If the ID matches a core-provided effect, then this
 * data will be merged into the core data.
 * @enum {object}
 */
const statusEffects = {
	burrowing: {
		name: "EFFECT.BF.Burrowing",
		icon: "systems/black-flag/artwork/statuses/burrowing.svg",
		special: "BURROW"
	},
	concentrating: {
		name: "EFFECT.BF.Concentrating",
		icon: "systems/black-flag/artwork/statuses/concentrating.svg",
		special: "CONCENTRATING"
	},
	dead: {
		icon: "systems/black-flag/artwork/statuses/dead.svg",
		special: "DEFEATED"
	},
	dodging: {
		name: "EFFECT.BF.Dodging",
		icon: "systems/black-flag/artwork/statuses/dodging.svg"
	},
	ethereal: {
		name: "EFFECT.BF.Ethereal",
		icon: "systems/black-flag/artwork/statuses/ethereal.svg"
	},
	fly: {
		label: "EFFECT.BF.Flying",
		icon: "systems/black-flag/artwork/statuses/flying.svg",
		special: "FLY"
	},
	hiding: {
		name: "EFFECT.BF.Hiding",
		icon: "systems/black-flag/artwork/statuses/hiding.svg"
	},
	hovering: {
		name: "EFFECT.BF.Hovering",
		icon: "systems/black-flag/artwork/statuses/hovering.svg"
	},
	marked: {
		name: "EFFECT.BF.Marked",
		icon: "systems/black-flag/artwork/statuses/marked.svg"
	},
	sleeping: {
		name: "EFFECT.BF.Sleeping",
		icon: "systems/black-flag/artwork/statuses/sleeping.svg"
	},
	stable: {
		name: "EFFECT.BF.Stable",
		icon: "systems/black-flag/artwork/statuses/stable.svg"
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configure system status effects.
 * @internal
 */
function _configureStatusEffects() {
	const addEffect = (effects, data) => {
		effects.push({ _id: staticID(`bf${data.id}`), ...data });
		if ("special" in data) CONFIG.specialStatusEffects[data.special] = data.id;
	};
	CONFIG.statusEffects = Object.entries(statusEffects).reduce((arr, [id, data]) => {
		const original = CONFIG.statusEffects.find(s => s.id === id);
		addEffect(arr, foundry.utils.mergeObject(original ?? {}, { id, ...data }, { inplace: false }));
		return arr;
	}, []);
	for (const [id, { label: name, ...data }] of Object.entries(conditions)) {
		addEffect(CONFIG.statusEffects, { id, name, ...data });
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

Hooks.on("i18nInit", () => {
	// Localize & sort status effects
	CONFIG.statusEffects.forEach(s => (s.name = game.i18n.localize(s.name)));
	CONFIG.statusEffects.sort((lhs, rhs) =>
		lhs.id === "dead" ? -1 : rhs.id === "dead" ? 1 : lhs.name.localeCompare(rhs.name)
	);
});

var conditions$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_configureStatusEffects: _configureStatusEffects,
	conditionEffects: conditionEffects,
	conditions: conditions,
	statusEffects: statusEffects
});

/**
 * Properties that can be applied to containers.
 * @type {string[]}
 */
const containerProperties = ["magical", "weightlessContents"];

var containers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	containerProperties: containerProperties
});

/**
 * Should damages be displayed pre-aggregated in the chat?
 * @type {boolean}
 */
const aggregateDamageDisplay = true;

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Different ways damage can be scaled.
 * @enum {LabeledConfiguration}
 */
const damageScalingModes = {
	whole: {
		label: "BF.DAMAGE.Scaling.Mode.Whole"
	},
	half: {
		label: "BF.DAMAGE.Scaling.Mode.Half"
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for damage types.
 *
 * @typedef {LabeledConfiguration} DamageTypeConfiguration
 * @property {string} icon - Icon representing the damage.
 * @property {number} [color] - Color of the damage.
 * @property {string} [reference] - UUID of a journal entry with details on this damage type.
 */

/**
 * Types of damage.
 * @enum {DamageTypeConfiguration}
 */
const damageTypes = {
	acid: {
		label: "BF.DAMAGE.Type.Acid",
		icon: "systems/black-flag/artwork/damage/acid.svg",
		color: new Color(0x839d50),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Dx45LLPVeFTPMNJ7"
	},
	bludgeoning: {
		label: "BF.DAMAGE.Type.Bludgeoning",
		icon: "systems/black-flag/artwork/damage/bludgeoning.svg",
		color: new Color(0x0000a0),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.qWxvYtMSJMq7b8cu"
	},
	cold: {
		label: "BF.DAMAGE.Type.Cold",
		icon: "systems/black-flag/artwork/damage/cold.svg",
		color: new Color(0xadd8e6),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.33LfnLQMKLJSqEbW"
	},
	fire: {
		label: "BF.DAMAGE.Type.Fire",
		icon: "systems/black-flag/artwork/damage/fire.svg",
		color: new Color(0xff4500),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Pfk4JeLjQ5DSUwUT"
	},
	force: {
		label: "BF.DAMAGE.Type.Force",
		icon: "systems/black-flag/artwork/damage/force.svg",
		color: new Color(0x800080),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ivc2H8JjzInzqaEg"
	},
	lightning: {
		label: "BF.DAMAGE.Type.Lightning",
		icon: "systems/black-flag/artwork/damage/lightning.svg",
		color: new Color(0x1e90ff),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.BTKLWHDe2zxupshb"
	},
	necrotic: {
		label: "BF.DAMAGE.Type.Necrotic",
		icon: "systems/black-flag/artwork/damage/necrotic.svg",
		color: new Color(0x006400),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.rh7AKdxbCNie6OMl"
	},
	piercing: {
		label: "BF.DAMAGE.Type.Piercing",
		icon: "systems/black-flag/artwork/damage/piercing.svg",
		color: new Color(0xc0c0c0),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.oDlJ4GI6QmUBaxJf"
	},
	poison: {
		label: "BF.DAMAGE.Type.Poison",
		icon: "systems/black-flag/artwork/damage/poison.svg",
		color: new Color(0x8a2be2),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.3m1zwxVlklmFD7Kk"
	},
	psychic: {
		label: "BF.DAMAGE.Type.Psychic",
		icon: "systems/black-flag/artwork/damage/psychic.svg",
		color: new Color(0xff1493),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.K7dMLfqqUJxq0PJC"
	},
	radiant: {
		label: "BF.DAMAGE.Type.Radiant",
		icon: "systems/black-flag/artwork/damage/radiant.svg",
		color: new Color(0xffd700),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.RYlrlgpcQKAYDWqe"
	},
	slashing: {
		label: "BF.DAMAGE.Type.Slashing",
		icon: "systems/black-flag/artwork/damage/slashing.svg",
		color: new Color(0x8b0000),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.2MbmC9y8UL6gxqZ3"
	},
	thunder: {
		label: "BF.DAMAGE.Type.Thunder",
		icon: "systems/black-flag/artwork/damage/thunder.svg",
		color: new Color(0x708090),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.sfwK0rXw9GTREeDb"
	}
};
localizeConfig(damageTypes);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Types of healing.
 * @enum {DamageTypeConfiguration}
 */
const healingTypes = {
	healing: {
		label: "BF.Healing.Type.Normal",
		icon: "systems/black-flag/artwork/healing/normal.svg",
		color: new Color(0x46c252)
	},
	temp: {
		label: "BF.Healing.Type.Temp",
		icon: "systems/black-flag/artwork/healing/temp.svg",
		color: new Color(0x4b66de),
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.PGW1FFQySj1EF5SV"
	},
	max: {
		label: "BF.Healing.Type.Maximum",
		icon: "systems/black-flag/artwork/healing/max.svg"
	}
};
localizeConfig(healingTypes, { sort: false });

var damage = /*#__PURE__*/Object.freeze({
	__proto__: null,
	aggregateDamageDisplay: aggregateDamageDisplay,
	damageScalingModes: damageScalingModes,
	damageTypes: damageTypes,
	healingTypes: healingTypes
});

/**
 * Debug options offered by the system.
 */
const debug = {
	// Print list of all advancement changes applied to an actor
	advancementChanges: false,
	// Print modifier data whenever `getModifiers` is called
	modifiers: false
};

var debug$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	debug: debug
});

/**
 * Different rolling modes for Challenge Rolls.
 * @enum {LabeledConfiguration}
 */
const challengeRollModes = {
	normal: {
		label: "BF.Roll.Action.Normal.Label",
		abbreviation: "BF.Roll.Action.Normal.Abbreviation",
		value: 0
	},
	advantage: {
		label: "BF.Roll.Action.Advantage.Label",
		abbreviation: "BF.Roll.Action.Advantage.Abbreviation",
		value: 1
	},
	disadvantage: {
		label: "BF.Roll.Action.Disadvantage.Label",
		abbreviation: "BF.Roll.Action.Disadvantage.Abbreviation",
		value: -1
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Standard dice spread available for things like damage.
 * @type {number[]}
 */
const dieSteps = [4, 6, 8, 10, 12, 20, 100];

Object.defineProperty(dieSteps, "labeled", {
	get() {
		return Object.fromEntries(dieSteps.map(v => [v, `d${v}`]));
	},
	enumerable: false
});

var dice$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	challengeRollModes: challengeRollModes,
	dieSteps: dieSteps
});

class BaseDataModel extends foundry.abstract.TypeDataModel {
	/**
	 * Metadata that describes a system data type.
	 *
	 * @typedef {object} BaseDataMetadata
	 * @property {string} type - Name of type to which this system data model belongs.
	 * @property {string} [module] - For module-defined types, which module provides this type.
	 * @property {string} [category] - Which category in the create item dialog should this Document be listed?
	 * @property {string} localization - Base localization key for this type. This should be a localization key that
	 *                                   accepts plural types (e.g. `BF.Item.Type.Weapon` becomes
	 *                                   `BF.Item.Type.Weapon[few]` and `BF.Item.Type.Weapon[other]`).
	 * @property {string} [icon] - Font awesome icon string used for links to this type.
	 * @property {string} [img] - Default image used when creating a Document of this type.
	 */

	/**
	 * Metadata that describes a type.
	 * @type {BaseDataMetadata}
	 */
	static metadata = {};

	/**
	 * Metadata that describes a type.
	 * @type {BaseDataMetadata}
	 */
	get metadata() {
		return this.constructor.metadata;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Full type with module prefix if it is a module-defined type.
	 * @type {string}
	 */
	static get fullType() {
		return this.metadata.module ? `${this.metadata.module}.${this.metadata.type}` : this.metadata.type;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	static _enableV10Validation = true;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Base templates used for construction.
	 * @type {*[]}
	 * @private
	 */
	static _schemaTemplates = [];

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A list of properties that should not be mixed-in to the final type.
	 * @type {Set<string>}
	 * @private
	 */
	static _immiscible = new Set(["length", "mixed", "name", "prototype", "migrateData", "defineSchema"]);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static defineSchema() {
		const schema = {};
		for (const template of this._schemaTemplates) {
			this.mergeSchema(schema, this[`${template.name}_defineSchema`]?.() ?? {});
		}
		return schema;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Merge two schema definitions together as well as possible.
	 * @param {DataSchema} a - First schema that forms the basis for the merge. *Will be mutated.*
	 * @param {DataSchema} b - Second schema that will be merged in, overwriting any non-mergeable properties.
	 * @returns {DataSchema} - Fully merged schema.
	 */
	static mergeSchema(a, b) {
		for (const key of Object.keys(b)) {
			if (!(key in a) || a[key].constructor !== b[key].constructor) {
				if (b[key] === false) delete a[key];
				else a[key] = b[key];
				continue;
			}
			const mergedOptions = { ...a[key].options, ...b[key].options };
			if (b[key] instanceof foundry.data.fields.SchemaField) {
				const fields = this.mergeSchema(a[key].fields, b[key].fields);
				Object.values(fields).forEach(f => (f.parent = undefined));
				a[key] = new b[key].constructor(fields, mergedOptions);
				continue;
			}
			switch (b[key].constructor) {
				case foundry.data.fields.ArrayField:
				case foundry.data.fields.SetField:
					const elementOptions = foundry.utils.mergeObject(a[key].element.options, b[key].element.options);
					const ElementType = (b[key].element || a[key].element).constructor;
					a[key] = new b[key].constructor(new ElementType(elementOptions), mergedOptions);
					break;
				case BlackFlag.data.fields.MappingField:
					mergedOptions.extraFields = this.mergeSchema(
						a[key].options.extraFields ?? {},
						b[key].options.extraFields ?? {}
					);
					const modelOptions = foundry.utils.mergeObject(a[key].model.options, b[key].model.options);
					const ModelType = (b[key].model || a[key].model).constructor;
					a[key] = new b[key].constructor(new ModelType(modelOptions), mergedOptions);
					break;
				default:
					a[key] = new b[key].constructor(mergedOptions);
			}
		}
		return a;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mix multiple templates with the base type.
	 * @param {...*} templates - Template classes to mix.
	 * @returns {typeof SystemDataModel} - Final prepared type.
	 */
	static mixin(...templates) {
		const Base = class extends this {};
		Object.defineProperty(Base, "_schemaTemplates", {
			value: Object.seal([...this._schemaTemplates, ...templates]),
			writable: false,
			configurable: false
		});

		for (const template of templates) {
			let defineSchema;

			// Take all static methods and fields from template and mix in to base class
			for (const [key, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(template))) {
				if (key === "defineSchema") defineSchema = descriptor;
				if (this._immiscible.has(key)) continue;
				Object.defineProperty(Base, key, { ...descriptor, enumerable: true });
			}

			// Take all instance methods and fields from template and mix in to base class
			for (const [key, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(template.prototype))) {
				if (["constructor"].includes(key)) continue;
				Object.defineProperty(Base.prototype, key, { ...descriptor, enumerable: true });
			}

			// Copy over defineSchema with a custom name
			if (defineSchema) {
				Object.defineProperty(Base, `${template.name}_defineSchema`, defineSchema);
			}
		}

		return Base;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine whether this class mixes in a specific template.
	 * @param {*} template
	 * @returns {boolean}
	 */
	static mixes(template) {
		if (foundry.utils.getType(template) === "string") {
			return this._schemaTemplates.find(t => t.name === template) !== undefined;
		} else {
			return this._schemaTemplates.includes(template);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Key path to the description used for default embeds.
	 * @type {string|null}
	 */
	get embeddedDescriptionKeyPath() {
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Helper method to get all enumerable methods, inherited or own, for this class.
	 * @param {object} options
	 * @param {string} [options.startingWith] - Optional filtering string.
	 * @param {string} [options.notEndingWith] - Exclude any method that ends with this suffix.
	 * @param {boolean} [options.prototype=true] - Whether the prototype should be checked or the class.
	 * @returns {string[]} - Array of method keys.
	 */
	static _getMethods({ startingWith, notEndingWith, prototype = true }) {
		let keys = [];
		for (const key in prototype ? this.prototype : this) {
			keys.push(key);
		}
		for (let cls of [this, ...foundry.utils.getParentClasses(this)].reverse()) {
			if (["Base", "BaseDataModel", "DataModel"].includes(cls.name)) continue;
			if (prototype) cls = cls.prototype;
			keys.push(...Object.getOwnPropertyNames(cls));
		}
		if (startingWith) keys = keys.filter(key => key.startsWith(startingWith) && key !== startingWith);
		if (notEndingWith) keys = keys.filter(key => !key.endsWith(notEndingWith));
		return keys;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static migrateData(source) {
		this._getMethods({ startingWith: "migrate", notEndingWith: "Data", prototype: false }).forEach(k =>
			this[k](source)
		);
		return super.migrateData(source);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare data related to this DataModel itself, before any embedded Documents or derived data is computed.
	 */
	prepareBaseData() {
		this.constructor._getMethods({ startingWith: "prepareBase", notEndingWith: "Data" }).forEach(k => this[k]());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare data that needs to be prepared after embedded documents have been prepared,
	 * but before active effects are applied.
	 */
	prepareEmbeddedData() {
		this.constructor._getMethods({ startingWith: "prepareEmbedded", notEndingWith: "Data" }).forEach(k => this[k]());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply transformations or derivations to the values of the source data object.
	 */
	prepareDerivedData() {
		this.constructor._getMethods({ startingWith: "prepareDerived", notEndingWith: "Data" }).forEach(k => this[k]());
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Render a rich tooltip for this document.
	 * @param {EnrichmentOptions} [enrichmentOptions={}] - Options for text enrichment.
	 * @returns {{ content: string, classes: string[] }|null}
	 */
	async richTooltip(enrichmentOptions = {}) {
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		const keyPath = this.embeddedDescriptionKeyPath;
		if (!keyPath || !foundry.utils.hasProperty(this, keyPath)) return null;
		const enriched = await TextEditor.enrichHTML(foundry.utils.getProperty(this, keyPath), {
			...options,
			relativeTo: this.parent
		});
		const container = document.createElement("div");
		container.innerHTML = enriched;
		return container.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Pre-creation logic for this system data.
	 * @param {object} data - The initial data object provided to the document creation request.
	 * @param {object} options - Additional options which modify the creation request.
	 * @param {User} user - The User requesting the document creation.
	 * @returns {boolean} - Return false to prevent document creation.
	 * @protected
	 */
	async _preCreate(data, options, user) {
		for (const name of this.constructor._getMethods({ startingWith: "_preCreate" })) {
			if ((await this[name](data, options, user)) === false) return false;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Pre-update logic for this system data.
	 * @param {object} changed - The differential data that is changed relative to the documents prior values.
	 * @param {object} options - Additional options which modify the update request.
	 * @param {User} user - The User requesting the document update.
	 * @returns {boolean} - Return false to prevent document update.
	 * @protected
	 */
	async _preUpdate(changed, options, user) {
		for (const name of this.constructor._getMethods({ startingWith: "_preUpdate" })) {
			if ((await this[name](changed, options, user)) === false) return false;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Pre-deletion logic for this system data.
	 * @param {object} options - Additional options which modify the deletion request.
	 * @param {User} user - The User requesting the document deletion.
	 * @returns {boolean} - Return false to prevent document deletion.
	 * @protected
	 */
	async _preDelete(options, user) {
		for (const name of this.constructor._getMethods({ startingWith: "_preDelete" })) {
			if ((await this[name](options, user)) === false) return false;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Post-creation logic for this system data.
	 * @param {object} data - The initial data object provided to the document creation request.
	 * @param {object} options - Additional options which modify the creation request.
	 * @param {string} userId - The id of the User requesting the document update.
	 * @protected
	 */
	_onCreate(data, options, userId) {
		this.constructor._getMethods({ startingWith: "_onCreate" }).forEach(k => this[k](data, options, userId));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Post-update logic for this system data.
	 * @param {object} changed - The differential data that was changed relative to the documents prior values.
	 * @param {object} options - Additional options which modify the update request.
	 * @param {string} userId - The id of the User requesting the document update.
	 * @protected
	 */
	_onUpdate(changed, options, userId) {
		this.constructor._getMethods({ startingWith: "_onUpdate" }).forEach(k => this[k](changed, options, userId));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Post-deletion logic for this system data.
	 * @param {object} options - Additional options which modify the deletion request
	 * @param {string} userId - The id of the User requesting the document update
	 * @protected
	 */
	_onDelete(options, userId) {
		this.constructor._getMethods({ startingWith: "_onDelete" }).forEach(k => this[k](options, userId));
	}
}

class ActorDataModel extends BaseDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareBaseData() {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare data that needs to be prepared after embedded documents have been prepared,
	 * but before active effects are applied.
	 */
	prepareEmbeddedData() {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	prepareDerivedData() {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare any final notifications. Called at the very end of the data preparation process.
	 */
	prepareNotifications() {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get embeddedDescriptionKeyPath() {
		return "biography.value";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this actor under the effect of this property from some status or due to its level of exhaustion?
	 * @param {string} key - A key in `CONFIG.BlackFlag.conditionEffects`.
	 * @returns {boolean} - Whether the actor is affected.
	 */
	hasConditionEffect(key) {
		const props = CONFIG.BlackFlag.conditionEffects[key] ?? new Set();
		const level = this.attributes?.exhaustion ?? null;
		const imms = this.traits?.condition?.immunities?.value ?? new Set();
		const applyExhaustion = level !== null && !imms.has("exhaustion");
		return props.some(k => {
			const l = Number(k.split("-").pop());
			return (this.parent.statuses.has(k) && !imms.has(k)) || (applyExhaustion && Number.isInteger(l) && level >= l);
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine the ability with the highest modifier from the provided list, or from all abilities.
	 * @param {string[]|Set<string>} [from] - Set of abilities to select from.
	 * @returns {string} - Ability with the highest modifier.
	 */
	selectBestAbility(from) {
		from ??= new Set(Object.keys(CONFIG.BlackFlag.abilities));
		return from.reduce((highest, key) =>
			(this.abilities?.[key]?.mod ?? -Infinity) > (this.abilities?.[highest]?.mod ?? -Infinity) ? key : highest
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Construct an initiative roll.
	 * @param {ChallengeRollOptions} [options] - Options for the roll.
	 * @returns {InitiativeRollProcessConfiguration}
	 */
	getInitiativeRollConfig(options = {}) {
		return {};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare a data object which defines the data schema used by dice roll commands against this Actor.
	 * @param {object} [options]
	 * @param {boolean} [options.deterministic] - Whether to force deterministic values for data properties that could be
	 *                                            either a die term or a flat term.
	 * @returns {object}
	 */
	getRollData({ deterministic = false } = {}) {
		const rollData = { ...this };
		rollData.prof = new Proficiency(this.attributes?.proficiency ?? 0, 1);
		if (deterministic) rollData.prof = rollData.prof.flat;
		return rollData;
	}
}

const { SchemaField: SchemaField$y } = foundry.data.fields;

/**
 * Data definition template for armor class.
 *
 * @property {SourceData} source - Source of the creature's stat block.
 * @mixin
 */
class SourceTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			description: new SchemaField$y({
				source: new SourceField()
			})
		};
	}
	
	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare description data during derived data stage.
	 */
	prepareSource() {
		const uuid = this.parent._stats?.compendiumSource ?? this.parent.uuid;
		SourceField.prepareData.call(this.description.source, uuid);
	}
}

const { HTMLField: HTMLField$9, NumberField: NumberField$j, SchemaField: SchemaField$x } = foundry.data.fields;

/**
 * Data model for Lair actors.
 * @mixes {SourceTemplate}
 *
 * @property {object} description
 * @property {string} description.value - Main description of this lair.
 * @property {string} description.lairActions - Introduction to the lair actions section.
 * @property {string} description.regionalEffects - Introduction to the regional effects section.
 * @property {string} description.conclusion - Conclusion of the regional effects section.
 * @property {number} initiative - Fixed initiative value where lair actions can be triggered.
 */
class LairData extends ActorDataModel.mixin(SourceTemplate) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = {
		type: "lair",
		category: "place",
		localization: "BF.Actor.Type.Lair",
		img: "systems/black-flag/artwork/types/lair.svg",
		sheet: {
			application: LairSheet,
			label: "BF.Sheet.Default.Lair"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			description: new SchemaField$x({
				value: new HTMLField$9(),
				lairActions: new HTMLField$9(),
				regionalEffects: new HTMLField$9(),
				conclusion: new HTMLField$9()
			}),
			initiative: new NumberField$j({ initial: 20 })
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareSource();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		const context = await this.parent.sheet.getData();
		context.headerLevel = 4;
		const section = document.createElement("section");
		section.innerHTML = await renderTemplate("systems/black-flag/templates/actor/embeds/lair-embed.hbs", context);
		return section.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	getInitiativeRollConfig(options = {}) {
		return { fixed: this.initiative };
	}
}

const { ArrayField: ArrayField$7, BooleanField: BooleanField$5, NumberField: NumberField$i, SchemaField: SchemaField$w, SetField: SetField$e, StringField: StringField$t } = foundry.data.fields;

/**
 * Data definition template for armor class.
 */
class ACTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			attributes: new SchemaField$w({
				ac: new SchemaField$w({
					baseFormulas: new SetField$e(new StringField$t(), {
						initial: ["unarmored", "armored"]
					}, { label: "BF.ArmorClass.Formula.DefaultLabel[other]" }),
					customLabel: new StringField$t({ label: "BF.ArmorClass.CustomLabel" }),
					formulas: new ArrayField$7(new SchemaField$w({
						label: new StringField$t(),
						formula: new FormulaField({ deterministic: true }),
						armored: new BooleanField$5({ nullable: true, initial: null }),
						shielded: new BooleanField$5({ nullable: true, initial: null })
					}), { label: "BF.ArmorClass.Formula.Label[other]" }),
					flat: new NumberField$i({
						min: 0, integer: true, label: "BF.ArmorClass.Flat.Label", hint: "BF.ArmorClass.Flat.Hint"
					}),
					override: new NumberField$i({
						min: 0, integer: true, label: "BF.ArmorClass.Override.Label", hint: "BF.ArmorClass.Override.Hint"
					})
				}, {label: "BF.ArmorClass.Label"})
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add default armor formulas with their labels.
	 */
	prepareBaseArmorFormulas() {
		const ac = this.attributes.ac;
		ac.cover = 0;
		for ( const [id, data] of Object.entries(CONFIG.BlackFlag.armorFormulas) ) {
			ac.formulas.push(foundry.utils.mergeObject(data, {
				enabled: ac.baseFormulas.has(id),
				id,
				label: game.i18n.localize(data.label),
				type: "base"
			}, {inplace: false}));
		}

		Object.defineProperty(ac, "defaultLabel", {
			get() {
				const label = [];
				if ( this.currentFormula?.id === "armored" ) label.push(this.equippedArmor.name);
				else if ( this.currentFormula?.label ) label.push(game.i18n.localize(this.currentFormula.label));
				if ( this.equippedShield ) label.push(this.equippedShield.name);
				return game.i18n.getListFormatter({ style: "short", type: "unit" }).format(label);
			},
			configurable: true
		});
		Object.defineProperty(ac, "label", {
			get() {
				return this.customLabel || this.defaultLabel;
			},
			configurable: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mark final armor formulas to indicate ones from active effects.
	 */
	prepareDerivedArmorFormulas() {
		for ( const formula of this.attributes.ac.formulas ) {
			if ( !formula.type ) formula.type = "effect";
			// TODO: Attribute each non-manual formula to a source (e.g. effect or advancement)
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate final AC values. Must be called after ability modifiers are prepared.
	 */
	computeArmorClass() {
		const ac = this.attributes.ac;

		// If armor is equipped, prepare clamped abilities
		ac.clamped = Object.entries(this.abilities).reduce((obj, [k, v]) => {
			obj[k] = Math.clamp(
				v.mod,
				ac.equippedArmor?.system.modifier.min ?? -Infinity,
				ac.equippedArmor?.system.modifier.max ?? Infinity
			);
			return obj;
		}, {});

		ac.armor = ac.equippedArmor?.system.armor.value ?? 0;
		ac.flat ??= 10;

		const rollData = this.parent.getRollData({ deterministic: true });
		rollData.attributes.ac = ac;
		const acData = {
			type: "armor-class",
			armored: !!ac.equippedArmor,
			armor: ac.equippedArmor?.system,
			shielded: !!ac.equippedShield,
			shield: ac.equippedShield?.system
		};

		// Filter formulas to only ones that match current armor settings
		const validFormulas = ac.formulas.filter(formula => {
			if ( formula.enabled === false ) return false;
			if ( (typeof formula.armored === "boolean") && (formula.armored !== !!acData.armored) ) return false;
			if ( (typeof formula.shielded === "boolean") && (formula.shielded !== !!acData.shielded) ) return false;
			return true;
		});

		// Iterate of all armor class formulas, calculating their final values
		ac.base = -Infinity;
		for ( const [index, config] of validFormulas.entries() ) {
			try {
				const replaced = Roll.replaceFormulaData(config.formula, rollData);
				const result = Roll.safeEval(replaced);
				if ( result > ac.base ) {
					ac.base = result;
					ac.currentFormula = config;
				}
			} catch(error) {
				this.parent.notifications.set(`ac-formula-error-${index}`, {
					level: "error", category: "armor-class", section: "main",
					message: game.i18n.format("BF.ArmorClass.Formula.Error", {formula: config.formula, error: error.message})
				});
			}
		}
		if ( !Number.isFinite(ac.base) ) {
			ac.base = ac.flat;
			ac.currentFormula = null;
		}

		ac.shield = ac.equippedShield?.system.armor.value ?? 0;

		ac.modifiers = this.getModifiers(acData);
		ac.bonus = this.buildBonus(ac.modifiers, { deterministic: true, rollData });
		ac.min = this.buildMinimum(this.getModifiers(acData, "min"), { rollData });

		if ( ac.override ) ac.value = ac.override;
		else ac.value = Math.max(ac.min, ac.base + ac.shield + ac.bonus + ac.cover);
	}
}

const { NumberField: NumberField$h, SchemaField: SchemaField$v } = foundry.data.fields;

/**
 * Data definition template for exhaustion & other conditions.
 */
class ConditionsTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			attributes: new SchemaField$v({
				exhaustion: new NumberField$h({
					initial: 0, min: 0, max: 6, integer: true, label: "BF.Condition.Exhaustion.Label"
				})
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare exhaustion level and condition roll notes.
	 */
	prepareConditions() {
		const exhaustion = this.parent.effects.get(BlackFlagActiveEffect.ID.EXHAUSTION);
		const level = exhaustion?.getFlag("black-flag", "level");
		this.attributes.exhaustion = Number.isFinite(level) ? level : 0;

		for ( const status of this.parent.statuses ) {
			const notes = CONFIG.BlackFlag.statusEffectRollNotes[status];
			if ( !notes?.length ) continue;
			for ( const note of notes ) {
				if ( (status === "exhaustion") && note.level && (note.level > this.attributes.exhaustion) ) continue;
				this.modifiers.push({
					type: "note", filter: note.filter, note: { rollMode: note.rollMode ?? 0, text: game.i18n.localize(note.text) }
				});
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	async _preUpdateExhaustion(changed, options, user) {
		// Record previous exhaustion level.
		if ( Number.isFinite(foundry.utils.getProperty(changed, "system.attributes.exhaustion")) ) {
			foundry.utils.setProperty(options, "blackFlag.originalExhaustion", this.attributes.exhaustion);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_onUpdateExhaustion(data, options, userId) {
		if ( userId !== game.userId ) return;

		// TODO: Perform this as part of Actor._preUpdateOperation instead when it becomes available in v12
		const level = foundry.utils.getProperty(data, "system.attributes.exhaustion");
		if ( !Number.isFinite(level) ) return;
		let effect = this.parent.effects.get(BlackFlagActiveEffect.ID.EXHAUSTION);
		if ( level < 1 ) return effect?.delete();
		else if ( effect ) {
			const originalExhaustion = foundry.utils.getProperty(options, "blackFlag.originalExhaustion");
			return effect.update({ "flags.black-flag.level": level }, { blackFlag: { originalExhaustion } });
		} else {
			effect = ActiveEffect.implementation.fromStatusEffect("exhaustion", { parent: this.parent });
			effect.updateSource({ "flags.black-flag.level": level });
			return ActiveEffect.implementation.create(effect, { parent: this.parent, keepId: true });
		}
	}
}

const { NumberField: NumberField$g, SchemaField: SchemaField$u } = foundry.data.fields;

/**
 * Data definition template for non-PC actors with hit points.
 *
 * @property {object} attributes
 * @property {object} attributes.hp
 * @property {number} attributes.hp.value - Current hit points.
 * @property {number} attributes.hp.max - Maximum hit points.
 * @property {number} attributes.hp.temp - Temporary hit points.
 * @property {number} attributes.hp.tempMax - Temporary max hit points.
 */
class HPTemplate extends foundry.abstract.DataModel {
	/** @inheritDoc */
	static defineSchema() {
		return {
			attributes: new SchemaField$u({
				hp: new SchemaField$u(
					{
						value: new NumberField$g({ min: 0, integer: true, label: "BF.HitPoint.Current.LabelLong" }),
						max: new NumberField$g({ min: 0, integer: true, label: "BF.HitPoint.Max.LabelLong" }),
						temp: new NumberField$g({ min: 0, integer: true, label: "BF.HitPoint.Temp.LabelLong" }),
						tempMax: new NumberField$g({ integer: true, label: "BF.HitPoint.TempMax.LabelLong" })
					},
					{ label: "BF.HitPoint.Label[other]" }
				)
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare the hit points data during the `prepareDerivedData` stage.
	 */
	prepareDerivedHitPoints() {
		const hp = this.attributes.hp;
		hp.max ??= 0;
		if ((this.attributes.exhaustion ?? 0) >= 4) hp.max = Math.floor(hp.max * 0.5);
		hp.baseMax = hp.max;
		hp.max += hp.tempMax ?? 0;
		hp.value = Math.clamp(hp.value, 0, hp.max);
		hp.damage = hp.max - hp.value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	async _preUpdateHP(changed, options, user) {
		const changedMaxHP = foundry.utils.getProperty(changed, "system.attributes.hp.max");
		if (changedMaxHP !== undefined) {
			const maxHPDelta = changedMaxHP - this.attributes.hp.baseMax;
			foundry.utils.setProperty(changed, "system.attributes.hp.value", this.attributes.hp.value + maxHPDelta);
		}
	}
}

const { SchemaField: SchemaField$t, StringField: StringField$s } = foundry.data.fields;

/**
 * Data definition template for initiative.
 *
 * @property {object} attributes
 * @property {object} attributes.initiative
 * @property {string} attributes.initiative.ability - Ability to add to the initiative roll.
 * @property {Proficiency} attributes.initiative.proficiency - Proficiency in initiative.
 */
class InitiativeTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			attributes: new SchemaField$t({
				initiative: new SchemaField$t({
					ability: new StringField$s({label: "BF.Initiative.Ability.Label"}),
					proficiency: new ProficiencyField()
				}, {label: "BF.Initiative.Label"})
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate the derived data on initiative.
	 */
	computeInitiative() {
		const init = this.attributes.initiative ??= {};
		init.ability ||= CONFIG.BlackFlag.defaultAbilities.initiative;
		const ability = this.abilities[init.ability];

		init.proficiency = new Proficiency(
			this.attributes.proficiency,
			init.proficiency.multiplier,
			init.proficiency.rounding
		);

		const initiativeData = [
			{ type: "ability-check", ability: init.ability, proficiency: init.proficiency.multiplier },
			{ type: "initiative", proficiency: init.proficiency.multiplier }
		];
		init.modifiers = {
			_data: initiativeData,
			bonus: this.getModifiers(initiativeData),
			min: this.getModifiers(initiativeData, "min"),
			note: this.getModifiers(initiativeData, "note")
		};
		init.bonus = this.buildBonus(init.modifiers.bonus, {
			deterministic: true, rollData: this.parent.getRollData({deterministic: true})
		});

		init.mod = (ability?.mod ?? 0) + init.proficiency.flat + init.bonus;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	getInitiativeRollConfig(options = {}) {
		const init = this.attributes?.initiative ?? {};
		const abilityKey = init.ability ?? CONFIG.BlackFlag.defaultAbilities.initiative;
		const ability = this.abilities?.[abilityKey] ?? {};

		const rollConfig = {
			rolls: [
				{
					...buildRoll(
						{
							mod: ability.mod,
							prof: init.proficiency?.hasProficiency ? init.proficiency.term : null,
							bonus: this.buildBonus?.(this.getModifiers?.(init.modifiers?._data)),
							tiebreaker:
								game.settings.get(game.system.id, "initiativeTiebreaker") && ability ? ability.value / 100 : null
						},
						this.parent.getRollData()
					),
					options: foundry.utils.mergeObject(
						{
							minimum: this.buildMinimum?.(this.getModifiers?.(init.modifiers?._data, "min"))
						},
						options
					)
				}
			]
		};

		return rollConfig;
	}
}

const { ArrayField: ArrayField$6, NumberField: NumberField$f, SchemaField: SchemaField$s, SetField: SetField$d, StringField: StringField$r } = foundry.data.fields;

/**
 * Data for an actor's languages.
 *
 * @typedef {object} LanguagesData
 * @property {Set<string>} value - Language dialects understood by actor.
 * @property {Record<string, CommunicationData>} communication
 * @property {string[]} custom - Additional custom languages.
 * @property {Set<string>} tags - Additional tags describing actor's language usage.
 */

/**
 * Data for ranged communication modes.
 *
 * @typedef {object} CommunicationData
 * @property {number} range - Range to which this ability can be used.
 * @property {string} units - Units used to measure range.
 */

/**
 * Data definition template for actors with language proficiencies.
 *
 * @property {object} proficiencies
 * @property {LanguagesData} proficiencies.languages
 */
class LanguagesTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			proficiencies: new SchemaField$s({
				languages: new SchemaField$s({
					value: new SetField$d(new StringField$r(), { required: true, label: "BF.Language.Dialect.Label" }),
					communication: new MappingField(new SchemaField$s({
						range: new NumberField$f({ min: 0, label: "BF.RANGE.Label" }),
						units: new StringField$r({ initial: "foot", label: "BF.RANGE.Unit.Label" })
					}), { label: "BF.Language.Communication.Label" }),
					custom: new ArrayField$6(new StringField$r(), { required: true, label: "BF.Language.Custom.Label" }),
					tags: new SetField$d(new StringField$r(), { required: true, label: "BF.Language.Tag.Label" })
				}, { label: "BF.Language.Label[other]" })
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare final language labels.
	 */
	prepareLanguages() {
		const languages = this.proficiencies.languages;
		const entries = new Map(Array.from(languages.value).map(v => [v, keyLabel(v, { trait: "languages" })]));
		languages.custom.forEach(c => entries.set(c, c));
		const extras = Object.entries(languages.communication).reduce((arr, [key, data]) => {
			const label = CONFIG.BlackFlag.rangedCommunication[key]?.label;
			if ( label && data.range ) arr.push(
				`${game.i18n.localize(label)} ${numberFormat(data.range, { unit: data.units })}`
			);
			return arr;
		}, []);

		languages.label = formatTaggedList({
			entries, extras, tags: languages.tags, tagDefinitions: CONFIG.BlackFlag.languageTags,
			inlineTags: true, listType: "conjunction"
		});
	}
}

/**
 * Template for actors with modifiers including a number of helper methods.
 */
class ModifiersTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			modifiers: new ModifierField()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add a note to initial modifiers that they are manual rather than added by advancement or effects.
	 */
	prepareBaseModifiers() {
		this.modifiers.forEach(modifier => Object.defineProperty(modifier, "source", {
			value: "manual",
			enumerable: true,
			writable: false
		}));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Clear out invalid modifiers & add static index for updates.
	 */
	prepareDerivedModifiers() {
		this.modifiers = this.modifiers.filter(m => !foundry.utils.isEmpty(m));
		this.modifiers.forEach((modifier, index) => Object.defineProperty(modifier, "index", {
			value: index,
			enumerable: false,
			writable: false
		}));
		// TODO: Attribute each non-manual modifier to a source (e.g. effect or advancement)
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Build a bonus formula or value from the provided modifiers.
	 * @param {object[]} modifiers - Modifiers from which to build the bonus.
	 * @param {object} [options={}]
	 * @param {boolean} [options.deterministic=false] - Should only deterministic modifiers be included?
	 * @param {object} [options.rollData={}] - Roll data to use when simplifying.
	 * @returns {string|number}
	 */
	buildBonus(modifiers, { deterministic=false, rollData={} }={}) {
		return this.mergeModifiers(modifiers, { deterministic, rollData });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Build a minimum roll value from the provided modifiers.
	 * @param {object[]} modifiers - Modifiers from which to build the minimum.
	 * @param {object} [options={}]
	 * @param {object} [options.rollData={}] - Roll data to use when simplifying.
	 * @returns {number|null}
	 */
	buildMinimum(modifiers, { rollData={} }={}) {
		return this.mergeModifiers(modifiers, { mode: "largest", rollData });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Merge multiple modifiers into one.
	 * @param {object[]} modifiers - Modifiers which to merge.
	 * @param {object} [options={}]
	 * @param {boolean} [options.deterministic=false] - Should only deterministic modifiers be included? Only use in
	 *                                                  additive mode.
	 * @param {"additive"|"smallest"|"largest"} [options.mode="additive"] - Mode used to arrive at the final value.
	 * @param {object} [options.rollData={}] - Roll data to use when simplifying.
	 * @returns {string|number|null}
	 */
	mergeModifiers(modifiers=[], { deterministic=true, mode="additive", rollData={} }={}) {
		if ( mode !== "additive" || deterministic ) modifiers = modifiers.map(m => simplifyBonus(m.formula, rollData));
		if ( mode === "additive" ) {
			if ( deterministic ) return modifiers.reduce((t, m) => t + m, 0);
			return modifiers.filter(m => m.formula).map(m => m.formula).join(" + ");
		}
		const pick = modifiers.reduce((extreme, m) => {
			if ( mode === "largest" ) return m > extreme ? m : extreme;
			else return m < extreme ? m : extreme;
		}, mode === "largest" ? -Infinity : Infinity);
		return Number.isFinite(pick) ? pick : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Modifiers              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add a new modifier.
	 * @param {object} data
	 */
	async addModifier(data) {
		const modifierCollection = this.toObject().modifiers;
		modifierCollection.push(data);
		await this.parent.update({"system.modifiers": modifierCollection});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Delete a modifier.
	 * @param {number} index
	 */
	async deleteModifier(index) {
		const modifierCollection = this.toObject().modifiers;
		modifierCollection.splice(index, 1);
		await this.parent.update({"system.modifiers": modifierCollection});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get a list of modifiers that match the provided data.
	 * @param {object|object[]} data - Description of modifiers to find.
	 * @param {string} [type="bonus"] - Modifier type to find.
	 * @returns {object[]}
	 */
	getModifiers(data, type="bonus") {
		if ( foundry.utils.getType(data) !== "Array" ) data = [data];
		if ( CONFIG.BlackFlag.debug.modifiers ) log("Fetching Modifiers:", { extras: foundry.utils.deepClone(data) });
		return this.modifiers.filter(modifier => {
			if ( modifier.type !== type ) return false;
			return data.some(d => performCheck(d, modifier.filter));
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Update a modifier.
	 * @param {number} index
	 * @param {object} updates
	 * @param {DocumentModificationContext} options
	 */
	async updateModifier(index, updates, options) {
		const modifierCollection = this.toObject().modifiers;
		foundry.utils.mergeObject(modifierCollection[index], updates);
		await this.parent.update({"system.modifiers": modifierCollection}, options);
	}
}

const { ArrayField: ArrayField$5, SchemaField: SchemaField$r, SetField: SetField$c, StringField: StringField$q } = foundry.data.fields;

/**
 * Field for storing information about damage & condition resistances, immunities, and vulnerabilities.
 *
 * @property {Set<string>} value - Resistances regardless of source.
 * @property {Set<string>} nonmagical - Resistances to non-magical sources.
 * @property {string[]} custom - Special resistance information.
 *
 * @param {object} [fields={}] - Additional fields to add or, if value is `false`, default fields to remove.
 * @param {object} [options={}] - Additional options in addition to the default label.
 */
class ResistancesField extends SchemaField$r {
	constructor(fields = {}, options = {}) {
		fields = {
			value: new SetField$c(new StringField$q()),
			nonmagical: new SetField$c(new StringField$q()),
			custom: new ArrayField$5(new StringField$q()),
			...fields
		};
		Object.entries(fields).forEach(([k, v]) => (!v ? delete fields[k] : null));
		super(fields, options);
	}
}

const { SchemaField: SchemaField$q } = foundry.data.fields;

/**
 * @typedef {object} ConditionResistanceData
 * @property {Set<string>} value - Resistances regardless of source.
 * @property {Set<string>} nonmagical - Resistances to non-magical sources.
 * @property {string[]} custom - Special resistance information.
 */

/**
 * @typedef {ConditionResistanceData} DamageResistanceData
 * @property {Set<string>} nonmagical - Resistances to non-magical sources.
 */

/**
 * Data definition template for condition & damage resistances, immunities, and vulnerabilities.
 *
 * @property {object} traits
 * @property {object} traits.condition
 * @property {ConditionResistanceData} traits.condition.immunities - Condition immunities.
 * @property {ConditionResistanceData} traits.condition.resistances - Condition resistances.
 * @property {ConditionResistanceData} traits.condition.vulnerabilities - Condition vulnerabilities.
 * @property {object} traits.damage
 * @property {DamageResistanceData} traits.damage.immunities - Damage immunities.
 * @property {DamageResistanceData} traits.damage.resistances - Damage resistances.
 * @property {DamageResistanceData} traits.damage.vulnerabilities - Damage vulnerabilities.
 */
class ResistancesTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			traits: new SchemaField$q({
				condition: new SchemaField$q({
					immunities: new ResistancesField({ nonmagical: false }, { label: "BF.Immunity.Label" }),
					resistances: new ResistancesField({ nonmagical: false }, { label: "BF.Resistance.Label" }),
					vulnerabilities: new ResistancesField({ nonmagical: false }, { label: "BF.Vulnerability.Label" })
				}),
				damage: new SchemaField$q({
					immunities: new ResistancesField({}, { label: "BF.Immunity.Label" }),
					resistances: new ResistancesField({}, { label: "BF.Resistance.Label" }),
					vulnerabilities: new ResistancesField({}, { label: "BF.Vulnerability.Label" })
				})
			}, { label: "BF.Trait.Label[other]" })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve final movement, senses, and resistances/immunities.
	 * @param {object} rollData
	 */
	prepareDerivedResistances(rollData) {
		// Adjust resistances & immunities based on status effects
		if ( this.hasConditionEffect("petrification") ) {
			this.traits.condition.immunities.value.add("poisoned");
			this.traits.damage.resistances.value.add("all");
			this.traits.damage.immunities.value.add("poison");
		}

		// Clean up damage resistances, immunities, and vulnerabilities
		// If all damage is set for a section, remove all other types
		// Remove any resistances from non-magical sources that are also in all sources
		["resistances", "immunities", "vulnerabilities"].forEach(k => this.cleanLabelResistances(
			this.traits.condition[k], this.traits.damage[k]
		));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Clean and create labels for resistance, immunity, and vulnerability sets.
	 * @param {ConditionResistanceData} condition - Condition data.
	 * @param {DamageResistanceData} damage - Damage data.
	 */
	cleanLabelResistances(condition, damage) {
		if ( damage.value.has("all") ) {
			damage.value.clear();
			damage.nonmagical.clear();
			damage.value.add("all");
		} else if ( damage.nonmagical.has("all") ) {
			damage.nonmagical.clear();
			damage.nonmagical.add("all");
		} else {
			damage.value.forEach(v => damage.nonmagical.delete(v));
		}

		const makeDamageLabel = (source, formatter) => formatter.format(
			Array.from(source).map(t => t === "all" ?
				game.i18n.localize("BF.Resistance.AllDamage") :
				CONFIG.BlackFlag.damageTypes.localized[t]).filter(t => t)
		);
		const nonmagical = makeDamageLabel(damage.nonmagical, game.i18n.getListFormatter({ style: "long" }));
		damage.label = [
			makeDamageLabel(damage.value, game.i18n.getListFormatter({ type: "unit" })),
			nonmagical ? game.i18n.format("BF.Resistance.Nonmagical", { type: nonmagical }) : null
		].filter(t => t).join("; ");

		condition.label = game.i18n.getListFormatter({ type: "unit" })
			.format(Array.from(condition.value).map(t => CONFIG.BlackFlag.conditions.localized[t]).filter(t => t));
	}
}

const { SchemaField: SchemaField$p, StringField: StringField$p } = foundry.data.fields;

/**
 * Data definition template for actors with size & auto-sizing tokens.
 *
 * @property {object} traits
 * @property {object} traits.size - Creature size.
 */
class SizeTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			traits: new SchemaField$p({
				size: new StringField$p({ label: "BF.Size.Label" })
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	async _preCreateSize(data, options, user) {
		if ( !foundry.utils.hasProperty(data, "prototypeToken.width")
			&& !foundry.utils.hasProperty(data, "prototypeToken.height")) {
			const size = CONFIG.BlackFlag.sizes[this.traits.size]?.scale;
			this.parent.updateSource({ "prototypeToken.width": size, "prototypeToken.height": size });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _preUpdateSize(changed, options, user) {
		const newSize = foundry.utils.getProperty(changed, "system.traits.size");
		if ( !newSize || (newSize === this.traits.size) ) return;

		if ( !foundry.utils.hasProperty(changed, "prototypeToken.width")
			&& !foundry.utils.hasProperty(changed, "prototypeToken.height") ) {
			const size = CONFIG.BlackFlag.sizes[newSize]?.scale;
			foundry.utils.setProperty(changed, "prototypeToken.width", size);
			foundry.utils.setProperty(changed, "prototypeToken.height", size);
		}
	}
}

const { ArrayField: ArrayField$4, NumberField: NumberField$e, SchemaField: SchemaField$o, SetField: SetField$b, StringField: StringField$o } = foundry.data.fields;

/**
 * Data definition template for PC & NPC traits.
 *
 * @property {object} traits
 * @property {object} traits.movement
 * @property {number} traits.movement.base - Base movement value made available to specific types as `@base`.
 * @property {string[]} traits.movement.custom - Special movement information.
 * @property {Set<string>} traits.movement.tags - Movement tags.
 * @property {Record<string, string>} traits.movement.types - Formulas for specific movement types.
 * @property {string} traits.movement.units - Units used to measure movement.
 * @property {object} traits.senses
 * @property {string[]} traits.senses.custom - Special sense information.
 * @property {Set<string>} traits.senses.tags - Sense tags.
 * @property {Record<string, string>} traits.senses.types - Formulas for specific sense types.
 * @property {string} traits.senses.units - Units used to measure senses.
 */
class TraitsTemplate extends foundry.abstract.DataModel {

	/** @override */
	static defineSchema() {
		return {
			traits: new SchemaField$o({
				movement: new SchemaField$o({
					base: new NumberField$e({ nullable: false, initial: 30, min: 0, step: 0.1 }),
					custom: new ArrayField$4(new StringField$o()),
					tags: new SetField$b(new StringField$o()),
					types: new MappingField(new FormulaField({ deterministic: true }), {
						initial: { walk: "@base" }
					}),
					units: new StringField$o({ initial: "foot", label: "BF.MOVEMENT.FIELDS.traits.movement.units.label" })
				}),
				senses: new SchemaField$o({
					custom: new ArrayField$4(new StringField$o()),
					tags: new SetField$b(new StringField$o()),
					types: new MappingField(new FormulaField({ deterministic: true })),
					units: new StringField$o({ initial: "foot" })
				})
			}, {label: "BF.Trait.Label[other]"})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare initial movement values.
	 */
	prepareBaseTraits() {
		this.traits.movement.multiplier ??= "1";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve final movement and senses.
	 * @param {object} rollData
	 */
	prepareDerivedTraits(rollData) {
		const movement = this.traits.movement;
		rollData.base = movement.base;

		// Determine how movement should be changed by status effects
		const noMovement = this.hasConditionEffect("noMovement");
		const halfMovement = this.hasConditionEffect("halfMovement");
		const multiplier = simplifyBonus(movement.multiplier, rollData);

		const modifierData = {
			type: "movement",
			actor: this,
			armored: !!this.attributes?.ac?.equippedArmor,
			armor: this.attributes?.ac?.equippedArmor?.system,
			shielded: !!this.attributes?.ac?.equippedShield,
			shield: this.attributes?.ac?.equippedShield?.system
		};

		// Calculate each special movement type using base speed
		const entries = new Map();
		for ( const [type, formula] of Object.entries(movement.types) ) {
			let speed;
			if ( (this.parent.statuses.has("prone") && (type !== "walk")) || noMovement ) speed = 0;
			else speed = simplifyBonus(formula, rollData);
			if ( speed > 0 ) speed += this.buildBonus(
				this.getModifiers({ ...modifierData, movementType: type }),
				{ deterministic: true, rollData }
			);
			movement.types[type] = speed * multiplier * (halfMovement ? 0.5 : 1);

			const label = CONFIG.BlackFlag.movementTypes.localized[type];
			if ( speed && label ) {
				if ( type === "walk" ) entries.set(type, numberFormat(speed, { unit: movement.units }));
				else entries.set(type, `${label.toLowerCase()} ${numberFormat(speed, { unit: movement.units })}`);
			}
		}

		// Prepare movement labels
		movement.labels = Object.entries(movement.types)
			.filter(([type, speed]) => speed > 0)
			.sort((lhs, rhs) => rhs[1] - lhs[1])
			.map(([type, speed]) => {
				const config = CONFIG.BlackFlag.movementTypes[type];
				const label = config ? game.i18n.localize(config.label) : type;
				return `${label} ${numberFormat(speed, { unit: movement.units })}`;
			});
		movement.labels.push(...movement.custom);
		movement.label = formatTaggedList({
			entries, extras: movement.custom, tags: movement.tags, tagDefinitions: CONFIG.BlackFlag.movementTags
		});

		// Calculate each special sense type
		const senses = this.traits.senses;
		const senseEntries = new Map();
		for ( const [type, formula] of Object.entries(senses.types) ) {
			const range = simplifyBonus(formula, rollData);
			senses.types[type] = range;
			const label = CONFIG.BlackFlag.senses.localized[type];
			if ( range && label ) senseEntries.set(type, `${label} ${numberFormat(range, { unit: senses.units })}`);
		}
		senses.label = formatTaggedList({
			entries: senseEntries, extras: senses.custom, tags: senses.tags, tagDefinitions: CONFIG.BlackFlag.senseTags
		});
	}
}

const { BooleanField: BooleanField$4, HTMLField: HTMLField$8, NumberField: NumberField$d, SchemaField: SchemaField$n, SetField: SetField$a, StringField: StringField$n } = foundry.data.fields;

/**
 * Data for NPC abilities.
 *
 * @typedef {object} NPCAbilityData
 * @property {number} mod - Ability modifier with proficiency included.
 * @property {boolean} proficient - Is the NPC proficient in this ability?
 */

/**
 * Data model for NPC actors.
 * @mixes {ACTemplate}
 * @mixes {ConditionsTemplate}
 * @mixes {HPTemplate}
 * @mixes {InitiativeTemplate}
 * @mixes {LanguagesTemplate}
 * @mixes {ModifiersTemplate}
 * @mixes {ResistancesTemplate}
 * @mixes {SizeTemplate}
 * @mixes {SourceTemplate}
 * @mixes {TraitsTemplate}
 *
 * @property {Record<string, NPCAbilityData} abilities - NPC's ability modifiers.
 * @property {object} attributes
 * @property {number} attributes.cr - Challenge rating.
 * @property {number} attributes.legendary.spent - Number of spent legendary actions this round.
 * @property {number} attributes.legendary.max - Number of available legendary actions per round.
 * @property {number} attributes.perception - Creature's perception score.
 * @property {number} attributes.stealth - Creature's stealth score.
 * @property {object} biography
 * @property {string} biography.value - Biography on the creature.
 * @property {string} biography.legendary - Override of the legendary actions description.
 * @property {object} spellcasting
 * @property {string} spellcasting.ability - Ability used for spellcasting.
 * @property {number} spellcasting.dc - Spell save DC if not auto-calculated.
 * @property {object} traits
 * @property {CreatureTypeField} traits.type - Creature type information.
 */
class NPCData extends ActorDataModel.mixin(
	ACTemplate,
	ConditionsTemplate,
	HPTemplate,
	InitiativeTemplate,
	LanguagesTemplate,
	ModifiersTemplate,
	ResistancesTemplate,
	SizeTemplate,
	SourceTemplate,
	TraitsTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = {
		type: "npc",
		category: "person",
		localization: "BF.Actor.Type.NPC",
		img: "systems/black-flag/artwork/types/npc.svg",
		sheet: {
			application: NPCSheet,
			label: "BF.Sheet.Default.NPC"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			abilities: new MappingField(
				new SchemaField$n({
					mod: new NumberField$d({ integer: true }),
					proficient: new BooleanField$4()
				}),
				{
					initialKeys: CONFIG.BlackFlag.abilities,
					prepareKeys: true,
					label: "BF.Ability.Label[other]"
				}
			),
			attributes: new SchemaField$n({
				ac: new SchemaField$n({
					baseFormulas: new SetField$a(new StringField$n(), {
						initial: ["unarmored", "armored", "natural"]
					})
				}),
				cr: new NumberField$d({ nullable: true, min: 0, initial: 0, label: "BF.ChallengeRating.Label" }),
				legendary: new SchemaField$n({
					spent: new NumberField$d({ min: 0, initial: 0, integer: true }),
					max: new NumberField$d({ min: 1, initial: null, integer: true })
				}),
				perception: new NumberField$d({ min: 0, integer: true, label: "BF.Skill.Perception.Label" }),
				stealth: new NumberField$d({ min: 0, integer: true, label: "BF.Skill.Stealth.Label" })
			}),
			biography: new SchemaField$n({
				value: new HTMLField$8(),
				legendary: new HTMLField$8()
			}),
			spellcasting: new SchemaField$n({
				ability: new StringField$n({ initial: "intelligence" }),
				dc: new NumberField$d({ integer: true, min: 0 })
			}),
			traits: new SchemaField$n({
				type: new CreatureTypeField(),
				size: new StringField$n({ initial: "medium" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * XP value for this NPC based on its CR.
	 * @type {number}
	 */
	get xpValue() {
		if (this.attributes.cr === null) return 0;
		const index =
			this.attributes.cr >= 1 ? this.attributes.cr + 3 : { 0: 0, 0.125: 1, 0.25: 2, 0.5: 3 }[this.attributes.cr];
		return CONFIG.BlackFlag.xpForCR[index] ?? 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate source data to an object.
	 * @param {object} source - The candidate source data from which the model will be constructed.
	 */
	static migrateSource(source) {
		// Added 0.9.031
		if (foundry.utils.getType(source.biography?.source) === "string") {
			source.description ??= {};
			source.description.source = { fallback: source.biography.source };
		}

		// Added 0.10.046
		else if (foundry.utils.getType(source.biography?.source) === "Object") {
			source.description ??= {};
			source.description.source = foundry.utils.mergeObject(source.description.source ?? {}, source.biography.source);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();

		for (const [key, ability] of Object.entries(this.abilities)) {
			ability._source = this._source.abilities?.[key] ?? {};
			ability.check ??= {};
			ability.save ??= {};
		}
		Object.defineProperty(this.abilities, "_supportsProficiency", {
			value: true,
			configurable: true,
			writable: false
		});

		this.attributes.proficiency = Proficiency.calculateMod(Math.max(this.attributes.cr ?? 1, 1));

		this.prepareBaseArmorFormulas();
		this.prepareBaseModifiers();
		this.prepareBaseTraits();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareEmbeddedData() {
		super.prepareEmbeddedData();

		// Conditions
		// TODO: Refactor this out into mixin
		this.conditions = {};
		for (const effect of this.parent.effects) {
			const identifier = effect.statuses.first();
			const level = foundry.utils.getProperty(effect, "flags.black-flag.condition.level");
			if (!identifier) continue;
			this.conditions[identifier] = Math.max(this.conditions[identifier] ?? 0, level ?? 1);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		const rollData = this.parent.getRollData({ deterministic: true });

		this.prepareConditions();
		this.prepareLanguages();
		this.prepareSource();
		this.prepareDerivedArmorFormulas();
		this.prepareDerivedHitPoints();
		this.prepareDerivedModifiers();
		this.prepareDerivedResistances();
		this.prepareDerivedTraits(rollData);

		this.prepareDerivedAbilities(rollData);

		// Initiative
		this.computeInitiative();

		// Languages
		Object.defineProperty(this.proficiencies.languages, "list", {
			get() {
				return Array.from(this.value).join(" ");
			},
			configurable: true,
			enumerable: false
		});

		// Legendary Actions
		this.attributes.legendary.max ??= 0;
		this.attributes.legendary.value = Math.clamp(
			this.attributes.legendary.max - this.attributes.legendary.spent,
			0,
			this.attributes.legendary.max
		);

		// Perception & Stealth
		this.attributes.perception ??= 10 + (this.abilities.wisdom?.mod ?? 0);
		this.attributes.stealth ??= 10 + (this.abilities.dexterity?.mod ?? 0);
		if (this.attributes.ac.equippedArmor?.system.properties.has("noisy")) {
			this.attributes.baseStealth = this.attributes.stealth;
			this.attributes.stealth -= 5;
		}

		// Spellcasting
		const ability = this.abilities[this.spellcasting.ability];
		this.spellcasting.autoDC = 8 + (ability?.mod ?? 0) + this.attributes.proficiency;
		this.spellcasting.cantripScale = SpellcastingTemplate.calculateCantripScale(Math.max(this.attributes.cr ?? 1, 1));
		this.spellcasting.dc ??= this.spellcasting.autoDC;

		this.computeArmorClass();
		this.computeInitiative();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare abilities.
	 * @param {object} rollData
	 */
	prepareDerivedAbilities(rollData) {
		for (const [key, ability] of Object.entries(this.abilities)) {
			ability.valid = ability.mod !== null;
			ability.mod ??= 0;
			ability.adjustedMod = ability.mod - (ability.proficient ? this.attributes.proficiency : 0);

			ability.check.proficiency = new Proficiency(this.attributes.proficiency, 0, "down");
			ability.save.proficiency = new Proficiency(this.attributes.proficiency, 0, "down");

			const checkData = { type: "ability-check", ability: key, proficiency: ability.check.proficiency.multiplier };
			ability.check.modifiers = {
				_data: checkData,
				bonus: this.getModifiers(checkData),
				minimum: this.getModifiers(checkData, "min"),
				notes: this.getModifiers(checkData, "note")
			};
			ability.check.bonus = this.buildBonus(ability.check.modifiers.bonus, { deterministic: true, rollData });
			const saveData = { type: "ability-save", ability: key, proficiency: ability.save.proficiency.multiplier };
			ability.save.modifiers = {
				_data: saveData,
				bonus: this.getModifiers(saveData),
				minimum: this.getModifiers(saveData, "min"),
				notes: this.getModifiers(saveData, "note")
			};
			ability.save.bonus = this.buildBonus(ability.save.modifiers.bonus, { deterministic: true, rollData });

			ability.check.mod = ability.mod + ability.check.proficiency.flat + ability.check.bonus;
			ability.save.mod = ability.mod + ability.save.proficiency.flat + ability.save.bonus;
			ability.dc = 8 + ability.mod + this.attributes.proficiency;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		for (const value of config.values) {
			if (value === "statblock") config.statblock = true;
		}
		if (!config.statblock) return super.toEmbed(config, options);

		const context = await this.parent.sheet.getData();
		context.cr = formatCR(context.system.attributes.cr, { narrow: false });
		context.name = config.label || this.parent.name;
		if (config.cite === true) {
			context.anchor = this.parent.toAnchor({ name: context.name }).outerHTML;
			config.cite = false;
		}
		const section = document.createElement("section");
		section.innerHTML = await renderTemplate("systems/black-flag/templates/actor/embeds/npc-embed.hbs", context);
		return section.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async recoverCombatUses(periods, results) {
		// Recover legendary actions
		if (this.attributes.legendary.max && (periods.includes("encounter") || periods.includes("roundEnd"))) {
			results.actor["system.attributes.legendary.spent"] = 0;
		}
	}
}

/**
 * Data definition template for actors that need to calculate carrying capacity.
 */
class EncumbranceTemplate extends foundry.abstract.DataModel {

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Initialize base encumbrance fields so they can be targeted by active effects.
	 */
	prepareBaseEncumbrance() {
		const encumbrance = this.attributes.encumbrance ??= {};
		encumbrance.multipliers = {
			encumbered: "1", heavilyEncumbered: "1", maximum: "1", overall: "1"
		};
		encumbrance.bonuses = {
			encumbered: "", heavilyEncumbered: "", maximum: "", overall: ""
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare final language labels.
	 * @param {object} rollData
	 * @param {object} [options={}]
	 * @param {Function} [options.validateItem] - Method to determine whether an item should count towards carried weight.
	 */
	prepareDerivedEncumbrance(rollData, { validateItem }={}) {
		const config = CONFIG.BlackFlag.encumbrance;
		const encumbrance = this.attributes.encumbrance ??= {};
		const baseUnits = config.baseUnits[this.parent.type] ?? config.baseUnits.default;
		const unitSystem = "imperial";

		// Get the total weight from items
		let weight = this.parent.items
			.filter(item => !item.container && (validateItem?.(item) ?? true))
			.reduce((weight, item) => weight + (item.system.totalWeightIn?.(baseUnits[unitSystem]) ?? 0), 0);

		// Determine size class
		// TODO: Add support for Powerful Build
		const sizeConfig = CONFIG.BlackFlag.sizes[this.traits.size];
		const sizeMod = sizeConfig?.capacityMultiplier ?? sizeConfig?.token ?? 1;

		// Calculate encumbrance thresholds
		let maximumMultiplier;
		encumbrance.thresholds = Array.from(Object.keys(config.threshold)).reduce((obj, threshold) => {
			let base = this.abilities.strength?.value ?? 0;
			const bonus = simplifyBonus(encumbrance.bonuses?.[threshold], rollData)
				+ simplifyBonus(encumbrance.bonuses?.overall, rollData);
			let multiplier = simplifyBonus(encumbrance.multipliers[threshold], rollData)
				* simplifyBonus(encumbrance.multipliers.overall, rollData);
			if ( threshold === "maximum" ) maximumMultiplier = multiplier;
			multiplier *= (config.threshold[threshold]?.[unitSystem] ?? 1) * sizeMod;
			obj[threshold] = (base * multiplier).toNearest(0.1) + bonus;
			return obj;
		}, {});

		// Populate final encumbrance values
		encumbrance.value = weight.toNearest(0.1);
		encumbrance.max = encumbrance.thresholds.maximum;
		encumbrance.multiplier = (sizeMod * maximumMultiplier).toNearest(0.1);
		if ( encumbrance.max ) {
			encumbrance.stops = {
				encumbered: Math.clamp((encumbrance.thresholds.encumbered * 100) / encumbrance.max, 0, 100),
				heavilyEncumbered: Math.clamp((encumbrance.thresholds.heavilyEncumbered * 100) / encumbrance.max, 0, 100)
			};
			encumbrance.percentage = Math.clamp((encumbrance.value * 100) / encumbrance.max, 0, 100);
		} else {
			encumbrance.stops = { encumbered: 0, heavilyEncumbered: 0 };
			encumbrance.percentage = 0;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle applying or removing encumbrance status effects.
	 * @param {DocumentModificationContext} options - Additional options supplied with the update.
	 * @returns {Promise<BlackFlagActiveEffect>|void}
	 */
	updateEncumbrance(options) {
		const encumbrance = this.attributes?.encumbrance;
		if ( !encumbrance || (game.settings.get(game.system.id, "encumbrance") === "none") ) return;
		const statuses = [];
		const variant = game.settings.get(game.system.id, "encumbrance") === "variant";
		if ( encumbrance.value > encumbrance.thresholds.maximum ) statuses.push("exceedingCarryingCapacity");
		if ( encumbrance.value > encumbrance.thresholds.heavilyEncumbered && variant ) statuses.push("heavilyEncumbered");
		if ( encumbrance.value > encumbrance.thresholds.encumbered && variant ) statuses.push("encumbered");

		const effect = this.parent.effects.get(BlackFlagActiveEffect.ID.ENCUMBERED);
		if ( !statuses.length ) return effect?.delete();

		const effectData = { ...CONFIG.BlackFlag.encumbrance.effects[statuses[0]], statuses };
		effectData.name = game.i18n.localize(effectData.name);
		if ( effect ) {
			const originalEncumbrance = effect.statuses.first();
			return effect.update(effectData, { [game.system.id]: { originalEncumbrance } });
		}

		return ActiveEffect.implementation.create(
			{ _id: BlackFlagActiveEffect.ID.ENCUMBERED, ...effectData },
			{ parent: this.parent, keepId: true }
		)
	}
}

const { ArrayField: ArrayField$3, HTMLField: HTMLField$7, NumberField: NumberField$c, SchemaField: SchemaField$m, SetField: SetField$9, StringField: StringField$m } = foundry.data.fields;

/**
 * @typedef {object} PCAbilityData
 * @property {number} base - Base ability score set during character creation.
 * @property {number} max - Maximum ability score available during Improvement.
 * @property {object} save
 * @property {Proficiency} save.proficiency - Saving throw proficiency.
 */

/**
 * Data model for PC actors.
 * @mixes {ACTemplate}
 * @mixes {ConditionsTemplate}
 * @mixes {EncumbranceTemplate}
 * @mixes {InitiativeTemplate}
 * @mixes {LanguagesTemplate}
 * @mixes {ModifiersTemplate}
 * @mixes {ResistancesTemplate}
 * @mixes {SpellcastingTemplate}
 * @mixes {SizeTemplate}
 * @mixes {TraitsTemplate}
 *
 * @property {Record<string, PCAbilityData} abilities - NPC's ability modifiers.
 * @property {object} attributes
 * @property {object} attributes.attunement
 * @property {number} attributes.attunement.max - Maximum number of items that can be attuned.
 * @property {object} attributes.death
 * @property {string} attributes.death.status - Current character status (e.g. alive, dying, stable, dead).
 * @property {number} attributes.death.success - Current number of death save successes.
 * @property {number} attributes.death.failure - Current number of death save failures.
 * @property {object} attributes.death.overrides
 * @property {number} attributes.death.overrides.success - Number of successes needed to stabilize.
 * @property {number} attributes.death.overrides.failure - Number of failures needed to die.
 * @property {number} attributes.death.overrides.target - Target value to roll on death saves to succeed.
 * @property {object} attributes.hd
 * @property {Record<number, { spent: number }>} attributes.hd.d - Spent hit dice of each denomination.
 * @property {object} attributes.hp
 * @property {object} attributes.hp.bonuses
 * @property {string} attributes.hp.bonuses.level - Per-level hit points bonus.
 * @property {string} attributes.hp.bonuses.overall - Overall hit points bonus.
 * @property {number} attributes.hp.override - Maximum HP override that ignores all calculation.
 * @property {number} attributes.hp.temp - Temporary hit points.
 * @property {number} attributes.hp.tempMax - Temporary maximum hit points.
 * @property {number} attributes.hp.value - Current hit points.
 * @property {object} attributes.initiative
 * @property {string} attributes.initiative.ability - Ability to use when rolling initiative.
 * @property {Proficiency} attributes.initiative.proficiency - Proficiency with initiative rolls.
 * @property {object} attributes.luck
 * @property {number} attributes.luck.value - Current luck points.
 * @property {string} attributes.luck.formula - Formula to use when re-rolling luck.
 * @property {object} biography
 * @property {string} biography.age - Character's age.
 * @property {string} biography.height - Character's height.
 * @property {string} biography.weight - Character's weight.
 * @property {string} biography.eyes - Character's eyes.
 * @property {string} biography.skin - Character's skin.
 * @property {string} biography.hair - Character's hair.
 * @property {string} biography.backstory - Description of character's backstory.
 * @property {string} biography.motivation - Description of character's motivation.
 * @property {string} biography.allies - Description of character's allies.
 * @property {object} proficiencies
 * @property {object} proficiencies.armor
 * @property {Set<string>} proficiencies.armor.value
 * @property {string[]} proficiencies.armor.custom
 * @property {object} proficiencies.base
 * @property {Proficiency} proficiencies.base.checks - Minimum proficiency in all ability checks.
 * @property {Proficiency} proficiencies.base.saves - Minimum proficiency in saving throws.
 * @property {Proficiency} proficiencies.base.skills - Minimum proficiency in skill checks.
 * @property {Proficiency} proficiencies.base.tools - Minimum proficiency in tool checks.
 * @property {Proficiency} proficiencies.base.vehicles - Minimum proficiency in vehicle checks.
 * @property {Record<string, { proficiency: Proficiency }>} proficiencies.skills - Skill proficiencies.
 * @property {Record<string, { proficiency: Proficiency }>} proficiencies.tools - Tool proficiencies.
 * @property {Record<string, { proficiency: Proficiency }>} proficiencies.vehicles - Vehicle proficiencies.
 * @property {object} proficiencies.weapons
 * @property {Set<string>} proficiencies.weapons.value
 * @property {string[]} proficiencies.weapons.custom
 * @property {object} progression
 * @property {object} progression.abilities
 * @property {string} progression.abilities.method - Method used to determine ability scores.
 * @property {BaseRoll[]} progression.abilities.rolls - Rolls if rolling used to determine scores.
 * @property {Record<string, number>} progression.abilities.assignments - Indices of scores assigned to each ability if
 *                                                                        rolling or standard array assignment were
 *                                                                        used, or number of steps assigned to a score
 *                                                                        if point buy was used.
 * @property {Record<string, number>} progression.abilities.bonuses - Indices of bonuses assigned to each score.
 * @property {AdvancementValueField} progression.advancement - Stored advancement data.
 * @property {BlackFlagItem} progression.background - Character's background item.
 * @property {BlackFlagItem} progression.heritage - Character's heritage item.
 * @property {BlackFlagItem} progression.lineage - Character's lineage item.
 * @property {Record<number, { class: BlackFlagItem, time: TimeData }>} progression.levels - Level information.
 * @property {object} progression.xp
 * @property {number} progression.xp.value - Total XP earned.
 * @property {{ amount: number, time: TimeData, source: string }[]} progression.xp.log
 * @property {object} traits
 * @property {CreatureTypeField} traits.type - Character's type information.
 */
class PCData extends ActorDataModel.mixin(
	ACTemplate,
	ConditionsTemplate,
	EncumbranceTemplate,
	InitiativeTemplate,
	LanguagesTemplate,
	ModifiersTemplate,
	ResistancesTemplate,
	SpellcastingTemplate,
	SizeTemplate,
	TraitsTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.PC"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static metadata = {
		type: "pc",
		category: "person",
		localization: "BF.Actor.Type.PC",
		img: "systems/black-flag/artwork/types/pc.svg",
		sheet: {
			application: PCSheet,
			label: "BF.Sheet.Default.PC"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			abilities: new MappingField(
				new SchemaField$m({
					base: new NumberField$c({ min: 0, integer: true, label: "BF.Ability.Score.Base" }),
					max: new NumberField$c({ min: 0, initial: 20, integer: true }),
					save: new SchemaField$m({
						proficiency: new ProficiencyField({ rounding: false })
					})
				}),
				{ initialKeys: CONFIG.BlackFlag.abilities, prepareKeys: true }
			),
			attributes: new SchemaField$m({
				attunement: new SchemaField$m({
					max: new NumberField$c({ initial: 3, min: 0, integer: true, label: "BF.Attunement.Max.Label" })
				}),
				death: new SchemaField$m({
					status: new StringField$m({ initial: "alive", blank: false }),
					success: new NumberField$c({
						nullable: false,
						initial: 0,
						min: 0,
						integer: true,
						label: "BF.Death.Success.Label"
					}),
					failure: new NumberField$c({
						nullable: false,
						initial: 0,
						min: 0,
						integer: true,
						label: "BF.Death.Failure.Label"
					}),
					overrides: new SchemaField$m({
						success: new NumberField$c({
							label: "BF.Death.Override.Success.Label",
							hint: "BF.Death.Override.Success.hint"
						}),
						failure: new NumberField$c({
							label: "BF.Death.Override.Failure.Label",
							hint: "BF.Death.Override.Failure.hint"
						}),
						target: new NumberField$c({
							label: "BF.Death.Override.Target.Label",
							hint: "BF.Death.Override.Target.hint"
						})
					})
				}),
				hd: new SchemaField$m({
					d: new MappingField(
						new SchemaField$m({
							spent: new NumberField$c({ min: 0, integer: true })
						})
					)
				}),
				hp: new SchemaField$m({
					bonuses: new SchemaField$m({
						level: new FormulaField({ deterministic: true }),
						overall: new FormulaField({ deterministic: true })
					}),
					override: new NumberField$c({ integer: true }),
					temp: new NumberField$c({ min: 0, integer: true }),
					tempMax: new NumberField$c({ integer: true }),
					value: new NumberField$c({ min: 0, integer: true })
				}),
				initiative: new SchemaField$m({
					ability: new StringField$m({ label: "BF.Initiative.Ability.Label" }),
					proficiency: new ProficiencyField()
				}),
				luck: new SchemaField$m({
					value: new NumberField$c({ min: 0, max: 5, integer: true }),
					formula: new FormulaField({ label: "BF.Luck.Formula.Label", hint: "BF.Luck.Formula.Hint" })
				})
			}),
			biography: new SchemaField$m({
				age: new StringField$m(),
				height: new StringField$m(),
				weight: new StringField$m(),
				eyes: new StringField$m(),
				skin: new StringField$m(),
				hair: new StringField$m(),
				backstory: new HTMLField$7(),
				motivation: new HTMLField$7(),
				allies: new HTMLField$7()
			}),
			proficiencies: new SchemaField$m({
				armor: new SchemaField$m({
					value: new SetField$9(new StringField$m()),
					custom: new ArrayField$3(new StringField$m())
				}),
				base: new SchemaField$m({
					checks: new ProficiencyField(),
					saves: new ProficiencyField(),
					skills: new ProficiencyField(),
					tools: new ProficiencyField(),
					vehicles: new ProficiencyField()
				}),
				skills: new MappingField(
					new SchemaField$m({
						proficiency: new ProficiencyField({ rounding: false })
					}),
					{
						initialKeys: CONFIG.BlackFlag.skills,
						prepareKeys: true,
						label: "BF.Skill.Label[other]"
					}
				),
				tools: new MappingField(
					new SchemaField$m({
						proficiency: new ProficiencyField({ rounding: false }, { initial: { multiplier: 1 } })
					}),
					{ label: "BF.Tool.Label[other]" }
				),
				vehicles: new MappingField(
					new SchemaField$m({
						proficiency: new ProficiencyField({ rounding: false }, { initial: { multiplier: 1 } })
					}),
					{ label: "BF.VEHICLE.Label[other]" }
				),
				weapons: new SchemaField$m({
					value: new SetField$9(new StringField$m()),
					custom: new ArrayField$3(new StringField$m())
				})
			}),
			progression: new SchemaField$m({
				abilities: new SchemaField$m({
					method: new StringField$m(),
					rolls: new ArrayField$3(new RollField({ nullable: true })),
					assignments: new MappingField(new NumberField$c({ min: 0, integer: true })),
					bonuses: new MappingField(new NumberField$c({ integer: true }))
				}),
				advancement: new AdvancementValueField(),
				background: new LocalDocumentField(foundry.documents.BaseItem),
				heritage: new LocalDocumentField(foundry.documents.BaseItem),
				lineage: new LocalDocumentField(foundry.documents.BaseItem),
				levels: new MappingField(
					new SchemaField$m({
						class: new LocalDocumentField(foundry.documents.BaseItem),
						time: new TimeField()
					}),
					{ label: "BF.Level.Label[other]" }
				),
				xp: new SchemaField$m(
					{
						value: new NumberField$c({
							nullable: false,
							initial: 0,
							min: 0,
							integer: true,
							label: "BF.ExperiencePoints.Current.Label"
						}),
						log: new ArrayField$3(
							new SchemaField$m({
								amount: new NumberField$c({ nullable: false, initial: 0, min: 0, integer: true }),
								time: new TimeField(),
								source: new StringField$m()
							})
						)
					},
					{ label: "BF.ExperiencePoints.Label" }
				)
			}),
			traits: new SchemaField$m({
				type: new CreatureTypeField({ swarm: false })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get embeddedDescriptionKeyPath() {
		return "biography.backstory";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();

		this.progression.abilities.assignmentComplete = true;
		for (const [key, ability] of Object.entries(this.abilities)) {
			ability._source = this._source.abilities?.[key] ?? {};
			ability.check ??= {};
			ability.value = ability.base;
			if (!ability.base) this.progression.abilities.assignmentComplete = false;
		}

		this.spellcasting.dc ??= 0;
		this.spellcasting.maxCircle ??= 0;
		this.spellcasting.totals ??= { value: 0, spent: 0, max: 0 };
		this.spellcasting.origins ??= {};
		this.spellcasting.spells ??= { total: 0, cantrips: 0, rituals: 0, damaging: 0 };
		this.spellcasting.spells.knowable ??= { cantrips: 0, rituals: 0, spells: 0 };

		this.prepareBaseArmorFormulas();
		this.prepareBaseEncumbrance();
		this.prepareBaseModifiers();
		this.prepareBaseTraits();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareEmbeddedData() {
		super.prepareEmbeddedData();

		// Classes & Progression
		this.progression.classes = {};
		const subclasses = this.parent.items
			.filter(i => i.type === "subclass")
			.reduce((obj, i) => {
				obj[i.system.identifier.class] = i;
				return obj;
			}, {});
		for (const [level, data] of Object.entries(this.progression.levels)) {
			const document = data.class;
			if (!document) continue;
			const classData = (this.progression.classes[data.class.identifier] ??= {
				document,
				subclass: subclasses[document.identifier],
				levels: 0,
				originalClass: Number(level) === 1
			});
			classData.levels += 1;
			data.levels = { character: Number(level), class: classData.levels, identifier: document.identifier };
		}
		for (const data of Object.values(this.progression.classes)) {
			Object.defineProperty(data, "levelsLabel", {
				get() {
					return game.i18n.format(`BF.Level.Count[${getPluralRules().select(this.levels)}]`, { number: this.levels });
				},
				configurable: true,
				enumerable: false
			});
			Object.defineProperty(data, "requiresSubclass", {
				value: !data.subclass && data.levels >= CONFIG.BlackFlag.subclassLevel,
				enumerable: false,
				writable: false
			});
		}
		this.progression.level = Object.keys(this.progression.levels).length;
		this.attributes.proficiency = Proficiency.calculateMod(this.progression.level ?? 1);

		// Experience Points
		const xp = this.progression.xp;
		const getXP = level =>
			CONFIG.BlackFlag.experiencePoints[Math.clamp(level, 1, CONFIG.BlackFlag.experiencePoints.length)];
		xp.max = getXP(this.progression.level + 1);
		xp.min = getXP(this.progression.level);
		Object.defineProperty(xp, "percentage", {
			get() {
				const result = Math.clamp(Math.round(((this.value - this.min) * 100) / (this.max - this.min)), 0, 100);
				return Number.isNaN(result) ? 100 : result;
			},
			enumerable: false
		});

		// Hit Dice
		const hd = this.attributes.hd;
		hd.available ??= 0;
		hd.spent ??= 0;
		hd.max ??= 0;
		for (const data of Object.values(this.progression.levels)) {
			const cls = data.class;
			const hpAdvancement = cls.system.advancement.byType("hitPoints")[0];
			if (!hpAdvancement) continue;
			const denom = (hd.d[hpAdvancement.configuration.denomination] ??= { spent: 0 });
			denom.max ??= 0;
			denom.max += 1;
			hd.max += 1;
		}
		for (const [key, denom] of Object.entries(hd.d)) {
			if (denom.max) denom.available = denom.max - denom.spent;
			else delete hd.d[key];
			hd.available += hd.d[key]?.available ?? 0;
			hd.spent += hd.d[key]?.spent ?? 0;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		const rollData = this.parent.getRollData({ deterministic: true });

		this.prepareConditions();
		this.prepareDerivedArmorFormulas();
		this.prepareDerivedEncumbrance(rollData);
		this.prepareLanguages();
		this.prepareDerivedModifiers();
		this.prepareDerivedResistances();
		this.prepareDerivedTraits(rollData);

		this.prepareDerivedAbilities(rollData);
		this.prepareComplexProficiencies(rollData);
		this.prepareDerivedHitPoints(rollData);
		this.prepareDerivedSpellcasting();
		this.prepareDerivedProficiencies();

		// Attunement
		this.attributes.attunement.value = this.parent.items.reduce((value, item) => {
			if (item.system.attuned) value += 1;
			return value;
		}, 0);
		if (this.attributes.attunement.value > this.attributes.attunement.max) {
			this.parent.notifications.set("too-much-attunement", {
				level: "warn",
				section: "inventory",
				message: game.i18n.localize("BF.Attunement.Warning")
			});
		}

		this.computeArmorClass();
		this.computeInitiative();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare abilities.
	 * @param {object} rollData
	 */
	prepareDerivedAbilities(rollData) {
		for (const [key, ability] of Object.entries(this.abilities)) {
			const config = CONFIG.BlackFlag.abilities[key];
			ability.valid = !!ability.value;
			ability.mod = ability.valid ? Math.floor((ability.value - 10) / 2) : 0;

			const base = this.proficiencies.base;
			ability.check.proficiency = new Proficiency(
				this.attributes.proficiency,
				base.checks.multiplier ?? 0,
				base.checks.rounding ?? "down"
			);
			ability.save.proficiency = new Proficiency(
				this.attributes.proficiency,
				Math.max(base.saves.multiplier, ability.save.proficiency.multiplier),
				base.saves.rounding ?? "down"
			);

			const checkData = { type: "ability-check", ability: key, proficiency: ability.check.proficiency.multiplier };
			ability.check.modifiers = {
				_data: checkData,
				bonus: this.getModifiers(checkData),
				minimum: this.getModifiers(checkData, "min"),
				notes: this.getModifiers(checkData, "note")
			};
			ability.check.bonus = this.buildBonus(ability.check.modifiers.bonus, { deterministic: true, rollData });
			const saveData = { type: "ability-save", ability: key, proficiency: ability.save.proficiency.multiplier };
			ability.save.modifiers = {
				_data: saveData,
				bonus: this.getModifiers(saveData),
				minimum: this.getModifiers(saveData, "min"),
				notes: this.getModifiers(saveData, "note")
			};
			ability.save.bonus = this.buildBonus(ability.save.modifiers.bonus, { deterministic: true, rollData });

			ability.check.mod = ability.mod + ability.check.proficiency.flat + ability.check.bonus;
			ability.save.mod = ability.mod + ability.save.proficiency.flat + ability.save.bonus;
			ability.dc = 8 + ability.mod + this.attributes.proficiency;

			ability.labels = config.labels;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare tools & vehicles.
	 * @param {object} rollData
	 */
	prepareComplexProficiencies(rollData) {
		for (const trait$1 of ["skills", "tools", "vehicles"]) {
			const shortTrait = trait$1.slice(0, -1);

			for (const [key, data] of Object.entries(this.proficiencies[trait$1])) {
				data._source = this._source.proficiencies?.[trait$1]?.[key] ?? {};
				const config = configForKey(key, { trait: trait$1 });

				data.ability = config?.ability;

				const base = this.proficiencies.base;
				data.proficiency = new Proficiency(
					this.attributes.proficiency,
					Math.max(base.checks.multiplier, base[trait$1].multiplier, data.proficiency.multiplier),
					[base.checks.rounding, base[trait$1].rounding].includes("up") ? "up" : "down"
				);

				const checkData = [
					{ type: "ability-check", ability: data.ability, proficiency: data.proficiency.multiplier },
					{ type: `${shortTrait}-check`, [shortTrait]: key, proficiency: data.proficiency.multiplier }
				];
				if (trait$1 === "skills") checkData[1].ability = data.ability;
				data.modifiers = {
					_data: checkData,
					check: this.getModifiers(checkData),
					minimum: this.getModifiers(checkData, "min"),
					notes: this.getModifiers(checkData, "note")
				};
				data.bonus = this.buildBonus(data.modifiers.check, { deterministic: true, rollData });

				const ability = this.abilities[data.ability];
				data.valid = ability?.valid ?? false;
				data.mod = (ability?.mod ?? 0) + data.bonus + data.proficiency.flat;

				if (trait$1 === "skills") {
					data.modifiers.passive = this.getModifiers({ type: "skill-passive", ability: data.ability, skill: key });
					data.passive = 10 + data.mod + this.buildBonus(data.modifiers.passive, { deterministic: true, rollData });
					data.labels = {
						name: config.label,
						ability: ability?.labels.abbreviation
					};
				} else {
					data.label = !config ? "" : config.label ?? `${config.localization}[other]`;
				}
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare final hit points values.
	 * @param {object} rollData
	 */
	prepareDerivedHitPoints(rollData) {
		const hp = this.attributes.hp;

		if (hp.override) hp.max = hp.override;
		else {
			const hpAdvancements = Object.values(this.progression.classes)
				.map(c => c.document?.system.advancement.byType("hitPoints")[0])
				.filter(a => a);
			const hpAdvancement = this.progression.levels[1]?.class?.system.advancement.byType("hitPoints")[0];
			if (!hpAdvancement) return;

			const ability = this.abilities[CONFIG.BlackFlag.defaultAbilities.hitPoints];

			const base = hpAdvancements.reduce((total, a) => total + a.getAdjustedTotal(ability?.mod ?? 0), 0);
			const levelBonus = simplifyBonus(hp.bonuses.level, rollData) * this.progression.level;
			const overallBonus = simplifyBonus(hp.bonuses.overall, rollData);

			hp.max = base + levelBonus + overallBonus;
		}
		if (this.attributes.exhaustion >= 4) hp.max = Math.floor(hp.max * 0.5);

		hp.baseMax = hp.max;
		hp.max += hp.tempMax ?? 0;
		hp.value = Math.clamp(hp.value, 0, hp.max);
		hp.damage = hp.max - hp.value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare final spellcasting.
	 */
	prepareDerivedSpellcasting() {
		Object.defineProperty(this.spellcasting, "circles", {
			get() {
				foundry.utils.logCompatibilityWarning("`spellcasting.circles` has been migrated to `spellcasting.slots`.", {
					since: "Black Flag 0.9.034",
					until: "Black Flag 0.9.038"
				});
				return this.slots;
			},
			enumerable: false
		});

		this.spellcasting.hasSpellcastingAdvancement = false;

		// Combine class spellcasting data to total progression
		const progression = { cantrips: false, leveled: 0, pact: { circle: null, slots: 0 } };
		const types = {};

		// TODO: Determine if more sophisticated merging of spellcasting configs is needed here
		const getSpellcasting = d => d.subclass?.system.spellcasting ?? d.document.system.spellcasting;

		// Grab any class with spellcasting and tally up different types
		const spellcastingClasses = Object.values(this.progression.classes).filter(classData => {
			const spellcasting = getSpellcasting(classData);
			if (!spellcasting?.type) return false;
			types[spellcasting.type] ??= 0;
			types[spellcasting.type] += 1;
			this.spellcasting.hasSpellcastingAdvancement = true;
			return true;
		});

		for (const cls of spellcastingClasses) {
			const doc = cls.document;
			const spellcasting = getSpellcasting(cls);
			this.constructor.computeClassProgression(progression, doc, {
				actor: this.parent,
				levels: cls.levels,
				count: types[spellcasting.type],
				spellcasting
			});
		}

		for (const type of Object.keys(CONFIG.BlackFlag.spellcastingTypes)) {
			this.constructor.prepareSpellcastingSlots(this.spellcasting.slots, type, progression, { actor: this });
		}

		for (const slot of Object.values(this.spellcasting.slots)) {
			slot.value = Math.clamp(slot.max - slot.spent, 0, slot.max);
			if (Number.isFinite(slot.max)) {
				this.spellcasting.totals.value += slot.value;
				this.spellcasting.totals.spent += slot.spent;
				this.spellcasting.totals.max += slot.max;
				if (slot.max > 0 && slot.circle > this.spellcasting.maxCircle) this.spellcasting.maxCircle = slot.circle;
			}
		}

		const abilities = Object.values(this.spellcasting?.origins ?? {}).reduce((set, o) => {
			set.add(o.ability);
			return set;
		}, new Set());
		// TODO: Bugged, move to prepareFinalSpellcasting
		this.spellcasting.ability = this.selectBestAbility?.(abilities) ?? null;
		this.spellcasting.cantripScale = SpellcastingTemplate.calculateCantripScale(this.progression.level);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Final proficiencies information.
	 */
	prepareDerivedProficiencies() {
		// Determine which categories a player has a least one proficiency within
		for (const type of ["armor", "weapons", "tools"]) {
			Object.defineProperty(this.proficiencies[type], "categories", {
				value: new Set(),
				enumerable: false
			});

			let proficient;
			if (type === "tools") {
				proficient = new Set(
					Object.entries(this.proficiencies.tools)
						.filter(([k, v]) => v.proficiency.multiplier >= 1)
						.map(([k, v]) => k)
				);
			} else proficient = this.proficiencies[type].value;

			for (const [key, data] of Object.entries(CONFIG.BlackFlag[type])) {
				if (proficient.has(key)) {
					this.proficiencies[type].categories.add(key);
				} else if (data.children) {
					const childrenSet = new Set(Object.keys(data.children));
					if (childrenSet.intersection(proficient)?.size) {
						this.proficiencies[type].categories.add(key);
					}
				}
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareNotifications() {
		super.prepareNotifications();
		this.prepareCharacterCreationWarnings();

		// Advancement warnings
		const anyLevel = { levels: { character: 0, class: 0 } };
		for (const data of [anyLevel, ...Object.values(this.progression.levels)]) {
			for (const advancement of this.parent.advancementForLevel(data.levels.character)) {
				advancement.prepareWarnings(data.levels, this.parent.notifications);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare warnings associated with incomplete character creation.
	 */
	prepareCharacterCreationWarnings() {
		let order = 0;

		// 1. Choose Class
		if (!Object.keys(this.progression.classes).length) {
			order++;
			this.parent.notifications.set("no-class", {
				level: "warn",
				category: "class",
				section: "progression",
				order,
				message: game.i18n.localize("BF.Progression.Notification.ChooseClass")
			});
		}

		// 2. Determine Ability Scores
		if (!this.progression.abilities.assignmentComplete) {
			order++;
			this.parent.notifications.set("no-abilities", {
				level: "warn",
				category: "abilities",
				section: "progression",
				order,
				message: game.i18n.localize("BF.Progression.Notification.DetermineAbilityScores")
			});
		}

		// 3. Choose a Lineage
		if (!this.progression.lineage) {
			order++;
			this.parent.notifications.set("no-lineage", {
				level: "warn",
				category: "lineage",
				section: "progression",
				order,
				message: game.i18n.localize("BF.Progression.Notification.ChooseLineage")
			});
		}

		// 4. Choose a Heritage
		if (!this.progression.heritage) {
			order++;
			this.parent.notifications.set("no-heritage", {
				level: "warn",
				category: "heritage",
				section: "progression",
				order,
				message: game.i18n.localize("BF.Progression.Notification.ChooseHeritage")
			});
		}

		// 5. Choose a Background
		if (!this.progression.background) {
			order++;
			this.parent.notifications.set("no-background", {
				level: "warn",
				category: "background",
				section: "progression",
				order,
				message: game.i18n.localize("BF.Progression.Notification.ChooseBackground")
			});
		}

		// 6. Choose a Subclass
		for (const [key, data] of Object.entries(this.progression.classes)) {
			if (!data.requiresSubclass) continue;
			order++;
			const message = game.i18n.format("BF.Progression.Notification.ChooseSubclass", { class: data.document.name });
			this.parent.notifications.set(`no-subclass-${key}`, {
				level: "warn",
				section: "progression",
				document: data.document.id,
				order,
				message
			});
			data.document.notifications.set("no-subclass", { level: "warn", category: "class", order, message });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set a condition to a level or remove it by setting level to 0.
	 * @param {string} condition - Identifier for the condition to modify.
	 * @param {number} [level] - New level to set, or nothing to remove the condition.
	 * @returns {Promise}
	 */
	async setConditionLevel(condition, level) {
		if (this.conditions[condition] === level) return;

		const effects = this.parent.effects.filter(e => e.statuses.has(condition));
		const toDelete = [];

		// No level, remove all associated effects
		if (!level) effects.forEach(e => toDelete.push(e.id));
		// Lower level, remove any unnecessary effects
		else if (level < this.conditions[condition])
			effects.forEach(e =>
				foundry.utils.getProperty(e, "flags.black-flag.condition.level") > level ? toDelete.push(e.id) : null
			);
		// Higher level, add any required effects
		else {
			const document = CONFIG.BlackFlag.registration.get("condition", condition)?.cached;
			if (!document) return;
			const toAdd = document.system.levels.slice(this.conditions[condition] ?? 0, level);
			await this.parent.createEmbeddedDocuments(
				"ActiveEffect",
				toAdd.map(add => add.effect.toObject())
			);
		}

		if (toDelete.length) await this.parent.deleteEmbeddedDocuments("ActiveEffect", toDelete);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Luck                 */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add a luck point, resetting the luck value if the character already has the max.
	 * @returns {Promise}
	 */
	async addLuck() {
		const luck = this.attributes.luck;
		let newValue = luck.value + 1;
		if (newValue > CONFIG.BlackFlag.luck.max) {
			const rollConfig = { rolls: [{ parts: [luck.formula || "1d4"] }] };
			const type = game.i18n.localize("BF.Luck.Label");
			const flavor = game.i18n.format("BF.Roll.Action.RerollSpecific", { type });
			const dialogConfig = { configure: false };
			const messageConfig = {
				data: {
					title: `${flavor}: ${this.name}`,
					flavor,
					speaker: ChatMessage.getSpeaker({ actor: this.parent }),
					"flags.black-flag.roll": {
						type: "luck"
					}
				}
			};

			/**
			 * A hook event that fires before luck is re-rolled.
			 * @function blackFlag.preRollLuck
			 * @memberof hookEvents
			 * @param {BlackFlagActor} actor - Actor for which the roll is being performed.
			 * @param {BasicRollProcessConfiguration} config - Configuration data for the pending roll.
			 * @param {BasicRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
			 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
			 * @returns {boolean} - Explicitly return `false` to prevent the roll.
			 */
			if (Hooks.call("blackFlag.preRollLuck", this.parent, rollConfig, dialogConfig, messageConfig) === false) return;

			const rolls = await CONFIG.Dice.BasicRoll.build(rollConfig, dialogConfig, messageConfig);

			/**
			 * A hook event that fires after luck has been re-rolled.
			 * @function blackFlag.rollLuck
			 * @memberof hookEvents
			 * @param {BlackFlagActor} actor - Actor for which the roll has been performed.
			 * @param {BasicRoll[]} rolls - The resulting rolls.
			 */
			if (rolls?.length) Hooks.callAll("blackFlag.rollLuck", this.parent, rolls);

			newValue = rolls[0].total;
		}

		return this.parent.update({ "system.attributes.luck.value": newValue });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Progression             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set a lineage, heritage, or background item on the actor.
	 * @param {BlackFlagItem} document - Document to set.
	 * @returns {Promise}
	 */
	async setConcept(document) {
		if (!["lineage", "heritage", "background"].includes(document.type))
			throw new Error(game.i18n.format("BF.ConceptSelection.Warning.InvalidType", { type: document.type }));
		if (this.progression[document.type])
			throw new Error(
				game.i18n.format("BF.ConceptSelection.Warning.Duplicate", { type: document.type, name: this.parent.name })
			);

		const newDocument = await this.parent.createEmbeddedDocuments("Item", [document.toObject()], { render: false });
		return this.parent.update({ [`system.progression.${document.type}`]: newDocument[0] });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Level up using the provided class.
	 * @param {BlackFlagItem} cls - Class in which to level up.
	 * @returns {Promise}
	 */
	async levelUp(cls) {
		if (!game.settings.get(game.system.id, "allowMulticlassing")) {
			const existingClass = Object.keys(this.progression.classes)[0];
			if (existingClass && existingClass !== cls.identifier) {
				throw new Error(game.i18n.localize("BF.Progression.Warning.NoMulticlassing"));
			}
		}

		const levels = {
			character: (this.progression.level ?? 0) + 1,
			class: (this.progression.classes[cls.identifier]?.levels ?? 0) + 1,
			identifier: cls.identifier
		};
		if (levels.character > CONFIG.BlackFlag.maxLevel)
			throw new Error(game.i18n.format("BF.Level.Warning.Max", { max: CONFIG.BlackFlag.maxLevel }));

		// Create class if it doesn't already exist on actor
		let existingClass = this.progression.classes[cls.identifier]?.document;
		if (!existingClass) {
			existingClass = (await this.parent.createEmbeddedDocuments("Item", [cls.toObject()], { render: false }))[0];
		}

		// Add new progression data
		await this.parent.update(
			{ [`system.progression.levels.${levels.character}.class`]: existingClass },
			{ blackFlag: { levelUp: true } }
		);

		// Apply advancements for the new level
		for (const advancement of this.parent.advancementForLevel(levels.character)) {
			this.parent.enqueueAdvancementChange(advancement, "apply", [levels, undefined, { initial: true, render: false }]);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Level down the character one level.
	 * @returns {Promise}
	 */
	async levelDown() {
		const cls = this.progression.levels[this.progression.level].class;
		const levels = {
			character: this.progression.level,
			class: this.progression.classes[cls.identifier].levels,
			identifier: cls.identifier
		};

		// Remove advancements for the old level
		for (const advancement of this.parent.advancementForLevel(levels.character)) {
			this.parent.enqueueAdvancementChange(advancement, "reverse", [levels, undefined, { render: false }]);
		}

		// Remove subclass if less than 3rd level
		const subclass = this.progression.classes[cls.identifier].subclass;
		if (levels.class <= CONFIG.BlackFlag.subclassLevel && subclass)
			this.parent.enqueueAdvancementChange(this.parent, "deleteEmbeddedDocuments", [
				"Item",
				[subclass.id],
				{ render: false }
			]);

		// Remove progression data for level
		this.parent.enqueueAdvancementChange(this.parent, "update", [
			{ [`system.progression.levels.-=${this.progression.level}`]: null },
			{ render: false, blackFlag: { levelDown: true } }
		]);

		// If class has no more levels, remove it from the actor
		if (levels.class <= 1)
			this.parent.enqueueAdvancementChange(this.parent, "deleteEmbeddedDocuments", [
				"Item",
				[cls.id],
				{ render: false }
			]);

		// TODO: Remove any spells that were learned at the previous level
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove any progression data from ability scores.
	 */
	async resetAbilities() {
		const updates = Object.keys(CONFIG.BlackFlag.abilities).reduce((obj, key) => {
			obj[`system.abilities.${key}.base`] = null;
			return obj;
		}, {});
		await this.parent.update(updates);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	async _preCreateToken(data, options, user) {
		const prototypeToken = {};
		if (!foundry.utils.hasProperty(data, "prototypeToken.actorLink")) prototypeToken.actorLink = true;
		if (!foundry.utils.hasProperty(data, "prototypeToken.sight.enabled")) prototypeToken.sight = { enabled: true };
		if (!foundry.utils.hasProperty(data, "prototypeToken.disposition")) {
			prototypeToken.disposition = CONST.TOKEN_DISPOSITIONS.FRIENDLY;
		}
		this.parent.updateSource({ prototypeToken });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _preUpdateHP(changed, options, user) {
		const changedHP = foundry.utils.getProperty(changed, "system.attributes.hp.value");
		if (changedHP !== undefined) {
			if (changedHP > 0 || this.attributes.hp.max === 0) {
				foundry.utils.setProperty(changed, "system.attributes.death.status", "alive");
				foundry.utils.setProperty(changed, "system.attributes.death.success", 0);
				foundry.utils.setProperty(changed, "system.attributes.death.failure", 0);
			} else if (this.attributes.death.status === "alive") {
				foundry.utils.setProperty(changed, "system.attributes.death.status", "dying");
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onUpdate(changed, options, userId) {
		await super._onUpdate(changed, options, userId);
		if (userId === game.userId) {
			await this.updateEncumbrance(options);
		}
	}
}

const { HTMLField: HTMLField$6, NumberField: NumberField$b, SchemaField: SchemaField$l, StringField: StringField$l } = foundry.data.fields;

/**
 * Data model for Siege Weapon actors.
 * @mixes {HPTemplate}
 * @mixes {ModifiersTemplate}
 * @mixes {ResistancesTemplate}
 * @mixes {SizeTemplate}
 * @mixes {SourceTemplate}
 *
 * @property {object} attributes
 * @property {object} attributes.ac
 * @property {number} attributes.ac.threshold - Damage threshold.
 * @property {number} attributes.ac.value - Armor class.
 * @property {object} description
 * @property {string} description.value - Description of the siege weapon.
 * @property {object} traits
 * @property {string} traits.size - Vehicle's size category.
 */
class SiegeData extends ActorDataModel.mixin(
	HPTemplate,
	ModifiersTemplate,
	ResistancesTemplate,
	SizeTemplate,
	SourceTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SIEGE", "BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = {
		type: "siege",
		category: "thing",
		localization: "BF.Actor.Type.SiegeWeapon",
		img: "systems/black-flag/artwork/types/siege.svg",
		sheet: {
			application: SiegeWeaponSheet,
			label: "BF.Sheet.Default.SiegeWeapon"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			attributes: new SchemaField$l({
				ac: new SchemaField$l({
					threshold: new NumberField$b(),
					value: new NumberField$b()
				})
			}),
			description: new SchemaField$l({
				value: new HTMLField$6()
			}),
			traits: new SchemaField$l({
				size: new StringField$l({ initial: "large" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get embeddedDescriptionKeyPath() {
		return "description.value";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();
		this.attributes.proficiency = 0;
		this.prepareBaseModifiers();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareSource();
		this.prepareDerivedHitPoints();
		this.prepareDerivedModifiers();
		this.prepareDerivedResistances();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		for (const value of config.values) {
			if (value === "statblock") config.statblock = true;
		}
		if (!config.statblock) return super.toEmbed(config, options);

		const context = await this.parent.sheet.getData();
		context.name = config.label || this.parent.name;
		if (config.cite === true) {
			context.anchor = this.parent.toAnchor({ name: context.name }).outerHTML;
			config.cite = false;
		}
		const section = document.createElement("section");
		section.innerHTML = await renderTemplate("systems/black-flag/templates/actor/embeds/siege-embed.hbs", context);
		return section.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preCreate(data, options, user) {
		if ((await super._preCreate(data, options, user)) === false) return false;
		if (!data._id && !data.items?.length) {
			foundry.utils.setProperty(options, `${game.system.id}.createResilience`, true);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onCreate(data, options, userId) {
		super._onCreate(data, options, userId);
		if (userId === game.user.id && options[game.system.id]?.createResilience) {
			const resilience = await fromUuid("Compendium.black-flag.npcfeatures.Item.rViKTBoqaXbonMPo");
			if (resilience) await this.parent.createEmbeddedDocuments("Item", [game.items.fromCompendium(resilience)]);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	getInitiativeRollConfig(options = {}) {
		return { fixed: 0 };
	}
}

const { ArrayField: ArrayField$2, HTMLField: HTMLField$5, NumberField: NumberField$a, SchemaField: SchemaField$k, SetField: SetField$8, StringField: StringField$k } = foundry.data.fields;

/**
 * Data for Vehicle abilities.
 *
 * @typedef {object} VehicleAbilityData
 * @property {number} mod - Ability modifier with proficiency included.
 */

/**
 * Data model for Vehicle actors.
 * @mixes {HPTemplate}
 * @mixes {ModifiersTemplate}
 * @mixes {ResistancesTemplate}
 * @mixes {SourceTemplate}
 *
 * @property {Record<string, VehicleAbilityData} abilities - Vehicle's ability modifiers.
 * @property {object} attributes
 * @property {object} attributes.ac
 * @property {number} attributes.ac.threshold - Damage threshold.
 * @property {number} attributes.ac.value - Armor class.
 * @property {object} attributes.cargo
 * @property {number} attributes.cargo.max - Maximum cargo carrying capacity.
 * @property {string} attributes.cargo.units - Units used to measure cargo capacity.
 * @property {object} attributes.crew
 * @property {number} attributes.crew.required - Crew required for a full complement.
 * @property {object} attributes.passengers
 * @property {number} attributes.passengers.max - Maximum number of passengers that can be carried.
 * @property {object} description
 * @property {string} description.actions - Brief description for the actions section.
 * @property {string} description.bonusActions - Brief description for the bonus actions section.
 * @property {string} description.reactions - Brief description for the reactions section.
 * @property {string} description.value - Biography on the vehicle.
 * @property {number} initiative - Initiative score for the vehicle.
 * @property {object} traits
 * @property {object} traits.dimensions
 * @property {string} traits.dimensions.length - Length of the vehicle.
 * @property {string} traits.dimensions.units - Units used to measure the dimensions.
 * @property {string} traits.dimensions.width - Width of the vehicle.
 * @property {string} traits.size - Vehicle's size category.
 * @property {string} traits.type - Type of vehicle.
 */
class VehicleData extends ActorDataModel.mixin(
	HPTemplate,
	ModifiersTemplate,
	ResistancesTemplate,
	SourceTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.VEHICLE", "BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = {
		type: "vehicle",
		category: "thing",
		localization: "BF.Actor.Type.Vehicle",
		img: "systems/black-flag/artwork/types/vehicle.svg",
		sheet: {
			application: VehicleSheet,
			label: "BF.Sheet.Default.Vehicle"
		}
	};

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			abilities: new MappingField(new SchemaField$k({ mod: new NumberField$a({ integer: true }) }), {
				initialKeys: CONFIG.BlackFlag.abilities,
				prepareKeys: true
			}),
			attributes: new SchemaField$k({
				ac: new SchemaField$k({
					threshold: new NumberField$a(),
					value: new NumberField$a()
				}),
				cargo: new SchemaField$k({
					max: new NumberField$a(),
					units: new StringField$k({ initial: "ton" })
				}),
				crew: new SchemaField$k({
					required: new NumberField$a()
				}),
				passengers: new SchemaField$k({
					max: new NumberField$a()
				})
			}),
			description: new SchemaField$k({
				actions: new StringField$k(),
				bonusActions: new StringField$k(),
				reactions: new StringField$k(),
				value: new HTMLField$5()
			}),
			initiative: new NumberField$a({ initial: 0 }),
			traits: new SchemaField$k({
				dimensions: new SchemaField$k({
					length: new NumberField$a(),
					units: new StringField$k(),
					width: new NumberField$a()
				}),
				size: new StringField$k({ initial: "huge" }),
				movement: new SchemaField$k({
					custom: new ArrayField$2(new StringField$k()),
					tags: new SetField$8(new StringField$k()),
					types: new MappingField(new FormulaField({ deterministic: true })),
					units: new StringField$k({ initial: "foot", label: "BF.MOVEMENT.FIELDS.traits.movement.units.label" })
				}),
				pace: new SchemaField$k({
					types: new MappingField(new FormulaField({ deterministic: true })),
					units: new StringField$k({ initial: "mph", label: "BF.MOVEMENT.FIELDS.traits.pace.units.label" })
				}),
				type: new SchemaField$k({
					value: new StringField$k({ initial: "land" })
				})
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get embeddedDescriptionKeyPath() {
		return "description.value";
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();

		for (const [key, ability] of Object.entries(this.abilities)) {
			ability._source = this._source.abilities?.[key] ?? {};
			ability.check ??= {};
			ability.save ??= {};
		}

		this.attributes.proficiency = 0;
		this.traits.movement.multiplier ??= "1";

		this.prepareBaseModifiers();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		const rollData = this.parent.getRollData({ deterministic: true });

		this.prepareSource();
		this.prepareDerivedHitPoints();
		this.prepareDerivedModifiers();
		this.prepareDerivedResistances();

		this.prepareDerivedAbilities(rollData);
		this.prepareDerivedMovement(rollData);

		// Cargo capacity
		this.attributes.cargo.label = formatNumber(this.attributes.cargo.max ?? 0, {
			unit: this.attributes.cargo.units
		});
		// TODO: Fix this once weight units are fully localized
		if (this.attributes.cargo.units === "ton") {
			this.attributes.cargo.label += ` ${game.i18n.localize("BF.UNITS.WEIGHT.Ton.Label").toLowerCase()}`;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare abilities.
	 * @param {object} rollData
	 */
	prepareDerivedAbilities(rollData) {
		for (const [key, ability] of Object.entries(this.abilities)) {
			ability.valid = ability.mod !== null;
			ability.mod ??= 0;

			ability.check.proficiency = new Proficiency(this.attributes.proficiency, 0, "down");
			ability.save.proficiency = new Proficiency(this.attributes.proficiency, 0, "down");

			const checkData = { type: "ability-check", ability: key, proficiency: ability.check.proficiency.multiplier };
			ability.check.modifiers = {
				_data: checkData,
				bonus: this.getModifiers(checkData),
				minimum: this.getModifiers(checkData, "min"),
				notes: this.getModifiers(checkData, "note")
			};
			ability.check.bonus = this.buildBonus(ability.check.modifiers.bonus, { deterministic: true, rollData });
			const saveData = { type: "ability-save", ability: key, proficiency: ability.save.proficiency.multiplier };
			ability.save.modifiers = {
				_data: saveData,
				bonus: this.getModifiers(saveData),
				minimum: this.getModifiers(saveData, "min"),
				notes: this.getModifiers(saveData, "note")
			};
			ability.save.bonus = this.buildBonus(ability.save.modifiers.bonus, { deterministic: true, rollData });

			ability.check.mod = ability.mod + ability.check.proficiency.flat + ability.check.bonus;
			ability.save.mod = ability.mod + ability.save.proficiency.flat + ability.save.bonus;
			ability.dc = 8 + ability.mod + this.attributes.proficiency;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Resolve derived movement data.
	 * @param {object} rollData
	 */
	prepareDerivedMovement(rollData) {
		const movement = this.traits.movement;
		const noMovement = this.hasConditionEffect("noMovement");
		const halfMovement = this.hasConditionEffect("halfMovement");
		const crawl = this.hasConditionEffect("crawl");
		const multiplier = simplifyBonus(movement.multiplier, rollData);
		const modifierData = { type: "movement", actor: this };

		// Calculate each special movement type using base speed
		let types = Object.keys(CONFIG.BlackFlag.movementTypes);
		if (types.includes("walk")) {
			types.findSplice(k => k === "walk");
			types.unshift("walk");
		}

		const entries = new Map();
		for (const type of types) {
			const movementFormula = this.traits.movement.types[type] ?? "";
			const paceFormula = this.traits.pace.types[type] ?? "";

			let speed = simplifyBonus(movementFormula, rollData);
			let pace = simplifyBonus(paceFormula, rollData);
			if (noMovement || (crawl && type !== "walk")) speed = pace = 0;

			if (speed > 0)
				speed += this.buildBonus(this.getModifiers({ ...modifierData, movementType: type }), {
					deterministic: true,
					rollData
				});
			this.traits.movement.types[type] = speed * multiplier * (halfMovement ? 0.5 : 1);
			this.traits.pace.types[type] = pace * multiplier * (halfMovement ? 0.5 : 1);

			const label = CONFIG.BlackFlag.movementTypes.localized[type];
			if (speed && label) {
				let generatedLabel;
				if (type === "walk") generatedLabel = formatNumber(speed, { unit: movement.units });
				else generatedLabel = `${label.toLowerCase()} ${formatNumber(speed, { unit: movement.units })}`;
				if (pace) {
					generatedLabel = game.i18n.format("BF.VEHICLE.FormattedPace", {
						speed: generatedLabel,
						perHour: formatPace(pace, this.traits.pace.units, { unitDisplay: "short" }),
						perDay: formatPace(pace * 24, this.traits.pace.units, { period: "day" })
					});
				}
				entries.set(type, generatedLabel);
			}

			rollData = { ...rollData, [type]: speed };
		}

		// Prepare movement labels
		movement.labels = Object.entries(movement.types)
			.filter(([type, speed]) => speed > 0)
			.sort((lhs, rhs) => rhs[1] - lhs[1])
			.map(([type, speed]) => {
				const config = CONFIG.BlackFlag.movementTypes[type];
				const label = config ? game.i18n.localize(config.label) : type;
				return `${label} ${formatNumber(speed, { unit: movement.units })}`;
			});
		movement.labels.push(...movement.custom);
		movement.label = formatTaggedList({
			entries,
			extras: movement.custom,
			tags: movement.tags,
			tagDefinitions: CONFIG.BlackFlag.movementTags
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		for (const value of config.values) {
			if (value === "statblock") config.statblock = true;
		}
		if (!config.statblock) return super.toEmbed(config, options);

		const context = await this.parent.sheet.getData();
		context.name = config.label || this.parent.name;
		if (config.cite === true) {
			context.anchor = this.parent.toAnchor({ name: context.name }).outerHTML;
			config.cite = false;
		}
		const section = document.createElement("section");
		section.innerHTML = await renderTemplate("systems/black-flag/templates/actor/embeds/vehicle-embed.hbs", context);
		return section.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preCreate(data, options, user) {
		if ((await super._preCreate(data, options, user)) === false) return false;
		if (!data._id && !data.items?.length) {
			foundry.utils.setProperty(options, `${game.system.id}.createResilience`, true);
		}
		if (
			!foundry.utils.hasProperty(data, "prototypeToken.width") &&
			!foundry.utils.hasProperty(data, "prototypeToken.height")
		) {
			const size = this.scaledTokenSize(foundry.utils.getProperty(data, "system.traits.dimensions") ?? {});
			this.parent.updateSource({ "prototypeToken.width": size.width, "prototypeToken.height": size.height });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onCreate(data, options, userId) {
		super._onCreate(data, options, userId);
		if (userId === game.user.id && options[game.system.id]?.createResilience) {
			const resilience = await fromUuid("Compendium.black-flag.npcfeatures.Item.4mrsMh1wkqybueGe");
			if (resilience) await this.parent.createEmbeddedDocuments("Item", [game.items.fromCompendium(resilience)]);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preUpdate(changed, options, user) {
		if ((await super._preUpdate(changed, options, user)) === false) return false;

		const changedMaxHP = foundry.utils.getProperty(changed, "system.attributes.hp.max");
		if (changedMaxHP !== undefined) {
			const maxHPDelta = changedMaxHP - this.attributes.hp.baseMax;
			foundry.utils.setProperty(changed, "system.attributes.hp.value", this.attributes.hp.value + maxHPDelta);
		}

		let changedDimensions = foundry.utils.getProperty(changed, "system.traits.dimensions");
		if (
			changedDimensions &&
			(changedDimensions.length !== this.traits.dimensions.length ||
				changedDimensions.width !== this.traits.dimensions.width) &&
			!foundry.utils.hasProperty(changed, "prototypeToken.width") &&
			!foundry.utils.hasProperty(changed, "prototypeToken.height")
		) {
			const size = this.scaledTokenSize(
				foundry.utils.mergeObject(this.traits.dimensions, changedDimensions, { inplace: false })
			);
			foundry.utils.setProperty(changed, "prototypeToken.width", size.width);
			foundry.utils.setProperty(changed, "prototypeToken.height", size.height);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	getInitiativeRollConfig(options = {}) {
		return { fixed: this.initiative };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate adjusted token size based on the provided dimensions.
	 * @param {{ length: number, width: number, units: string }} dimensions
	 * @returns {{ height: number, width: number }}
	 */
	scaledTokenSize(dimensions) {
		const resize = d => Math.max(1, Math.floor((d ?? 0) / 5));
		return { height: resize(dimensions.width), width: resize(dimensions.length) };
	}
}

var _module$b = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ACTemplate: ACTemplate,
	ConditionsTemplate: ConditionsTemplate,
	EncumbranceTemplate: EncumbranceTemplate,
	HPTemplate: HPTemplate,
	InitiativeTemplate: InitiativeTemplate,
	LairData: LairData,
	LanguagesTemplate: LanguagesTemplate,
	ModifiersTemplate: ModifiersTemplate,
	NPCData: NPCData,
	PCData: PCData,
	ResistancesField: ResistancesField,
	ResistancesTemplate: ResistancesTemplate,
	SiegeData: SiegeData,
	SizeTemplate: SizeTemplate,
	SourceTemplate: SourceTemplate,
	SpellcastingTemplate: SpellcastingTemplate,
	TraitsTemplate: TraitsTemplate,
	VehicleData: VehicleData
});

class ItemDataModel extends BaseDataModel {
	/**
	 * @typedef {object} ItemRegistrationConfiguration
	 * @property {boolean} cached - Should a cached version of this item type be made ready?
	 */

	/**
	 * Metadata that describes an item data type.
	 *
	 * @typedef {BaseDataMetadata} ItemDataMetadata
	 * @property {string} [accentColor] - Accent color to use if none is specified by system data.
	 * @property {boolean|ItemRegistrationConfig} [register] - Register all items of this type within the central list.
	 * @property {string} [tooltipTemplate]
	 */

	/**
	 * Metadata that describes a type.
	 * @type {ItemDataMetadata}
	 */
	static metadata = Object.freeze({
		tooltipTemplate: "systems/black-flag/templates/item/item-tooltip.hbs"
	});

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Magical bonus to attacks.
	 * @returns {number|null}
	 */
	get attackMagicalBonus() {
		return null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Modes that can be used when making an attack with this item.
	 * @type {FormSelectOption[]}
	 */
	get attackModes() {
		return [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Tags that should be displayed in chat.
	 * @type {Map<string, string>}
	 */
	get chatTags() {
		return this.parent.chatTags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Magical bonus to damage.
	 * @returns {number|null}
	 */
	get damageMagicalBonus() {
		return this.attackMagicalBonus;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get embeddedDescriptionKeyPath() {
		return "description.value";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Item type specific scaling increase.
	 * @type {number|null}
	 */
	get scaling() {
		return this.parent.getFlag(game.system.id, "scaling") ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Should this Document run final data preparation on its own, or wait for another Document to call those methods?
	 * @type {boolean}
	 */
	get shouldPrepareFinalData() {
		return !this.parent.isEmbedded;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Compendium source.
	 * @type {string}
	 */
	get _compendiumSource() {
		return this.parent.flags[game.system.id]?.sourceId ?? this.parent._stats.compendiumSource;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();
		if (this.parent.isEmbedded && this.parent.actor?.items.has(this.parent.id)) {
			const sourceId = this._compendiumSource;
			if (sourceId) {
				if (!this.parent.actor.sourcedItems?.has(sourceId)) {
					this.parent.actor.sourcedItems?.set(sourceId, new Set());
				}
				this.parent.actor.sourcedItems?.get(sourceId).add(this.parent);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Final data preparation steps performed on Items after parent actor has been fully prepared.
	 */
	prepareFinalData() {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async richTooltip(enrichmentOptions = {}) {
		if (!this.metadata.tooltipTemplate) return null;
		return {
			content: await renderTemplate(this.metadata.tooltipTemplate, await this.getTooltipData(enrichmentOptions)),
			classes: ["black-flag", "black-flag-tooltip", "item-tooltip"]
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch the context used to render this item's rich tooltip.
	 * @param {EnrichmentOptions} enrichmentOptions - Options for text enrichment.
	 * @returns {Promise<object>}
	 */
	async getTooltipData(enrichmentOptions = {}) {
		const description = foundry.utils.getProperty(this, this.embeddedDescriptionKeyPath) ?? "";
		const rollData = this.parent.getRollData();
		const context = {
			item: this.parent,
			description: await TextEditor.enrichHTML(description, {
				rollData,
				relativeTo: this.parent,
				...enrichmentOptions
			}),
			tags: Array.from(this.chatTags.entries())
				.map(([key, label]) => ({ key, label }))
				.filter(t => t.label)
		};
		return context;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare a data object which defines the data schema used by dice roll commands against this Item.
	 * @param {object} [options]
	 * @param {boolean} [options.deterministic] - Whether to force deterministic values for data properties that could be
	 *                                            either a die term or a flat term.
	 * @returns {object}
	 */
	getRollData(options = {}) {
		const rollData = { ...(this.parent.actor?.getRollData(options) ?? {}), item: { ...this } };
		return rollData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any type-specific preparation on the activity activation chat context.
	 * @param {object} context - Rendering context being prepared.
	 */
	async prepareActivationChatContext(context) {}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);

		// Clear "relationship" flags when moved
		if ("_id" in data && !options.keepRelationship) {
			this.parent.updateSource({ "flags.black-flag.-=relationship": null });
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Reset combat-related uses.
	 * @param {string[]} periods - Which recovery periods should be considered.
	 * @param {CombatRecoveryResults} results - Updates to perform on the actor and containing items.
	 * @abstract
	 */
	async recoverCombatUses(periods, results) {}
}

const { HTMLField: HTMLField$4, SchemaField: SchemaField$j } = foundry.data.fields;

/**
 * Data definition template for Items with descriptions.
 *
 * @property {object} description
 * @property {SourceData} description.source - The item's source.
 * @property {string} description.value - Main description for the item.
 * @property {object} identifier
 * @property {string} identifier.value - This item's unique identifier.
 */
class DescriptionTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			description: new SchemaField$j({
				source: new SourceField(),
				value: new HTMLField$4({ label: "BF.Item.Description.Label", hint: "BF.Item.Description.Hint" })
			}),
			identifier: new SchemaField$j({
				value: new IdentifierField()
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate source data to an object.
	 * @param {object} source - The candidate source data from which the model will be constructed.
	 */
	static migrateSource(source) {
		// Added 0.9.031
		if ( foundry.utils.getType(source.description?.source) === "string" ) {
			source.description.source = { fallback: source.description.source };
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare description data during derived data stage.
	 */
	prepareDescription() {
		const uuid = this.parent.flags[game.system.id]?.sourceId ??
			this.parent._stats?.compendiumSource ?? this.parent.uuid;
		SourceField.prepareData.call(this.description.source, uuid);
	}
}

const { SetField: SetField$7, StringField: StringField$j } = foundry.data.fields;

/**
 * Data definition template for Items with properties.
 *
 * @property {Set<string>} properties  List of applied properties.
 */
class PropertiesTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			properties: new SetField$7(new StringField$j(), {label: "BF.Property.Label[other]"})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Properties that can be applied to this object.
	 * @type {object}
	 */
	get validProperties() {
		const validProperties = CONFIG.BlackFlag[`${this.parent.type}Properties`];
		if ( !validProperties ) return {};
		return Object.entries(CONFIG.BlackFlag.itemProperties.localized).reduce((obj, [k, l]) => {
			if ( validProperties.includes(k) ) obj[k] = l;
			return obj;
		}, {});
	}
}

const { BooleanField: BooleanField$3, NumberField: NumberField$9, SchemaField: SchemaField$i, StringField: StringField$i } = foundry.data.fields;

/**
 * Data definition for Ammunition items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} damage
 * @property {DamageField} damage.base - Base ammunition damage.
 * @property {boolean} damage.replace - Does this ammunition's base damage replace the weapon's base damage
 *                                      rather than supplement it?
 * @property {number} magicalBonus - Magical bonus added to attack & damage rolls.
 * @property {object} type
 * @property {string} type.category - Ammunition category as defined in `CONFIG.BlackFlag.ammunition`.
 */
class AmmunitionData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	DescriptionTemplate,
	PhysicalTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.AMMUNITION", "BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "ammunition",
				category: "equipment",
				localization: "BF.Item.Type.Ammunition",
				icon: "fa-solid fa-lines-leaning",
				img: "systems/black-flag/artwork/types/ammunition.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			damage: new SchemaField$i({
				base: new DamageField(),
				replace: new BooleanField$3()
			}),
			magicalBonus: new NumberField$9({ integer: true }),
			type: new SchemaField$i({
				category: new StringField$i()
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get attackMagicalBonus() {
		return this.magicAvailable ? this.magicalBonus : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get validCategories() {
		return CONFIG.BlackFlag.ammunition;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();

		const type = CONFIG.BlackFlag.ammunition.localized[this.type.category];
		if (type) this.type.label = `${game.i18n.localize("BF.WEAPON.Label[one]")} (${type})`;
		else this.type.label = game.i18n.localize("BF.WEAPON.Label[one]");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}
}

const { BooleanField: BooleanField$2, SchemaField: SchemaField$h } = foundry.data.fields;

/**
 * Data definition template for items with proficiency.
 *
 * @property {object} overrides
 * @property {boolean} overrides.proficiency - Is the user always proficient (`true`), never proficient (`false`),
 *                                             or should it be calculated automatically (`null`).
 */
class ProficiencyTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			overrides: new SchemaField$h({
				proficiency: new BooleanField$2({nullable: true, initial: null})
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Trait type used to establish proficiency.
	 */
	static proficiencyCategory;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the current actor proficient with this item?
	 * @type {boolean|null}
	 */
	get proficient() {
		if ( !this.parent.isEmbedded ) return null;
		return this.proficientFor(this.parent.actor);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Proficiency description.
	 * @type {Proficiency}
	 */
	get proficiency() {
		return new Proficiency(
			this.parent.actor?.system.attributes?.proficiency ?? 0,
			this.proficient ? 1 : 0
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the provided actor proficient with this item?
	 * @param {BlackFlagActor} actor - Actor to check.
	 * @returns {boolean}
	 */
	proficientFor(actor) {
		if ( this.overrides.proficiency !== null ) return this.overrides.proficiency;
		const values = actorValues(actor, this.constructor.proficiencyCategory);
		if ( foundry.utils.isEmpty(values) ) return true;
		const check = key => (values[`${this.constructor.proficiencyCategory}:${key}`] ?? 0) > 0;
		return check(this.type.category) || check(this.type.base) || check(`${this.type.category}:${this.type.base}`);
	}
}

const { NumberField: NumberField$8, SchemaField: SchemaField$g, StringField: StringField$h } = foundry.data.fields;

/**
 * Data definition for Armor items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {ProficiencyTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} armor
 * @property {number} armor.value - Base armor class offered by this item.
 * @property {number} armor.requiredStrength - Strength score required to wear this armor.
 * @property {number} magicalBonus - Magical bonus added to armor class.
 * @property {object} modifier
 * @property {number} modifier.min - Minimum amount of modifier ability (usually DEX) that is contributed to AC.
 * @property {number} modifier.max - Maximum amount of modifier ability (usually DEX) that is contributed to AC.
 * @property {object} type
 * @property {string} type.category - Armor category as defined in `CONFIG.BlackFlag.armor`.
 * @property {string} type.base - Specific armor type defined as a child of its category.
 */
class ArmorData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	DescriptionTemplate,
	ProficiencyTemplate,
	PhysicalTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "armor",
				category: "equipment",
				localization: "BF.Item.Type.Armor",
				icon: "fa-solid fa-shield-halved",
				img: "systems/black-flag/artwork/types/armor.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			armor: new SchemaField$g({
				value: new NumberField$8({ min: 0, integer: true, label: "BF.Armor.Value.Label" }),
				requiredStrength: new NumberField$8({
					min: 0,
					integer: true,
					label: "BF.Armor.RequiredStrength.Label"
				})
			}),
			magicalBonus: new NumberField$8({
				integer: true,
				label: "BF.Armor.MagicalBonus.Label",
				hint: "BF.Armor.MagicalBonus.Hint"
			}),
			modifier: new SchemaField$g({
				min: new NumberField$8({
					required: false,
					initial: undefined,
					integer: true,
					label: "BF.Armor.Modifier.Minimum.Label"
				}),
				max: new NumberField$8({
					required: false,
					initial: undefined,
					integer: true,
					label: "BF.Armor.Modifier.Maximum.Label"
				})
			}),
			type: new SchemaField$g({
				category: new StringField$h({ label: "BF.Equipment.Category.Label" }),
				base: new StringField$h({ label: "BF.Equipment.Base.Label" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Label for the final AC value.
	 * @type {string}
	 */
	get acLabel() {
		let label;
		if (this.type.category === "shield") label = numberFormat(this._source.armor.value || 2, { sign: true });
		else
			label = `${game.i18n.localize("BF.ArmorClass.Abbreviation")}: ${numberFormat(
				this._source.armor.value || 0
			)} ${this.modifierHint(false)}`;
		if (this.magicAvailable && this.magicalBonus) label += ` + ${numberFormat(this.magicalBonus)}`;
		return label.trim();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		if (this.type.category) tags.set("type", CONFIG.BlackFlag.armor.localized[this.type.category]);
		tags.set("details", this.acLabel);
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static proficiencyCategory = "armor";

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get traits() {
		const traits = [
			this.acLabel,
			...Array.from(this.properties).map(p => CONFIG.BlackFlag.itemProperties.localized[p])
		];
		// TODO: Display required strength with cumbersome property
		const listFormatter = new Intl.ListFormat(game.i18n.lang, { type: "unit" });
		return listFormatter.format(traits.filter(t => t).map(t => game.i18n.localize(t)));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get validCategories() {
		return CONFIG.BlackFlag.armor;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();
		this.armor.value = this._source.armor.value;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();

		this.prepareDescription();
		this.prepareEquippedArmor();
		this.preparePhysicalLabels();

		const type = CONFIG.BlackFlag.armor.localized[this.type.base ?? this.type.category];
		if (type) this.type.label = `${game.i18n.localize("BF.Armor.Label[one]")} (${type})`;
		else this.type.label = game.i18n.localize("BF.Armor.Label[one]");

		if (!this.armor.value && this.type.category === "shield") this.armor.value = 2;
		if (this.magicAvailable && this.magicalBonus) this.armor.value += this.magicalBonus;

		const armorConfig = CONFIG.BlackFlag.armor[this.type.category]?.modifier;
		if (armorConfig) {
			this.modifier.min ??= armorConfig.min;
			this.modifier.max ??= armorConfig.max;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare equipped armor and add error if too many armor or shields are equipped.
	 */
	prepareEquippedArmor() {
		const ac = this.parent.actor?.system.attributes?.ac;
		if (!ac || !this.equipped) return;

		const target = this.type.category === "shield" ? "equippedShield" : "equippedArmor";
		if (ac[target]) {
			if (ac[target] === this.parent) return;
			this.parent.actor.notifications.set(`armor-${this.parent.id}-equipped`, {
				level: "warn",
				category: "armor-class",
				section: "inventory",
				document: this.parent.id,
				message: game.i18n.format("BF.Armor.Notification.TooMany", {
					type: game.i18n
						.localize(`BF.Armor.${this.type.category === "shield" ? "Category.Shield" : "Label"}[one]`)
						.toLowerCase()
				})
			});
			return;
		}

		Object.defineProperty(ac, target, {
			value: this.parent,
			configurable: true,
			enumerable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();

		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);

		if (!this.equipped) return;
		if (this.proficient === false) {
			const message = game.i18n.format("BF.Armor.Notification.NotProficient", {
				type: game.i18n
					.localize(`BF.Armor.${this.type.category === "shield" ? "Category.Shield" : "Label"}[one]`)
					.toLowerCase()
			});
			this.parent.actor.notifications.set(`armor-${this.parent.id}-proficiency`, {
				label: "info",
				document: this.parent.id,
				message
			});
			this.parent.actor.system.modifiers.push({
				type: "note",
				filter: [
					{ k: "type", v: "ability-check" },
					{
						o: "OR",
						v: [
							{ k: "ability", v: "strength" },
							{ k: "ability", v: "dexterity" }
						]
					}
				],
				note: {
					rollMode: CONFIG.Dice.ChallengeDie.MODES.DISADVANTAGE,
					text: game.i18n.format("BF.Armor.Notification.NotProficientNote", { name: this.parent.name })
				}
			});
		}
		if (this.properties.has("noisy")) {
			this.parent.actor.system.modifiers.push({
				type: "note",
				filter: [
					{ k: "type", v: "skill-check" },
					{ k: "skill", v: "stealth" }
				],
				note: {
					rollMode: CONFIG.Dice.ChallengeDie.MODES.DISADVANTAGE,
					text: game.i18n.localize("BF.Armor.Notification.Noisy")
				}
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Hint displayed in the editing interface (e.g. " + DEX modifier (max 2)").
	 * @param {boolean} [long=true] - Use the long format?
	 * @returns {string}
	 */
	modifierHint(long = true) {
		if (this.modifier.max === 0) return "";

		const ability = CONFIG.BlackFlag.abilities[CONFIG.BlackFlag.defaultAbilities.armor];
		const hint = game.i18n.format(`BF.Armor.Modifier.Description.${long ? "Long" : "Short"}`, {
			ability: game.i18n.localize(ability.labels.abbreviation).toUpperCase()
		});
		if (!this.modifier.max) return hint;

		return game.i18n.format("BF.Armor.Modifier.Description.Max", { hint, max: numberFormat(this.modifier.max) });
	}
}

/**
 * Data definition template for items with advancement.
 *
 * @property {AdvancementField} advancement - Advancement for this item.
 */
class AdvancementTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			advancement: new AdvancementField()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_onCreateApplyAdvancement(data, options, userId) {
		const progression = this.parent.actor?.system.progression;
		if ( (game.user.id !== userId) || !progression || !this.advancement.size ) return;

		// Apply all advancements for this item up to current level
		const levels = [{ character: 0, class: 0 }, ...Object.values(progression.levels).map(l => l.levels)];
		log(`Applying advancement for ${this.parent.name}`);
		for ( const level of levels ) {
			for ( const advancement of this.parent.advancementForLevel(level) ) {
				this.parent.actor.enqueueAdvancementChange(advancement, "apply", [
					level, undefined, { initial: true, render: false }
				]);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_onDeleteRevertAdvancement(options, userId) {
		const progression = this.parent.actor?.system.progression;
		if ( (game.user.id !== userId) || !progression || !this.advancement.size ) return;

		const levels = [{ character: 0, class: 0 }, ...Object.values(progression.levels).map(l => l.levels)];
		log(`Removing advancement for ${this.parent.name}`);
		for ( const level of levels.reverse() ) {
			// TODO: These advancements should be unapplied in reverse order
			for ( const advancement of this.parent.advancementForLevel(level) ) {
				this.parent.actor.enqueueAdvancementChange(advancement, "reverse", [level, undefined, { render: false }]);
			}
		}

		// Remove any remaining advancement data
		this.parent.actor.enqueueAdvancementChange(this.parent.actor, "update", [
			{ [`system.progression.advancement.-=${this.parent.id}`]: null }, { render: false }
		]);
	}
}

const { SchemaField: SchemaField$f, StringField: StringField$g } = foundry.data.fields;

/**
 * Data definition template for Concept items (class, background, lineage, heritage).
 *
 * @property {object} description
 * @property {string} description.short - Brief description that appears in the selection dialog.
 * @property {string} description.journal - UUID of a journal page describing this item in further detail.
 */
class ConceptTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			description: new SchemaField$f({
				short: new StringField$g({label: "BF.Item.Description.ShortLabel", hint: "BF.Item.Description.ShortHint"}),
				journal: new StringField$g({label: "BF.Item.Journal.Label", hint: "BF.Item.Journal.Hint"})
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Spellcasting configuration data if defined for this class or subclass.
	 * @type {SpellcastingConfigurationData|null}
	 */
	get spellcasting() {
		return this.advancement.byType("spellcasting")[0]?.configuration ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * List of the traits to display on the item sheet.
	 * @type {object[]}
	 * @abstract
	 */
	get traits() {
		return [];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contribute details on a spellcasting advancement to parent actor if embedded.
	 * Should be called during the `prepareFinalData` stage.
	 */
	prepareSpellcastingSource() {
		const parent = this.parent;
		const spellcasting = this.spellcasting;
		if ( !this.parent.actor || !spellcasting ) return;
		const spellcastingOrigins = parent.actor.system.spellcasting.origins ??= {};
		const origin = spellcastingOrigins[parent.identifier] ??= {};
		const identifier = parent.type === "class" ? parent.identifier : parent.system.identifier.class;
		const rollData = this.parent.getRollData({ deterministic: true });

		Object.defineProperty(origin, "document", {
			get() { return parent; },
			configurable: true,
			enumerable: false
		});
		Object.defineProperty(origin, "spellcasting", {
			get() { return spellcasting; },
			configurable: true,
			enumerable: false
		});

		// Spellcasting Ability
		origin.ability = spellcasting.spellcastingAbility;
		const ability = parent.actor.system.abilities[origin.ability];
		const proficiency = parent.actor.system.attributes.proficiency ?? 0;

		// Spell Attack Modifier
		origin.attack = proficiency + (ability?.mod ?? 0);
		origin.attack += this.parent.actor.system.buildBonus?.(
			this.parent.actor.system.getModifiers(foundry.utils.expandObject({
				type: "attack", class: identifier, "activity.attack.type.classification": "spell"
			})),
			{ deterministic: true, rollData }
		) ?? 0;

		// Spell Save DC
		origin.dc = ability?.dc ?? (8 + proficiency);
		origin.dc += this.parent.actor.system.buildBonus?.(
			this.parent.actor.system.getModifiers({ type: "spellcasting-dc", class: identifier }),
			{ deterministic: true, rollData }
		) ?? 0;
		parent.actor.system.spellcasting.dc = Math.max(parent.actor.system.spellcasting.dc ?? -Infinity, origin.dc);

		// Knowable cantrips/rituals/spells
		parent.actor.system.spellcasting.spells ??= {};
		const stats = parent.actor.system.spellcasting.spells.knowable ??= {};
		for ( const type of ["cantrips", "rituals", "spells"] ) {
			origin[type] ??= { value: 0 };
			origin[type].max = spellcasting[type].known;
			stats[type] += spellcasting[type].known;
		}
		if ( spellcasting.spells.mode === "spellbook" ) {
			const identifier = parent.type === "subclass" ? parent.system.identifier.class : parent.identifier;
			const levels = parent.actor.system.progression.classes[identifier]?.levels ?? 0;
			origin.spellbook ??= { value: 0, max: 0 };
			origin.spellbook.max = spellcasting.spells.spellbook.firstLevel ?? 0;
			origin.spellbook.max += (spellcasting.spells.spellbook.otherLevels ?? 0) * (levels - 1);
		}
		const canPrepare = CONFIG.BlackFlag.spellLearningModes[spellcasting.spells.mode]?.prepared;
		if ( canPrepare ) {
			origin.prepared ??= { value: 0 };
			const abilityMod = parent.actor?.system.abilities[spellcasting.spellcastingAbility]?.mod;
			origin.prepared.max = (this.levels ?? 0) + (abilityMod ?? 0);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create one or more advancement documents when this item is created.
	 * @param {object[]} data - Initial data for advancement documents. Must include "type".
	 * @internal
	 */
	_createInitialAdvancement(data) {
		const advancement = {};
		for ( const initialData of data ) {
			const AdvancementClass = CONFIG.Advancement.types[initialData.type].documentClass;
			if ( !initialData._id ) initialData._id = foundry.utils.randomID();
			const createData = foundry.utils.deepClone(initialData);
			const newAdvancement = new AdvancementClass(initialData, { parent: this.parent });
			newAdvancement._preCreate(createData);
			advancement[initialData._id] = newAdvancement.toObject();
		}
		this.parent.updateSource({"system.advancement": advancement});
	}
}

/**
 * Data definition for Background items.
 * @mixes {AdvancementTemplate}
 * @mixes {ConceptTemplate}
 * @mixes {DescriptionTemplate}
 */
class BackgroundData extends ItemDataModel.mixin(
	AdvancementTemplate,
	ConceptTemplate,
	DescriptionTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "background",
				category: "concept",
				localization: "BF.Item.Type.Background",
				icon: "fa-solid fa-person-digging",
				img: "systems/black-flag/artwork/types/background.svg",
				accentColor: "#0000aa",
				register: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateAdvancement(data, options, user) {
		if (data._id || foundry.utils.hasProperty(data, "system.advancement")) return;
		this._createInitialAdvancement([
			{ type: "trait", title: "Skill Proficiencies", configuration: { choices: [{ count: 2, pool: "skills:*" }] } },
			{ type: "trait", title: "Additional Proficiencies" },
			{
				type: "chooseFeatures",
				title: "Talent",
				configuration: {
					choices: { 0: 1 },
					allowDrops: false,
					type: "talent"
				}
			}
		]);
	}
}

const { ColorField } = foundry.data.fields;

/**
 * Data definition for Class items.
 * @mixes {AdvancementTemplate}
 * @mixes {ConceptTemplate}
 * @mixes {DescriptionTemplate}
 *
 * @property {string} color - Color used to represent this class, used to tinting headers.
 */
class ClassData extends ItemDataModel.mixin(AdvancementTemplate, ConceptTemplate, DescriptionTemplate) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "class",
				category: "concept",
				localization: "BF.Item.Type.Class",
				icon: "fa-solid fa-landmark-dome",
				img: "systems/black-flag/artwork/types/class.svg",
				register: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			color: new ColorField()
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Key ability selected for this class.
	 * @type {string|null}
	 */
	get keyAbility() {
		const keyAbility = this.advancement.byType("keyAbility")[0];
		return keyAbility?.configuration.options.first();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Number of levels of this class a character has.
	 * @type {number}
	 */
	get levels() {
		return this.parent.actor?.system.progression?.classes[this.parent.identifier]?.levels ?? 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get traits() {
		const traits = [];
		if (this.labels.hitDie)
			traits.push({
				label: "BF.HitDie.Label[one]",
				value: this.labels.hitDie
			});
		if (this.labels.keyAbility)
			traits.push({
				label: "BF.Advancement.KeyAbility.Title",
				value: this.labels.keyAbility
			});
		if (this.spellcasting)
			traits.push({
				label: "BF.Spellcasting.Label",
				value: this.spellcasting.label
			});
		return traits;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();

		this.labels ??= {};

		// Hit Die
		const hpAdvancement = this.advancement.byType("hitPoints")[0];
		this.labels.hitDie = hpAdvancement ? `d${hpAdvancement.configuration.denomination}` : "";

		// Key Ability
		const keyAbilityAdvancement = this.advancement.byType("keyAbility")[0];
		if (keyAbilityAdvancement) {
			const keyAbilityOptions = keyAbilityAdvancement.configuration.options.map(
				o => game.i18n.localize(CONFIG.BlackFlag.abilities.localized[o]) ?? o
			);
			const listFormatter = game.i18n.getListFormatter({ style: "short", type: "conjunction" });
			this.labels.keyAbility = listFormatter.format(keyAbilityOptions);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		this.prepareSpellcastingSource();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateAdvancement(data, options, user) {
		if (data._id || foundry.utils.hasProperty(data, "system.advancement")) return;
		this._createInitialAdvancement([
			{ type: "hitPoints" },
			{ type: "keyAbility" },
			{ type: "trait", level: { classRestriction: "original", value: 1 } },
			{ type: "trait", configuration: { choices: [{ count: 2, pool: ["skills:*"] }] } },
			{ type: "equipment", level: { classRestriction: "original" } }
		]);
	}
}

const { SchemaField: SchemaField$e, StringField: StringField$f } = foundry.data.fields;

/**
 * Data definition for Consumable items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} type
 * @property {string} type.category - Consumable category as defined in `CONFIG.BlackFlag.consumableCategories`.
 * @property {string} type.base - Specific consumable type defined as a child of its category.
 */
class ConsumableData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	DescriptionTemplate,
	PhysicalTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "consumable",
				category: "equipment",
				localization: "BF.Item.Type.Consumable",
				icon: "fa-solid fa-bottle-droplet",
				img: "systems/black-flag/artwork/types/consumable.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			type: new SchemaField$e({
				category: new StringField$f({ label: "BF.Equipment.Category.Label" }),
				base: new StringField$f({ label: "BF.Equipment.Base.Label" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get validCategories() {
		return CONFIG.BlackFlag.consumableCategories;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();
		this.type.label = CONFIG.BlackFlag.consumableCategories.localized[this.type.category] ?? "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}
}

const { NumberField: NumberField$7, SchemaField: SchemaField$d, StringField: StringField$e } = foundry.data.fields;

/**
 * Data definition for Container items.
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} capacity
 * @property {number} capacity.count - Number if items that can be stored within.
 * @property {object} capacity.volume
 * @property {number} capacity.volume.value - Limit on the internal volume of the container.
 * @property {string} capacity.volume.units - Units used to measure the volume.
 * @property {object} capacity.weight
 * @property {number} capacity.weight.value - Limit on the weight of the contained items.
 * @property {string} capacity.weight.units - Units used to measure the weight.
 */
class ContainerData extends ItemDataModel.mixin(
	DescriptionTemplate,
	PhysicalTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "container",
				category: "equipment",
				localization: "BF.Item.Type.Container",
				icon: "fa-solid fa-box-open",
				img: "systems/black-flag/artwork/types/container.svg",
				sheet: {
					application: ContainerSheet,
					label: "BF.Sheet.Default.Container"
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			capacity: new SchemaField$d(
				{
					count: new NumberField$7({ min: 0, integer: true, label: "BF.Container.Capacity.Number.Label" }),
					volume: new SchemaField$d(
						{
							value: new NumberField$7({ min: 0, label: "BF.Volume.Label" }),
							units: new StringField$e({ initial: "cubicFoot", label: "BF.UNITS.VOLUME.Label" })
						},
						{ label: "BF.Container.Capacity.Volume.Label" }
					),
					weight: new SchemaField$d(
						{
							value: new NumberField$7({ min: 0, label: "BF.Weight.Label" }),
							units: new StringField$e({ initial: "pound", label: "BF.UNITS.WEIGHT.Label" })
						},
						{ label: "BF.Container.Capacity.Weight.Label" }
					)
				},
				{ label: "BF.Container.Capacity.Label" }
			)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get all of the items contained in this container. A promise if item is within a compendium.
	 * @type {Collection<BlackFlagItem>|Promise<Collection<BlackFlagItem>>}
	 */
	get contents() {
		if (!this.parent) return new foundry.utils.Collection();

		// If in a compendium, fetch using getDocuments and return a promise
		if (this.parent.pack && !this.parent.isEmbedded) {
			const pack = game.packs.get(this.parent.pack);
			return pack
				.getDocuments({ system: { container: this.parent.id } })
				.then(d => new foundry.utils.Collection(d.map(d => [d.id, d])));
		}

		// Otherwise use local document collection
		return (this.parent.isEmbedded ? this.parent.actor.items : game.items).reduce((collection, item) => {
			if (item.system.container === this.parent.id) collection.set(item.id, item);
			return collection;
		}, new foundry.utils.Collection());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get all of the items in this container and any sub-containers. A promise if item is within a compendium.
	 * @type {Collection<BlackFlagItem>|Promise<Collection<BlackFlagItem>>}
	 */
	get allContainedItems() {
		if (!this.parent) return new foundry.utils.Collection();
		if (this.parent.pack) return this.#allContainedItems();

		return this.contents.reduce((collection, item) => {
			collection.set(item.id, item);
			if (item.type === "container") item.system.allContainedItems.forEach(i => collection.set(i.id, i));
			return collection;
		}, new foundry.utils.Collection());
	}

	/**
	 * Asynchronous helper method for fetching all contained items from a compendium.
	 * @returns {Promise<Collection<BlackFlagItem>>}
	 */
	async #allContainedItems() {
		return (await this.contents).reduce(async (promise, item) => {
			const collection = await promise;
			collection.set(item.id, item);
			if (item.type === "container") (await item.system.allContainedItems).forEach(i => collection.set(i.id, i));
			return collection;
		}, new foundry.utils.Collection());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch a specific contained item.
	 * @param {string} id - ID of the item to fetch.
	 * @returns {BlackFlagItem|Promise<BlackFlagItem>} - Item if found.
	 */
	getContainedItem(id) {
		if (this.parent?.isEmbedded) return this.parent.actor.items.get(id);
		if (this.parent?.pack) return game.packs.get(this.parent.pack)?.getDocument(id);
		return game.items.get(id);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Number of items contained in this container including items in sub-containers. Result is a promise if item
	 * is within a compendium.
	 * @type {number|Promise<number>}
	 */
	get contentsCount() {
		const reducer = (count, item) => count + item.system.quantity;
		const items = this.allContainedItems;
		if (items instanceof Promise) return items.then(items => items.reduce(reducer, 0));
		return items.reduce(reducer, 0);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Weight of the items in this container. Result is a promise if item is within a compendium.
	 * @type {number|Promise<number>}
	 */
	get contentsWeight() {
		if (this.parent?.pack && !this.parent?.isEmbedded) return this.#contentsWeight();
		return this.contents.reduce(
			(weight, item) => weight + convertWeight(item.system.totalWeight, item.system.weight.units, this.weight.units),
			0
		);
	}

	/**
	 * Asynchronous helper method for calculating the weight of items in a compendium.
	 * @returns {Promise<number>}
	 */
	async #contentsWeight() {
		const contents = await this.contents;
		return contents.reduce(
			async (weight, item) =>
				(await weight) + convertWeight(await item.system.totalWeight, item.system.weight.units, this.weight.units),
			0
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The weight of this container with all of its contents. Result is a promise if item is within a compendium.
	 * @type {number|Promise<number>}
	 */
	get totalWeight() {
		if (this.properties.has("weightlessContents")) return this.weight.value;
		const containedWeight = this.contentsWeight;
		if (containedWeight instanceof Promise) return containedWeight.then(c => this.weight.value + c);
		return this.weight.value + containedWeight;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();
		this.quantity = 1;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();
		this.type ??= {};
		this.type.label = game.i18n.localize("BF.Item.Gear.Category.WondrousItem");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	async _onUpdateFolder(changed, options, userId) {
		// Keep contents folder synchronized with container
		if (game.user.id === userId && foundry.utils.hasProperty(changed, "folder")) {
			const contents = await this.contents;
			await Item.updateDocuments(
				contents.map(c => ({ _id: c.id, folder: changed.folder })),
				{
					parent: this.parent.parent,
					pack: this.parent.pack,
					...options,
					render: false
				}
			);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async _onDeleteContents(options, userId) {
		if (userId !== game.user.id || !options.deleteContents) return;

		// Delete a container's contents when it is deleted
		const contents = await this.allContainedItems;
		if (contents?.size)
			await Item.deleteDocuments(Array.from(contents.map(i => i.id)), {
				pack: this.parent.pack,
				parent: this.parent.parent
			});
	}
}

const { NumberField: NumberField$6, SchemaField: SchemaField$c, StringField: StringField$d } = foundry.data.fields;

/**
 * Data definition for Currency items.
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 *
 * @property {object} conversion
 * @property {number} conversion.value - Rate at which this currency is converted into a standard baseline.
 */
class CurrencyData extends ItemDataModel.mixin(DescriptionTemplate, PhysicalTemplate) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "currency",
				category: "meta",
				localization: "BF.Item.Type.Currency",
				icon: "fa-solid fa-boxes-stacked",
				img: "systems/black-flag/artwork/types/currency.svg",
				register: {
					cache: true
				},
				sheet: {
					application: CurrencySheet,
					label: "BF.Sheet.Default.Currency"
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			conversion: new SchemaField$c({
				value: new NumberField$6({
					initial: 1,
					positive: true,
					label: "BF.Currency.ConversionRatio.Label",
					hint: "BF.Currency.ConversionRatio.Hint"
				})
			}),
			price: false,
			weight: new SchemaField$c(
				{
					value: new NumberField$6({ initial: 0.32 }),
					units: new StringField$d({ initial: "ounce" })
				},
				{ label: "BF.Weight.Label" }
			)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The abbreviated name for this currency.
	 * @type {string}
	 */
	get abbreviation() {
		return CONFIG.BlackFlag.currencies[this.parent.identifier]?.abbreviation ?? this.parent.identifier;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		tags.set("details", `${numberFormat(this.quantity)} ${this.abbreviation}`);
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get equippable() {
		return false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();
	}
}

const { ArrayField: ArrayField$1, BooleanField: BooleanField$1, SchemaField: SchemaField$b, SetField: SetField$6, StringField: StringField$c } = foundry.data.fields;

/**
 * Data definition template for Feature and Talent items.
 *
 * @property {object} restriction
 * @property {boolean} restriction.allowMultipleTimes - Can this talent be taken more than once?
 * @property {string[]} restriction.custom - Custom restrictions with no mechanical effect.
 * @property {FilterField} restriction.filters - Filters limiting when this item can be selected.
 * @property {Set<string>} restriction.items - Other items that must be present on the actor to take this feature.
 * @property {boolean} restriction.requireAll - Do all filters need to be satisfied to take this feature, or only one.
 * @property {object} type
 * @property {string} type.category - Feature or talent category for this item.
 * @property {string} type.value - Specific feature type.
 */
class FeatureTemplate extends foundry.abstract.DataModel {

	/** @inheritDoc */
	static defineSchema() {
		return {
			restriction: new SchemaField$b({
				allowMultipleTimes: new BooleanField$1({
					label: "BF.Prerequisite.AllowMultipleTimes.Label",
					hint: "BF.Prerequisite.AllowMultipleTimes.Hint"
				}),
				custom: new ArrayField$1(new StringField$c()),
				filters: new FilterField(),
				items: new SetField$6(new StringField$c()),
				requireAll: new BooleanField$1({
					initial: true,
					label: "BF.Prerequisite.RequireAll.Label",
					hint: "BF.Prerequisite.RequireAll.Hint"
				})
			}),
			type: new SchemaField$b({
				category: new StringField$c(),
				value: new StringField$c()
			})
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate source data to an object.
	 * Added in 0.9.031
	 * @param {object} source - The candidate source data from which the model will be constructed.
	 */
	static migrateFilterIds(source) {
		for ( const filter of source.restriction?.filters ?? [] ) {
			if ( filter._id ) continue;
			switch ( filter.k ) {
				case "system.spellcasting.present":
					filter._id = "spellcastingFeature";
					filter.k = "system.spellcasting.hasSpellcastingAdvancement";
					filter.v = true;
					delete filter.o;
					break;
				case "system.spellcasting.spells.damaging":
					filter._id = "hasDamagingSpells";
					break;
				case "system.traits.size":
					filter._id = "creatureSize";
					break;
				default:
					if ( filter.k?.startsWith("system.abilities.") ) {
						const ability = filter.k.replace("system.abilities.", "").replace(".value", "");
						filter._id = `ability-${ability}`;
					}
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare this feature's pre-requisites label.
	 * Should be called during the `prepareDerivedData` stage.
	 */
	preparePrerequisiteLabel() {
		const makeLabel = this.createPrerequisiteLabel.bind(this);
		Object.defineProperty(this.restriction, "label", {
			get() { return makeLabel(); },
			configurable: true
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add the prerequisite label to the embedded content.
	 * @param {HTMLCollection} embed - Existing embed collection.
	 * @returns {HTMLCollection}
	 */
	async embedPrerequisite(embed) {
		if ( this.restriction.label ) embed[0]?.insertAdjacentHTML("beforebegin", `<p><em>${
			game.i18n.format("BF.Prerequisite.Listing", { prerequisite: this.restriction.label })
		}</em></p>`);
		return embed;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a label for this item's prerequisites, validating if an actor is provided.
	 * @param {BlackFlagActor} [actor] - Actor to validate if required.
	 * @returns {string} - Prerequisite label, will contains HTML if actor is provided.
	 */
	createPrerequisiteLabel(actor) {
		const prerequisites = [];

		const validate = (f, label) => {
			if ( !actor ) return label;
			return `${label} <i class="filter ${performCheck(actor, [f]) ? "" : "in"}valid"></i>`;
		};

		const filters = this.restriction.filters.reduce((obj, f) => {
			obj[f._id] = f;
			return obj;
		}, {});

		// Abilities
		for ( const [key, ability] of Object.entries(CONFIG.BlackFlag.abilities) ) {
			if ( !filters[`ability-${key}`] ) continue;
			prerequisites.push(validate(filters[`ability-${key}`], game.i18n.format("BF.Prerequisite.Ability.Label", {
				abbreviation: game.i18n.localize(ability.labels.abbreviation).toUpperCase(),
				value: numberFormat(filters[`ability-${key}`].v)
			})));
		}

		// Proficiencies
		const proficiencies = [];
		const formatter = game.i18n.getListFormatter({ type: "disjunction", style: "short" });
		const prepareProficiency = trait$1 => {
			if ( filters[`${trait$1}Proficiency`] ) proficiencies.push(validate(filters[`${trait$1}Proficiency`],
				formatter.format(
					filters[`${trait$1}Proficiency`].v.map(p => keyLabel(p._key ?? p, { trait: trait$1, priority: "localization" }))
				)
			));
			if ( filters[`${trait$1}Categories`] ) proficiencies.push(validate(filters[`${trait$1}Categories`],
				game.i18n.format("BF.Prerequisite.Proficiency.AtLeastOne", { category: formatter.format(
					filters[`${trait$1}Categories`].v.map(p => keyLabel(p, { trait: trait$1, count: 1, priority: "localization" }))
				) })
			));
		};
		prepareProficiency("armor");
		prepareProficiency("weapons");
		prepareProficiency("tools");
		prepareProficiency("skills");
		if ( proficiencies.length ) prerequisites.push(game.i18n.format("BF.Prerequisite.Proficiency.Label", {
			proficiency: game.i18n.getListFormatter({ style: "short" }).format(proficiencies)
		}));

		// Spellcasting
		if ( filters.spellcastingFeature ) prerequisites.push(validate(
			filters.spellcastingFeature, game.i18n.localize("BF.Prerequisite.SpellcastingFeature.Label")
		));
		if ( filters.spellCircle ) prerequisites.push(validate(
			filters.spellCircle, game.i18n.format("BF.Prerequisite.SpellcastingCircle.Label", {
				circle: CONFIG.BlackFlag.spellCircles()[filters.spellCircle.v]
			})
		));
		if ( filters.hasCantrips ) prerequisites.push(validate(
			filters.hasCantrips, game.i18n.localize("BF.Prerequisite.SpellcastingCantrip.Label")
		));
		if ( filters.hasDamagingSpells ) prerequisites.push(validate(
			filters.hasDamagingSpells, game.i18n.localize("BF.Prerequisite.SpellcastingDamage.Label")
		));

		// Traits
		if ( filters.characterLevel ) prerequisites.push(validate(filters.characterLevel, game.i18n.format(
			"BF.Prerequisite.LevelCharacter.Label", { level: numberFormat(filters.characterLevel.v, { ordinal: true }) }
		)));
		if ( filters.classLevel ) prerequisites.push(validate(filters.classLevel, game.i18n.format(
			"BF.Prerequisite.LevelClass.Label", {
				level: numberFormat(filters.classLevel.v, { ordinal: true }),
				class: CONFIG.BlackFlag.registration.get("class", filters.classLevel._class)?.name ?? "â€”"
			}
		)));
		if ( filters.creatureSize ) prerequisites.push(validate(filters.creatureSize, game.i18n.format(
			"BF.Prerequisite.Size.Label", { size: game.i18n.localize(CONFIG.BlackFlag.sizes[filters.creatureSize.v]?.label) }
		)));

		// Other Items
		for ( const uuid of this.restriction.items ) {
			const doc = fromUuidSync(uuid);
			if ( !doc ) continue;
			let label = linkForUUID(uuid);
			if ( actor ) label = `${label} <i class="filter ${actor.sourcedItems.get(uuid)?.size ? "" : "in"}valid"></i>`;
			prerequisites.push(label);
		}

		prerequisites.push(...this.restriction.custom.filter(_ => _));

		// TODO: Send out hook for custom filter handling

		if ( !prerequisites.length ) return "";
		const listFormatter = game.i18n.getListFormatter({
			type: this.restriction.requireAll ? "unit" : "disjunction", style: "short"
		});
		return listFormatter.format(prerequisites);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Validate item prerequisites against actor data.
	 * @param {BlackFlagActor} actor - Actor that needs to be validated.
	 * @returns {true|null|string[]} - True if the item is valid, null if custom restrictions are provided that can't
	 *                                 be properly evaluated, or a list of invalid descriptions if validation failed.
	 */
	validatePrerequisites(actor) {
		let missingItems = this.restriction.items.filter(uuid => !actor.sourcedItems.get(uuid)?.size);

		let invalidFilters;
		if ( this.restriction.requireAll ) {
			invalidFilters = this.restriction.filters.filter(f => !performCheck(actor, [f]));
			if ( !invalidFilters.length && !missingItems.size ) return this.restriction.custom.length ? null : true;
		} else {
			if ( this.restriction.custom.length ) return null;
			const atLeastOneItem = missingItems.size < this.restriction.items.size;
			if ( this.restriction.filters.some(f => performCheck(actor, [f])) || atLeastOneItem ) return true;
			invalidFilters = this.restriction.filters;
		}

		const messages = [];
		const proficiencies = [];
		const formatter = game.i18n.getListFormatter({ type: "disjunction", style: "short" });
		for ( const invalidFilter of invalidFilters ) {
			if ( invalidFilter._id?.startsWith("ability-") ) {
				const abilityKey = invalidFilter._id.replace("ability-", "");
				messages.push(game.i18n.format("BF.Prerequisite.Ability.Warning", {
					ability: game.i18n.localize(CONFIG.BlackFlag.abilities[abilityKey].labels.full).toLowerCase(),
					value: numberFormat(invalidFilter.v)
				}));
				continue;
			}

			switch ( invalidFilter._id ) {
				case "armorCategories":
				case "toolsCategories":
				case "skillsCategories":
				case "weaponsCategories":
					proficiencies.push(game.i18n.format("BF.Prerequisite.Proficiency.AtLeastOne", {
						category: formatter.format(invalidFilter.v.map(p => keyLabel(
							p?._key ?? p, { trait: invalidFilter._id.replace("Categories", ""), count: 1, priority: "localization" }
						)))
					}).toLowerCase());
					break;
				case "armorProficiency":
				case "toolsProficiency":
				case "skillsProficiency":
				case "weaponsProficiency":
					proficiencies.push(formatter.format(invalidFilter.v.map(p => keyLabel(
						p?._key ?? p, { trait: invalidFilter._id.replace("Proficiency", ""), priority: "localization" }
					))));
					break;
				case "characterLevel":
					messages.push(game.i18n.format("BF.Prerequisite.LevelCharacter.Warning", {
						level: numberFormat(invalidFilter.v, { ordinal: true })
					}));
					break;
				case "classLevel":
					messages.push(game.i18n.format("BF.Prerequisite.LevelClass.Warning", {
						level: numberFormat(invalidFilter.v, { ordinal: true }),
						class: CONFIG.BlackFlag.registration.get("class", invalidFilter._class)?.name ?? "â€”"
					}));
					break;
				case "creatureSize":
					messages.push(game.i18n.format("BF.Prerequisite.Size.Warning", {
						size: game.i18n.localize(CONFIG.BlackFlag.sizes[invalidFilter.v].label)
					}));
					break;
				case "hasCantrips":
					messages.push(game.i18n.localize("BF.Prerequisite.SpellcastingCantrip.Warning"));
					break;
				case "hasDamagingSpells":
					messages.push(game.i18n.localize("BF.Prerequisite.SpellcastingDamage.Warning"));
					break;
				case "spellcastingFeature":
					messages.push(game.i18n.localize("BF.Prerequisite.SpellcastingFeature.Warning"));
					break;
				case "spellCircle":
					messages.push(game.i18n.format("BF.Prerequisite.SpellcastingCircle.Warning", {
						circle: CONFIG.BlackFlag.spellCircles()[invalidFilter.v]
					}));
					break;
			}
		}

		if ( proficiencies.length ) messages.push(game.i18n.format("BF.Prerequisite.Proficiency.Warning", {
			proficiency: game.i18n.getListFormatter({ style: "short" }).format(proficiencies)
		}));

		for ( const uuid of missingItems ) messages.push(game.i18n.format("BF.Prerequisite.Items.Warning", {
			name: fromUuidSync(uuid)?.name
		}));

		return messages;
	}
}

const { NumberField: NumberField$5, SchemaField: SchemaField$a } = foundry.data.fields;

/**
 * Data definition for Feature items.
 * @mixes {ActivitiesTemplate}
 * @mixes {AdvancementTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {FeatureTemplate}
 * @mixes {ProficiencyTemplate}
 *
 * @property {object} identifier
 * @property {string} identifier.associated - Identifier of a concept item this feature is associated with.
 * @property {object} level
 * @property {number} level.value - Class or character level at which this feature is available.
 */
class FeatureData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	AdvancementTemplate,
	DescriptionTemplate,
	FeatureTemplate,
	ProficiencyTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "feature",
				category: "features",
				localization: "BF.Item.Type.Feature",
				img: "systems/black-flag/artwork/types/feature.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			identifier: new SchemaField$a({
				associated: new IdentifierField()
			}),
			level: new SchemaField$a({
				value: new NumberField$5({ min: 0, integer: true })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePrerequisiteLabel();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(...args) {
		return this.embedPrerequisite(await super.toEmbed(...args));
	}
}

const { SchemaField: SchemaField$9, StringField: StringField$b } = foundry.data.fields;

/**
 * Data definition for Gear items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} type
 * @property {string} type.category - Gear category as defined in `CONFIG.BlackFlag.gearCategories`.
 * @property {string} type.base - Specific gear type defined as a child of its category.
 */
class GearData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	DescriptionTemplate,
	PhysicalTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "gear",
				category: "equipment",
				localization: "BF.Item.Type.Gear",
				icon: "fa-solid fa-wand-magic",
				img: "systems/black-flag/artwork/types/gear.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			type: new SchemaField$9({
				category: new StringField$b({ label: "BF.Equipment.Category.Label" }),
				base: new StringField$b({ label: "BF.Equipment.Base.Label" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get validCategories() {
		return CONFIG.BlackFlag.gearCategories;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static migrateData(source) {
		super.migrateData(source);

		// Added in 0.10.051
		if (source.type?.category === "focus") {
			source.type.category = "adventuringGear";
			source.type.base = "focus";
		} else if (source.type?.category === "clothing") {
			source.type.category =
				source.properties?.includes("magical") || source.rarity ? "wondrousItem" : "adventuringGear";
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();
		this.type.label = CONFIG.BlackFlag.gearCategories.localized[this.type.category] ?? "";
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}
}

/**
 * Data definition for Background items.
 * @mixes {AdvancementTemplate}
 * @mixes {ConceptTemplate}
 * @mixes {DescriptionTemplate}
 */
class HeritageData extends ItemDataModel.mixin(
	AdvancementTemplate,
	ConceptTemplate,
	DescriptionTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "heritage",
				category: "concept",
				localization: "BF.Item.Type.Heritage",
				icon: "fa-solid fa-monument",
				img: "systems/black-flag/artwork/types/heritage.svg",
				accentColor: "#aa0000",
				register: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateAdvancement(data, options, user) {
		if (data._id || foundry.utils.hasProperty(data, "system.advancement")) return;
		this._createInitialAdvancement([
			{
				type: "trait",
				title: "Languages",
				configuration: { grants: ["languages:standard:common"], choices: [{ count: 1, pool: "languages:*" }] }
			}
		]);
	}
}

/**
 * Data definition for Lineage items.
 * @mixes {AdvancementTemplate}
 * @mixes {ConceptTemplate}
 * @mixes {DescriptionTemplate}
 */
class LineageData extends ItemDataModel.mixin(
	AdvancementTemplate,
	ConceptTemplate,
	DescriptionTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "lineage",
				category: "concept",
				localization: "BF.Item.Type.Lineage",
				icon: "fa-solid fa-globe",
				img: "systems/black-flag/artwork/types/lineage.svg",
				accentColor: "#00aa00",
				register: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateAdvancement(data, options, user) {
		if (data._id || foundry.utils.hasProperty(data, "system.advancement")) return;
		this._createInitialAdvancement([{ type: "size" }]);
	}
}

const { BooleanField, NumberField: NumberField$4, SchemaField: SchemaField$8, SetField: SetField$5, StringField: StringField$a } = foundry.data.fields;

/**
 * Data definition for Spell items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 *
 * @property {ActivationField} casting - Information on casting this spell.
 * @property {object} circle
 * @property {number} circle.value - Effective spell circle.
 * @property {number} circle.base - Base circle for this spell before any upcasting.
 * @property {object} components
 * @property {Set<string>} components.required - Components required to cast the spell.
 * @property {object} components.material
 * @property {string} components.material.description - Description of the material components required.
 * @property {boolean} components.material.consumed - Are the material components consumed in casting?
 * @property {number} components.material.cost - Cost of the material components.
 * @property {string} components.material.denomination - Currency used to measure the material component cost.
 * @property {object} description
 * @property {string} description.short - Short sentence used to describe the spell that will appear in spell lists.
 * @property {DurationField} duration - How long the spell lasts.
 * @property {Set<string>} tags - Additional tags that describe the spell.
 * @property {RangeField} range - Range of the spell.
 * @property {string} school - Spell school.
 * @property {Set<string>} source - Source of magic that grants this spell (e.g. Arcane, Divine, Primordial, or Wyrd).
 * @property {TargetField} target - Targeting information.
 */
class SpellData extends ItemDataModel.mixin(ActivitiesTemplate, DescriptionTemplate) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "spell",
				category: "meta",
				localization: "BF.Item.Type.Spell",
				icon: "fa-solid fa-wand-sparkles",
				img: "systems/black-flag/artwork/types/spell.svg",
				sheet: {
					application: SpellSheet,
					label: "BF.Sheet.Default.Spell"
				}
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			casting: new ActivationField({}, { label: "BF.Spell.CastingTime.Label" }),
			circle: new SchemaField$8(
				{
					value: new NumberField$4({ label: "BF.Spell.Circle.Effective.Label" }),
					base: new NumberField$4({ label: "BF.Spell.Circle.Base.Label" })
				},
				{ label: "BF.Spell.Circle.Label" }
			),
			components: new SchemaField$8(
				{
					required: new SetField$5(new StringField$a()),
					material: new SchemaField$8(
						{
							description: new StringField$a({ label: "BF.Spell.Component.Material.Description.Label" }),
							consumed: new BooleanField({ label: "BF.Spell.Component.Material.Consumed.Label" }),
							cost: new NumberField$4({ min: 0, integer: true, label: "BF.Spell.Component.Material.Cost.Label" }),
							denomination: new StringField$a({ initial: "gp", label: "BF.Currency.Denomination.Label" })
						},
						{ label: "BF.Spell.Component.Material.Label" }
					)
				},
				{ label: "BF.Spell.Component.Label" }
			),
			description: new SchemaField$8({
				short: new StringField$a({ label: "BF.Item.Description.ShortLabel", hint: "BF.Item.Description.ShortHint" })
			}),
			duration: new DurationField(),
			tags: new SetField$5(new StringField$a(), { label: "BF.Spell.Tag.Label" }),
			range: new RangeField(),
			school: new StringField$a({ label: "BF.Spell.School.Label" }),
			source: new SetField$5(new StringField$a(), { label: "BF.Spell.Source.Label" }),
			target: new TargetField()
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Ability used for attacks, save DCs, and damage with this spell.
	 * @type {string}
	 */
	get ability() {
		return this.parent.getFlag(game.system.id, "relationship.origin.ability") || this.defaultAbility;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Class with which this spell is associated, if any.
	 * @type {BlackFlagItem|null}
	 */
	get associatedClass() {
		const doc =
			this.parent.actor?.system.spellcasting?.origins?.[
				this.parent.getFlag("black-flag", "relationship.origin.identifier")
			]?.document;
		if (!doc) return null;
		return (doc.type === "class" ? doc : doc.system.class) ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		if (this.school) tags.set("type", CONFIG.BlackFlag.spellSchools.localized[this.school]);
		tags.set("details", this.components.label);
		tags.set("activation", this.casting.label);
		tags.set("duration", this.duration.label);
		if (this.range.units) tags.set("range", this.range.label);
		if (this.target.affects.type) tags.set("affects", this.target.affects.label);
		if (this.target.template.units) tags.set("template", this.target.template.label);
		tags.set("attuned", this.preparationLabel);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Default spellcasting ability based on this spell's origin.
	 * @type {string}
	 */
	get defaultAbility() {
		return (
			this.parent.actor?.system.spellcasting?.origins?.[
				this.parent.getFlag(game.system.id, "relationship.origin.identifier")
			]?.ability ??
			this.parent.actor?.system.spellcasting?.ability ??
			"intelligence"
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get displayActions() {
		const linked = this.linkedActivity;
		if (linked) return false;
		return this.prepared;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Retrieve a linked activity that granted this spell using the stored `cachedFor` value.
	 * @returns {Activity|null}
	 */
	get linkedActivity() {
		const relative = this.parent.actor;
		if (!relative) return null;
		return fromUuidSync(this.parent.getFlag(game.system.id, "cachedFor"), { relative, strict: false }) ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the "Always Prepared" option valid for this item?
	 * @type {boolean}
	 */
	get alwaysPreparable() {
		const config = CONFIG.BlackFlag.spellPreparationModes[this.parent.getFlag("black-flag", "relationship.mode")];
		return config?.preparable && this.circle.base !== 0 && !this.tags.has("ritual");
	}

	/**
	 * Can this spell be prepared?
	 * @type {boolean}
	 */
	get preparable() {
		const alwaysPrepared = this.parent.getFlag("black-flag", "relationship.alwaysPrepared");
		return this.alwaysPreparable && !alwaysPrepared;
	}

	/**
	 * Would this spell be considered to be prepared?
	 * @type {boolean}
	 */
	get prepared() {
		if (!this.preparable || this.parent.actor?.type !== "pc") return true;
		return this.parent.getFlag("black-flag", "relationship.prepared") === true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Label for displaying preparation status in chat.
	 * @type {string|null}
	 */
	get preparationLabel() {
		const preparationMode = this.parent.getFlag("black-flag", "relationship.mode");
		if (!preparationMode || preparationMode === "standard") {
			if (this.parent.getFlag("black-flag", "relationship.alwaysPrepared")) {
				return game.i18n.localize("BF.Spell.Preparation.AlwaysPrepared");
			} else if (this.alwaysPreparable) {
				return game.i18n.localize(`BF.Spell.Preparation.${this.prepared ? "" : "Not"}Prepared`);
			}
			return null;
		}
		return CONFIG.BlackFlag.spellPreparationModes.localized[preparationMode] ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Proficiency description.
	 * @type {Proficiency}
	 */
	get proficiency() {
		return new Proficiency(this.parent.actor?.system.attributes?.proficiency ?? 0, 1);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Does activating this spell require a spell slot?
	 * @type {boolean}
	 */
	get requiresSpellSlot() {
		// Cantrips & rituals never consume slots
		if (this.circle.base === 0 || this.tags.has("ritual")) return false;

		// At Will & Innate preparation modes never consume slots
		const prep = CONFIG.BlackFlag.spellPreparationModes[this.parent.getFlag("black-flag", "relationship.mode")];
		if (!prep?.scalable) return false;

		return true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get scaling() {
		return (
			super.scaling ??
			(this.circle.base === 0
				? this.parent.actor?.system.spellcasting?.cantripScale
				: this.circle.value
					? this.circle.value - this.circle.base
					: null)
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get traits() {
		const traits = [
			this.associatedClass?.name,
			CONFIG.BlackFlag.spellSchools.localized[this.school],
			this.duration.units !== "instantaneous" ? this.duration.label : null,
			...this.tags.map(t => CONFIG.BlackFlag.spellTags.localized[t])
		];
		const listFormatter = new Intl.ListFormat(game.i18n.lang, { type: "unit" });
		return listFormatter.format(traits.filter(_ => _).map(t => game.i18n.localize(t)));
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Migrations           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Migrate spell circle to source, ring to circle, and migrate single spell source to set of sources.
	 * Added in 0.9.023
	 * @param {object} source - Candidate source data to migrate.
	 */
	static migrateSourceCircle(source) {
		if ("circle" in source && !("source" in source)) source.source = source.circle;
		if ("ring" in source) source.circle = source.ring;
		if (foundry.utils.getType(source.source) !== "string") return;
		source.source = [source.source];
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		super.prepareBaseData();
		const system = this;

		Object.defineProperty(this.casting, "scalar", {
			get() {
				return this.type ? CONFIG.BlackFlag.activationOptions().get(this.type).scalar : false;
			},
			configurable: true,
			enumerable: false
		});

		Object.defineProperty(this.circle, "toString", {
			value: () => String(this.circle.value ?? this.circle.base),
			configurable: true,
			enumerable: false
		});

		Object.defineProperty(this.components, "label", {
			get() {
				return SpellData.componentsLabel(system);
			},
			configurable: true,
			enumerable: false
		});
		Object.defineProperty(this.components, "embedLabel", {
			get() {
				return SpellData.componentsLabel(system, { style: "embed" });
			},
			configurable: true,
			enumerable: false
		});

		Object.defineProperty(this.source, "label", {
			get() {
				const sources = Array.from(this)
					.map(c => CONFIG.BlackFlag.spellSources.localized[c])
					.filter(c => c);
				return game.i18n.getListFormatter({ type: "unit" }).format(sources);
			},
			configurable: true,
			enumerable: false
		});

		this.type ??= {};
		Object.defineProperty(this.type, "classification", {
			value: "spell",
			writable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.duration.concentration = this.tags.has("concentration");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });

		const prepareFinalValue = (keyPath, label) =>
			foundry.utils.setProperty(
				this,
				keyPath,
				simplifyBonus(
					replaceFormulaData(foundry.utils.getProperty(this, keyPath) ?? "", rollData, {
						notifications: this.parent.notifications,
						key: `invalid-target-${keyPath.replaceAll(".", "-")}`,
						section: "auto",
						messageData: { name: this.parent.name, property: game.i18n.localize(label) }
					})
				)
			);
		prepareFinalValue("duration.value", "BF.DURATION.Label");
		prepareFinalValue("range.value", "BF.RANGE.Label");
		prepareFinalValue("target.affects.count", "BF.TARGET.Label[other]");
		prepareFinalValue("target.template.count", "BF.TARGET.FIELDS.template.count.label");
		prepareFinalValue("target.template.size", "BF.AreaOfEffect.Size.Label");
		prepareFinalValue("target.template.width", "BF.AreaOfEffect.Size.Width");
		prepareFinalValue("target.template.height", "BF.AreaOfEffect.Size.Height");

		this.prepareFinalActivities(rollData);
		this.prepareSpellStats();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Contribute to total spell numbers on actor if embedded.
	 */
	prepareSpellStats() {
		if (!this.parent.actor?.system.spellcasting) return;
		const stats = this.parent.actor.system.spellcasting.spells;
		if (stats) {
			stats.total += 1;
			if (this.circle.base === 0) stats.cantrips += 1;
			else if (this.tags.has("ritual")) stats.rituals += 1;
			for (const activity of this.activities) {
				if (activity.hasDamage) {
					stats.damaging += 1;
					break;
				}
			}
		}

		const origins = (this.parent.actor.system.spellcasting.origins ??= {});
		const relationship = this.parent.getFlag("black-flag", "relationship.origin") ?? {};
		if (!relationship.identifier) return;
		const origin = (origins[relationship.identifier] ??= {});
		if (this.circle.base === 0) {
			origin.cantrips ??= { value: 0 };
			origin.cantrips.value += 1;
		} else if (this.tags.has("ritual")) {
			origin.rituals ??= { value: 0 };
			origin.rituals.value += 1;
		} else {
			origin.spells ??= { value: 0 };
			origin.spells.value += 1;
			if (relationship.spellbookOrigin === "free") {
				origin.spellbook ??= { value: 0 };
				origin.spellbook.value += 1;
			}
			if (this.preparable && this.prepared) {
				origin.prepared ??= { value: 0 };
				origin.prepared.value += 1;
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		const context = await this.parent.sheet.getData();

		const localizationKey = this.circle.base === 0 ? "Cantrip" : this.tags.has("ritual") ? "Ritual" : "Standard";
		context.circleType = game.i18n.format(`BF.Spell.CircleType.${localizationKey}`, {
			circle: CONFIG.BlackFlag.spellCircles({ dashed: true })[this.circle.base],
			school: CONFIG.BlackFlag.spellSchools.localized[this.school],
			types: game.i18n
				.getListFormatter({ style: "long" })
				.format(Array.from(this.source).map(s => CONFIG.BlackFlag.spellSources.localized[s]))
		});

		context.rangeLabel = this.range.label;
		if (this.range.units === "self") {
			const templateLabel = TargetField.templateLabel(this.target, { style: "long" });
			if (templateLabel) context.rangeLabel = `${context.rangeLabel} (${templateLabel})`;
		}

		context.durationLabel = this.tags.has("concentration")
			? game.i18n.format("BF.Spell.Tag.Concentration.Formatted", {
					duration: this.duration.label
				})
			: this.duration.label;

		const section = document.createElement("section");
		section.innerHTML = await renderTemplate("systems/black-flag/templates/item/embeds/spell-embed.hbs", context);
		return section.children;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a label for a spell's components.
	 * @param {SpellData} spell - System data for the spell.
	 * @param {object} [options={}]
	 * @param {string} [options.style="combined"] - Style of either "combined" or "embed".
	 * @returns {string}
	 */
	static componentsLabel(spell, { style = "combined" } = {}) {
		const components = [];
		for (const key of spell.components.required) {
			const config = CONFIG.BlackFlag.spellComponents[key];
			const data = {
				type: "component",
				label: game.i18n.localize(config.abbreviation),
				tooltip: style === "combined " ? game.i18n.localize(config.label) : game.i18n.localize(config.abbreviation)
			};
			if (key === "material" && spell.components.material.description) {
				data.label += "*";
				data.tooltip += ` (${spell.components.material.description})`;
			}
			components.push(data);
		}

		if (style === "combined") {
			return components
				.map(({ type, label, tooltip }) => `<span class="${type}" data-tooltip="${tooltip}">${label}</span>`)
				.join("");
		} else {
			return game.i18n.getListFormatter({ type: "unit" }).format(components.map(c => c.tooltip));
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine if this item matches against an inventory filter.
	 * @param {string} filter - Filter name.
	 * @returns {boolean|void} - Boolean if the filter matches or not, or undefined if filter isn't valid for this item.
	 */
	evaluateFilter(filter) {
		switch (filter) {
			case "action":
				return this.casting.type === "action";
			case "bonus":
				return this.casting.type === "bonus";
			case "reaction":
				return this.casting.type === "reaction";
			case "concentration":
				return this.tags.has("concentration");
			case "ritual":
				return this.tags.has("ritual");
			case "prepared":
				return this.prepared;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getRollData(options = {}) {
		const rollData = super.getRollData(options);
		rollData.spellcasting = {
			...(rollData.spellcasting ?? {}),
			dc: this.parent.actor?.system.abilities?.[this.ability]?.dc
		};
		return rollData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async prepareActivationChatContext(context) {
		const rollData = context.activity.getRollData();
		const spellCircle = CONFIG.BlackFlag.spellCircles()[rollData.item.circle.value || rollData.item.circle.base];
		if (spellCircle) context.subtitle = `${spellCircle} â€¢ ${context.subtitle}`;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_validConsumptionTypes(types) {
		return types.filter(t => t.key !== "spellSlots");
	}
}

const { SchemaField: SchemaField$7 } = foundry.data.fields;

/**
 * Data definition for Subclass items.
 * @mixes {AdvancementTemplate}
 * @mixes {ConceptTemplate}
 * @mixes {DescriptionTemplate}
 *
 * @property {object} identifier
 * @property {string} identifier.class - Class with which this subclass is associated.
 */
class SubclassData extends ItemDataModel.mixin(
	AdvancementTemplate,
	ConceptTemplate,
	DescriptionTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "subclass",
				category: "concept",
				localization: "BF.Item.Type.Subclass",
				icon: "fa-solid fa-landmark-flag",
				img: "systems/black-flag/artwork/types/subclass.svg",
				register: true
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			identifier: new SchemaField$7({
				class: new IdentifierField({ label: "BF.Item.Type.Class[one]" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Class with which this subclass is associated. Only available if embedded.
	 * @type {BlackFlagItem|null}
	 */
	get class() {
		return this.parent.actor?.system.progression?.classes?.[this.identifier.class]?.document ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch the color from parent class if available.
	 * @type {string|void}
	 */
	get color() {
		return this.class?.system.color;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Key ability selected for this subclass.
	 * @type {string|null}
	 */
	get keyAbility() {
		return this.class?.system.keyAbility ?? null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Number of levels of the class associated with this subclass a character has.
	 * @type {number}
	 */
	get levels() {
		return this.parent.actor?.system.progression?.classes[this.identifier.class]?.levels ?? 0;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get traits() {
		const traits = [];
		if (this.spellcasting)
			traits.push({
				label: "BF.Spellcasting.Label",
				value: this.spellcasting.label
			});
		return traits;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		this.prepareDescription();
		this.prepareSpellcastingSource();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateAdvancement(data, options, user) {
		if (data._id || foundry.utils.hasProperty(data, "system.advancement")) return;
		this._createInitialAdvancement(
			CONFIG.BlackFlag.subclassFeatureLevels.map(level => ({ type: "grantFeatures", level: { value: level } }))
		);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateSubclass(data, options, user) {
		if (!this.parent.actor) return;

		const matchingClass = this.parent.actor.system.progression?.classes?.[this.identifier.class];
		if (!matchingClass) {
			ui.notifications.error(
				game.i18n.format("BF.Subclass.Warning.MissingClass", {
					class: CONFIG.BlackFlag.registration.all.class[this.identifier.class]?.name ?? this.identifier.class
				})
			);
			return false;
		} else if (matchingClass.subclass) {
			ui.notifications.error(
				game.i18n.format("BF.Subclass.Warning.ExistingSubclass", {
					class: CONFIG.BlackFlag.registration.all.class[this.identifier.class]?.name ?? this.identifier.class,
					subclass: matchingClass.subclass.name
				})
			);
			return false;
		}
	}
}

const { SchemaField: SchemaField$6, StringField: StringField$9 } = foundry.data.fields;

/**
 * Data definition for Sundry items.
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 *
 * @property {object} type
 * @property {string} type.category - Sundry category as defined in `CONFIG.BlackFlag.sundryCategories`.
 * @property {string} type.base - Specific sundry type defined as a child of its category.
 */
class SundryData extends ItemDataModel.mixin(DescriptionTemplate, PhysicalTemplate) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "sundry",
				category: "equipment",
				localization: "BF.Item.Type.Sundry",
				icon: "fa-solid fa-boxes-stacked",
				img: "systems/black-flag/artwork/types/sundry.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			type: new SchemaField$6({
				category: new StringField$9({ label: "BF.Equipment.Category.Label" }),
				base: new StringField$9({ label: "BF.Equipment.Base.Label" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get validCategories() {
		return CONFIG.BlackFlag.sundryCategories;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();
	}
}

/**
 * Data definition for Talent items.
 * @mixes {ActivityTemplate}
 * @mixes {AdvancementTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {FeatureTemplate}
 * @mixes {ProficiencyTemplate}
 */
class TalentData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	AdvancementTemplate,
	DescriptionTemplate,
	FeatureTemplate,
	ProficiencyTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "talent",
				category: "features",
				localization: "BF.Item.Type.Talent",
				img: "systems/black-flag/artwork/types/talent.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePrerequisiteLabel();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Embeds & Tooltips          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(...args) {
		return this.embedPrerequisite(await super.toEmbed(...args));
	}
}

const { SchemaField: SchemaField$5, StringField: StringField$8 } = foundry.data.fields;

/**
 * Data definition for Tool items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {ProficiencyTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} type
 * @property {string} type.category - Tool category as defined in `CONFIG.BlackFlag.tools`.
 * @property {string} type.base - Specific tool type defined as a child of its category.
 */
class ToolData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	DescriptionTemplate,
	PhysicalTemplate,
	ProficiencyTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "tool",
				category: "equipment",
				localization: "BF.Item.Type.Tool",
				icon: "fa-solid fa-screwdriver-wrench",
				img: "systems/black-flag/artwork/types/tool.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			type: new SchemaField$5({
				category: new StringField$8({ label: "BF.Equipment.Category.Label" }),
				base: new StringField$8({ label: "BF.Equipment.Base.Label" })
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static proficiencyCategory = "tools";

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get validCategories() {
		return CONFIG.BlackFlag.tools;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}
}

const { NumberField: NumberField$3, SchemaField: SchemaField$4, SetField: SetField$4, StringField: StringField$7 } = foundry.data.fields;

/**
 * Data definition for Weapon items.
 * @mixes {ActivitiesTemplate}
 * @mixes {DescriptionTemplate}
 * @mixes {PhysicalTemplate}
 * @mixes {ProficiencyTemplate}
 * @mixes {PropertiesTemplate}
 *
 * @property {object} ammunition
 * @property {number} ammunition.capacity - Number of shots that can be held in a weapon with the magazine property.
 * @property {string} ammunition.type - Category of ammunition that can be used with this weapon.
 * @property {object} damage
 * @property {DamageField} damage.base - Base weapon damage.
 * @property {number} magicalBonus - Magical bonus added to attack & damage rolls.
 * @property {Set<string>} options - Weapon options that can be used with this weapon.
 * @property {object} range
 * @property {number} range.short - Short range of the weapon.
 * @property {number} range.long - Long range of the weapon.
 * @property {number} range.reach - Additional reach of the weapon beyond the wielder's normal reach.
 * @property {string} range.units - Units used to measure range and reach.
 * @property {object} type
 * @property {string} type.value - Is this a melee or a ranged weapon?
 * @property {string} type.category - Weapon category as defined in `CONFIG.BlackFlag.weapons`.
 * @property {string} type.base - Specific weapon type defined as a child of its category.
 */
class WeaponData extends ItemDataModel.mixin(
	ActivitiesTemplate,
	DescriptionTemplate,
	PhysicalTemplate,
	ProficiencyTemplate,
	PropertiesTemplate
) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.WEAPON", "BF.SOURCE"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "weapon",
				category: "equipment",
				localization: "BF.Item.Type.Weapon",
				icon: "fa-solid fa-trowel",
				img: "systems/black-flag/artwork/types/weapon.svg"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {
			ammunition: new SchemaField$4({
				capacity: new NumberField$3(),
				type: new StringField$7()
			}),
			damage: new SchemaField$4({
				base: new DamageField({ simple: true })
			}),
			magicalBonus: new NumberField$3({ integer: true }),
			options: new SetField$4(new StringField$7()),
			range: new SchemaField$4({
				short: new NumberField$3({ min: 0, step: 0.1 }),
				long: new NumberField$3({ min: 0, step: 0.1 }),
				reach: new NumberField$3({ min: 0, step: 0.1 }),
				units: new StringField$7({ initial: "foot" })
			}),
			type: new SchemaField$4({
				value: new StringField$7({ initial: "melee" }),
				category: new StringField$7(),
				base: new StringField$7()
			})
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static proficiencyCategory = "weapons";

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Magical bonus to attacks.
	 * @returns {number|null}
	 */
	get attackMagicalBonus() {
		return this.magicAvailable ? this.magicalBonus : null;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get attackModes() {
		const modes = [];

		// All weapons except thrown ranged weapons, which will just display the "Thrown" mode
		if (!(this.properties.has("thrown") && this.type.value === "ranged")) {
			// Weapons without the "Two-Handed" property or with the "Versatile" property will have One-Handed attack
			if (this.properties.has("versatile") || !this.properties.has("twoHanded"))
				modes.push({
					value: "oneHanded",
					label: CONFIG.BlackFlag.attackModes.localized.oneHanded
				});

			// Weapons with the "Two-Handed" property or with the "Versatile" property will have Two-Handed attack
			if (this.properties.has("versatile") || this.properties.has("twoHanded"))
				modes.push({
					value: "twoHanded",
					label: CONFIG.BlackFlag.attackModes.localized.twoHanded
				});
		}

		// Weapons with the "Light" property will have Offhand attack
		if (this.properties.has("light"))
			modes.push({
				value: "offhand",
				label: CONFIG.BlackFlag.attackModes.localized.offhand
			});

		// Weapons with the "Thrown" property will have the Thrown attack
		if (this.properties.has("thrown")) {
			if (modes.length) modes.push({ rule: true });
			modes.push({ value: "thrown", label: CONFIG.BlackFlag.attackModes.localized.thrown });

			// Weapons with the "Thrown" & "Light" properties will have a Thrown Offhand attack
			if (this.properties.has("light"))
				modes.push({
					value: "thrownOffhand",
					label: CONFIG.BlackFlag.attackModes.localized.thrownOffhand
				});
		}

		return modes;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Abilities that could potentially be used with this weapon.
	 * @type {Set<string>}
	 */
	get availableAbilities() {
		const melee = CONFIG.BlackFlag.defaultAbilities.meleeAttack;
		const ranged = CONFIG.BlackFlag.defaultAbilities.rangedAttack;
		if (this.properties.has("finesse")) return new Set([melee, ranged]);
		return new Set([this.type.value === "ranged" ? ranged : melee]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	get chatTags() {
		const tags = this.parent.chatTags;
		tags.set("type", this.typeLabel);
		if (this.rangeLabel) tags.set("range", this.rangeLabel);
		else if (this.reachLabel) tags.set("range", this.reachLabel);
		this.setPhysicalChatTags(tags);
		return tags;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Label for the range with units.
	 * @type {string}
	 */
	get rangeLabel() {
		if (this.type.value !== "ranged" && !this.properties.has("thrown")) return "";

		const values = [];
		if (this.range.short) values.push(this.range.short);
		if (this.range.long && this.range.long !== this.range.short) values.push(this.range.long);
		const unit = this.range.units ?? Object.keys(CONFIG.BlackFlag.distanceUnits)[0];
		if (!values.length || !unit) return "";

		const last = values.pop();
		return [...values.map(v => formatNumber(v)), formatDistance(last, unit, { unitDisplay: "short" })].filterJoin("/");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Label for the reach with units.
	 * @type {string}
	 */
	get reachLabel() {
		if (this.type.value !== "melee") return "";

		const unit = this.range.units ?? Object.keys(CONFIG.BlackFlag.distanceUnits)[0];
		// TODO: Define starting reach for imperial/metric
		const reach = this.properties.has("reach") ? this.range.reach || 5 : 0;
		return formatDistance(5 + reach, unit, { unitDisplay: "short" });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get traits() {
		const traits = [
			CONFIG.BlackFlag.weaponTypes[this.type.value]?.label,
			...this.properties.map(p => CONFIG.BlackFlag.itemProperties.localized[p])
		];
		const listFormatter = game.i18n.getListFormatter({ type: "unit" });
		return listFormatter.format(traits.filter(t => t).map(t => game.i18n.localize(t)));
		// Ranged
		// Reach (total)
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Combined label for the weapon's type (e.g. "Simple Melee Weapon").
	 * @type {string}
	 */
	get typeLabel() {
		return game.i18n
			.format("BF.WEAPON.Type.CombinedLabel[one]", {
				category: CONFIG.BlackFlag.weapons.localized[this.type.category] ?? "",
				type: CONFIG.BlackFlag.weaponTypes.localized[this.type.value] ?? ""
			})
			.replace("  ", " ")
			.trim();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get validCategories() {
		return CONFIG.BlackFlag.weapons;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get validOptions() {
		return CONFIG.BlackFlag.weaponOptions;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	get versatileDamage() {
		if (!this.properties.has("versatile") || !this.damage.base.denomination) return this.damage.base;
		return this.damage.base.clone({
			...this.damage.base,
			denomination: stepDenomination(this.damage.base.denomination)
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Data Migration           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static migrateData(source) {
		super.migrateData(source);

		// Added in 0.10.042
		if ("damage" in source) {
			if ("number" in source.damage) foundry.utils.setProperty(source, "damage.base.number", source.damage.number);
			if ("denomination" in source.damage) {
				foundry.utils.setProperty(source, "damage.base.denomination", source.damage.denomination);
			}
			if ("type" in source.damage) foundry.utils.setProperty(source, "damage.base.type", source.damage.type);
			if ("additionalTypes" in source.damage) {
				foundry.utils.setProperty(source, "damage.base.additionalTypes", source.damage.additionalTypes);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareBaseData() {
		this.applyShims();
		super.prepareBaseData();

		Object.defineProperty(this.type, "classification", {
			value: "weapon",
			writable: false
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		this.prepareDescription();
		this.preparePhysicalLabels();

		const type = CONFIG.BlackFlag.weapons.allLocalized[this.type.base ?? this.type.category];
		if (type) this.type.label = `${game.i18n.localize("BF.WEAPON.Label[one]")} (${type})`;
		else this.type.label = game.i18n.localize("BF.WEAPON.Label[one]");
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareFinalData() {
		super.prepareFinalData();
		const rollData = this.parent.getRollData({ deterministic: true });
		this.prepareFinalActivities(rollData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getRollData(...args) {
		const rollData = super.getRollData(...args);
		rollData.labels ??= {};
		rollData.labels.range = this.rangeLabel;
		rollData.labels.reach = this.reachLabel;
		return rollData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	_preCreateActivities(data, options, user) {
		if (data._id || foundry.utils.hasProperty(data, "system.activities")) return;
		this._createInitialActivities([{ type: "attack" }]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*                Shims                */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add shims for removed properties.
	 */
	applyShims() {
		const log = () =>
			foundry.utils.logCompatibilityWarning("The `damage` data on `WeaponData` has been moved to `damage.base`", {
				since: "Black Flag 0.10.042",
				until: "Black Flag 0.10.047"
			});
		Object.defineProperty(this.damage, "number", {
			get() {
				log();
				return this.damage.base.number;
			},
			configurable: true
		});
		Object.defineProperty(this.damage, "denomination", {
			get() {
				log();
				return this.damage.base.denomination;
			},
			configurable: true
		});
		Object.defineProperty(this.damage, "type", {
			get() {
				log();
				return this.damage.base.type;
			},
			configurable: true
		});
		Object.defineProperty(this.damage, "additionalTypes", {
			get() {
				log();
				return this.damage.base.additionalTypes;
			},
			configurable: true
		});
	}
}

var _module$a = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActivitiesTemplate: ActivitiesTemplate,
	AdvancementTemplate: AdvancementTemplate,
	ConceptTemplate: ConceptTemplate,
	DescriptionTemplate: DescriptionTemplate,
	FeatureTemplate: FeatureTemplate,
	PhysicalTemplate: PhysicalTemplate,
	ProficiencyTemplate: ProficiencyTemplate,
	PropertiesTemplate: PropertiesTemplate
});

var _module$9 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AmmunitionData: AmmunitionData,
	ArmorData: ArmorData,
	BackgroundData: BackgroundData,
	ClassData: ClassData,
	ConsumableData: ConsumableData,
	ContainerData: ContainerData,
	CurrencyData: CurrencyData,
	FeatureData: FeatureData,
	GearData: GearData,
	HeritageData: HeritageData,
	LineageData: LineageData,
	SpellData: SpellData,
	SubclassData: SubclassData,
	SundryData: SundryData,
	TalentData: TalentData,
	ToolData: ToolData,
	WeaponData: WeaponData,
	template: _module$a
});

const { DocumentUUIDField: DocumentUUIDField$1, HTMLField: HTMLField$3, NumberField: NumberField$2, SchemaField: SchemaField$3, SetField: SetField$3 } = foundry.data.fields;

/**
 * Data definition for Class Summary journal entry pages.
 *
 * @property {string} item - UUID of the referenced class item.
 * @property {number} headingLevel - Override the level of included headers.
 * @property {object} description
 * @property {string} description.introduction - Introductory description for the class.
 * @property {string} description.additionalHitPoints - Additional text displayed beneath the hit points section.
 * @property {string} description.additionalTraits - Additional text displayed beneath the traits section.
 * @property {string} description.additionalEquipment - Additional text displayed beneath the equipment section.
 * @property {string} description.conclusion - Text added after features, but before subclasses.
 * @property {string} description.subclassAdvancement - Subclass description as it appears in the features list.
 * @property {string} description.subclassSection - Subclass description as it appears before the list of subclasses.
 * @property {Set<string>} subclasses - UUIDs of subclasses to display on the class page.
 */
class ClassJournalPageData extends BaseDataModel {
	/** @inheritDoc */
	static get metadata() {
		return {
			type: "class",
			localization: "BF.JournalPage.Type.Class",
			sheet: {
				application: ClassPageSheet,
				label: "BF.Sheet.Default.ClassPage"
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			item: new DocumentUUIDField$1({ label: "BF.JournalPage.Class.Item" }),
			headingLevel: new NumberField$2({ initial: 3 }),
			description: new SchemaField$3({
				additionalHitPoints: new HTMLField$3({
					label: "BF.HitPoint.Label[other]",
					hint: "BF.JournalPage.Class.HitPoints.Hint"
				}),
				additionalTraits: new HTMLField$3({
					label: "BF.Proficiency.Label[other]",
					hint: "BF.JournalPage.Class.Traits.Hint"
				}),
				additionalEquipment: new HTMLField$3({
					label: "BF.JournalPage.Class.Equipment.Header",
					hint: "BF.JournalPage.Class.Equipment.Hint"
				}),
				conclusion: new HTMLField$3({
					label: "BF.JournalPage.Class.Conclusion.Label",
					hint: "BF.JournalPage.Class.Conclusion.Hint"
				}),
				introduction: new HTMLField$3({
					label: "BF.JournalPage.Class.Introduction.Label",
					hint: "BF.JournalPage.Class.Introduction.Hint"
				}),
				subclassAdvancement: new HTMLField$3({
					label: "BF.JournalPage.Class.Subclass.AdvancementDescription.Label",
					hint: "BF.JournalPage.Class.Subclass.AdvancementDescription.Hint"
				}),
				subclassSection: new HTMLField$3({
					label: "BF.JournalPage.Class.Subclass.SectionDescription.Label",
					hint: "BF.JournalPage.Class.Subclass.SectionDescription.Hint"
				})
			}),
			subclasses: new SetField$3(new DocumentUUIDField$1(), { label: "BF.JournalPage.Class.Subclass.Items" })
		};
	}
}

const { StringField: StringField$6 } = foundry.data.fields;

/**
 * Data definition for Map Location journal entry pages.
 *
 * @property {string} code - Code for the location marker displayed on the map.
 */
class MapLocationJournalPageData extends BaseDataModel {
	/** @inheritDoc */
	static get metadata() {
		return {
			type: "map",
			localization: "BF.JournalPage.Type.Map",
			sheet: {
				application: MapLocationPageSheet,
				label: "BF.Sheet.Default.Map"
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			code: new StringField$6()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Adjust the number of this entry in the table of contents.
	 * @param {number} number - Current position number.
	 * @returns {{ number: string, adjustment: number }|void}
	 */
	adjustTOCNumbering(number) {
		if (!this.code) return;
		return { number: this.code, adjustment: -1 };
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a control icon for rendering this page on a scene.
	 * @param {object} options - Options passed through to ControlIcon construction.
	 * @returns {PIXI.Container|void}
	 */
	getControlIcon(options) {
		if (!this.code) return;
		const { icon: IconClass, ...style } = foundry.utils.mergeObject(
			CONFIG.BlackFlag.mapLocationMarkerStyle.default,
			CONFIG.BlackFlag.mapLocationMarkerStyle[this.parent.getFlag("black-flag", "mapMarkerStyle")] ?? {},
			{ inplace: false }
		);
		return new IconClass({ code: this.code, ...options, ...style });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		return this.parent._embedTextPage(config, options);
	}
}

const { HTMLField: HTMLField$2, StringField: StringField$5 } = foundry.data.fields;

/**
 * Data definition for Rule journal entry pages.
 *
 * @property {string} tooltip - Content to display in tooltip in place of page's text content.
 * @property {string} type - Type of rule represented. Should match an entry defined in `CONFIG.BlackFlag.ruleTypes`.
 */
class RuleJournalPageData extends BaseDataModel {
	/** @inheritDoc */
	static get metadata() {
		return {
			type: "rule",
			localization: "BF.JournalPage.Type.Rule",
			sheet: {
				application: JournalRulePageSheet,
				label: "BF.Sheet.Default.Rule"
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			tooltip: new HTMLField$2({ label: "BF.Rule.Tooltip" }),
			type: new StringField$5({ blank: false, initial: "rule", label: "BF.Rule.Type.Label" })
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async richTooltip(enrichmentOptions = {}) {
		const context = {
			page: this.parent,
			type: CONFIG.BlackFlag.ruleTypes.localized[this.type],
			content: await TextEditor.enrichHTML(this.tooltip || this.parent.text.content, {
				relativeTo: this.parent,
				...enrichmentOptions
			})
		};
		return {
			content: await renderTemplate("systems/black-flag/templates/journal/rule-page-tooltip.hbs", context),
			classes: ["black-flag", "black-flag-tooltip", "rule-tooltip"]
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async toEmbed(config, options = {}) {
		return this.parent._embedTextPage(config, options);
	}
}

const { HTMLField: HTMLField$1, NumberField: NumberField$1, SchemaField: SchemaField$2, SetField: SetField$2, StringField: StringField$4 } = foundry.data.fields;

/**
 * Data model for spell list data.
 *
 * @property {object} description
 * @property {string} description.conclusion - Description to display after spell list.
 * @property {string} description.introduction - Description to display before spell list.
 * @property {string} grouping - Default grouping mode.
 * @property {number} headingLevel - Override the level of included headers.
 * @property {Set<string>} spells - UUIDs of spells to display.
 */
class SpellListJournalPageData extends BaseDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.SPELLLIST"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static get metadata() {
		return {
			type: "spells",
			localization: "BF.JournalPage.Type.SpellList",
			sheet: {
				application: JournalSpellListPageSheet,
				label: "BF.Sheet.Default.SpellListPage"
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static defineSchema() {
		return {
			description: new SchemaField$2({
				conclusion: new HTMLField$1({ textSearch: true }),
				introduction: new HTMLField$1({ textSearch: true })
			}),
			grouping: new StringField$4({ initial: "circle", choices: this.GROUPING_MODES }),
			headingLevel: new NumberField$1({ initial: 3 }),
			spells: new SetField$2(new StringField$4())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Different ways in which spells can be grouped on the sheet.
	 * @enum {string}
	 */
	static GROUPING_MODES = {
		none: "BF.SPELLLIST.Grouping.None",
		alphabetical: "BF.SPELLLIST.Grouping.Alphabetical",
		circle: "BF.SPELLLIST.Grouping.Circle",
		school: "BF.SPELLLIST.Grouping.School"
	};
}

const { DocumentUUIDField, HTMLField, NumberField, SchemaField: SchemaField$1 } = foundry.data.fields;

/**
 * Data definition for Subclass Summary journal entry pages.
 *
 * @property {string} item - UUID of the referenced subclass item.
 * @property {number} headingLevel - Override the level of included headers.
 * @property {object} description
 * @property {string} description.conclusion - Text added after features, but before subclasses.
 * @property {string} description.introduction - Introductory description for the subclass.
 */
class SubclassJournalPageData extends BaseDataModel {
	/** @inheritDoc */
	static get metadata() {
		return {
			type: "subclass",
			localization: "BF.JournalPage.Type.Subclass",
			sheet: {
				application: ClassPageSheet,
				label: "BF.Sheet.Default.ClassPage"
			}
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return {
			item: new DocumentUUIDField({ label: "BF.JournalPage.Subclass.Item" }),
			headingLevel: new NumberField({ initial: 4 }),
			description: new SchemaField$1({
				conclusion: new HTMLField({
					label: "BF.JournalPage.Class.Conclusion.Label",
					hint: "BF.JournalPage.Class.Conclusion.Hint"
				}),
				introduction: new HTMLField({
					label: "BF.JournalPage.Class.Introduction.Label",
					hint: "BF.JournalPage.Subclass.Introduction.Hint"
				})
			})
		};
	}
}

var _module$8 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ClassJournalPageData: ClassJournalPageData,
	MapLocationJournalPageData: MapLocationJournalPageData,
	RuleJournalPageData: RuleJournalPageData,
	SpellListJournalPageData: SpellListJournalPageData,
	SubclassJournalPageData: SubclassJournalPageData
});

/**
 * Categories of documents that appear in the create menu.
 */
const _documentCategories = {
	Actor: {
		person: {
			label: "BF.Actor.Category.Person",
			types: [PCData, NPCData]
		},
		place: {
			label: "BF.Actor.Category.Place",
			types: [LairData]
		},
		thing: {
			label: "BF.Actor.Category.Thing",
			types: [SiegeData, VehicleData]
		}
	},
	Item: {
		concept: {
			label: "BF.Item.Category.Concept.Label",
			types: [
				ClassData,
				SubclassData,
				LineageData,
				HeritageData,
				BackgroundData
			],
			sheet: {
				application: ConceptSheet,
				label: "BF.Sheet.Default.Concept"
			}
		},
		feature: {
			label: "BF.Item.Category.Feature.Label",
			types: [FeatureData, TalentData],
			sheet: {
				application: FeatureSheet,
				label: "BF.Sheet.Default.Feature"
			}
		},
		equipment: {
			label: "BF.Item.Category.Equipment.Label",
			types: [
				AmmunitionData,
				ArmorData,
				ConsumableData,
				ContainerData,
				GearData,
				SundryData,
				ToolData,
				WeaponData
			],
			sheet: {
				application: EquipmentSheet,
				label: "BF.Sheet.Default.Equipment"
			}
		},
		meta: {
			label: "BF.Item.Category.Meta.Label",
			types: [CurrencyData, SpellData]
		}
	},
	JournalEntryPage: {
		summaries: {
			types: [
				ClassJournalPageData,
				SubclassJournalPageData,
				MapLocationJournalPageData,
				RuleJournalPageData,
				SpellListJournalPageData
			]
		}
	}
};

var documents$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_documentCategories: _documentCategories
});

/**
 * Configuration data for skills.
 *
 * @typedef {LabeledConfiguration} SkillConfiguration
 * @property {string} abbreviation - Shortened version of the skill used for conversion from dnd5e & other features.
 * @property {string} ability - Key for the default ability used by this skill.
 * @property {string} [reference] - UUID of a journal entry with details on this ability.
 */

/**
 * The set of Skills used within the system.
 * @enum {SkillConfiguration}
 */
const skills = {
	acrobatics: {
		abbreviation: "acr",
		ability: "dexterity",
		label: "BF.Skill.Acrobatics.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.0rnx5k7zLW1jLsA3"
	},
	animalHandling: {
		abbreviation: "ani",
		ability: "wisdom",
		label: "BF.Skill.AnimalHandling.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.VCX1jEWng4DMJU7H"
	},
	arcana: {
		abbreviation: "arc",
		ability: "intelligence",
		label: "BF.Skill.Arcana.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.o5ZHVnTLZYI7rNbo"
	},
	athletics: {
		abbreviation: "ath",
		ability: "strength",
		label: "BF.Skill.Athletics.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.f4nHzzwmvXLTMtBN"
	},
	deception: {
		abbreviation: "dec",
		ability: "charisma",
		label: "BF.Skill.Deception.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.XaT2y2buV0yvDrTk"
	},
	history: {
		abbreviation: "his",
		ability: "intelligence",
		label: "BF.Skill.History.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.2aWfTWGV9hXNn852"
	},
	insight: {
		abbreviation: "ins",
		ability: "wisdom",
		label: "BF.Skill.Insight.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.MPosUcQrIt9cPpAm"
	},
	intimidation: {
		abbreviation: "itm",
		ability: "charisma",
		label: "BF.Skill.Intimidation.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.7q5pPgwleIwNsQNC"
	},
	investigation: {
		abbreviation: "inv",
		ability: "intelligence",
		label: "BF.Skill.Investigation.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.8qBuzZi49vwFhBkN"
	},
	medicine: {
		abbreviation: "med",
		ability: "wisdom",
		label: "BF.Skill.Medicine.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Y4A240Yf16dCnCVU"
	},
	nature: {
		abbreviation: "nat",
		ability: "intelligence",
		label: "BF.Skill.Nature.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.QjxD5FiLqzvOLxWu"
	},
	perception: {
		abbreviation: "prc",
		ability: "wisdom",
		label: "BF.Skill.Perception.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ZaOV2vOXwjLvA6Hu"
	},
	performance: {
		abbreviation: "prf",
		ability: "charisma",
		label: "BF.Skill.Performance.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.mmpNs1ZOLpBzesLb"
	},
	persuasion: {
		abbreviation: "per",
		ability: "charisma",
		label: "BF.Skill.Persuasion.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.yXAwGzMClEIYisik"
	},
	religion: {
		abbreviation: "rel",
		ability: "intelligence",
		label: "BF.Skill.Religion.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.nyn5Aek4FY30ucRT"
	},
	sleightOfHand: {
		abbreviation: "slt",
		ability: "dexterity",
		label: "BF.Skill.SleightOfHand.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.B3NYZiRdJrGJmQ43"
	},
	stealth: {
		abbreviation: "ste",
		ability: "dexterity",
		label: "BF.Skill.Stealth.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.P3qlI7fAxH63YDTg"
	},
	survival: {
		abbreviation: "sur",
		ability: "wisdom",
		label: "BF.Skill.Survival.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.aGBN1xZWuB48dPB9"
	}
};
localizeConfig(skills);

var skills$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	skills: skills
});

const enrichment = {};

let _enrichmentLookup;
Object.defineProperty(enrichment, "lookup", {
	get() {
		if (!_enrichmentLookup) _createEnrichmentLookup();
		return _enrichmentLookup;
	},
	enumerable: true
});

/**
 * Create the initial enrichment lookup object.
 */
function _createEnrichmentLookup() {
	const addKeys = (key, object, localization) => {
		_enrichmentLookup[key] = {};
		for (const [k, v] of Object.entries(object)) {
			_enrichmentLookup[key][slugify(k)] = _enrichmentLookup[key][slugify(v.abbreviation)] = {
				key: k,
				...v,
				label: localization[k] ?? v.label
			};
		}
	};
	const addTrait = trait$1 => {
		_enrichmentLookup[trait$1] = {};
		const choices$1 = choices(trait$1);
		for (const key of choices$1.set) {
			const config = choices$1.get(key);
			_enrichmentLookup[trait$1][slugify(key)] = { key, label: config.label };
		}
	};
	const slugify = value => value?.slugify().replaceAll("-", "");

	_enrichmentLookup = {};
	addKeys("abilities", abilities, abilities.localizedAbbreviations);
	addKeys("skills", skills, skills.localized);
	addTrait("tools");
	addTrait("vehicles");

	_enrichmentLookup.abilities.spellcasting = {
		label: game.i18n.localize("BF.Ability.Spellcasting.Label"),
		key: "spellcasting"
	};
}

var enrichers$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	enrichment: enrichment
});

/**
 * Register the system fonts with Foundry.
 * @internal
 */
function _configureFonts() {
	Object.assign(CONFIG.fontDefinitions, {
		"Open Sans": {
			editor: true,
			fonts: [
				{ urls: ["systems/black-flag/fonts/Open_Sans/Open_Sans.woff2"] },
				{ urls: ["systems/black-flag/fonts/Open_Sans/Open_Sans_i.woff2"], style: "italic" }
			]
		},
		Oswald: {
			editor: true,
			fonts: [{ urls: ["systems/black-flag/fonts/Oswald/Oswald.woff2"] }]
		}
	});
}

var fonts = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_configureFonts: _configureFonts
});

/**
 * Configuration data for sheet sections.
 *
 * @typedef {object} SheetSectionConfiguration
 * @property {string} id - ID of the section, should be unique per document type.
 * @property {string} tab - Name of the tab on which this section will appear. Places the section into an object
 *                          for that tab's name within the sheet rendering context.
 * @property {string} label - Localizable label for the section.
 * @property {FilterDescription[]} filters - Set of filters to determine which items should appear in this section.
 * @property {ExpandSheetSectionCallback} expand - Callback used to expand a single section into multiple based on data
 *                                                 in the document instance.
 * @property {CheckVisibilityCallback} [checkVisibility] - Callback used to determine whether an item should be visible.
 * @property {object[]} [create] - Data used when creating items within this section, with an optional `label`.
 * @property {object} [options]
 * @property {boolean} [options.autoHide=false] - Should this section be hidden unless it has items?
 * @property {boolean} [options.canDelete=true] - Should the delete control be exposed to the user?
 * @property {boolean} [options.canDuplicate=true] - Should the duplicate control be exposed to the user?
 * @property {string} [options.sorting] - Force a specific sorting mode on this section.
 */

/**
 * Method that expands a single section into multiple based on document's data.
 *
 * @callback ExpandSheetSectionCallback
 * @param {BlackFlagActor|BlackFlagItem} document - Document whose sheet is being rendered.
 * @param {object} sectionData - Existing data for the section being expanded.
 * @returns {object[]} - Sections that should replace the expanded section.
 */

/**
 * Method that determines whether a specific item should be visible after being sorted into a section.
 *
 * @callback CheckVisibilityCallback
 * @param {object} sectionData - Data on the section.
 * @param {BlackFlagItem} item - Item for which visibility should be checked.
 * @returns {boolean}
 */

const currencySection = () => ({
	id: "currency",
	tab: "currency",
	label: "BF.Item.Type.Currency[one]",
	filters: [{ k: "type", v: "currency" }],
	options: { sorting: "currency" }
});

/**
 * Sections that will appear on document sheets. They are arrays of objects grouped by document type.
 * @enum {SheetSectionConfiguration[]}
 */
const sheetSections = {
	pc: [
		currencySection(),
		{
			id: "circle-*",
			tab: "spellcasting",
			filters: [
				{ k: "type", v: "spell" },
				{ k: "flags.black-flag.relationship.mode", o: "in", v: ["standard", undefined] },
				{ k: "flags.black-flag.cachedFor", v: undefined },
				{ o: "NOT", v: { k: "system.tags", o: "has", v: "ritual" } }
			],
			expand: (document, sectionData) => {
				return Object.entries(CONFIG.BlackFlag.spellCircles({ plural: true })).map(([number, label]) => {
					number = Number(number);
					const cantrip = number === 0;
					const id = cantrip ? "cantrip" : `circle-${number}`;
					const slot = document.system.spellcasting.slots[id] ?? {};
					return foundry.utils.mergeObject(
						sectionData,
						{
							id,
							label,
							filters: [...sectionData.filters, { k: "system.circle.base", v: number }],
							options: { autoHide: !slot.max && !cantrip },
							slot
						},
						{ inplace: false }
					);
				});
			}
		},
		{
			id: "pact",
			tab: "spellcasting",
			label: "pact",
			filters: [
				{ k: "type", v: "spell" },
				{ k: "flags.black-flag.relationship.mode", v: "pact" },
				{ k: "flags.black-flag.cachedFor", v: undefined },
				{ o: "NOT", v: { k: "system.tags", o: "has", v: "ritual" } }
			],
			options: { autoHide: true },
			expand: (document, sectionData) => {
				sectionData.slot = document.system.spellcasting.slots.pact;
				if (sectionData.slot?.max) {
					sectionData.label = sectionData.slot.label;
					sectionData.options.autoHide = false;
				}
				return [sectionData];
			}
		},
		{
			id: "ritual",
			tab: "spellcasting",
			label: "BF.Spell.Preparation.Mode.Rituals",
			filters: [
				{ k: "type", v: "spell" },
				{ k: "system.tags", o: "has", v: "ritual" },
				{ k: "flags.black-flag.cachedFor", v: undefined }
			],
			options: { autoHide: true }
		},
		{
			id: "atWill",
			tab: "spellcasting",
			label: "BF.Spell.Preparation.Mode.AtWill",
			filters: [
				{ k: "type", v: "spell" },
				{ k: "flags.black-flag.relationship.mode", v: "atWill" },
				{ k: "flags.black-flag.cachedFor", v: undefined }
			],
			options: { autoHide: true }
		},
		{
			id: "innate",
			tab: "spellcasting",
			label: "BF.Spell.Preparation.Mode.Innate",
			filters: [
				{ k: "type", v: "spell" },
				{ k: "flags.black-flag.relationship.mode", v: "innate" },
				{ k: "flags.black-flag.cachedFor", v: undefined }
			],
			options: { autoHide: true }
		},
		{
			id: "item-spells",
			tab: "spellcasting",
			label: "BF.CAST.SECTION.Spellbook",
			filters: [
				{ k: "type", v: "spell" },
				{ o: "NOT", v: { k: "flags.black-flag.cachedFor", v: undefined } }
			],
			checkVisibility: item => item.system.linkedActivity?.displayInSpellbook ?? false,
			options: { autoHide: true, canDelete: false, canDuplicate: false }
		},
		{
			id: "weapons",
			tab: "inventory",
			label: "BF.Item.Type.Weapon[other]",
			filters: [{ k: "type", v: "weapon" }]
		},
		{
			id: "ammunition",
			tab: "inventory",
			label: "BF.Item.Type.Ammunition[other]",
			filters: [{ k: "type", v: "ammunition" }],
			options: { autoHide: true }
		},
		{
			id: "armor",
			tab: "inventory",
			label: "BF.Item.Type.Armor[other]",
			filters: [{ k: "type", v: "armor" }]
		},
		{
			id: "gear",
			tab: "inventory",
			label: "BF.Item.Type.Gear[other]",
			filters: [{ k: "type", v: "gear" }]
		},
		{
			id: "tools",
			tab: "inventory",
			label: "BF.Item.Type.Tool[other]",
			filters: [{ k: "type", v: "tool" }]
		},
		{
			id: "consumables",
			tab: "inventory",
			label: "BF.Item.Type.Consumable[other]",
			filters: [{ k: "type", v: "consumable" }]
		},
		{
			id: "containers",
			tab: "inventory",
			label: "BF.Item.Type.Container[other]",
			filters: [{ k: "type", v: "container" }]
		},
		{
			id: "sundries",
			tab: "inventory",
			label: "BF.Item.Type.Sundry[other]",
			filters: [{ k: "type", v: "sundry" }],
			options: { autoHide: true }
		},
		{
			id: "class-features",
			tab: "features",
			label: "BF.Feature.Category.Class[other]",
			filters: [
				{ k: "type", v: "feature" },
				{ k: "system.type.category", v: "class" }
			],
			expand: (document, sectionData) => {
				if (document.system.progression.level === 0) return [];
				return Object.entries(document.system.progression.classes)
					.map(([identifier, cls]) => {
						const label = pluralRule =>
							game.i18n.format(`BF.Feature.Category.ClassSpecific[${pluralRule}]`, { class: cls.document.name });
						const filters = [
							{ k: "system.identifier.associated", v: identifier },
							{ k: "flags.black-flag.ultimateOrigin", v: `${cls.document.id}.`, o: "startswith" }
						];
						if (cls.subclass)
							filters.push(
								{ k: "system.identifier.associated", v: cls.subclass.identifier },
								{ k: "flags.black-flag.ultimateOrigin", v: `${cls.subclass.id}.`, o: "startswith" }
							);
						return foundry.utils.mergeObject(
							sectionData,
							{
								id: `class-${identifier}`,
								label: label("other"),
								filters: [
									...sectionData.filters,
									{
										o: "OR",
										v: filters
									}
								],
								levels: cls.levels
							},
							{ inplace: false }
						);
					})
					.sort((lhs, rhs) => rhs.levels - lhs.levels);
			}
		},
		{
			id: "talents",
			tab: "features",
			label: "BF.Item.Type.Talent[other]",
			filters: [{ k: "type", v: "talent" }]
		},
		{
			id: "lineage-features",
			tab: "features",
			label: "BF.Feature.Category.Lineage[other]",
			filters: [
				{ k: "type", v: "feature" },
				{ k: "system.type.category", v: "lineage" }
			]
		},
		{
			id: "heritage-features",
			tab: "features",
			label: "BF.Feature.Category.Heritage[other]",
			filters: [
				{ k: "type", v: "feature" },
				{ k: "system.type.category", v: "heritage" }
			]
		},
		{
			id: "features",
			tab: "features",
			label: "BF.Item.Category.Feature.Label",
			filters: [{ k: "type", v: "feature" }],
			options: { autoHide: true }
		},
		{
			id: "progression",
			tab: "progression",
			filters: [{ k: "type", o: "in", v: ["class", "subclass", "background", "heritage", "lineage"] }]
		}
	],
	npc: [
		currencySection(),
		{
			id: "features",
			tab: "features",
			label: "BF.Item.Category.Feature.Label",
			filters: [{ k: "type", o: "in", v: ["feature", "talent"] }]
		},
		{
			id: "equipment",
			tab: "features",
			label: "BF.Item.Category.Equipment.Label",
			filters: [{ k: "type", o: "in", v: ["ammunition", "armor", "gear", "tool", "weapon"] }]
		},
		{
			id: "spells",
			tab: "features",
			label: "BF.Item.Type.Spell[other]",
			filters: [{ k: "type", v: "spell" }],
			options: { autoHide: true }
		},
		{
			id: "sundries",
			tab: "features",
			label: "BF.Item.Type.Sundry[other]",
			filters: [{ k: "type", o: "in", v: ["consumable", "sundry"] }],
			options: { autoHide: true }
		}
	],
	lair: [
		{
			id: "lairActions",
			tab: "features",
			filters: [
				{ k: "type", v: "feature" },
				{ k: "system.type.value", v: "lairAction" }
			]
		},
		{
			id: "regionalEffects",
			tab: "features",
			filters: [
				{ k: "type", v: "feature" },
				{ k: "system.type.value", v: "regionalEffect" }
			]
		}
	],
	siege: [
		{
			id: "features",
			tab: "features",
			label: "BF.Item.Category.Feature.Label",
			filters: []
		}
	],
	vehicle: [
		currencySection(),
		{
			id: "features",
			tab: "features",
			label: "BF.Item.Category.Feature.Label",
			filters: [{ k: "type", o: "in", v: ["feature"] }]
		},
		{
			id: "equipment",
			tab: "features",
			label: "BF.Item.Category.Equipment.Label",
			filters: [{ k: "type", o: "in", v: ["ammunition", "weapon"] }]
		},
		{
			id: "cargo",
			tab: "features",
			label: "BF.VEHICLE.FIELDS.attributes.cargo.label",
			filters: [{ k: "type", o: "in", v: ["armor", "consumable", "gear", "sundry", "tool"] }],
			options: { autoHide: true }
		}
	],
	container: [
		currencySection(),
		{
			id: "contents",
			tab: "inventory",
			label: "BF.Sheet.Tab.Contents",
			filters: [
				{
					k: "type",
					o: "in",
					v: ["ammunition", "armor", "consumable", "container", "gear", "tool", "sundry", "weapon"]
				}
			]
		}
	]
};

var inventory = /*#__PURE__*/Object.freeze({
	__proto__: null,
	sheetSections: sheetSections
});

/**
 * Categories of consumable items.
 * @enum {NestedTypeConfiguration}
 */
const consumableCategories = {
	food: {
		localization: "BF.Item.Consumable.Category.Food"
	},
	poison: {
		localization: "BF.Item.Consumable.Category.Poison",
		children: {
			contact: {
				localization: "BF.Item.Poison.Type.Contact"
			},
			ingested: {
				localization: "BF.Item.Poison.Type.Ingested"
			},
			inhaled: {
				localization: "BF.Item.Poison.Type.Inhaled"
			},
			injury: {
				localization: "BF.Item.Poison.Type.Injury"
			}
		}
	},
	potion: {
		localization: "BF.Item.Consumable.Category.Potion"
	},
	scroll: {
		localization: "BF.Item.Consumable.Category.Scroll"
	}
};
localizeConfig(consumableCategories);
localizeConfig(consumableCategories.poison.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Properties that can be applied to consumables.
 * @type {string[]}
 */
const consumableProperties = ["magical"];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {NestedTypeConfiguration} FeatureCategoryConfiguration
 * @property {number|false} [level] - Fixed level at which this feature will be gained.
 * @property {string[]} [sources] - If set, source identifier from these categories will be listed.
 * @property {Record<string, FeatureCategoryConfiguration>} [children] - Nested children.
 */

/**
 * Classifications of feature items (e.g. Class Feature, Heritage Trait) and any types available within that
 * category (e.g. Channel Divinity, Martial Action).
 * @enum {NestedTypeConfiguration}
 */
const featureCategories = {
	class: {
		localization: "BF.Feature.Category.Class",
		sources: ["class", "subclass"],
		children: {
			animalFocus: {
				localization: "BF.Feature.Type.AnimalFocus",
				level: false
			},
			augmentEffect: {
				localization: "BF.Feature.Type.AugmentEffect",
				level: false,
				sources: ["class", "subclass"]
			},
			bardicPerformance: {
				localization: "BF.Feature.Type.BardicPerformance",
				sources: ["class", "subclass"]
			},
			channelDivinity: {
				localization: "BF.Feature.Type.ChannelDivinity",
				sources: ["class", "subclass"]
			},
			dragonAncestor: {
				localization: "BF.Feature.Type.DragonAncestor",
				level: false
			},
			enhancedBoon: {
				localization: "BF.Feature.Type.EnhancedBoon",
				level: false
			},
			eldritchInvocation: {
				localization: "BF.Feature.Type.EldritchInvocation",
				level: false
			},
			elementalInfusion: {
				localization: "BF.Feature.Type.ElementalInfusion"
			},
			empoweredRage: {
				localization: "BF.Feature.Type.EmpoweredRage",
				level: false
			},
			epicBoon: {
				localization: "BF.Feature.Type.EpicBoon",
				level: 20,
				sources: ["class"]
			},
			heroicBoon: {
				localization: "BF.Feature.Type.HeroicBoon",
				level: 10,
				sources: ["class"]
			},
			martialAction: {
				localization: "BF.Feature.Type.MartialAction"
			},
			metamagicOption: {
				localization: "BF.Feature.Type.MetamagicOption"
			},
			pactBoon: {
				localization: "BF.Feature.Type.PactBoon",
				level: false
			},
			primalAspect: {
				localization: "BF.Feature.Type.PrimalAspect",
				level: false
			},
			stunt: {
				localization: "BF.Feature.Type.Stunt"
			},
			technique: {
				localization: "BF.Feature.Type.Technique"
			},
			wildShape: {
				localization: "BF.Feature.Type.WildShape",
				sources: ["class", "subclass"]
			}
		}
	},
	lineage: {
		localization: "BF.Feature.Category.Lineage",
		sources: ["lineage"],
		children: {
			naturalAdaptation: {
				localization: "BF.Feature.Type.NaturalAdaptation"
			}
		}
	},
	heritage: {
		localization: "BF.Feature.Category.Heritage",
		sources: ["heritage"]
	},
	monsters: {
		localization: "BF.Feature.Category.Monster",
		children: {
			lairAction: {
				localization: "BF.Feature.Type.LairAction"
			},
			regionalEffect: {
				localization: "BF.Feature.Type.RegionalEffect"
			}
		}
	},
	talent: {
		localization: "BF.Feature.Category.Talent"
	},
	vehicle: {
		localization: "BF.Feature.Category.Vehicle"
	}
};
localizeConfig(featureCategories, { sort: false });
localizeConfig(featureCategories.class.children);
localizeConfig(featureCategories.lineage.children);
localizeConfig(featureCategories.monsters.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

const clothingTypes = {
	amulet: {
		localization: "BF.Item.Clothing.Type.Amulet"
	},
	belt: {
		localization: "BF.Item.Clothing.Type.Belt"
	},
	boots: {
		localization: "BF.Item.Clothing.Type.Boots"
	},
	cloak: {
		localization: "BF.Item.Clothing.Type.Cloak"
	},
	glasses: {
		localization: "BF.Item.Clothing.Type.Glasses"
	},
	gloves: {
		localization: "BF.Item.Clothing.Type.Gloves"
	},
	helm: {
		localization: "BF.Item.Clothing.Type.Helm"
	},
	ring: {
		localization: "BF.Item.Clothing.Type.Ring"
	}
};

/**
 * Categories of gear items.
 * @enum {NestedTypeConfiguration}
 */
const gearCategories = {
	adventuringGear: {
		localization: "BF.Item.Gear.Category.AdventuringGear",
		children: {
			...clothingTypes,
			focus: {
				localization: "BF.Item.Gear.Category.Focus"
			}
		}
	},
	rod: {
		localization: "BF.Item.Gear.Category.Rod"
	},
	wand: {
		localization: "BF.Item.Gear.Category.Wand"
	},
	wondrousItem: {
		localization: "BF.Item.Gear.Category.WondrousItem",
		children: { ...clothingTypes }
	}
};
localizeConfig(gearCategories);
localizeConfig(gearCategories.adventuringGear.children);
localizeConfig(gearCategories.wondrousItem.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Properties that can be applied to gear.
 * @type {string[]}
 */
const gearProperties = ["magical"];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {LabeledConfiguration} ItemPropertyConfiguration
 * @property {string} [reference] - Reference to a rules journal entry page describing this property.
 * @property {string} [rules] - Rules setting category that allows these options to be toggled by GM.
 */

/**
 * Properties that can be applied to weapons.
 * @enum {LabeledConfiguration}
 */
const itemProperties = {
	// Shared
	magical: {
		label: "BF.Item.Property.Magical.Label"
	},
	special: {
		label: "BF.Item.Property.Special.Label"
	},

	// Armor
	cumbersome: {
		label: "BF.Armor.Property.Cumbersome",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.520mFFl9c7MsE3X5"
	},
	naturalMaterials: {
		label: "BF.Armor.Property.NaturalMaterials",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.DgadUc3PINhgxqT7"
	},
	noisy: {
		label: "BF.Armor.Property.Noisy",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.fbvoFGjhh0fwqVxI"
	},

	// Container
	weightlessContents: {
		label: "BF.Container.Property.WeightlessContents.Label"
	},

	// Weapon
	ammunition: {
		label: "BF.WEAPON.Property.Ammunition",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.hEqdEZpofvIVhZbV"
	},
	finesse: {
		label: "BF.WEAPON.Property.Finesse",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Nwe1EXlZHGBrNOGD"
	},
	gunpowder: {
		label: "BF.WEAPON.Property.Gunpowder",
		rules: "firearms"
	},
	heavy: {
		label: "BF.WEAPON.Property.Heavy",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.06OJCIgMWhfAWfi6"
	},
	light: {
		label: "BF.WEAPON.Property.Light",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.AjLCb6Qp0btCuzv1"
	},
	loading: {
		label: "BF.WEAPON.Property.Loading",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.6T8MmG97dLpEOv36"
	},
	magazine: {
		label: "BF.WEAPON.Property.Magazine",
		rules: "firearms"
	},
	reach: {
		label: "BF.WEAPON.Property.Reach",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.IqJ491vX9cgfBC4a"
	},
	thrown: {
		label: "BF.WEAPON.Property.Thrown",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.nlNCYugyCLULTc55"
	},
	twoHanded: {
		label: "BF.WEAPON.Property.TwoHanded",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ncge72BaBpqk68V0"
	},
	versatile: {
		label: "BF.WEAPON.Property.Versatile",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.iuDmrgxZEnH5bQF0"
	}
};
localizeConfig(itemProperties);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Categories of talent items.
 * @enum {LocalizedConfiguration}
 */
const talentCategories = {
	magic: {
		localization: "BF.Feature.Talent.Category.Magic",
		description: "BF.Feature.Talent.Category.MagicDescription"
	},
	martial: {
		localization: "BF.Feature.Talent.Category.Martial",
		description: "BF.Feature.Talent.Category.MartialDescription"
	},
	technical: {
		localization: "BF.Feature.Talent.Category.Technical",
		description: "BF.Feature.Talent.Category.TechnicalDescription"
	}
};
localizeConfig(talentCategories);
localizeConfig(talentCategories, { propertyName: "localizedPlural", pluralRule: "other" });
localizeConfig(talentCategories, { labelKeyPath: "description", propertyName: "localizedDescription" });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Rarities of magic items.
 * @enum {object}
 */
const rarities = {
	common: {
		label: "BF.Rarity.Level.Common"
	},
	uncommon: {
		label: "BF.Rarity.Level.Uncommon"
	},
	rare: {
		label: "BF.Rarity.Level.Rare"
	},
	veryRare: {
		label: "BF.Rarity.Level.VeryRare"
	},
	legendary: {
		label: "BF.Rarity.Level.Legendary"
	},
	fabled: {
		label: "BF.Rarity.Level.Fabled"
	},
	artifact: {
		label: "BF.Rarity.Level.Artifact"
	}
};
localizeConfig(rarities);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Categories of sundry items.
 * @enum {LocalizedConfiguration}
 */
const sundryCategories = {
	clothing: {
		localization: "BF.Item.Sundry.Category.Clothing"
	},
	component: {
		localization: "BF.Item.Sundry.Category.Component"
	},
	tradeGood: {
		localization: "BF.Item.Sundry.Category.TradeGood"
	},
	treasure: {
		localization: "BF.Item.Sundry.Category.Treasure"
	},
	trinket: {
		localization: "BF.Item.Sundry.Category.Trinket"
	}
};
localizeConfig(sundryCategories);

var items = /*#__PURE__*/Object.freeze({
	__proto__: null,
	consumableCategories: consumableCategories,
	consumableProperties: consumableProperties,
	featureCategories: featureCategories,
	gearCategories: gearCategories,
	gearProperties: gearProperties,
	itemProperties: itemProperties,
	rarities: rarities,
	sundryCategories: sundryCategories,
	talentCategories: talentCategories
});

/**
 * Types of modifiers that can be created.
 * @enum {object}
 */
const modifierTypes = {
	bonus: {
		localization: "BF.Bonus.Label"
	},
	min: {
		localization: "BF.Minimum.Label"
	},
	note: {
		localization: "BF.Note.Label"
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for roll notes that are added automatically with status effects.
 *
 * @typedef {object} StatusEffectNoteConfiguration
 * @property {FilterDescription[]} filter - Filter used to limit when this modifier is used.
 * @property {number} [rollMode=0] - Roll mode that should be applied.
 * @property {string} text - Localizable text for the roll note.
 * @property {number} [level] - For exhaustion, what level is required to apply this note.
 */

const strDexNote = {
	filter: [
		{ k: "type", v: "ability-save" },
		{ k: "ability", o: "in", v: ["strength", "dexterity"] }
	]
};

/**
 * Roll notes that are added automatically for certain status effects.
 * @type {Record<string, StatusEffectNoteConfiguration[]>}
 */
const statusEffectRollNotes = {
	blinded: [
		{ filter: [{ k: "type", v: "ability-check" }], text: "BF.Condition.Blinded.NoteAbilityChecks" },
		{ filter: [{ k: "type", v: "attack" }], rollMode: -1, text: "BF.Condition.Blinded.NoteAttackRolls" }
	],
	deafened: [{ filter: [{ k: "type", v: "ability-check" }], text: "BF.Condition.Deafened.Note" }],
	exhaustion: [
		{
			filter: [{ k: "type", v: "ability-check" }],
			rollMode: -1,
			text: "BF.Condition.Exhaustion.NoteAbilityChecks",
			level: 1
		},
		{
			filter: [{ k: "type", o: "in", v: ["ability-save", "attack"] }],
			rollMode: -1,
			text: "BF.Condition.Exhaustion.NoteAttackRollsSaves",
			level: 3
		}
	],
	frightened: [
		{
			filter: [{ k: "type", o: "in", v: ["ability-check", "attack"] }],
			rollMode: -1,
			text: "BF.Condition.Frightened.Note"
		}
	],
	invisible: [
		{
			filter: [
				{ k: "type", v: "skill-check" },
				{ k: "skill", v: "stealth" },
				{ k: "ability", v: "dexterity" }
			],
			rollMode: 1,
			text: "BF.Condition.Invisible.Note"
		}
	],
	paralyzed: [{ ...strDexNote, text: "BF.Condition.Paralyzed.Note" }],
	petrified: [{ ...strDexNote, text: "BF.Condition.Petrified.Note" }],
	poisoned: [
		{
			filter: [{ k: "type", o: "in", v: ["ability-check", "attack"] }],
			rollMode: -1,
			text: "BF.Condition.Poisoned.Note"
		}
	],
	prone: [{ filter: [{ k: "type", v: "attack" }], rollMode: -1, text: "BF.Condition.Prone.Note" }],
	restrained: [
		{
			filter: [
				{
					o: "OR",
					v: [
						{ k: "type", v: "attack" },
						{
							o: "AND",
							v: [
								{ k: "type", v: "ability-save" },
								{ k: "ability", v: "dexterity" }
							]
						}
					]
				}
			],
			rollMode: -1,
			text: "BF.Condition.Restrained.Note"
		}
	],
	stunned: [{ ...strDexNote, text: "BF.Condition.Stunned.Note" }],
	unconscious: [{ ...strDexNote, text: "BF.Condition.Unconscious.Note" }]
};

var modifiers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	modifierTypes: modifierTypes,
	statusEffectRollNotes: statusEffectRollNotes
});

/**
 * Notification levels that can be displayed on sheets.
 * @enum {{symbol: string}}
 */
const notificationLevels = {
	info: {
		symbol: "fa-solid fa-info"
	},
	warn: {
		symbol: "fa-solid fa-exclamation"
	},
	error: {
		symbol: "fa-solid fa-xmark"
	}
};

var notifications = /*#__PURE__*/Object.freeze({
	__proto__: null,
	notificationLevels: notificationLevels
});

/**
 * Perform compendium redirects from premium content UUIDs to BFRD UUIDs if content isn't enabled.
 */
function _configureRedirects() {
	for (const [id, map] of Object.entries(mappings)) {
		if (game.modules.get(id)?.active) continue;
		Object.assign(CONFIG.compendium.uuidRedirects, map);
	}
}

const mappings = {
	"kp-tov-monster-vault": {
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.rjTvRRXk5fYm7I2A":
			"Compendium.black-flag.npcs.Actor.0HVNfNw8FH86Okt2",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.enOvZ0mSQM9wof8C":
			"Compendium.black-flag.npcs.Actor.0JZiKg6CAIMLtZH8",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.bTEmBJqxeUIVPuo3":
			"Compendium.black-flag.npcs.Actor.0K5CxUDUiujeakgk",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Dbpd9MMe1OaMZmTf":
			"Compendium.black-flag.npcs.Actor.0Mg4V0kejtIaabNH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.tlUZfdwZ6hAehA28":
			"Compendium.black-flag.npcs.Actor.0V3Lr3QRumobWHx0",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ZcHoYyg5pRSMQTQn":
			"Compendium.black-flag.npcs.Actor.17IBYn92WaO4cpZV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.VjOYBpVmVIGXBrYG":
			"Compendium.black-flag.npcs.Actor.18raGcNxoTnhNR4e",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.zf4FJXjcJAmdwj6D":
			"Compendium.black-flag.npcs.Actor.1DE36RiFP9m36ArE",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.gquf11NznYRqOGsH":
			"Compendium.black-flag.npcs.Actor.1G7XY0ZB4uyZ3nmq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.dmhQoMojRRfBqC5u":
			"Compendium.black-flag.npcs.Actor.1yxIUY2PhIB0JL6F",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.xzNkh19gS47k8afx":
			"Compendium.black-flag.npcs.Actor.258vx22WFSTFOm89",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.eEAXziz8XtFZ3nzF":
			"Compendium.black-flag.npcs.Actor.2DCblylWLteSqQ07",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.WsRWRaPKfLxqEoPF":
			"Compendium.black-flag.npcs.Actor.2Uyw9ZrqRJur5bwE",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.OqxTARVO2L9pnp8E":
			"Compendium.black-flag.npcs.Actor.2fm38cdINKCumyVe",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.5vnQLJvpGCK6Xd3G":
			"Compendium.black-flag.npcs.Actor.2jjHoh5gIkTX9UJh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.qL9i20vF4fhV0HEX":
			"Compendium.black-flag.npcs.Actor.2kfljh07dG03TyFw",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.IrCppwl32Eh1x3eB":
			"Compendium.black-flag.npcs.Actor.30cQKcGgU756PTGc",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.wSdGAr8dgNapGEy0":
			"Compendium.black-flag.npcs.Actor.38E3bpoPnOg2DVJg",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ha3bnaIj7LunHO3k":
			"Compendium.black-flag.npcs.Actor.3OZjOK8mayQUCVGq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.40kqb3AQkrtccwLS":
			"Compendium.black-flag.npcs.Actor.3TQoqyumjGWMNY8A",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ITN3FquhYychsRtp":
			"Compendium.black-flag.npcs.Actor.3kWX8wTv3jSx6Eip",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.f0ChPe9ka5Oj527N":
			"Compendium.black-flag.npcs.Actor.3pxse6nO7eDOzBcW",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.fIIoyvy7gfJ5RkGo":
			"Compendium.black-flag.npcs.Actor.42AgwMUryk85tzJH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.g6jt98ZIbZYHkCkH":
			"Compendium.black-flag.npcs.Actor.44drnXUj8btZkBGo",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.xM3mRZBcUVAgBkPh":
			"Compendium.black-flag.npcs.Actor.4CrFraJ1x2kGXq8m",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.M924d7xV1m3yfY1B":
			"Compendium.black-flag.npcs.Actor.4NUA3TSPsgFOuw9u",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.IJdyJCqfn6aI505u":
			"Compendium.black-flag.npcs.Actor.4PpHHnBivDwDPaSG",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.7e3SS1Mjoapo1mcN":
			"Compendium.black-flag.npcs.Actor.4Qkpm6O4vpdLLHUr",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KzY2NPwgBCezJzzk":
			"Compendium.black-flag.npcs.Actor.50j1gqWnNtKO7X0d",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.vkhLYJsFYo5eUmei":
			"Compendium.black-flag.npcs.Actor.6KZkDgmaA18V8VQa",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.lOWajmXJhPGe2Lh5":
			"Compendium.black-flag.npcs.Actor.6O7aWmTPxvS8onm6",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.pEygHFdyqtSneUEf":
			"Compendium.black-flag.npcs.Actor.6W5ONcmLafNXxgp1",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.tjiu1CY6XEBIYF4a":
			"Compendium.black-flag.npcs.Actor.6aHtiu1tmyE9zRkJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.T6Y9t1QIhVkuF3bq":
			"Compendium.black-flag.npcs.Actor.6iYSh1A8TVKlGH7D",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.OTlZsWBqV6F2L1zU":
			"Compendium.black-flag.npcs.Actor.6pw2lqbPkMvsrPOK",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.SOAK3SDQ3c7MsSIM":
			"Compendium.black-flag.npcs.Actor.720AD4nxM0Gc6OYk",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.QEkn4dWZyNdKZ8HA":
			"Compendium.black-flag.npcs.Actor.7DTd6bSfeGM62mkz",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.aRW9QRVHO3YrEmyo":
			"Compendium.black-flag.npcs.Actor.7VfZiocWIMOANfjs",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sEozPuP4TJCeQUd8":
			"Compendium.black-flag.npcs.Actor.7VmFAXDknLqyUSQH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.M9SO7NuHcRo7MIoI":
			"Compendium.black-flag.npcs.Actor.7iAgwX9bFGLZSwhf",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.1lE2yWVl8kpG2f0G":
			"Compendium.black-flag.npcs.Actor.7o3c60QL0eOzwgbw",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.vWKlM4EMHEdnCeuD":
			"Compendium.black-flag.npcs.Actor.7ug5ZKvOZ6YrRxUJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.6gpJXdD0yisigJHl":
			"Compendium.black-flag.npcs.Actor.8ZGw45FNU52DyRyf",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Mwhkv4yinQUCG3Ly":
			"Compendium.black-flag.npcs.Actor.90gAvpMg83KhqRdh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HSZcrK1zHXlSQV25":
			"Compendium.black-flag.npcs.Actor.99a2Tu4HoGWQT7cQ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.88mj0DVWeZNbpcdx":
			"Compendium.black-flag.npcs.Actor.9MiXuSE9adOdqXSh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.eFwwMKxLYn9d2wQ1":
			"Compendium.black-flag.npcs.Actor.9i7BxxS2qSNRAoFU",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HKMbXJBhJwyTM3yC":
			"Compendium.black-flag.npcs.Actor.9lP9jFwc6Ib2XcKv",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.S3T9ofMkM1h8CG4E":
			"Compendium.black-flag.npcs.Actor.AA2C6GyHE5bJ9IQb",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KxVVm8AwJ0yc8ajg":
			"Compendium.black-flag.npcs.Actor.AVUy5QORsFknY1cl",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.phz06mVnAbtiArlc":
			"Compendium.black-flag.npcs.Actor.Ab3rAgIxsyfZi3Bw",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.TW6wjoCey2SYQouC":
			"Compendium.black-flag.npcs.Actor.AbtSnvjVHTDzZciV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.tyALSoc25e5GDDQD":
			"Compendium.black-flag.npcs.Actor.Ae67uuF7mBe8NGDN",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.DKAEalKU31jRB9d1":
			"Compendium.black-flag.npcs.Actor.AhQGKYIaDvfyO09q",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9Wq3qyFB3H8wYFB2":
			"Compendium.black-flag.npcs.Actor.Al2A3NEedXjtvwb6",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.t75FujoFBxZyrqms":
			"Compendium.black-flag.npcs.Actor.AqapgXTjbGNI08sZ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.pMKupJjIGbSNLSuy":
			"Compendium.black-flag.npcs.Actor.AvBMFHvsEuWp70t6",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.MzKEuWIUSKUY64Mr":
			"Compendium.black-flag.npcs.Actor.BKeSIam1C0mXCW3s",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.p421h7yYH3XgDtTc":
			"Compendium.black-flag.npcs.Actor.BLi3PwiKwa4TVWVB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0yzHkdrMED9Ms2dr":
			"Compendium.black-flag.npcs.Actor.BMQmretRxYzJOeeV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sGR4gEstTMNswYI1":
			"Compendium.black-flag.npcs.Actor.BZwfOqKD0mlStI12",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HnIUbzUEVqnKZmZI":
			"Compendium.black-flag.npcs.Actor.Bhgv9Dgx4oMv7noH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.tI6lREz0xXbwpLuv":
			"Compendium.black-flag.npcs.Actor.Byks5SnzyZS2lLM9",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.gVTpUJU70liiZEtO":
			"Compendium.black-flag.npcs.Actor.C8poa43FQVz7g733",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.2xBI2p3EmzFpGfBN":
			"Compendium.black-flag.npcs.Actor.CHhj6Dc9MioKZUW0",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.NDt1OGqBETnpgjDI":
			"Compendium.black-flag.npcs.Actor.CXZYL33DFVG6GJwL",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.MWTaF42tj3dC1s6w":
			"Compendium.black-flag.npcs.Actor.CaJnEjsHWu9hgyKK",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HIiZ71cuP8yl8liN":
			"Compendium.black-flag.npcs.Actor.Cdi71IHxNif3sV33",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jmCstjvQ7Q1iRpz6":
			"Compendium.black-flag.npcs.Actor.CesKpbFPrfkosm60",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.wW7gKs3U0L4m481U":
			"Compendium.black-flag.npcs.Actor.D57uCaeuo8hdTWAj",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.XpMqpcy2K70mImav":
			"Compendium.black-flag.npcs.Actor.DIozpmms6n4Oy2Lj",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.msTA8dZH1kDkIXYj":
			"Compendium.black-flag.npcs.Actor.DUp2nkLdBa11964x",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.hmhQZ76sYww1aYv4":
			"Compendium.black-flag.npcs.Actor.DbHnyqTe1SirbX1n",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9XDtfO9S4bbOuMIi":
			"Compendium.black-flag.npcs.Actor.Doo3kyUey8pTbY8K",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.A3qsz8JPCNORRTOV":
			"Compendium.black-flag.npcs.Actor.DsBUbp4BWMKUJeJF",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.8lEOr7TCGjtUhWgg":
			"Compendium.black-flag.npcs.Actor.DwmqCxwUGgJVxj30",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.GO3NKnF4hQheioLX":
			"Compendium.black-flag.npcs.Actor.E1xyqyeEeOjxQfDd",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nw4fBZPwgqOlwrki":
			"Compendium.black-flag.npcs.Actor.E2GtLSyUX3zyv1iK",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sDUb240K87nZTU1r":
			"Compendium.black-flag.npcs.Actor.E7WUOZSTtaXlxpzg",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HxlDiBpVKrxWilzR":
			"Compendium.black-flag.npcs.Actor.E91VqMOUotcixlqp",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.JfsobFzqn7vjZsj9":
			"Compendium.black-flag.npcs.Actor.EL4NK2bZqTV0erXC",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KVwo05T2GM49miil":
			"Compendium.black-flag.npcs.Actor.ELOJUXJGpMxWSxdh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.PO2VE1GIACd0xXXx":
			"Compendium.black-flag.npcs.Actor.EMVh5u9dhoOw0cjR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.6lorRKK9WK4yvUvq":
			"Compendium.black-flag.npcs.Actor.EPPs9D9dOiv1aMvP",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.7QqOyvzwPshbqxqc":
			"Compendium.black-flag.npcs.Actor.EoPZ2R8diSblHcq5",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.VIkJBidKobuQsRHG":
			"Compendium.black-flag.npcs.Actor.Eq0kPFHAIxVCsRHO",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nxHYOXqaPKuTDSng":
			"Compendium.black-flag.npcs.Actor.EuzLTBHGHkXp4uEI",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Hjt32yTa8tOAHm8K":
			"Compendium.black-flag.npcs.Actor.F5iAJEkQmX1oCW8z",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.hlBRzzdJYaZJXwfi":
			"Compendium.black-flag.npcs.Actor.F83TtnzrjXEXQ3N7",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.qO24WxfI7zPqFif8":
			"Compendium.black-flag.npcs.Actor.FDxN3ZFZFK1TzVjx",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.bjUNPVfA8uSOyJIl":
			"Compendium.black-flag.npcs.Actor.FFzAbPY1xZBZ9i7V",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.YqsZ4mit5Q8SP0CY":
			"Compendium.black-flag.npcs.Actor.FIdfBlHC564JtPUH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.yesCrSp5RrWc1ol9":
			"Compendium.black-flag.npcs.Actor.FN3IwIUVWKkhhiF4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.izTZNcFeJYRyKsd1":
			"Compendium.black-flag.npcs.Actor.FSgYGI4PWAYSea0n",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.awgUbS5Rc7UJ0sjy":
			"Compendium.black-flag.npcs.Actor.FZJ6y3tsNnZ6wjFs",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jMFFEgCAoGOxGwFc":
			"Compendium.black-flag.npcs.Actor.FlG5TBMwT6On5d36",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.uK69K7ZqOCGXNxQh":
			"Compendium.black-flag.npcs.Actor.FoI9Kwk09xJJ8TJq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.WihiQ04O60XZHXSJ":
			"Compendium.black-flag.npcs.Actor.Fq8H09xuu7otAUpn",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.4gDQrjsCbcjQCkXr":
			"Compendium.black-flag.npcs.Actor.FuwI4sYfUqwJUCLZ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.5h0hMglnNjaN4Wip":
			"Compendium.black-flag.npcs.Actor.GCLXU9huKDU164WF",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.8JIKtp17DUjJCJOd":
			"Compendium.black-flag.npcs.Actor.GNVzrdU7XykGzIXW",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.rDZOboA3YcHaHmDE":
			"Compendium.black-flag.npcs.Actor.GTo6rb03cdWAZ4lh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.4x95UhZYanzOQBIm":
			"Compendium.black-flag.npcs.Actor.H6pAKPnTrxJfFJhi",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ilvok2j4Ys7zjeS5":
			"Compendium.black-flag.npcs.Actor.HM8lzmU017IEKutE",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.OnaHbel8cLmycIvw":
			"Compendium.black-flag.npcs.Actor.HQ2jkq8ZZacZwF03",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Teim2Uc5FaEmTF93":
			"Compendium.black-flag.npcs.Actor.HjLzNvpWvHANVJT0",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jvgfL1KwSHTsigT2":
			"Compendium.black-flag.npcs.Actor.HuCHKme4WginEBvZ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.yGbSstgBhBy006mV":
			"Compendium.black-flag.npcs.Actor.HygHNXNR3ltqfGCU",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ZmLZvoJTIGM7ztVU":
			"Compendium.black-flag.npcs.Actor.IM118pSBKG93TdCT",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.JRZWv6AegnprZ1n4":
			"Compendium.black-flag.npcs.Actor.IN6xQ0eaTEGbzbjC",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.AVx4QzLcbr0ikcii":
			"Compendium.black-flag.npcs.Actor.INFGYVVuVhDKEL0g",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.uOJNVscBK4rEzyoD":
			"Compendium.black-flag.npcs.Actor.IQutgcAWWYUWePKs",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HgHLXqcGnd07lvqu":
			"Compendium.black-flag.npcs.Actor.ISXBZMqeLNEI8zmd",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jJMX1iTWir0epaFB":
			"Compendium.black-flag.npcs.Actor.ITGAkxRlWepJr2gF",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ByLHmInyBC5Y74j0":
			"Compendium.black-flag.npcs.Actor.ImTx2hN7pQqGK6fe",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.yFHKLNBBGMjmg20E":
			"Compendium.black-flag.npcs.Actor.Imfc7AYR6TCzVgRl",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.g3e8e7V5BooXSeLo":
			"Compendium.black-flag.npcs.Actor.IsiIz1yjC3Xg29a4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9vzDWLJejIJtqsAY":
			"Compendium.black-flag.npcs.Actor.Iw4X0SJiYqWIiyy8",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UDoyS1CNcX67kPS1":
			"Compendium.black-flag.npcs.Actor.J4EWVKO4Egps6OtA",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UAzDdV1wnxtpgs0C":
			"Compendium.black-flag.npcs.Actor.JDgmzjnGH4W18u3m",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0crdJs3BeDniYEx7":
			"Compendium.black-flag.npcs.Actor.JHttBWIKfW7bFVtr",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.dVDhW2kPhuwl5eNP":
			"Compendium.black-flag.npcs.Actor.JKa19JUYxYjD4Tlz",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.VUl8Zv3IDxOSNN1M":
			"Compendium.black-flag.npcs.Actor.JX1vSza5sipBjUjf",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KDER5KdHroXML5GM":
			"Compendium.black-flag.npcs.Actor.JqdJE9zO1l4PjIgy",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jsKtEtawemj2arci":
			"Compendium.black-flag.npcs.Actor.JxE7IcBM4pJ6sdtY",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.wHHp6MwZElxaq0E5":
			"Compendium.black-flag.npcs.Actor.KyVY9u2LePlCcKDB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.BFZstHfi0baxmNx6":
			"Compendium.black-flag.npcs.Actor.LOgvRwKo3B5hXJSO",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.VQgAOB22p4l3p8tA":
			"Compendium.black-flag.npcs.Actor.M0bMYGaNEtdZQDxn",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.erXy8Tk2DQex25qP":
			"Compendium.black-flag.npcs.Actor.M7mHEq10RcVxYE9V",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Gih40JXfrR4kVoUr":
			"Compendium.black-flag.npcs.Actor.MB5q0gp40gptuY8K",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.r0YD5ZaQ22mUZCeN":
			"Compendium.black-flag.npcs.Actor.MF5NbhwjTV9b2dLB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ueDCdXsSa5jnyMRL":
			"Compendium.black-flag.npcs.Actor.MFiYHnCH5sJ1TMF9",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.CAiVOyUyEIy0rlxA":
			"Compendium.black-flag.npcs.Actor.MYH6C4WPx2UGzfm2",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.poMqcjy3rSLKMpTB":
			"Compendium.black-flag.npcs.Actor.MpMQ6Lo7389vbsbj",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.mUJ8Gx2175qhYaPN":
			"Compendium.black-flag.npcs.Actor.N1mEqhOK8oUD5XG3",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.FhbLe9O9nLMlhF22":
			"Compendium.black-flag.npcs.Actor.NC9LxARgmk2dFhS9",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.QpdjRtFpLswyGKik":
			"Compendium.black-flag.npcs.Actor.NDPrxKEbOwhpsm7t",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.S2uh3aoIAlQ1kjRi":
			"Compendium.black-flag.npcs.Actor.NKLtUM2Rp6LfHico",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.v5UX9VNwR5y1mJmo":
			"Compendium.black-flag.npcs.Actor.NLA3F4q9rFf8w9DN",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Goc4MfKzLtZr7Man":
			"Compendium.black-flag.npcs.Actor.NLKyXyyesFlraxWi",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.h9tksLn9pLljeoob":
			"Compendium.black-flag.npcs.Actor.NRhGNRfvqJrX30id",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.mEIsQBDOeEafi5Kc":
			"Compendium.black-flag.npcs.Actor.NS7UISvgtmDOQ9MI",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.h7zIE6bw8LN2NHxC":
			"Compendium.black-flag.npcs.Actor.NSwzdwp77mjlTHlD",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Pyxadmt6v553oLyh":
			"Compendium.black-flag.npcs.Actor.NbKK3JoT3U4yVgXX",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.qV6VRRvP0IceKudI":
			"Compendium.black-flag.npcs.Actor.Nd0vbYlEDsYMJSk2",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.CkirAVXYhCqLuDi9":
			"Compendium.black-flag.npcs.Actor.NrkJnkJEcByBsqr9",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.PFfhOuJNIw1dMUqI":
			"Compendium.black-flag.npcs.Actor.OFvaU7jGTycWM8sp",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jeyDcPmAXdZVX9EJ":
			"Compendium.black-flag.npcs.Actor.OMX5d94wnbioOWys",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.wNJOg4euAaZh9aL3":
			"Compendium.black-flag.npcs.Actor.OSMsc0YrZ1eUkPz2",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.xxS4ea7ZR4Zy0xVq":
			"Compendium.black-flag.npcs.Actor.PDsnXVO64ew2HMla",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.oX1C9ZnXVhVIzO6M":
			"Compendium.black-flag.npcs.Actor.PIz6OxdTiqdlix0y",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.zqSX9F3i2yHqdEgx":
			"Compendium.black-flag.npcs.Actor.Pb3ANp5eQ5rQdMuO",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.1VcYrovypQisy3G5":
			"Compendium.black-flag.npcs.Actor.PgG1Izz1wtP1AVc1",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.vUuyuRpA3goz6XnL":
			"Compendium.black-flag.npcs.Actor.PgohhJx6393szUlk",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.QHHmvn4B5SDA0otn":
			"Compendium.black-flag.npcs.Actor.PuyGsCyCqiZnH2Zl",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.42rhREi6ZuS2c0n8":
			"Compendium.black-flag.npcs.Actor.PxfSVMywI0tAA2yy",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.2I8EQXmRG9W7X91T":
			"Compendium.black-flag.npcs.Actor.QBvgtZKfIM8xi0We",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.04K7hp4aRLilOToF":
			"Compendium.black-flag.npcs.Actor.QCC1wGo0aUqX9nj5",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.2tthohHl8zNcyucI":
			"Compendium.black-flag.npcs.Actor.QIeRCv66WQ4OuZGw",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.EIQp1oc7OnlbroCI":
			"Compendium.black-flag.npcs.Actor.QPUYtws10izwB41G",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.WQJWoYnxRmLluZez":
			"Compendium.black-flag.npcs.Actor.QbwUREeTjQ2kv29j",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Le9JR4xE3zB3fk8j":
			"Compendium.black-flag.npcs.Actor.QhUdfEtDyVBgsWqJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.bS83voALAowFEnkv":
			"Compendium.black-flag.npcs.Actor.R02ibrI7r0P2MuYe",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UZ4A79JLsBoITdwg":
			"Compendium.black-flag.npcs.Actor.R6UAoLrMzuXs0rSc",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.VYqytAwAzTSuOTjn":
			"Compendium.black-flag.npcs.Actor.RS2SzdUsZvEAYUDt",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.fMakBiKUCXmwO5wO":
			"Compendium.black-flag.npcs.Actor.RgWTEI3qCEhH5f5p",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.lvJrzSKFfYsgeYTo":
			"Compendium.black-flag.npcs.Actor.Rstx00Mw1KHQ0Uau",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.wucjuYX6MwiG5c8E":
			"Compendium.black-flag.npcs.Actor.SOk3xmj8v4SZrsT1",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.w1sSced232MUUm1Z":
			"Compendium.black-flag.npcs.Actor.SXdg3MWnVxlg1urO",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.gPMjxuuvUHwuXevc":
			"Compendium.black-flag.npcs.Actor.SjxwoQ8AHbO3zHoU",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.N26jHGFtTXiHJPvC":
			"Compendium.black-flag.npcs.Actor.SkO0ZyfahsSJ0VGt",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.TmlQaRogztAV7jwn":
			"Compendium.black-flag.npcs.Actor.Ss0Bwrs6FOveDoFy",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.PodGfZc1k6sp5slf":
			"Compendium.black-flag.npcs.Actor.TQUgLlfRbjhyzVvR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Fx4ESN5CAVmYEVU6":
			"Compendium.black-flag.npcs.Actor.TQlCeRlqoGzuef9j",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.pQYXPzSXcfPw7rVt":
			"Compendium.black-flag.npcs.Actor.TY6IN0DHMzsqUYVk",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.lxXkTp6dYeDImqCv":
			"Compendium.black-flag.npcs.Actor.U301vMUDHMsilO8e",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.TObsyirpxiYFXl8K":
			"Compendium.black-flag.npcs.Actor.U97WXv0e1InYdlFY",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.dWoMxuPpIwlQDYAX":
			"Compendium.black-flag.npcs.Actor.UBFzn2d2RnVgO8Rl",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.P3UNTiAmn64plrnt":
			"Compendium.black-flag.npcs.Actor.UDelAhYWBUG6UB65",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.uz4svvqpgRdoXXtZ":
			"Compendium.black-flag.npcs.Actor.UHqydMVavWYtY4d3",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.o03D0YvjNIvwGTED":
			"Compendium.black-flag.npcs.Actor.Ud4a8hMgKHtjSSde",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nQwKHqzKbP6gDLGi":
			"Compendium.black-flag.npcs.Actor.UdDVSYvYVpizaE4I",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.vitUaDjoTiByRlgT":
			"Compendium.black-flag.npcs.Actor.Ue1i1lK4SQAqR3lq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.dSIa31EfarSWcB5t":
			"Compendium.black-flag.npcs.Actor.UeYX37CmSwDYEIo5",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.YrZuw5BeFj9obWcm":
			"Compendium.black-flag.npcs.Actor.V0hoY7QNVvQwQDCB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.rEb6s31LaUoFvGDz":
			"Compendium.black-flag.npcs.Actor.V6nG6JPoYtPbI1Ss",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.W4vQapOttm43LoJU":
			"Compendium.black-flag.npcs.Actor.V8ccZwy2rPAl67gB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.1ixlvxOVSYnWQGtU":
			"Compendium.black-flag.npcs.Actor.VWvHuk0QUHjoAPkC",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.iopOSQXnBVqwsvXz":
			"Compendium.black-flag.npcs.Actor.VeVmo85SztJhGZsN",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0KkLaWOyOUhPLfTn":
			"Compendium.black-flag.npcs.Actor.VgI9TWuZwWjD2xgg",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.WYEYTQljEF2YMF4j":
			"Compendium.black-flag.npcs.Actor.VhgEQGMdXxpOUfXL",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Ph2UYOuMPpxEikrO":
			"Compendium.black-flag.npcs.Actor.W9ftI3mrL0czngCq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9puI2Q0vfcj9LfEH":
			"Compendium.black-flag.npcs.Actor.WBg1MmOJneyRRKu8",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jcB4Lyu5JIk15eZG":
			"Compendium.black-flag.npcs.Actor.WJQwmBf1BFyGbIbP",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ulisaOWYriVtDUxA":
			"Compendium.black-flag.npcs.Actor.WMceKrllLfWXxPU4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.efxNVpDuzkBAnjGW":
			"Compendium.black-flag.npcs.Actor.WPrjdve77A9SA94h",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.w0wchIrkh5xU1YYj":
			"Compendium.black-flag.npcs.Actor.WaqJiuEog6C2Sjgw",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.DmHm2pUTgf1BcJsA":
			"Compendium.black-flag.npcs.Actor.WdBjJZWKexQ9yWKE",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.foo9T1hrJEGW7CjG":
			"Compendium.black-flag.npcs.Actor.WnWvUNVhVxcyfymA",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.wziCRFPh3XaZz5vL":
			"Compendium.black-flag.npcs.Actor.Wu2QaZI38nWZEZtb",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Ut8VwQPVs2ZJScx9":
			"Compendium.black-flag.npcs.Actor.X0zlkGwxdiwMe2VR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9S2Yfkhh0H5j27GY":
			"Compendium.black-flag.npcs.Actor.X82CDCyHgR41wdQE",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UuHYMxUkRVfXJo5B":
			"Compendium.black-flag.npcs.Actor.XI5EEwMBVeGGqYUA",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.i0Nn5KSz7yykIzUo":
			"Compendium.black-flag.npcs.Actor.XLurGEHU0ev1Tcsj",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.DS2KM0HmGiFpy3YF":
			"Compendium.black-flag.npcs.Actor.XY0ee4F1zQNR21Wy",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sDxmbONKiohKIvtq":
			"Compendium.black-flag.npcs.Actor.XZLnelxGPTG9ndG7",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.vhdEfqdzheEjB4sN":
			"Compendium.black-flag.npcs.Actor.Xax43OMCHOc2UUoc",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.cWfHn437bHzjZKtq":
			"Compendium.black-flag.npcs.Actor.XfSCmCndblO973ag",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3IUwvaPy4DBOQaEb":
			"Compendium.black-flag.npcs.Actor.XhTebmzMEmxnMYX7",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.om2QskCe08driuyo":
			"Compendium.black-flag.npcs.Actor.YVG4vXSOTxY7HfMJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UvzX3uUj1N8rxcm2":
			"Compendium.black-flag.npcs.Actor.YZB7WaKKKDjkd5la",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.f9KDVyADp1AY4B9a":
			"Compendium.black-flag.npcs.Actor.Yi7b5kSrOjaBWcz7",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.LH0XRcQxQHUr5QEg":
			"Compendium.black-flag.npcs.Actor.Yu69oqsjr4GnVygA",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.waK5T2RfmyiRryL0":
			"Compendium.black-flag.npcs.Actor.Z7Im1Pl2ugOycad7",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Mw1SWH3eLJLbm88s":
			"Compendium.black-flag.npcs.Actor.Za8SWZT6BRyG18Kx",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.NseZbQVdJSuiMLIw":
			"Compendium.black-flag.npcs.Actor.ZbOSkmu1Vo1l6UyP",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.g61ksVZoPvnF8ksU":
			"Compendium.black-flag.npcs.Actor.ZjUi1rotZtqrOb01",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.8eQULmnILzf8VIaD":
			"Compendium.black-flag.npcs.Actor.ZzDX43iwJ5GE57f4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.cIgcogNVdVICiMnu":
			"Compendium.black-flag.npcs.Actor.a7dzJIh3xbXeEz21",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.K1ZUbUg44jIgyLfv":
			"Compendium.black-flag.npcs.Actor.aHutizsTtDFfX1xw",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.GrspuvDT8VmvwAuD":
			"Compendium.black-flag.npcs.Actor.aODuTJFvfNhI76YH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.apQOibmdO07O9JUj":
			"Compendium.black-flag.npcs.Actor.asAvxBBPVAmlLVNB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.fiVu82tYM9GRYhwn":
			"Compendium.black-flag.npcs.Actor.b0zD8sn4N4SwQZWn",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.FHEPIhOkVeXAbZQf":
			"Compendium.black-flag.npcs.Actor.b3IuKxZgDZFB60TD",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.TzhpfrmGr5Cmb4wr":
			"Compendium.black-flag.npcs.Actor.b6WyT2uZ2s0hH5EQ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.mrzXMVgTTOKs3idf":
			"Compendium.black-flag.npcs.Actor.bWknOpKfG47YpIah",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.19gNcUBKwfHf9tgE":
			"Compendium.black-flag.npcs.Actor.bdVcAUcSnPMT6ZnL",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Jgwv1BbLyNY3Guix":
			"Compendium.black-flag.npcs.Actor.bk9J56h4Ng6K6mLI",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.in5Or33eZYZnjmBY":
			"Compendium.black-flag.npcs.Actor.brp0QMrUtl7IIMuX",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sAlKtDJ9Iq6m60TB":
			"Compendium.black-flag.npcs.Actor.buqFMdIMMReaxLgL",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.4c8OU0wppABeDwsB":
			"Compendium.black-flag.npcs.Actor.cB8DGxkbUhEiLB1w",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UjSJPi4f6SSi2X8b":
			"Compendium.black-flag.npcs.Actor.cSgTzu79oKyZAOLG",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Dq8YEToNEwx6kUSG":
			"Compendium.black-flag.npcs.Actor.cZQEGg1n82DtB1B7",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.phyQEH3HvxBqNKq7":
			"Compendium.black-flag.npcs.Actor.cgnLl6eA2TXlpDWA",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.QZ1gndKMQmX8Iisk":
			"Compendium.black-flag.npcs.Actor.ciX8E1MCTf6MsoLz",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sgP6OMZFvvQNLXtC":
			"Compendium.black-flag.npcs.Actor.ck0kqumkVqWznctK",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.qFP81iGnliYj2alW":
			"Compendium.black-flag.npcs.Actor.clrjqjIGpwSbKDdr",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KELhMhGeiYKwQNeA":
			"Compendium.black-flag.npcs.Actor.cquozeSlJD3zYlL8",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.1w76HzQMA8rBspFW":
			"Compendium.black-flag.npcs.Actor.cw0jtRfsxiGPSxVg",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.mFWXbgqPLgXl2kRT":
			"Compendium.black-flag.npcs.Actor.cwmRactFb8d6yQRn",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.w5Ro2ub0HPGYR8X4":
			"Compendium.black-flag.npcs.Actor.d5lMdSG98vqJO3xy",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.n97FjM0gzr6MkPOE":
			"Compendium.black-flag.npcs.Actor.dfInJBbszNjFdUtc",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.SzkPHt3tdXOFPLbj":
			"Compendium.black-flag.npcs.Actor.eKoP33PXVPjGlpYM",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.RqzOHuGw3dMSV3yQ":
			"Compendium.black-flag.npcs.Actor.eqOkida23HMGsEkC",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.zvALiWxXLJ6zwJU7":
			"Compendium.black-flag.npcs.Actor.euCGJRfmdRCsdnZs",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.csupVsyrd1FkrGO7":
			"Compendium.black-flag.npcs.Actor.f8OZ3qR5dktPErhU",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.g6A7BlrfD3GwWKR9":
			"Compendium.black-flag.npcs.Actor.fp7eFxkfnQqq5GJZ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nqLpQUGMhYLzIXWN":
			"Compendium.black-flag.npcs.Actor.g586vFs1XriKy1Al",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ALVbZLcZDuKOj14Q":
			"Compendium.black-flag.npcs.Actor.g7zcm2McnEiyfZKC",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sPQkw1lZ7sbNJtXK":
			"Compendium.black-flag.npcs.Actor.gHi8SHUcg2rmuJC4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.tqHuUlJtEE8ivxeG":
			"Compendium.black-flag.npcs.Actor.gWWEn9hsrNGlYi7Z",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UlS7Gk5jT7WEU7id":
			"Compendium.black-flag.npcs.Actor.ggoxWnq9zRR4EUom",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.5WiJTkoHGKYQDblH":
			"Compendium.black-flag.npcs.Actor.h1hoa6N6IlypbFz0",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.5eGrt6Xrn5J3SCFt":
			"Compendium.black-flag.npcs.Actor.hOgnjyo11UFsresY",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.4833Et4DRMHt073q":
			"Compendium.black-flag.npcs.Actor.hiQXL3rtSIZsrKui",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.tnWWozYBmCQ7bJPi":
			"Compendium.black-flag.npcs.Actor.hpAmWmT3s3VrflWl",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.QBld0sZEnXtrAjiK":
			"Compendium.black-flag.npcs.Actor.i3Uu10KX5tvmseAQ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3OJGopFO0cw5Mer6":
			"Compendium.black-flag.npcs.Actor.i4NFjO6EY2U2Rc8g",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KRhqSnlO4bD2W39h":
			"Compendium.black-flag.npcs.Actor.i5ZMW53YK1mODw9r",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.RRuostw1tIx3qFzg":
			"Compendium.black-flag.npcs.Actor.iGeIfiy7aIAg7JV5",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ydIgQDYLboTNpbc0":
			"Compendium.black-flag.npcs.Actor.iPE1p3z5N9774Aqz",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.xqC38manlqV2g6Bg":
			"Compendium.black-flag.npcs.Actor.ioptmAxgvplXdxMJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.y25rp8YTpk7E17ii":
			"Compendium.black-flag.npcs.Actor.iyWpO1bTYA1b3B7b",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UgTJarNfbXeUp83t":
			"Compendium.black-flag.npcs.Actor.j02ykQqDOZVgN8MV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.M5C9HJPqBudEM4tK":
			"Compendium.black-flag.npcs.Actor.jH8xObIbnEmk6Sjx",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.zwSZK8DNy3LHPP1e":
			"Compendium.black-flag.npcs.Actor.jrFETGwaRC12Gcgo",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.4NWGDo8dWELRjvTX":
			"Compendium.black-flag.npcs.Actor.jujAFfwxEOBwL2Us",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.86FQ5oEKeCXg7A3l":
			"Compendium.black-flag.npcs.Actor.jzd7C2z0p2vcCxLU",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UYyLgRglThNxpyGV":
			"Compendium.black-flag.npcs.Actor.kSCNogXBHBJCc2Lj",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.VaI1ZE2oan4EyNGH":
			"Compendium.black-flag.npcs.Actor.kUqTx9G9dCcGom8H",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0bN59SHOeVkBdCS9":
			"Compendium.black-flag.npcs.Actor.kXwQIPBSeUCmhroJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.KSZBvrZnwLYTVcaY":
			"Compendium.black-flag.npcs.Actor.knXlk6o8PxOdbDI4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.r1mNo4BD70pbA0kj":
			"Compendium.black-flag.npcs.Actor.l5Bd7urAFSOCktWs",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.cpei2Ltqggu8EGKh":
			"Compendium.black-flag.npcs.Actor.lPSgL3IEmYJb2FTm",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.OpybaPKKfV7P3vvm":
			"Compendium.black-flag.npcs.Actor.mMwrvECrgnTWkgSR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3rMnLACeMWi9SGWI":
			"Compendium.black-flag.npcs.Actor.mRLx4ou4JQf5IwMb",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Ilb52LQDjo2zAPBS":
			"Compendium.black-flag.npcs.Actor.mdERCYbI7VnDABew",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.inc27hpTUmrAAJao":
			"Compendium.black-flag.npcs.Actor.n7MQrAOMaaGucS5J",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.AdvVdNpBLIrkTKMd":
			"Compendium.black-flag.npcs.Actor.nI8fNmp3yL83G8fR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.4YE2zS05Naljo7G5":
			"Compendium.black-flag.npcs.Actor.nVo8nTfyk8DkPv3p",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.poTQVr316nY5wO2w":
			"Compendium.black-flag.npcs.Actor.naDs3W5YhTHbr1ej",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.y24kqStOgMTIzZYo":
			"Compendium.black-flag.npcs.Actor.net7utpz7v44amQ4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jXd3NxlDtHJJs11r":
			"Compendium.black-flag.npcs.Actor.oRKs6zIzuH0mO63T",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HjPDsuf859A8SHes":
			"Compendium.black-flag.npcs.Actor.ofeQtVfgvGIk6L0e",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.hR0LXas8LMP6oA1N":
			"Compendium.black-flag.npcs.Actor.oissj1hsaDwgvw3k",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.D77Jj3SqXOgzFYvh":
			"Compendium.black-flag.npcs.Actor.opwZgKqVqntUSyxN",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.1ImbqMffnFLT0YyB":
			"Compendium.black-flag.npcs.Actor.ov0XmnwLkhoR2PUS",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Bfg7QYOn4xpbYjfP":
			"Compendium.black-flag.npcs.Actor.p3pNpEqq7uMS4OIV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.UzUqDlLd8N2HqrP8":
			"Compendium.black-flag.npcs.Actor.pEqya9TxqRPwo1JI",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.fSq6ZPSOSQkIPr9T":
			"Compendium.black-flag.npcs.Actor.pHh8GddnzZYbiKQR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.w2Q3brSoIgqoe5dH":
			"Compendium.black-flag.npcs.Actor.pIR9tOfVD3TBs02T",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3xg4QNruvBchYDzC":
			"Compendium.black-flag.npcs.Actor.pLJ9uARWkhzv5RP4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.8hatMQYALXJqiUnW":
			"Compendium.black-flag.npcs.Actor.pMDqNFx7VKgC3SUZ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Ar7xRwRTKaBWGIMx":
			"Compendium.black-flag.npcs.Actor.pnMVYeOXRmIXdm2z",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.76Me6VcQ461FFvAJ":
			"Compendium.black-flag.npcs.Actor.puJPu9Fl8PI81zuh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.xj9sQNUcapS5bQEU":
			"Compendium.black-flag.npcs.Actor.pyDYHRdZzv3Br8wM",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.g8fjTkEb6UEqGD0f":
			"Compendium.black-flag.npcs.Actor.qQcu0AgHe762M5Gh",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Uwhl27mKQmB2nV2B":
			"Compendium.black-flag.npcs.Actor.qvC6VqO6BfDUg0sf",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.44l71RDORCEN7AIA":
			"Compendium.black-flag.npcs.Actor.r92GuCwB5hkH46GP",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.xQtbvxfWwIRSmsUl":
			"Compendium.black-flag.npcs.Actor.rABx4QexdSc6vTsq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Yi8ALRTei8diYLpQ":
			"Compendium.black-flag.npcs.Actor.rEjsBo7fnpeE7VyE",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9NNfvbSmfQIbSKFl":
			"Compendium.black-flag.npcs.Actor.rV9gDP0hIqmPm5ri",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.9vTeMPtBrkCKKWXz":
			"Compendium.black-flag.npcs.Actor.rZOCoED4brskz3Kp",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.mqnIiQQbY76f0M5N":
			"Compendium.black-flag.npcs.Actor.rgZKxFrXIhvhMoPe",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jpYV3kUeRc2wDTEZ":
			"Compendium.black-flag.npcs.Actor.sC5LVxumiNuA8EJH",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.XQVgMo1YBsPLfNIR":
			"Compendium.black-flag.npcs.Actor.sEpsqtVJdrJy5VQS",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Nx3vzPiXSysYOZSz":
			"Compendium.black-flag.npcs.Actor.shCcNmE8Rqfy6JIf",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.k0IixcKDbBhyYOCG":
			"Compendium.black-flag.npcs.Actor.shpqWu1QjD5eclBW",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.2nI2v5A6Y37wdUdK":
			"Compendium.black-flag.npcs.Actor.skR6NOTFWg20bng1",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.EUWcVtrvCMrbAC9T":
			"Compendium.black-flag.npcs.Actor.spxoi6GkVFiLmhPB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0RnEUV8shkrk7yrP":
			"Compendium.black-flag.npcs.Actor.t6Hq3bNVZrkPPGxa",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.TsKwxtv3C4zWBsEV":
			"Compendium.black-flag.npcs.Actor.tClMSNYOydhPEtCV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.l3dnjlxNXCcQiGPW":
			"Compendium.black-flag.npcs.Actor.tI2hsbBl6skqEkOp",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.REeq8PgajdfxsKGs":
			"Compendium.black-flag.npcs.Actor.tPJ2ypkwT92mglS6",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.t2IG9p2jxdXGEjny":
			"Compendium.black-flag.npcs.Actor.tekf4vWWHqDYFv8k",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3WPWSaK2rSwFCVtx":
			"Compendium.black-flag.npcs.Actor.tgA4k8Lbt4DN3soa",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.PVVqAIyhI9CvmQ6D":
			"Compendium.black-flag.npcs.Actor.th8XoqIxyhbFl55A",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.AbNTdipV1SMUIM0P":
			"Compendium.black-flag.npcs.Actor.uoDsMggejKynGeD9",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.weDsSe6WFEnWSgBw":
			"Compendium.black-flag.npcs.Actor.usBkwcEYxNPK7eXq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.U6s0o0HjC1YAadbd":
			"Compendium.black-flag.npcs.Actor.vGbowahPWqSQNJIj",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.oodjqXhuaDYJyxn3":
			"Compendium.black-flag.npcs.Actor.vPMpVsckn4SlfL2e",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Qci6BeSOEudLpDgv":
			"Compendium.black-flag.npcs.Actor.vQ7XQl5sZYsxpMnB",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.akPsOv3cFGffQjNt":
			"Compendium.black-flag.npcs.Actor.vU6tpBRh3XgEJCQS",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.pU1WCHTfqLWmoCI1":
			"Compendium.black-flag.npcs.Actor.vYLiHfYOHm9CXs9I",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.GA3E6TWY3u5PGVKa":
			"Compendium.black-flag.npcs.Actor.vdO9WvllTWSJTxO5",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.m8KzhZ4LUNeGYmUz":
			"Compendium.black-flag.npcs.Actor.viZtu4bAm6ZvKmIN",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.HjlGsxjpUZ1Dn3nb":
			"Compendium.black-flag.npcs.Actor.vlB6jIBlQqXBM2QF",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Hphga67uFjQ7pPVV":
			"Compendium.black-flag.npcs.Actor.vlOJ3k4XJoZhhkdK",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Yf4sTVl2mSLvMVRB":
			"Compendium.black-flag.npcs.Actor.vsJSzta9m9xgEXbW",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.QeljZDquBzAAd0DX":
			"Compendium.black-flag.npcs.Actor.vyegR5HG5tDlmfxn",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.D3ifP7BdJ2JiPB0p":
			"Compendium.black-flag.npcs.Actor.w1Kv6iA09ahXHClR",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.044rJ4pwxJf91Rji":
			"Compendium.black-flag.npcs.Actor.w6hV6Lspei6Bb5r5",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3EMBDpwzOAhAFhW5":
			"Compendium.black-flag.npcs.Actor.wRv1Bu617cEACE6Q",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.T8VEBtELs5cG9L3t":
			"Compendium.black-flag.npcs.Actor.wV7iTQXMeylQ1GLY",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ZACpAJBzhJhXQ5lD":
			"Compendium.black-flag.npcs.Actor.wdVwwqWDYfJ7V1xa",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nRFqKtVk5fCTgbgH":
			"Compendium.black-flag.npcs.Actor.wnnX3hr0Zo3jRtiY",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3uO24tvOGlqwFJvQ":
			"Compendium.black-flag.npcs.Actor.wsYhKmcZQGjpoxBM",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.7CQzEZizeSIcSP7O":
			"Compendium.black-flag.npcs.Actor.x0GMYLNpOmSzUC2w",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.821zAsnVWkkdEsu9":
			"Compendium.black-flag.npcs.Actor.xD6N8A8ZlTwNfmZ9",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nwFf0rAmXKAJG1Qe":
			"Compendium.black-flag.npcs.Actor.xV8xaPrWzlA2iSj8",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.zO19wD6ZiqJu5zAj":
			"Compendium.black-flag.npcs.Actor.xb6xkLufGgW66ADy",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.17hjCetGSGHmLoYV":
			"Compendium.black-flag.npcs.Actor.xi88QgskH6ueJ6Ma",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Ml5ccFxAdITuK4Kw":
			"Compendium.black-flag.npcs.Actor.xovBE0pXygwryVLa",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.J6WSA8wUKHVif124":
			"Compendium.black-flag.npcs.Actor.xr4I1f60XZGqtaOe",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.sWFvWjrCZ5A8GeWx":
			"Compendium.black-flag.npcs.Actor.yE6PgxHymFFfBNSu",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.plkKNaK7zo2ZraHj":
			"Compendium.black-flag.npcs.Actor.yU15RNDaUzQaM4cF",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.iUOk8bqGY6ivZOSB":
			"Compendium.black-flag.npcs.Actor.yfli1mZGZTLdPxEq",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0UchZ8TI5tG0vASc":
			"Compendium.black-flag.npcs.Actor.yhAnGtwttTdrbFxU",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.nN68OTU73RVAho3A":
			"Compendium.black-flag.npcs.Actor.yjcpvMcDeS82FWr4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.3WSCeiAurwKM2Kml":
			"Compendium.black-flag.npcs.Actor.yjd5EqF2xIbyppga",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.68Yn8SwPGkTHabhm":
			"Compendium.black-flag.npcs.Actor.ynfb6jhulpdR0d6D",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.d8vo0lmoCVu23As3":
			"Compendium.black-flag.npcs.Actor.z3MG8r2SDVnujWtJ",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.EBUashyUhb5XzNot":
			"Compendium.black-flag.npcs.Actor.z5c9ixFNcqW4Tgf4",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.jx4iRC7XoImafcxL":
			"Compendium.black-flag.npcs.Actor.zXP6iOGQpuxcyqp1",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.0MVm84PMtYWWhKOK":
			"Compendium.black-flag.npcs.Actor.zxugaPCgwV1Sp8uC",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.ayi4T3TKqqkrffGy":
			"Compendium.black-flag.npcs.Actor.zzQznETcwztvK2aV",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.qjYoG3uhPSTNDO6t":
			"Compendium.black-flag.npcs.Actor.3JVwDBkdsUvoi4fs",
		"Compendium.kp-tov-monster-vault.kp-tov-mv-bestiary.Actor.Ra8zQs38aWHUpbVs":
			"Compendium.black-flag.npcs.Actor.5j6yqkzmckGvlHbe"
	}
};

var redirects = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_configureRedirects: _configureRedirects
});

/**
 * @typedef {object} ItemRegistration
 * @property {string} name - Item's name.
 * @property {string} img - Item's icon.
 * @property {string[]} source - UUIDs of where this item is defined.
 */

/**
 * Registered item information grouped by type and identifier.
 * @type {{[key: string]: {[key: string]: ItemRegistration}}}
 * @private
 */
const all = {};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Has the initial registration been completed?
 * @type {boolean}
 */
let ready = false;

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Documents that will be reinitialized when registration is ready to ensure they can access cached data.
 * @type {Document[]}
 */
const reinitiatlizeOnReady = new Set();

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                         Lookup                        */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Fetch the item registration for the provided identifier if it exists.
 * @param {string} type - Item type to get.
 * @param {string} identifier - Identifier to get.
 * @returns {ItemRegistration|undefined}
 */
function get(type, identifier) {
	return all[type]?.[identifier];
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Fetch the source item registered if it exists.
 * @param {string} type - Item type to get.
 * @param {string} identifier - Identifier to get.
 * @returns {BlackFlagItem|Promise<BlackFlagItem>|undefined}
 */
function getSource(type, identifier) {
	const registration = get(type, identifier);
	return registration
		? registration.cached ?? fromUuid(registration.sources[registration.sources.length - 1])
		: undefined;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a nested list of options for one or more types of registered items.
 * @param {string[]|Set<string>} types - Item types to represent.
 * @param {Set<string>} [chosen] - Item to be marked as chosen.
 * @returns {SelectChoices}
 */
function groupedOptions(types, chosen) {
	return new SelectChoices(
		types.reduce((obj, type) => {
			obj[type] = {
				label: CONFIG.Item.typeLabelsPlural[type],
				children: Object.entries(list(type)).reduce((o, [k, v]) => {
					o[k] = { label: v.name };
					return o;
				}, {})
			};
			return obj;
		}, {}),
		chosen
	);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @callback RegistrationFilterCallback
 * @param {Document} element - The current element being processed.
 * @param {string} identifier - Identifier of the item.
 * @returns {boolean}
 */

/**
 * Filter registered items.
 * @param {string} type - Item type to filter.
 * @param {RegistrationFilterCallback} [callbackFn] - Function executed to perform the filtering.
 * @returns {{[key: string]: ItemRegistration}|undefined}
 */
async function filter(type, callbackFn) {
	let obj = list(type);
	if (!obj) return;
	obj = foundry.utils.deepClone(obj);
	for (const [identifier, data] of Object.entries(obj)) {
		const element = await fromUuid(data.sources[data.sources.length - 1]);
		if (!element) return obj;
		if (callbackFn && !callbackFn(element, identifier)) delete obj[identifier];
	}
	return obj;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Fetch all registered items of the specified type.
 * @param {string} type - Item type to list.
 * @returns {{[key: string]: ItemRegistration}|undefined}
 */
function list(type) {
	return all[type];
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                      Registration                     */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register all item types with `register` to to `true` in their metadata.
 * @private
 */
function registerItemTypes() {
	const indexes = _indexCompendiums();
	log("Preparing central item registrations");
	const registrations = [];
	for (const type of Item.TYPES) {
		const dataModel = CONFIG.Item.dataModels[type];
		if (!dataModel?.metadata?.register) continue;
		registrations.push(_registerItemType(dataModel.metadata.type, indexes));
	}

	// When all settled, populate registration, set to ready, and emit registration complete hook
	Promise.all(registrations).then(registrations => {
		registrations.forEach(r => (all[r.type] = r.registrations));
		ready = true;
		log("Central item registration setup complete");

		/**
		 * A hook event that fires when startup item registration is complete.
		 * @function blackFlag.registrationComplete
		 * @memberof hookEvents
		 */
		Hooks.callAll("blackFlag.registrationComplete");

		reinitiatlizeOnReady.forEach(d => d.reset());
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register all items of the specified type within compendiums or the world. Should only be called once per item type.
 * @param {string} type - Item type to register.
 * @param {Map[]} [indexes] - Previously prepared indexes of all Item compendiums.
 * @returns {{
 *   type: string,
 *   shouldCache: boolean,
 *   registrations: {[key: string]: ItemRegistration}
 * }}
 * @private
 */
async function _registerItemType(type, indexes) {
	const config = CONFIG.Item.dataModels[type].metadata.register;

	indexes = await (indexes ?? _indexCompendiums());
	const registerItem = (item, uuidPrefix) => {
		const identifier = item.system?.identifier?.value || slugify$1(item.name, { strict: true });
		registrations[identifier] ??= { sources: [] };
		registrations[identifier].name = item.name;
		registrations[identifier].img = item.img;
		registrations[identifier].sources.push(`${uuidPrefix}.${item._id}`);
	};

	log(`Registering ${type} items`, { level: "groupCollapsed" });
	const registrations = {};
	for (const [pack, index] of Object.entries(indexes)) {
		for (const item of index) {
			const dataModel = CONFIG.Item.dataModels[item.type];
			if (dataModel?.metadata.type !== type) continue;
			log(`Registering ${item.name} from ${pack}`);
			registerItem(item, `Compendium.${pack}.Item`);
		}
	}
	console.groupEnd();

	if (config?.cache === true)
		await Promise.all(Object.values(registrations).map(async r => (r.cached = await fromUuid(r.sources[0]))));

	return {
		type,
		shouldCache: config?.cache === true,
		registrations: sortObjectEntries(registrations, { sortKey: "name" })
	};
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enable the hooks needed to handle registration changes during item CRUD operations.
 */
function setupHooks() {
	Hooks.on("createItem", _onCreateItem);
	Hooks.on("preUpdateItem", _preUpdateItem);
	Hooks.on("updateItem", _onUpdateItem);
	Hooks.on("deleteItem", _onDeleteItem);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

const message = operation =>
	`Attempted to ${operation} item before registration was completed which may lead to invalid registration data. Wait until the "blackFlag.registrationComplete" hook has fired or "CONFIG.BlackFlag.registration.ready" is true before performing any automatic item management.`;

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register a new item type when an item is created.
 * @param {BlackFlagItem} item - Newly created item.
 * @param {object} options - Item creation options.
 * @param {string} userId - ID of the user that created the item.
 */
function _onCreateItem(item, options, userId) {
	if (item.isEmbedded || !item.system.metadata.register) return;
	if (!item.pack) return;
	if (!ready) log(message("create"), { level: "warn" });
	const type = item.system.metadata.type;
	let source = (all[type] ??= {});
	if (!source) source = all[type] = {};
	_handleCreate(source, item.identifier, item);

	all[type] = sortObjectEntries(source, { sortKey: "name" });
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Store the item's identifier before it is changed.
 * @param {BlackFlagItem} item - Updated item.
 * @param {object} changes - Changes being made.
 * @param {object} options - Item update options.
 * @param {string} userId - ID of the user that update the item.
 */
function _preUpdateItem(item, changes, options, userId) {
	foundry.utils.setProperty(options, `blackFlag.identifier.${item.id}`, item.identifier);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Update a registered item's name or image if it is the primary for an identifier or move
 * if its identifier has changed.
 * @param {BlackFlagItem} item - Updated item.
 * @param {object} changes - Changes that were made.
 * @param {object} options - Item update options.
 * @param {string} userId - ID of the user that update the item.
 */
function _onUpdateItem(item, changes, options, userId) {
	if (item.isEmbedded || !item.system.metadata.register) return;
	if (!item.pack) return;
	if (!ready) log(message("update"), { level: "warn" });
	const type = item.system.metadata.type;
	const source = (all[type] ??= {});

	// Identifier has changed, move this to the new location
	const oldIdentifier = foundry.utils.getProperty(options, `blackFlag.identifier.${item.id}`);
	if (item.identifier !== oldIdentifier) {
		if (!source[item.identifier]) _handleCreate(source, item.identifier, item);
		else source[item.identifier].sources.push(item.uuid);
		_handleDelete(source, oldIdentifier, item);
	} else if (!source[item.identifier]) _handleCreate(source, item.identifier, item);

	// Cached values should only be updated if this is the last item in the sources list
	const idx = source[item.identifier].sources.findIndex(i => i === item.uuid);
	if (idx !== source[item.identifier].sources.length - 1) return;
	source[item.identifier].name = item.name;
	source[item.identifier].img = item.img;

	_handleCache(source, item.identifier, item).then(() => {
		/**
		 * A hook event that fires when a registration entry is updated.
		 * @function blackFlag.registrationUpdated
		 * @memberof hookEvents
		 * @param {string} identifier - Identifier of the entry being updated.
		 * @param {BlackFlagItem} item - Item whose update caused the change.
		 */
		Hooks.callAll("blackFlag.registrationUpdated", item.identifier, item);
	});

	all[type] = sortObjectEntries(source, { sortKey: "name" });
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Un-register an item when it has been deleted.
 * @param {ItemEH} item - Deleted item.
 * @param {object} options - Item deletion options.
 * @param {string} userId - ID of the user that deleted the item.
 */
function _onDeleteItem(item, options, userId) {
	if (item.isEmbedded || !item.system.metadata.register) return;
	if (!item.pack) return;
	if (!ready) log(message("delete"), { level: "warn" });
	const type = item.system.metadata.type;
	const source = (all[type] ??= {});
	if (!source?.[item.identifier]) return;
	_handleDelete(source, item.identifier, item);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                         Utils                         */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Handle caching an item into registration.
 * @param {{[key: string]: ItemRegistration}} source - Item registration for this item's type.
 * @param {string} identifier - Identifier for this entry.
 * @param {ItemEH|string} item - Item to be cached or UUID of item.
 */
async function _handleCache(source, identifier, item) {
	if (foundry.utils.getType(item) === "string") item = await fromUuid(item);
	if (!CONFIG.Item.dataModels[item.type].metadata.register?.cache) return;
	source[identifier].cache = item;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Handle creating an entry.
 * @param {{[key: string]: ItemRegistration}} source - Item registration for this item's type.
 * @param {string} identifier - Identifier to use for creating the entry.
 * @param {ItemEH} item - Item being created.
 */
function _handleCreate(source, identifier, item) {
	const created = !source[identifier];

	source[identifier] ??= { sources: [] };
	source[identifier].name = item.name;
	source[identifier].img = item.img;
	source[identifier].sources.push(item.uuid);

	if (created) {
		_handleCache(source, identifier, item).then(() => {
			/**
			 * A hook event that fires when an entry is added to registration.
			 * @function blackFlag.registrationCreated
			 * @memberof hookEvents
			 * @param {string} identifier - Identifier of the entry being added.
			 * @param {BlackFlagItem} item - Item whose creation caused the change.
			 */
			Hooks.callAll("blackFlag.registrationCreated", identifier, item);
		});
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Handle deleting an entry.
 * @param {{[key: string]: ItemRegistration}} source - Item registration for this item's type.
 * @param {string} identifier - Identifier to use when deleting entry.
 * @param {ItemEH} item - Item being deleted.
 */
function _handleDelete(source, identifier, item) {
	source[identifier].sources.findSplice(i => i === item.uuid);
	if (source[identifier].sources.length === 0) {
		delete source[identifier];

		/**
		 * A hook event that fires when an entry is removed from registration.
		 * @function blackFlag.registrationDeleted
		 * @memberof hookEvents
		 * @param {string} identifier - Identifier of the entry being removed.
		 * @param {BlackFlagItem} item - Item whose deletion caused the change.
		 */
		Hooks.callAll("blackFlag.registrationDeleted", identifier, item);

		return;
	}
	const newSource = fromUuidSync(source[identifier].sources[source[identifier].sources.length - 1]);
	source[identifier].name = newSource.name;
	source[identifier].img = newSource.img;

	_handleCache(source, identifier, item).then(() => {
		Hooks.callAll("blackFlag.registrationUpdated", identifier, item);
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Re-index all Item compendiums to include the identifier.
 * @returns {{[key: string]: Collection}}
 * @private
 */
async function _indexCompendiums() {
	return Object.fromEntries(
		await Promise.all(
			Array.from(game.packs.entries())
				.filter(p => p[1].metadata.type === "Item")
				.map(async p => [p[0], await p[1].getIndex({ fields: ["system.identifier.value"] })])
		)
	);
}

var registration = /*#__PURE__*/Object.freeze({
	__proto__: null,
	all: all,
	filter: filter,
	get: get,
	getSource: getSource,
	groupedOptions: groupedOptions,
	list: list,
	get ready () { return ready; },
	registerItemTypes: registerItemTypes,
	reinitiatlizeOnReady: reinitiatlizeOnReady,
	setupHooks: setupHooks
});

/**
 * Configuration information for rule types.
 *
 * @typedef {object} RuleTypeConfiguration
 * @property {string} label         Localized label for the rule type.
 * @property {string} [references]  Key path for a configuration object that contains reference data.
 */

/**
 * Types of rules that can be used in rule pages and the &Reference enricher.
 * @enum {RuleTypeConfiguration}
 */
const ruleTypes = {
	rule: {
		label: "BF.Rule.Type.Rule",
		references: "rules"
	},
	ability: {
		label: "BF.Ability.Label[one]",
		references: "enrichment.lookup.abilities"
	},
	skill: {
		label: "BF.Skill.Label[one]",
		references: "enrichment.lookup.skills"
	},
	areaOfEffect: {
		label: "BF.AreaOfEffect.Label"
	},
	condition: {
		label: "BF.Condition.Label[one]",
		references: "conditions"
	},
	creatureTag: {
		label: "BF.CreatureType.Tag.RuleLabel",
		references: "creatureTags"
	},
	creatureType: {
		label: "BF.CreatureType.Label",
		references: "creatureTypes"
	},
	damageType: {
		label: "BF.DAMAGE.Type.Label",
		references: "damageTypes"
	},
	healingType: {
		label: "BF.Healing.Type.Label",
		references: "healingTypes"
	},
	movementType: {
		label: "BF.MOVEMENT.Type.Label",
		reference: "movementTypes"
	},
	property: {
		label: "BF.Property.Label[one]",
		references: "itemProperties"
	},
	sense: {
		label: "BF.SENSES.Label[one]",
		reference: "senses"
	},
	spellComponent: {
		label: "BF.Spell.Component.RuleLabel",
		reference: "spellComponents"
	},
	spellSchool: {
		label: "BF.Spell.School.RuleLabel",
		reference: "spellSchools"
	},
	spellSource: {
		label: "BF.Spell.Source.RuleLabel",
		reference: "spellSources"
	},
	spellTag: {
		label: "BF.Spell.Tag.RuleLabel"
	}
};
localizeConfig(ruleTypes);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * List of rules that can be referenced from enrichers. All keys should be lowercase.
 * @type {Record<string, { reference: string }>}
 */
const rules = {
	luck: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.KdRRH2CH4A47lOd2",
	attackrolls: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.6QEZLNjN9Vtd85mv",
	saves: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.iEjg4QCm1uXuHMWo",
	abilitychecks: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.hJLzQeaHZ5xMiRXB",
	passivechecks: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.JNHxlJWaLZhGt09B",
	groupchecks: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.vfc3jJSA1k7ZA3HJ",
	climbing: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.jWNv9cljSnyDEhui",
	crawling: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.EGfgIvHkET4oMnoB",
	jumping: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.MLrKpFNT81387YGg",
	longjump: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.q4vqA4xBUYEgb6WA",
	highjump: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.2jaVQ13CdtGfULdn",
	swimming: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.6ghqyz9CQReaSMQt",
	difficultterrain: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ZKv4Wvri7nHonnYQ",
	forcedmovement: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.SFb4kc8YK9Huw2De",
	falling: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.YUn5nBL14LRf9z5p",
	pushing: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.SqxcyzDSZO72tH07",
	pulling: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.SqxcyzDSZO72tH07",
	carrying: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Ijp2wMnVYr6W0iNb",
	push: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.i4IobJSHX0rSAiMx",
	drag: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.i4IobJSHX0rSAiMx",
	life: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.i4IobJSHX0rSAiMx",
	encumbered: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.4PZeNWg14gZDTlVa",
	heavilyencumbered: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.uXjn8lmUYmDn3byF",
	lightlyobscured: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.AH8dRfHfrEUF7exU",
	heavilyobscured: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Yckfqn5RxiGzXyEx",
	temphp: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.PGW1FFQySj1EF5SV",
	temporaryhitpoints: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.PGW1FFQySj1EF5SV",
	resistance: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.PXnFpTXXLkiCrVpa",
	vulnerability: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.PXnFpTXXLkiCrVpa",
	hitdice: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.1ytxMlHty9n0SLUa",
	resting: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.g1AZpcFksiW4yDRP",
	shortrest: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.OqQCOgw7ZBFVFAnQ",
	longrest: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.IBHaTCsK83luoW1f",
	deathsaves: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.wjQhC0QcU7vG1B94",
	dying: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.jwv2zYVcIekYalE4",
	stable: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.5gpBaeGshmsJbbTf",
	conditions: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.qNVN3MvCQ8yW8bWZ",
	curses: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Eod2awdchtcUfUeh",
	diseases: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.iuhsSvtEIxRUglVg",
	dread: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.2XMupRuUzzodxenW",
	poisons: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.9dVs2hSBQoOZLpO6",
	starvation: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.NrfxRiIdk7ghum2o",
	dehydration: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.NrfxRiIdk7ghum2o",
	food: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.V4frkDHhsWFBtmmt",
	water: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.4P9Yx1k4NFcuM8DO",
	suffocating: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.ATzEq6INUQJvWQDS",
	space: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.aLXrCrhJjElvBSVu",
	creaturesize: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.bCa3AmPRBm9hy1GN",
	bonusactions: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.FuXIjWgBcEJOUKOT",
	reactions: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.U4swqNA0bp6d4YmV",
	dash: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.epbcsiQAhC9n0fUS",
	disengage: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.kgh7CEm3NeD9g3yX",
	dodge: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.q42Xs8I48TGC212s",
	help: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.4BoF98Om04EuUwdz",
	hide: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.g2klsQxMTUpmmZeE",
	ready: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.aaOdqrd4d0XyFcDg",
	search: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.I7OBptE3reZmx8X2",
	useanobject: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.6EMGwT2zTi4XmJf8",
	halfcover: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.IWi5oHoHCq6oane8",
	threequarterscover: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.YTCTevHnuOJ3DYLq",
	totalcover: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.VGPEj8VnVXOFiIka",
	reach: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.kBB2z9Nn36Cu2ejB",
	unarmedstrikes: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Te0mVpqWlEMkPU1i",
	grappling: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.mfOKdTPnpmDvo5lx",
	shoving: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.eE2EG1jXAUy77fI4",
	twoweaponfighting: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.FX73QYzcEWlDeJAz",
	longrange: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.azYu72dhGH7HaIXF",
	closerange: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.JCodpDvIjVzcL5ra",
	mountedcombat: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.yFAJibohseTH3FQq",
	underwatercombat: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.kC0OgTvY7Pxd3sl5",
	cantrips: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.QcIjK8RvqI0lPPyJ",
	rituals: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.AP3BgwMAwevgC5Tr",
	instantaneous: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.c2dif2p9wEdC7A1e",
	concentration: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.9qY7qeHNuDQzCxQh"
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Source books that can be displayed in the source listing.
 * @enum {string}
 */
const sourceBooks = {};

var rules$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ruleTypes: ruleTypes,
	rules: rules,
	sourceBooks: sourceBooks
});

/**
 * Highest circle of spellcasting.
 * @type {number}
 */
const maxSpellCircle = 9;

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for different types of spellcasting supported.
 *
 * @typedef {LabeledConfiguration} SpellcastingTypeConfiguration
 * @property {string} [trait] - How this progression will be displayed in a trait list, if no progression trait set.
 * @property {Record<string, SpellcastingProgressionConfiguration>} [progression] - Progression modes for this type.
 * @property {Set<string>|boolean} [learningModes] - What learning modes can be used with this spellcasting type?
 */

/**
 * Configuration data for a spellcasting progression mode.
 *
 * @typedef {LabeledConfiguration} SpellcastingProgressionConfiguration
 * @property {string} [trait] - How this progression will be displayed in a trait list.
 * @property {number} [divisor=1] - Value by which the class levels are divided to determine spellcasting level.
 * @property {boolean} [roundUp=false] - Should fractional values should be rounded up by default?
 */

/**
 * Different spellcasting types and their progression.
 * @type {SpellcastingTypeConfiguration}
 */
const spellcastingTypes = {
	leveled: {
		label: "BF.Spellcasting.Type.Leveled.Label",
		trait: "BF.Spellcasting.Type.Trait",
		progression: {
			full: {
				label: "BF.Spellcasting.Progression.Full.Label",
				divisor: 1
			},
			half: {
				label: "BF.Spellcasting.Progression.Half.Label",
				trait: "BF.Spellcasting.Progression.Half.Trait",
				divisor: 2
			},
			third: {
				label: "BF.Spellcasting.Progression.Third.Label",
				trait: "BF.Spellcasting.Progression.Third.Trait",
				divisor: 3
			}
		}
	},
	pact: {
		label: "BF.Spellcasting.Type.Pact.Label",
		trait: "BF.Spellcasting.Type.Pact.Trait"
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Components that can be required by spells.
 * @enum {AbbreviatedConfiguration}
 */
const spellComponents = {
	verbal: {
		label: "BF.Spell.Component.Verbal.Label",
		abbreviation: "BF.Spell.Component.Verbal.Abbreviation",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.W1SxhcKBlrC3j8bI"
	},
	somatic: {
		label: "BF.Spell.Component.Somatic.Label",
		abbreviation: "BF.Spell.Component.Somatic.Abbreviation",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.VO8PLFNF1WHN6exu"
	},
	material: {
		label: "BF.Spell.Component.Material.Label",
		abbreviation: "BF.Spell.Component.Material.Abbreviation",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.wLWe4finRmO658xK"
	}
};
localizeConfig(spellComponents, { sort: false });
localizeConfig(spellComponents, { labelKeyPath: "abbreviation", propertyName: "localizedAbbreviations", sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for ways to learn spells.
 *
 * @typedef {LabeledConfiguration} SpellLearningModeConfiguration
 * @property {boolean} [prepared] - Does this learning mode need to learn spells?
 */

/**
 * Different ways in which a character can learn spells as they level up.
 * @type {SpellLearningModeConfiguration}
 */
const spellLearningModes = {
	all: {
		label: "BF.Spellcasting.Learning.Mode.All.Label",
		hint: "BF.Spellcasting.Learning.Mode.All.Hint",
		prepared: true
	},
	limited: {
		label: "BF.Spellcasting.Learning.Mode.Limited.Label",
		hint: "BF.Spellcasting.Learning.Mode.Limited.Hint"
	},
	spellbook: {
		label: "BF.Spellcasting.Learning.Mode.Spellbook.Label",
		hint: "BF.Spellcasting.Learning.Mode.Spellbook.Hint",
		prepared: true
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for spell preparation modes.
 *
 * @typedef {LabeledConfiguration} SpellPreparationConfiguration
 * @property {boolean} [preparable] - Can this spell be prepared?
 * @property {boolean} [scalable] - Can spells with this mode be scaled?
 */

/**
 * Spell preparation modes.
 * @type {SpellPreparationConfiguration}
 */
const spellPreparationModes = {
	standard: {
		label: "BF.Spell.Preparation.Mode.Standard",
		preparable: true,
		scalable: true
	},
	pact: {
		label: "BF.Spell.Preparation.Mode.Pact",
		scalable: true
	},
	atWill: {
		label: "BF.Spell.Preparation.Mode.AtWill"
	},
	innate: {
		label: "BF.Spell.Preparation.Mode.Innate"
	}
};
localizeConfig(spellPreparationModes, { sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Number of spell slots per-circle for each spellcasting level. First set of indices correspond to spellcaster level
 * and the second correspond to circles.
 * @type {number[][]}
 */
const spellSlotTable = [
	// 1  2  3  4  5
	[],
	[, 2], // Level 1
	[, 3], // Level 2
	[, 4, 2], // Level 3
	[, 4, 3], // Level 4
	[, 4, 3, 2], // Level 5
	[, 4, 3, 3], // Level 6
	[, 4, 3, 3, 1], // Level 7
	[, 4, 3, 3, 2], // Level 8
	[, 4, 3, 3, 3, 1], // Level 9
	[, 4, 3, 3, 3, 2], // Level 10
	// 1  2  3  4  5  6  7  8  9
	[, 4, 3, 3, 3, 2, 1], // Level 11
	[, 4, 3, 3, 3, 2, 1], // Level 12
	[, 4, 3, 3, 3, 2, 1, 1], // Level 13
	[, 4, 3, 3, 3, 2, 1, 1], // Level 14
	[, 4, 3, 3, 3, 2, 1, 1, 1], // Level 15
	[, 4, 3, 3, 3, 2, 1, 1, 1], // Level 16
	[, 4, 3, 3, 3, 2, 1, 1, 1, 1], // Level 17
	[, 4, 3, 3, 3, 3, 1, 1, 1, 1], // Level 18
	[, 4, 3, 3, 3, 3, 2, 1, 1, 1], // Level 19
	[, 4, 3, 3, 3, 3, 2, 1, 1, 1] // Level 20
];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * List of spell circles with localized names.
 * @param {object} [options={}]
 * @param {boolean} [options.dashed=false] - Should there be a dash between the number and word?
 * @param {boolean} [options.formOptions=false] - Return as form options rather than an object.
 * @param {boolean} [options.plural=false] - Return the plural names where relevant.
 * @param {boolean} [options.includeCantrip=true] - Should cantrips be included with other circles?
 * @returns {Record<number, string>|FormSelectOption[]}
 */
function spellCircles({ dashed = false, formOptions = false, plural = false, includeCantrip = true } = {}) {
	const obj = Array.fromRange(maxSpellCircle + Number(includeCantrip), Number(!includeCantrip)).reduce((obj, l) => {
		if (l === 0) obj[l] = game.i18n.localize(`BF.Spell.Circle.Cantrip[${plural ? "other" : "one"}]`);
		else
			obj[l] = game.i18n.format(`BF.Spell.Circle.Level${dashed ? "Dashed" : ""}`, {
				number: numberFormat(l, { ordinal: true })
			});
		return obj;
	}, {});
	return formOptions ? Object.entries(obj).map(([value, label]) => ({ value, label })) : obj;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Different schools to which a spell can belong.
 * @enum {LabeledConfiguration}
 */
const spellSchools = {
	abjuration: {
		label: "BF.Spell.School.Abjuration.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.DcoTpX7y2OtoUFrL"
	},
	conjuration: {
		label: "BF.Spell.School.Conjuration.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.zDbDUgVoYHwwMdUd"
	},
	divination: {
		label: "BF.Spell.School.Divination.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.40jPfp8PbmjhJfgS"
	},
	enchantment: {
		label: "BF.Spell.School.Enchantment.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.XxEvnr7eyY4g7m7M"
	},
	evocation: {
		label: "BF.Spell.School.Evocation.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.kxX9JTanZWJkEzpc"
	},
	illusion: {
		label: "BF.Spell.School.Illusion.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.PaxaHveatHiNGdSY"
	},
	necromancy: {
		label: "BF.Spell.School.Necromancy.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.cWCZy1b9fvechVL1"
	},
	transmutation: {
		label: "BF.Spell.School.Transmutation.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.TQXdW6aA3LjO10Ol"
	}
};
localizeConfig(spellSchools);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Spellcasting sources to which a spell can belong.
 * @enum {LabeledConfiguration}
 */
const spellSources = {
	arcane: {
		label: "BF.Spell.Source.Arcane.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.SM8bmpPSa9muCW30"
	},
	divine: {
		label: "BF.Spell.Source.Divine.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.sq1yhbfrrTAqw5c5"
	},
	primordial: {
		label: "BF.Spell.Source.Primordial.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.Egu3TijvCVrn6NxR"
	},
	wyrd: {
		label: "BF.Spell.Source.Wyrd.Label",
		reference: "Compendium.black-flag.rules.JournalEntry.zHvTHITijHvb07FK.JournalEntryPage.n0wni0OGVRyrenVZ"
	}
};
localizeConfig(spellSources);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Tags that can be attached to spells.
 * @enum {AbbreviatedConfiguration}
 */
const spellTags = {
	concentration: {
		label: "BF.Spell.Tag.Concentration.Label",
		abbreviation: "BF.Spell.Tag.Concentration.Abbreviation"
	},
	ritual: {
		label: "BF.Spell.Tag.Ritual.Label",
		abbreviation: "BF.Spell.Tag.Ritual.Abbreviation"
	}
};
localizeConfig(spellTags);

var spellcasting = /*#__PURE__*/Object.freeze({
	__proto__: null,
	maxSpellCircle: maxSpellCircle,
	spellCircles: spellCircles,
	spellComponents: spellComponents,
	spellLearningModes: spellLearningModes,
	spellPreparationModes: spellPreparationModes,
	spellSchools: spellSchools,
	spellSlotTable: spellSlotTable,
	spellSources: spellSources,
	spellTags: spellTags,
	spellcastingTypes: spellcastingTypes
});

/**
 * Information needed to represent different area of effect target types.
 *
 * @typedef {LocalizedConfiguration} AreaTargetDefinition
 * @property {string} template - Type of `MeasuredTemplate` create for this target type.
 * @property {string[]} sizes - Sizes that can be configured for this template. Can be any of "length", "width",
 *                              "height", or "radius".
 */

/**
 * Types of area of effect targeting.
 * @enum {AreaOfEffectConfiguration}
 */
const areaOfEffectTypes = {
	circle: {
		localization: "BF.AreaOfEffect.Type.Circle.Label",
		icon: "systems/black-flag/artwork/interface/area/circle.svg",
		template: "circle",
		sizes: ["radius"]
	},
	cone: {
		localization: "BF.AreaOfEffect.Type.Cone.Label",
		icon: "systems/black-flag/artwork/interface/area/cone.svg",
		template: "cone",
		sizes: ["length"]
	},
	cube: {
		localization: "BF.AreaOfEffect.Type.Cube.Label",
		icon: "systems/black-flag/artwork/interface/area/cube.svg",
		template: "ray",
		sizes: ["width"]
	},
	cylinder: {
		localization: "BF.AreaOfEffect.Type.Cylinder.Label",
		icon: "systems/black-flag/artwork/interface/area/cylinder.svg",
		template: "circle",
		sizes: ["radius", "height"]
	},
	line: {
		localization: "BF.AreaOfEffect.Type.Line.Label",
		icon: "systems/black-flag/artwork/interface/area/line.svg",
		template: "ray",
		sizes: ["length", "width"]
	},
	radius: {
		localization: "BF.AreaOfEffect.Type.Radius.Label",
		icon: "systems/black-flag/artwork/interface/area/radius.svg",
		template: "circle",
		sizes: ["radius"]
	},
	sphere: {
		localization: "BF.AreaOfEffect.Type.Sphere.Label",
		icon: "systems/black-flag/artwork/interface/area/sphere.svg",
		template: "circle",
		sizes: ["radius"]
	},
	square: {
		localization: "BF.AreaOfEffect.Type.Square.Label",
		icon: "systems/black-flag/artwork/interface/area/square.svg",
		template: "rect",
		sizes: ["width"]
	},
	wall: {
		localization: "BF.AreaOfEffect.Type.Wall.Label",
		icon: "systems/black-flag/artwork/interface/area/wall.svg",
		template: "ray",
		sizes: ["length", "thickness", "height"]
	}
	// TODO: Consider adding ring w/ thickness
	// TODO: Consider adding dome w/ height & thickness
};
localizeConfig(areaOfEffectTypes);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Types of ranges that can be defined on items.
 * @enum {LabeledConfiguration}
 */
const rangeTypes = {
	self: {
		label: "BF.RANGE.Type.Self.Label"
	},
	touch: {
		label: "BF.RANGE.Type.Touch.Label"
	},
	sight: {
		label: "BF.RANGE.Type.Sight.Label"
	},
	special: {
		label: "BF.RANGE.Type.Special.Label"
	},
	any: {
		label: "BF.RANGE.Type.Any.Label"
	}
};
localizeConfig(rangeTypes);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Types of targets that can be affected by a spell or feature.
 * @enum {LocalizedConfiguration}
 */
const targetTypes = {
	creature: {
		localization: "BF.TARGET.Type.Creature.Label"
	},
	ally: {
		localization: "BF.TARGET.Type.Ally.Label"
	},
	enemy: {
		localization: "BF.TARGET.Type.Enemy.Label"
	},
	willing: {
		localization: "BF.TARGET.Type.WillingCreature.Label"
	},
	creatureObject: {
		localization: "BF.TARGET.Type.CreatureObject.Label"
	},
	object: {
		localization: "BF.TARGET.Type.Object.Label"
	},
	objectNotWorn: {
		localization: "BF.TARGET.Type.ObjectNotWorn.Label"
	},
	special: {
		label: "BF.TARGET.Type.Special.Label"
	}
};
localizeConfig(targetTypes, { sort: false });

var targeting = /*#__PURE__*/Object.freeze({
	__proto__: null,
	areaOfEffectTypes: areaOfEffectTypes,
	rangeTypes: rangeTypes,
	targetTypes: targetTypes
});

/**
 * Types of tools offered by the system.
 * @enum {NestedLinkedConfiguration}
 */
const tools = {
	alchemist: {
		label: "BF.Tool.Type.AlchemistsTools",
		link: "Compendium.black-flag.items.Item.klz44oS9m4omG4eG"
	},
	artist: {
		label: "BF.Tool.Type.ArtistTools",
		link: "Compendium.black-flag.items.Item.lTlzI4osF7eGrLeY"
	},
	charlatan: {
		label: "BF.Tool.Type.CharlatanTools",
		link: "Compendium.black-flag.items.Item.1isXFPSnVUYm2qaQ"
	},
	clothier: {
		label: "BF.Tool.Type.ClothierTools",
		link: "Compendium.black-flag.items.Item.42AxnVcNl4R5WZj6"
	},
	construction: {
		label: "BF.Tool.Type.ConstructionTools",
		link: "Compendium.black-flag.items.Item.SDHvjOXW8MCnj54h"
	},
	gaming: {
		localization: "BF.Tool.Category.GamingSet",
		children: {
			dice: {
				label: "BF.Tool.Type.DiceSet",
				link: "Compendium.black-flag.items.Item.BI9JyierXbSWY3ra"
			},
			card: {
				label: "BF.Tool.Type.CardSet",
				link: "Compendium.black-flag.items.Item.Q7MSeHGCKue2HJha"
			}
		}
	},
	smithing: {
		label: "BF.Tool.Type.SmithingTools",
		link: "Compendium.black-flag.items.Item.fKjUrqM49opM4ps5"
	},
	herbalist: {
		label: "BF.Tool.Type.HerbalistTools",
		link: "Compendium.black-flag.items.Item.mhgW4NnKHq3Vy1nL"
	},
	musicalInstrument: {
		localization: "BF.Tool.Category.MusicalInstrument",
		children: {
			bagpipes: {
				label: "BF.Tool.Type.Bagpipes",
				link: "Compendium.black-flag.items.Item.vWJIN3enB9IwOmLa"
			},
			drum: {
				label: "BF.Tool.Type.Drum",
				link: "Compendium.black-flag.items.Item.HlPUKSzchiQQ8nXl"
			},
			flute: {
				label: "BF.Tool.Type.Flute",
				link: "Compendium.black-flag.items.Item.r4pkxm6VaV5jK3tQ"
			},
			lute: {
				label: "BF.Tool.Type.Lute",
				link: "Compendium.black-flag.items.Item.wmeF325yhWOASJki"
			},
			lyre: {
				label: "BF.Tool.Type.Lyre",
				link: "Compendium.black-flag.items.Item.mUhO214yHXAMN3W0"
			},
			horn: {
				label: "BF.Tool.Type.Horn",
				link: "Compendium.black-flag.items.Item.5gz3GKKchBFXOjj4"
			}
		}
	},
	navigator: {
		label: "BF.Tool.Type.NavigatorTools",
		link: "Compendium.black-flag.items.Item.2TuWsCp00Sbgaer3"
	},
	provisioner: {
		label: "BF.Tool.Type.ProvisionerTools",
		link: "Compendium.black-flag.items.Item.poBCR3CoQsHVKxU9"
	},
	trapper: {
		label: "BF.Tool.Type.TrapperTools",
		link: "Compendium.black-flag.items.Item.AwkFxBWOGLP5de8W"
	},
	thieves: {
		label: "BF.Tool.Type.ThievesTools",
		link: "Compendium.black-flag.items.Item.cNWGEyGSVCYKxmCg"
	},
	tinker: {
		label: "BF.Tool.Type.TinkerTools",
		link: "Compendium.black-flag.items.Item.02Se8KL2vaL2BF5s"
	}
};
localizeConfig(tools, { pluralRule: "other" });
localizeConfig(tools.gaming.children);
localizeConfig(tools.musicalInstrument.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Properties that can be applied to tools.
 * @type {string[]}
 */
const toolProperties = ["magical"];

var tools$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	toolProperties: toolProperties,
	tools: tools
});

/**
 * Configuration data for traits that apply to actors.
 *
 * @typedef {object} TraitConfiguration
 * @property {object} labels
 * @property {string} labels.title - Title for this trait type.
 * @property {string} labels.localization - Pluralizable localization key for selected entries.
 * @property {string} icon - Path to the icon used to represent this trait.
 * @property {string} type - If this a proficiency or trait.
 * @property {boolean} [expertise=false] - Does this proficiency support expertise?
 * @property {string} [format] - Is the proficiency data stored in a "simple" format (set of string, like weapons)
 *                               or "complex" format (object with proficiency, like skills or tools).
 * @property {string} [labelKeyPath="label"] - If config is an enum of objects, where can the label be found?
 * @property {string} [actorKeyPath] - Key path to this trait on the actor, if it isn't `traits.{name}` for traits
 *                                     or `proficiencies.{name}` for proficiencies.
 * @property {string} [configKey] - Key of the trait options if it isn't the same as the trait name.
 * @property {boolean} [sortCategories=true] - Should top-level categories should be sorted?
 */

/**
 * Configuration data for actor traits.
 * @enum {TraitConfiguration}
 */
const traits = {
	armor: {
		labels: {
			title: "BF.Armor.Label[other]",
			localization: "BF.Armor.Label"
		},
		icon: "systems/black-flag/artwork/traits/armor.svg",
		type: "proficiency",
		sortCategories: false
	},
	weapons: {
		labels: {
			title: "BF.WEAPON.Label[other]",
			localization: "BF.WEAPON.Label"
		},
		icon: "systems/black-flag/artwork/traits/weapons.svg",
		type: "proficiency",
		sortCategories: false
	},
	tools: {
		labels: {
			title: "BF.Tool.Label[other]",
			localization: "BF.Tool.Label"
		},
		icon: "systems/black-flag/artwork/traits/tools.svg",
		type: "proficiency",
		expertise: true,
		format: "complex"
	},
	vehicles: {
		labels: {
			title: "BF.VEHICLE.Label[other]",
			localization: "BF.VEHICLE.Label"
		},
		icon: "systems/black-flag/artwork/traits/vehicles.svg",
		type: "proficiency",
		expertise: true,
		format: "complex"
	},
	saves: {
		labels: {
			title: "BF.SavingThrow.LabelLong[other]",
			localization: "BF.Ability.Label"
		},
		localization: "BF.SavingThrow.LabelLong",
		icon: "systems/black-flag/artwork/traits/saves.svg",
		type: "proficiency",
		format: "complex",
		labelKeyPath: "labels.full",
		actorKeyPath: "system.abilities",
		configKey: "abilities"
	},
	skills: {
		labels: {
			title: "BF.Skill.Label[other]",
			localization: "BF.Skill.Label"
		},
		icon: "systems/black-flag/artwork/traits/skills.svg",
		type: "proficiency",
		expertise: true,
		format: "complex"
	},
	languages: {
		labels: {
			title: "BF.Language.Label[other]",
			localization: "BF.Language.Label"
		},
		icon: "systems/black-flag/artwork/traits/languages.svg",
		type: "proficiency",
		sortCategories: false
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                       Languages                       */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Standard languages provided by the system.
 * @enum {NestedTypeConfiguration}
 */
const languages = {
	standard: {
		localization: "BF.Language.Category.Standard",
		children: {
			common: {
				label: "BF.Language.Dialect.Common"
			},
			dwarvish: {
				label: "BF.Language.Dialect.Dwarvish"
			},
			elvish: {
				label: "BF.Language.Dialect.Elvish"
			},
			giant: {
				label: "BF.Language.Dialect.Giant"
			},
			gnomish: {
				label: "BF.Language.Dialect.Gnomish"
			},
			goblin: {
				label: "BF.Language.Dialect.Goblin"
			},
			halfling: {
				label: "BF.Language.Dialect.Halfling"
			},
			orcish: {
				label: "BF.Language.Dialect.Orcish"
			}
		}
	},
	esoteric: {
		localization: "BF.Language.Category.Esoteric",
		children: {
			abyssal: {
				label: "BF.Language.Dialect.Abyssal"
			},
			celestial: {
				label: "BF.Language.Dialect.Celestial"
			},
			draconic: {
				label: "BF.Language.Dialect.Draconic"
			},
			infernal: {
				label: "BF.Language.Dialect.Infernal"
			},
			machineSpeech: {
				label: "BF.Language.Dialect.MachineSpeech"
			},
			primordial: {
				label: "BF.Language.Dialect.Primordial",
				localization: "BF.Language.Category.Primordial",
				selectableCategory: true,
				children: {
					aquan: {
						label: "BF.Language.Dialect.Aquan"
					},
					auran: {
						label: "BF.Language.Dialect.Auran"
					},
					ignan: {
						label: "BF.Language.Dialect.Ignan"
					},
					terran: {
						label: "BF.Language.Dialect.Terran"
					}
				}
			},
			sylvan: {
				label: "BF.Language.Dialect.Sylvan"
			},
			undercommon: {
				label: "BF.Language.Dialect.Undercommon"
			},
			voidSpeech: {
				label: "BF.Language.Dialect.VoidSpeech"
			}
		}
	},
	secret: {
		localization: "BF.Language.Category.Secret",
		children: {
			druidic: {
				label: "BF.Language.Dialect.Druidic"
			},
			thievesCant: {
				label: "BF.Language.Dialect.ThievesCant"
			}
		}
	}
};
localizeConfig(languages, { flatten: true, keepCategories: c => !!c.label });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Tags the describe additional details of a character's communication.
 * @enum {TraitTagConfiguration}
 */
const languageTags = {
	cantSpeak: {
		label: "BF.Language.Tag.CantSpeak.Label",
		display: "BF.Language.Tag.CantSpeak.Formatter",
		type: "formatter"
	},
	knownInLife: {
		label: "BF.Language.Tag.KnownInLife.Label",
		display: "BF.Language.Tag.KnownInLife.Display",
		type: "inline"
	}
};
localizeConfig(languageTags);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Communication modes that have an associated distance.
 * @enum {LabeledConfiguration}
 */
const rangedCommunication = {
	telepathy: {
		label: "BF.Language.Communication.Telepathy"
	}
};
localizeConfig(rangedCommunication);

var traits$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	languageTags: languageTags,
	languages: languages,
	rangedCommunication: rangedCommunication,
	traits: traits
});

/**
 * List of attribute key paths that can be consumed by Actor type. Auto-populated during the setup stage.
 * @enum {string[]}
 */
const consumableResources = [];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration information for activity consumption types.
 *
 * @typedef {LabeledConfiguration} ConsumptionTypeConfiguration
 * @property {ConsumptionConsumeFunction} consume               Function used to consume according to this type.
 * @property {ConsumptionLabelsFunction} consumptionLabels      Function used to generate a hint of consumption amount.
 * @property {LabeledConfiguration} [scalingModes] - Consumption parts that can be scaled.
 * @property {boolean} [targetRequiresEmbedded] - Display text input rather than limited options when not embedded.
 * @property {ConsumptionValidTargetsFunction} [validTargets] - Function used to build list of targets for this type.
 */

/**
 * @callback ConsumptionConsumeFunction
 * @this {ConsumptionTargetData}
 * @param {ActivityUseConfiguration} config - Configuration data for the activity usage.
 * @param {ActivityUsageUpdates} updates - Updates to be performed.
 * @throws ConsumptionError
 */

/**
 * @callback ConsumptionLabelsFunction
 * @this {ConsumptionTargetData}
 * @param {ActivityUseConfiguration} config - Configuration data for the activity usage.
 * @param {boolean} consumed - Is this consumption currently set to be consumed?
 * @returns {ConsumptionLabels}
 */

/**
 * @callback ConsumptionValidTargetsFunction
 * @this {ConsumptionTargetData}
 * @returns {FormSelectOption[]} - Valid targets.
 */

/**
 * Types of resource consumption that can be used on activities.
 * @enum {ConsumptionTypeConfiguration}
 */
const consumptionTypes = {
	activity: {
		label: "BF.CONSUMPTION.Type.ActivityUses.Label",
		prompt: "BF.CONSUMPTION.Type.ActivityUses.Prompt",
		consume: ConsumptionTargetData.consumeActivityUses,
		consumptionLabels: ConsumptionTargetData.consumptionLabelsActivityUses
	},
	item: {
		label: "BF.CONSUMPTION.Type.ItemUses.Label",
		prompt: "BF.CONSUMPTION.Type.ItemUses.Prompt",
		consume: ConsumptionTargetData.consumeItemUses,
		consumptionLabels: ConsumptionTargetData.consumptionLabelsItemUses,
		targetRequiresEmbedded: true,
		validTargets: ConsumptionTargetData.validItemUsesTargets
	},
	attribute: {
		label: "BF.CONSUMPTION.Type.Attribute.Label",
		prompt: "BF.CONSUMPTION.Type.Attribute.Prompt",
		consume: ConsumptionTargetData.consumeAttribute,
		consumptionLabels: ConsumptionTargetData.consumptionLabelsAttribute,
		validTargets: ConsumptionTargetData.validAttributeTargets
	},
	hitDice: {
		label: "BF.CONSUMPTION.Type.HitDice.Label",
		prompt: "BF.CONSUMPTION.Type.HitDice.Prompt",
		consume: ConsumptionTargetData.consumeHitDice,
		consumptionLabels: ConsumptionTargetData.consumptionLabelsHitDice,
		validTargets: ConsumptionTargetData.validHitDiceTargets
	},
	spellSlots: {
		label: "BF.CONSUMPTION.Type.SpellSlots.Label",
		prompt: "BF.CONSUMPTION.Type.SpellSlots.Prompt",
		consume: ConsumptionTargetData.consumeSpellSlots,
		consumptionLabels: ConsumptionTargetData.consumptionLabelsSpellSlots,
		scalingModes: {
			circle: {
				label: "BF.Consumption.Scaling.Mode.Circle"
			}
		},
		validTargets: ConsumptionTargetData.validSpellSlotsTargets
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Configuration data for item usage recovery periods.
 *
 * @typedef {AbbreviatedConfiguration} RecoveryPeriodConfiguration
 * @property {string} [npcLabel] - Optional alternative label used to display recovery period on NPC sheets.
 * @property {boolean} [combatOnly=false] - Is this period only consumed during a combat encounter?
 * @property {string} [group] - Localizable label for the group.
 */

/**
 * At what point are an item's resources recovered?
 * @enum {RecoveryPeriodConfiguration}
 */
const recoveryPeriods = {
	longRest: {
		label: "BF.Rest.Type.Long.Label",
		npcLabel: "BF.Time.Unit.Day.Label[one]",
		abbreviation: "BF.Rest.Type.Long.Abbreviation",
		group: "BF.Recovery.Group.Rest"
	},
	shortRest: {
		label: "BF.Rest.Type.Short.Label",
		abbreviation: "BF.Rest.Type.Short.Abbreviation",
		group: "BF.Recovery.Group.Rest"
	},
	encounter: {
		label: "BF.Recovery.Period.Encounter",
		abbreviation: "BF.Recovery.Period.Encounter",
		combatOnly: true,
		group: "BF.Recovery.Group.Combat"
	},
	round: {
		label: "BF.Recovery.Period.Round",
		abbreviation: "BF.Recovery.Period.Round",
		combatOnly: true,
		group: "BF.Recovery.Group.Combat"
	},
	turn: {
		label: "BF.Recovery.Period.Turn",
		abbreviation: "BF.Recovery.Period.Turn",
		combatOnly: true,
		group: "BF.Recovery.Group.Combat"
	},
	day: {
		label: "BF.Recovery.Period.Day",
		abbreviation: "BF.Recovery.Period.Day",
		group: "BF.Recovery.Group.Time"
	},
	dawn: {
		label: "BF.Recovery.Period.Dawn",
		abbreviation: "BF.Recovery.Period.Dawn",
		group: "BF.Recovery.Group.Time"
	},
	dusk: {
		label: "BF.Recovery.Period.Dusk",
		abbreviation: "BF.Recovery.Period.Dusk",
		group: "BF.Recovery.Group.Time"
	}
};
localizeConfig(recoveryPeriods, { labelKeyPath: "label", sort: false });
localizeConfig(recoveryPeriods, { labelKeyPath: "abbreviation", propertyName: "localizedAbbreviations", sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Types of usage recovery.
 * @enum {LabeledConfiguration}
 */
const recoveryTypes = {
	recoverAll: {
		label: "BF.Recovery.Type.RecoverAll"
	},
	loseAll: {
		label: "BF.Recovery.Type.LoseAll"
	},
	formula: {
		label: "BF.Recovery.Type.Formula"
	}
};

var usage = /*#__PURE__*/Object.freeze({
	__proto__: null,
	consumableResources: consumableResources,
	consumptionTypes: consumptionTypes,
	recoveryPeriods: recoveryPeriods,
	recoveryTypes: recoveryTypes
});

/**
 * Types of vehicles offered by the system.
 * @enum {NestedTypeConfiguration}
 */
const vehicles = {
	air: {
		localization: "BF.VEHICLE.Category.Air"
	},
	land: {
		localization: "BF.VEHICLE.Category.Land"
	},
	water: {
		localization: "BF.VEHICLE.Category.Water"
	}
};
localizeConfig(vehicles);
localizeConfig(vehicles, { pluralRule: "other", propertyName: "localizedPlural" });

var vehicles$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	vehicles: vehicles
});

/**
 * Modes that can be used when attacking.
 * @typedef {LabeledConfiguration}
 */
const attackModes = {
	oneHanded: {
		label: "BF.ATTACK.Mode.OneHanded"
	},
	twoHanded: {
		label: "BF.ATTACK.Mode.TwoHanded"
	},
	offhand: {
		label: "BF.ATTACK.Mode.Offhand"
	},
	thrown: {
		label: "BF.ATTACK.Mode.Thrown"
	},
	thrownOffhand: {
		label: "BF.ATTACK.Mode.ThrownOffhand"
	}
};
localizeConfig(attackModes, { sort: false });

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Types of weapons offered by the system.
 * @enum {NestedLinkedConfiguration}
 */
const weapons = {
	simple: {
		label: "BF.WEAPON.Category.Simple",
		localization: "BF.WEAPON.Category.Simple",
		children: {
			// Simple Melee
			club: {
				label: "BF.WEAPON.Base.Club",
				type: "melee",
				link: "Compendium.black-flag.items.Item.WhFDR7nOBaBhhwmp"
			},
			dagger: {
				label: "BF.WEAPON.Base.Dagger",
				type: "melee",
				link: "Compendium.black-flag.items.Item.3bEIZYDB4eMayC6k"
			},
			greatclub: {
				label: "BF.WEAPON.Base.Greatclub",
				type: "melee",
				link: "Compendium.black-flag.items.Item.QAPscsGRbv5l778n"
			},
			handaxe: {
				label: "BF.WEAPON.Base.Handaxe",
				type: "melee",
				link: "Compendium.black-flag.items.Item.y6xWtgpXkPkn8cqO"
			},
			javelin: {
				label: "BF.WEAPON.Base.Javelin",
				type: "melee",
				link: "Compendium.black-flag.items.Item.8wAd9MmtaW1tizSN"
			},
			lightHammer: {
				label: "BF.WEAPON.Base.LightHammer",
				type: "melee",
				link: "Compendium.black-flag.items.Item.JBfKqjO5hbNcX6zN"
			},
			mace: {
				label: "BF.WEAPON.Base.Mace",
				type: "melee",
				link: "Compendium.black-flag.items.Item.XOrCLbriQXUoLCTL"
			},
			quarterstaff: {
				label: "BF.WEAPON.Base.Quarterstaff",
				type: "melee",
				link: "Compendium.black-flag.items.Item.B5J4heAlwqhvzXKW"
			},
			sickle: {
				label: "BF.WEAPON.Base.Sickle",
				type: "melee",
				link: "Compendium.black-flag.items.Item.MLfeXpp9ZSPKrB7w"
			},
			spear: {
				label: "BF.WEAPON.Base.Spear",
				type: "melee",
				link: "Compendium.black-flag.items.Item.eG0Vk1Kr8peAAYhW"
			},
			// Simple Ranged
			lightCrossbow: {
				label: "BF.WEAPON.Base.CrossbowLight",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.Zu15sMMg2KvxhA3e"
			},
			dart: {
				label: "BF.WEAPON.Base.Dart",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.14pCY7bJYfjnSZqB"
			},
			pistol: {
				label: "BF.WEAPON.Base.Pistol",
				type: "ranged",
				rules: "firearms"
			},
			shortbow: {
				label: "BF.WEAPON.Base.Shortbow",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.Zu15sMMg2KvxhA3e"
			},
			sling: {
				label: "BF.WEAPON.Base.Sling",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.QoMwONkjb7knNonO"
			}
		}
	},
	martial: {
		label: "BF.WEAPON.Category.Martial",
		localization: "BF.WEAPON.Category.Martial",
		children: {
			// Martial Melee
			battleaxe: {
				label: "BF.WEAPON.Base.Battleaxe",
				type: "melee",
				link: "Compendium.black-flag.items.Item.bDVnEZSy0tcZg0js"
			},
			flail: {
				label: "BF.WEAPON.Base.Flail",
				type: "melee",
				link: "Compendium.black-flag.items.Item.eEVYQ21cIi97CRl1"
			},
			glaive: {
				label: "BF.WEAPON.Base.Glaive",
				type: "melee",
				link: "Compendium.black-flag.items.Item.caf9G1uCz7agcoym"
			},
			greataxe: {
				label: "BF.WEAPON.Base.Greataxe",
				type: "melee",
				link: "Compendium.black-flag.items.Item.9EAkaGqWPK0qFoDq"
			},
			greatsword: {
				label: "BF.WEAPON.Base.Greatsword",
				type: "melee",
				link: "Compendium.black-flag.items.Item.LG9czlXCwzBSmWR4"
			},
			halberd: {
				label: "BF.WEAPON.Base.Halberd",
				type: "melee",
				link: "Compendium.black-flag.items.Item.PV6JskvwVJ9BVvQb"
			},
			lance: {
				label: "BF.WEAPON.Base.Lance",
				type: "melee",
				link: "Compendium.black-flag.items.Item.vDPNvqRkuKnzAbvR"
			},
			longsword: {
				label: "BF.WEAPON.Base.Longsword",
				type: "melee",
				link: "Compendium.black-flag.items.Item.ym1owWiMSNOcZNdO"
			},
			maul: {
				label: "BF.WEAPON.Base.Maul",
				type: "melee",
				link: "Compendium.black-flag.items.Item.WWJHSzi0T466vB3o"
			},
			morningstar: {
				label: "BF.WEAPON.Base.Morningstar",
				type: "melee",
				link: "Compendium.black-flag.items.Item.zWBmus194O0RLxeU"
			},
			pike: {
				label: "BF.WEAPON.Base.Pike",
				type: "melee",
				link: "Compendium.black-flag.items.Item.ib6aTaDTjlnG3m54"
			},
			rapier: {
				label: "BF.WEAPON.Base.Rapier",
				type: "melee",
				link: "Compendium.black-flag.items.Item.pcyyBxMi5naeXbSt"
			},
			scimitar: {
				label: "BF.WEAPON.Base.Scimitar",
				type: "melee",
				link: "Compendium.black-flag.items.Item.MwYjehTr9oJlHb1Z"
			},
			scythe: {
				label: "BF.WEAPON.Base.Scythe",
				type: "melee",
				link: "Compendium.black-flag.items.Item.4diYN02TlcURqvK3"
			},
			shortsword: {
				label: "BF.WEAPON.Base.Shortsword",
				type: "melee",
				link: "Compendium.black-flag.items.Item.C9nwbmL7uTX8t8nr"
			},
			trident: {
				label: "BF.WEAPON.Base.Trident",
				type: "melee",
				link: "Compendium.black-flag.items.Item.KOE2ZOUMtbY0OkS9"
			},
			warPick: {
				label: "BF.WEAPON.Base.WarPick",
				type: "melee",
				link: "Compendium.black-flag.items.Item.EcuWrcnF6FY79arQ"
			},
			warhammer: {
				label: "BF.WEAPON.Base.Warhammer",
				type: "melee",
				link: "Compendium.black-flag.items.Item.E7IJC52xWk7Utk4p"
			},
			whip: {
				label: "BF.WEAPON.Base.Whip",
				type: "melee",
				link: "Compendium.black-flag.items.Item.teX6pEUhupO8LBTu"
			},
			// Martial Ranged
			arquebus: {
				label: "BF.WEAPON.Base.Arquebus",
				type: "ranged",
				rules: "firearms"
			},
			blowgun: {
				label: "BF.WEAPON.Base.Blowgun",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.5jfXHBmPqbspahJk"
			},
			blunderbuss: {
				label: "BF.WEAPON.Base.Blunderbuss",
				type: "ranged",
				rules: "firearms"
			},
			handCrossbow: {
				label: "BF.WEAPON.Base.CrossbowHand",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.b126bs62p8TQIYZ8"
			},
			heavyCrossbow: {
				label: "BF.WEAPON.Base.CrossbowHeavy",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.Z8Wz5qUi16C36QQd"
			},
			longbow: {
				label: "BF.WEAPON.Base.Longbow",
				type: "ranged",
				link: "Compendium.black-flag.items.Item.IpWwpPrnKuwHQpVw"
			},
			musket: {
				label: "BF.WEAPON.Base.Musket",
				type: "ranged",
				rules: "firearms"
			},
			revolvingMusket: {
				label: "BF.WEAPON.Base.RevolvingMusket",
				type: "ranged",
				rules: "firearms"
			}
		}
	}
};
localizeConfig(weapons, { sort: false });
localizeConfig(weapons, { flatten: true, propertyName: "allLocalized" });
localizeConfig(weapons.simple.children);
localizeConfig(weapons.martial.children);

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * @typedef {LabeledConfiguration} WeaponOptionConfiguration
 * @property {string} [rules] - Rules setting category that allows these options to be toggled by GM.
 */

/**
 * Alternate actions that can be taken with weapons.
 * @enum {LabeledConfiguration}
 */
const weaponOptions = {
	bash: {
		label: "BF.WEAPON.Option.Bash"
	},
	disarm: {
		label: "BF.WEAPON.Option.Disarm"
	},
	hamstring: {
		label: "BF.WEAPON.Option.Hamstring"
	},
	harmlessFusillade: {
		label: "BF.WEAPON.Option.HarmlessFusillade",
		rules: "firearms"
	},
	pinningShot: {
		label: "BF.WEAPON.Option.PinningShot"
	},
	pull: {
		label: "BF.WEAPON.Option.Pull"
	},
	ricochetShot: {
		label: "BF.WEAPON.Option.RicochetShot"
	},
	trip: {
		label: "BF.WEAPON.Option.Trip"
	}
};

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Properties that can be applied to weapons.
 * @type {string[]}
 */
const weaponProperties = [
	"ammunition",
	"finesse",
	"gunpowder",
	"heavy",
	"light",
	"loading",
	"magazine",
	"magical",
	"special",
	"reach",
	"thrown",
	"twoHanded",
	"versatile"
];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Types of weapons supported.
 * @enum {LabeledConfiguration}
 */
const weaponTypes = {
	melee: {
		label: "BF.WEAPON.Type.Melee"
	},
	ranged: {
		label: "BF.WEAPON.Type.Ranged"
	}
};
localizeConfig(weaponTypes, { sort: false });

var weapons$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	attackModes: attackModes,
	weaponOptions: weaponOptions,
	weaponProperties: weaponProperties,
	weaponTypes: weaponTypes,
	weapons: weapons
});

/**
 * Basic configuration information with a static label.
 *
 * @typedef {object} LabeledConfiguration
 * @property {string} label - Localized label.
 */

/**
 * Basic configuration information with a pluralizable label.
 *
 * @typedef {object} LocalizedConfiguration
 * @property {string} localization - Pluralizable label.
 */

/**
 * Configuration that includes full label and abbreviation.
 *
 * @typedef {LabeledConfiguration} AbbreviatedConfiguration
 * @property {string} abbreviation - Abbreviated name.
 */

/**
 * Nested type configuration for traits & proficiencies.
 *
 * @typedef {object} NestedTypeConfiguration
 * @property {string} [label] - Localizable label for this type or category. Either this or localization must be set.
 * @property {string} [localization] - Pluralizable label for this type of category. Either this or label must be set.
 * @property {Record<string, NestedTypeConfiguration>} [children] - Nested children.
 */

/**
 * @typedef {NestedTypeConfiguration} NestedLinkedConfiguration
 * @property {string} [link] - Link to an item in the compendium.
 * @property {string} [rules] - Rules setting category that allows these options to be toggled by GM.
 * @property {Record<string, NestedLinkedConfiguration>} [children] - Nested children.
 */

/**
 * Configuration information for tags.
 *
 * @typedef {LabeledConfiguration} TraitTagConfiguration
 * @property {string} display - Localization key used for displaying in list using whatever mode is defined.
 * @property {"appended"|associated"|"formatter"|"inline"} type - How the trait is displayed in list. Appended will be
 *                              added to a parenthetical after the list, associated type will display grouped with
 *                              a trait entry in a parenthetical, formatter will wrap the trait list in a string,
 *                              and inline will display in the trait list after the normal entries.
 * @property {string} [association] - Key of a trait that this tag will be associated with for the "association" type.
 * @property {Set<string>} [validTypes] - Valid actor types with which this tag can be used.
 */

var config$1 = {
	...abilities$1,
	...activation,
	...activity,
	...actors,
	...advancement,
	...ammunition$1,
	...armor$1,
	...attributes,
	...canvas$1,
	...conditions$1,
	...containers,
	...damage,
	...debug$1,
	...dice$1,
	...documents$1,
	...enrichers$1,
	...fonts,
	...items,
	...inventory,
	...modifiers,
	...notifications,
	...redirects,
	registration,
	...rules$1,
	...skills$1,
	...spellcasting,
	...targeting,
	...tools$1,
	...traits$1,
	...units,
	...usage,
	...vehicles$1,
	...weapons$1
};

/**
 * @typedef {object} ChatMessageDataModelMetadata
 * @property {Record<string, ApplicationClickAction>} actions - Default click actions for buttons on the message.
 * @property {string} template - Template to use when rendering this message.
 */

/**
 * Abstract base class to add some shared functionality to all of the system's custom chat message types.
 * @abstract
 */
class ChatMessageDataModel extends foundry.abstract.TypeDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Metadata for this chat message type.
	 * @type {ChatMessageDataModelMetadata}
	 */
	static metadata = Object.freeze({
		actions: {
			activate: ChatMessageDataModel.#activateActivity
		},
		template: ""
	});

	get metadata() {
		return this.constructor.metadata;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Template to use when rendering this message.
	 * @type {string}
	 */
	get template() {
		return this.metadata.template;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any changes to the chat message's element before displaying in the list.
	 * @param {HTMLElement} element - Element representing the entire chat message.
	 * @param {object} options - Options forwarded to the render function.
	 */
	async getHTML(element, options) {
		const rendered = await this.render(options);
		if (rendered) element.querySelector(".message-content").innerHTML = rendered;
		this.parent._renderStandardCard(element);
		this.parent._collapseTrays(element);

		const click = this.#onClick.bind(this);
		element.addEventListener("click", click);
		element.addEventListener("contextmenu", click);
		this._onRender(element);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Render the contents of this chat message.
	 * @param {object} options - Rendering options.
	 * @returns {Promise<string>}
	 */
	async render(options) {
		if (!this.template) return "";
		return renderTemplate(this.template, await this._prepareContext(options));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare application rendering context data for a given render request.
	 * @param {object} options - Rendering options.
	 * @returns {Promise<ApplicationRenderContext>} - Context data for the render operation.
	 * @protected
	 */
	async _prepareContext(options) {
		return {};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Actions taken after the message has been rendered.
	 * @param {HTMLElement} element
	 * @protected
	 */
	_onRender(element) {
		for (const e of element.querySelectorAll(".item-tooltip")) {
			const uuid = e.closest("[data-item-uuid]")?.dataset.itemUuid;
			if (!uuid) continue;
			Object.assign(e.dataset, {
				tooltip: `<section class="loading" data-uuid="${uuid}"></section>`,
				tooltipClass: "black-flag black-flag-tooltip item-tooltip",
				tooltipDirection: "LEFT"
			});
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Event Handlers           */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle click events within the card.
	 * @param {PointerEvent} event - Triggering pointer event.
	 */
	#onClick(event) {
		const target = event.target.closest("[data-action]");
		if (target) {
			const action = target.dataset.action;
			let handler = this.metadata.actions[action];
			if (handler) {
				let buttons = [0];
				if (typeof handler === "object") {
					buttons = handler.buttons;
					handler = handler.handler;
				}
				if (buttons.includes(event.button)) handler?.call(this, event, target);
			} else {
				this._onClickAction(event, target);
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * A generic event handler for action clicks which can be extended by subclasses, called if no action is found in
	 * the actions list in the message type's metadata.
	 * @param {PointerEvent} event - Triggering pointer event.
	 * @param {HTMLElement} target - Button with [data-action] defined.
	 * @protected
	 */
	_onClickAction(event, target) {}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle using an activity.
	 * @this {ChatMessageDataModel}
	 * @param {Event} event - Triggering click event.
	 * @param {HTMLElement} target - Button that was clicked.
	 */
	static async #activateActivity(event, target) {
		event.stopImmediatePropagation();
		target.disabled = true;
		try {
			const activity = await fromUuid(target.closest("[data-activity-uuid]")?.dataset.activityUuid);
			await activity?.activate({ event });
		} finally {
			target.disabled = false;
		}
	}
}

var _module$7 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActivityDataModel: ActivityDataModel,
	ActorDataModel: ActorDataModel,
	AdvancementDataModel: AdvancementDataModel,
	BaseDataModel: BaseDataModel,
	ChatMessageDataModel: ChatMessageDataModel,
	ItemDataModel: ItemDataModel
});

/**
 * Data definition for Enchantment active effects.
 */
class EchantmentData extends BaseDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static LOCALIZATION_PREFIXES = ["BF.ENCHANTMENT"];

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				type: "enchantment",
				localization: "BF.EFFECT.Type.Enchantment"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static defineSchema() {
		return this.mergeSchema(super.defineSchema(), {});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Has this enchantment been applied by another item, or was it directly created.
	 * @type {boolean}
	 */
	get isApplied() {
		return !!this.origin && this.origin !== this.parent.uuid;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		if (this.isApplied) ;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _preCreate(data, options, user) {
		const result = await super._preCreate(data, options, user);
		if (result === false) return false;
		if (this.parent.parent instanceof Actor) {
			ui.notifications.error("BF.ENCHANTMENT.Warning.NotOnActor", { localize: true });
			return false;
		}
		// TODO: Validate enchantment restrictions
	}

	/** @inheritDoc */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if (this.isApplied) ;
	}
}

var _module$6 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	EnchantmentData: EchantmentData
});

var _module$5 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AppliedEffectField: AppliedEffectField,
	AttackData: AttackData,
	BaseActivity: BaseActivity,
	CastData: CastData,
	CheckData: CheckData,
	ConsumptionError: ConsumptionError,
	ConsumptionTargetData: ConsumptionTargetData,
	ConsumptionTargetsField: ConsumptionTargetsField,
	DamageData: DamageData,
	ForwardData: ForwardData,
	HealData: HealData,
	SaveData: SaveData,
	SummonData: SummonData,
	UtilityData: UtilityData
});

const { ArrayField, DocumentIdField: DocumentIdField$1, ObjectField, StringField: StringField$3 } = foundry.data.fields;

/**
 * @import { ActorDeltasData } from "./fields/deltas-field.mjs";
 */

/**
 * Data stored in a combat turn chat message.
 *
 * @property {string} [cause] - Relative ID of the activity that caused this one on the same actor.
 * @property {ActivityDeltasData} deltas - Actor/item consumption from this turn change.
 * @property {string[]} effects - Effects that can be applied.
 */
class ActivationMessageData extends ChatMessageDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static defineSchema() {
		return {
			cause: new StringField$3(),
			deltas: new ActorDeltasField(
				{
					created: new ArrayField(new DocumentIdField$1()),
					deleted: new ArrayField(new ObjectField())
				},
				{ initial: null, nullable: true }
			),
			effects: new ArrayField(new DocumentIdField$1())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				template: "systems/black-flag/templates/chat/activation-card.hbs"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The activity for the chat message.
	 * @type {Activity}
	 */
	get activity() {
		return this.parent.getAssociatedActivity();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The actor belonging to the combatant.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.parent.getAssociatedActor();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The item for the chat message.
	 * @type {BlackFlagItem}
	 */
	get item() {
		return this.parent.getAssociatedItem();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _prepareContext(options) {
		return {
			content: await TextEditor.enrichHTML(this.parent.content, { rollData: this.parent.getRollData() }),
			effects: this.effects
				.map(id => this.item?.effects.get(id))
				.filter(e => e && (game.user.isGM || e.transfer & (this.author.id === game.user.id)))
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onRender(element) {
		super._onRender(element);
		this.activity?.onRenderChatCard(this.parent, element);
		this._renderButtons(element);
		this.activity?.activateChatListeners(this.parent, element);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Control visibility of chat card action buttons based on viewing user.
	 * @param {HTMLElement} element - Rendered contents of the message.
	 * @protected
	 */
	_renderButtons(element) {
		if (this.parent.shouldDisplayChallenge) element.dataset.displayChallenge = "";

		const isCreator = game.user.isGM || this.actor?.isOwner || this.parent.author.id === game.user.id;
		for (const button of element.querySelectorAll(".menu button")) {
			if (this.activity?.shouldHideChatButton(button, this)) button.hidden = true;
			if (button.dataset.visibility === "all") continue;
			if ((button.dataset.visibility === "gm" && !game.user.isGM) || !isCreator) button.hidden = true;
		}
	}
}

const { SetField: SetField$1, StringField: StringField$2 } = foundry.data.fields;

/**
 * @typedef {Set<string>} ActivationsData
 */

/**
 * A field for storing relative UUIDs to activations on the actor.
 */
class ActivationsField extends SetField$1 {
	constructor() {
		super(new StringField$2());
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Find any activity relative UUIDs on this actor that can be used during a set of periods.
	 * @param {BlackFlagActor} actor
	 * @param {string[]} periods
	 * @returns {string[]}
	 */
	static getActivations(actor, periods) {
		return actor.items
			.map(i => i.system.activities?.filter(a => periods.includes(a.activation?.type)).map(a => a.relativeUUID) ?? [])
			.flat();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prepare activations for display on chat card.
	 * @this {ActivationsData}
	 * @param {BlackFlagActor} actor - Actor to which this activations can be used.
	 * @returns {Activity[]}
	 */
	static processActivations(actor) {
		return Array.from(this)
			.map(uuid => fromUuidSync(uuid, { relative: actor, strict: false }))
			.filter(_ => _)
			.sort((lhs, rhs) => lhs.item.sort - rhs.item.sort || lhs.sort - rhs.sort);
	}
}

const { StringField: StringField$1 } = foundry.data.fields;

/**
 * @import ActivationsData from "./fields/activations-field.mjs";
 * @import { ActorDeltasData } from "./fields/deltas-field.mjs";
 */

/**
 * Data stored in a rest chat message.
 *
 * @property {ActivationsData} activations - Activities that can be used after this rest, stored as relative UUIDs.
 * @property {ActorDeltasData} deltas - Actor/item recovery from this turn change.
 * @property {string} type - Type of rest performed.
 */
class RestMessageData extends ChatMessageDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static defineSchema() {
		return {
			activations: new ActivationsField(),
			deltas: new ActorDeltasField(),
			type: new StringField$1()
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				template: "systems/black-flag/templates/chat/rest-card.hbs"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The actor for the chat message.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.parent.getAssociatedActor();
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _prepareContext() {
		const context = {
			actor: this.actor,
			content: await TextEditor.enrichHTML(this.parent.content, { rollData: this.parent.getRollData() })
		};

		if (context.actor?.isOwner) {
			context.activities = ActivationsField.processActivations.call(this.activations, this.actor);
			context.deltas = ActorDeltasField.processDeltas.call(this.deltas, this.actor, this.parent.rolls);
		}

		return context;
	}
}

const { DocumentIdField, SchemaField, SetField, StringField } = foundry.data.fields;

/**
 * @import { ActorDeltasData } from "./fields/deltas-field.mjs";
 */

/**
 * Data stored in a combat turn chat message.
 *
 * @property {ActivationsData} activations - Activities that can be used with these periods, stored as relative UUIDs.
 * @property {ActorDeltasData} deltas - Actor/item recovery from this turn change.
 * @property {object} origin
 * @property {string} origin.combat - ID of the triggering combat.
 * @property {string} origin.combatant - ID of the relevant combatant within the combat.
 * @property {Set<string>} periods - Combat state change that triggered this message.
 */
class TurnMessageData extends ChatMessageDataModel {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Model Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static defineSchema() {
		return {
			activations: new ActivationsField(),
			deltas: new ActorDeltasField(),
			origin: new SchemaField({
				combat: new DocumentIdField({ nullable: false, required: true }),
				combatant: new DocumentIdField({ nullable: false, required: true })
			}),
			trigger: new SetField(new StringField())
		};
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static metadata = Object.freeze(
		foundry.utils.mergeObject(
			super.metadata,
			{
				template: "systems/black-flag/templates/chat/turn-card.hbs"
			},
			{ inplace: false }
		)
	);

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Properties              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The actor belonging to the combatant.
	 * @type {BlackFlagActor}
	 */
	get actor() {
		return this.combatant?.actor ?? this.parent.getAssociatedActor();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The combat during which this message was triggered.
	 * @type {BlackFlagCombat}
	 */
	get combat() {
		return game.combats.get(this.origin.combat);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The combatant to whom this message applies.
	 * @type {BlackFlagCombatant}
	 */
	get combatant() {
		return this.combat?.combatants.get(this.origin.combatant);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Rendering              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	async _prepareContext(options) {
		const context = {
			actor: this.actor,
			combat: this.combat,
			combatant: this.combatant
		};

		if (context.actor?.isOwner) {
			context.activities = ActivationsField.processActivations.call(this.activations, this.actor);
			context.deltas = ActorDeltasField.processDeltas.call(this.deltas, this.actor, this.parent.rolls);
		}

		return context;
	}
}

var _module$4 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActivationsField: ActivationsField,
	ActorDeltasField: ActorDeltasField,
	IndividualDeltaField: IndividualDeltaField
});

const config = {
	activation: ActivationMessageData,
	rest: RestMessageData,
	turn: TurnMessageData
};

var _module$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ActivationMessageData: ActivationMessageData,
	RestMessageData: RestMessageData,
	TurnMessageData: TurnMessageData,
	config: config,
	fields: _module$4
});

/**
 * Custom items collection to hide items in containers automatically.
 */
class BlackFlagItems extends Items {
	_getVisibleTreeContents(entry) {
		return this.contents.filter(c => c.visible && !this.has(c.system?.container));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	async importFromCompendium(pack, id, updateData = {}, options = {}) {
		const created = await super.importFromCompendium(pack, id, updateData, options);

		const item = await pack.getDocument(id);
		const contents = await item.system.contents;
		if (contents) {
			const fromOptions = foundry.utils.mergeObject({ clearSort: false }, options);
			const toCreate = await BlackFlagItem.createWithContents(contents, {
				container: created,
				keepId: options.keepId,
				transformAll: item => this.fromCompendium(item, fromOptions)
			});
			await BlackFlagItem.createDocuments(toCreate, { fromCompendium: true, keepId: true });
		}

		return created;
	}
}

var _module$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BlackFlagItems: BlackFlagItems
});

var _module$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	RulesSetting: RulesSetting
});

/**
 * Register the provided data models with Foundry using metadata.
 * @param {typeof Document} documentType - Document type to which these models will be registered.
 * @param {Record<string, SystemDataModel>} [models] - Models to register grouped by type name.
 * @returns {void}
 */
function registerDataModels(documentType, models) {
	log(`Registering ${documentType.name.toLowerCase()} data models`);

	const config = CONFIG[documentType.name];
	config.categories = CONFIG.BlackFlag._documentCategories[documentType.name];
	config.typeLabelsPlural ??= {};

	if (!models) {
		if (!config.categories) return log(`No models provided to register for ${documentType.name}`, { level: "error" });
		models = Object.fromEntries(
			Object.values(config.categories)
				.flatMap(v => v.types ?? [])
				.map(m => [m.fullType, m])
		);
	}

	for (let [type, model] of Object.entries(models)) {
		if (model.metadata.module) type = model.fullType;
		config.dataModels[type] = model;
		config.typeLabels[type] = `${model.metadata.localization}[one]`;
		config.typeLabelsPlural[type] = `${model.metadata.localization}[other]`;
		if (model.metadata.icon) config.typeIcons[type] = model.metadata.icon;
		if (config.categories?.[model.metadata.category]) {
			const types = config.categories[model.metadata.category].types;
			if (!types.includes(model)) insertBetween(types, model, model.metadata.categoryPosition);
		}
	}
}

var data = /*#__PURE__*/Object.freeze({
	__proto__: null,
	abstract: _module$7,
	activeEffect: _module$6,
	activity: _module$5,
	actor: _module$b,
	advancement: _module$d,
	chatMessage: _module$3,
	collection: _module$2,
	fields: _module$g,
	item: _module$9,
	journal: _module$8,
	registerDataModels: registerDataModels,
	settings: _module$1
});

/**
 * Configuration data for the process of rolling a basic roll.
 *
 * @typedef {object} BasicRollProcessConfiguration
 * @property {BasicRollConfiguration[]} rolls - Configuration data for individual rolls.
 * @property {boolean} [evaluate=true] - Should the rolls be evaluated? If set to `false`, then no chat message
 *                                       will be created regardless of message configuration.
 * @property {Event} [event] - Event that triggered the rolling process.
 * @property {string[]} [hookNames] - Name suffixes for configuration hooks called.
 * @property {Document|PseudoDocument} [subject] - Source of the roll.
 * @property {number} [target] - Default target value for all rolls.
 */

/**
 * Base roll configuration data.
 *
 * @typedef {object} BasicRollConfiguration
 * @property {string[]} [parts=[]] - Parts used to construct the roll formula.
 * @property {object} [data={}] - The roll data used to resolve the formula.
 * @property {boolean} [situational=true] - Whether a situational bonus can be added to this roll in the roll prompt.
 * @property {BasicRollOptions} [options] - Options passed through to the roll.
 */

/**
 * Options that describe a base roll.
 *
 * @typedef {object} BasicRollOptions
 * @property {number} [target] - The total roll result that must be met for the roll to be considered a success.
 */

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Data for the roll configuration dialog.
 *
 * @typedef {object} BasicRollDialogConfiguration
 * @property {boolean} [configure=true] - Should the roll configuration dialog be displayed?
 * @property {typeof BaseConfigurationDialog} - [applicationClass] - Alternate configuration dialog application to use.
 * @property {BaseConfigurationDialogOptions} [options] - Additional options passed through to the configuration dialog.
 */

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Message configuration data used when creating messages.
 *
 * @typedef {object} BasicRollMessageConfiguration
 * @property {boolean} [create=true] - Should a message be created when this roll is complete?
 * @property {object} [data={}] - Additional data used when creating the message.
 * @property {BlackFlagChatMessage} [document] - Final created chat message document once process is completed.
 * @property {PreCreateRollMessageCallback} [preCreate] - Message configuration callback.
 * @property {string} [rollMode] - The roll mode to apply to this message from `CONFIG.Dice.rollModes`.
 */

/**
 * Method called after the rolls are completed but before the message is created for further message customization.
 *
 * @callback PreCreateRollMessageCallback
 * @param {BasicRoll[]} rolls - Rolls that have been executed.
 * @param {BasicRollProcessConfiguration} config - Roll process configuration information.
 * @param {BasicRollMessageConfiguration} message - Message configuration information.
 */

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Custom roll type that allows rolls in chat messages to be revived as the correct roll type.
 * @param {string} formula - The formula used to construct the roll.
 * @param {object} data - The roll data used to resolve the formula.
 * @param {BasicRollOptions} options - Additional options that describe the roll.
 */
class BasicRoll extends Roll {
	/**
	 * Default application to use for configuring this roll.
	 * @type {typeof RollConfigurationDialog}
	 */
	static DefaultConfigurationDialog = BasicRollConfigurationDialog;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Static Construction         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Create a roll instance from the provided config.
	 * @param {BasicRollConfiguration} config - Roll configuration data.
	 * @param {BasicRollProcessConfiguration} [process={}] - Process configuration data.
	 * @returns {BasicRoll}
	 */
	static fromConfig(config, process = {}) {
		const formula = (config.parts ?? []).join(" + ");
		config.options ??= {};
		config.options.target ??= process.target;
		return new this(formula, config.data, config.options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Construct and perform a Base Roll through the standard workflow.
	 * @param {BasicRollProcessConfiguration} [config={}] - Roll configuration data.
	 * @param {BasicRollDialogConfiguration} [dialog={}] - Data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message={}] - Configuration data that guides roll message creation.
	 * @returns {BasicRoll[]} - Any rolls created.
	 */
	static async build(config = {}, dialog = {}, message = {}) {
		const rolls = await this.buildConfigure(config, dialog, message);
		await this.buildEvaluate(rolls, config, message);
		await this.buildPost(rolls, config, message);
		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stage one of the standard rolling workflow, configuring the roll.
	 * @param {BasicRollProcessConfiguration} [config={}] - Configuration for the rolls.
	 * @param {BasicRollDialogConfiguration} [dialog={}] - Configuration for roll prompt.
	 * @param {BasicRollMessageConfiguration} [message={}] - Configuration for message creation.
	 * @returns {BasicRoll[]}
	 */
	static async buildConfigure(config = {}, dialog = {}, message = {}) {
		config.hookNames = [...(config.hookNames ?? []), ""];

		this.applyKeybindings(config, dialog, message);

		let rolls;
		if (dialog.configure === false) {
			rolls = config.rolls?.map(c => this.fromConfig(c, config)) ?? [];
		} else {
			const DialogClass = dialog.applicationClass ?? this.DefaultConfigurationDialog;
			rolls = await DialogClass.configure(config, dialog, message);
		}

		/**
		 * A hook event that fires after roll configuration is complete, but before the roll is evaluated.
		 * Multiple hooks may be called depending on the rolling method (e.g. `dnd5e.postSkillCheckRollConfiguration`,
		 * `blackFlag.postAbilityTestRollConfiguration`, and `blackFlag.postRollConfiguration` for skill checks). Exact
		 * contents of the configuration object will also change based on the roll type, but the same objects will always
		 * be present.
		 * @function blackFlag.postRollConfiguration
		 * @memberof hookEvents
		 * @param {BasicRoll[]} rolls - Rolls that have been constructed but not evaluated.
		 * @param {BasicRollProcessConfiguration} config - Configuration information for the roll.
		 * @param {BasicRollDialogConfiguration} dialog - Configuration for the roll dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration for the roll message.
		 * @returns {boolean} - Explicitly return `false` to prevent rolls.
		 */
		for (const hookName of config.hookNames) {
			const name = `blackFlag.post${hookName.capitalize()}RollConfiguration`;
			if (Hooks.call(name, rolls, config, dialog, message) === false) return [];
		}

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stage two of the standard rolling workflow, evaluating the rolls.
	 * @param {BasicRoll[]} rolls - Rolls to evaluate.
	 * @param {BasicRollProcessConfiguration} [config={}] - Configuration for the rolls.
	 * @param {BasicRollMessageConfiguration} [message={}] - Configuration for message creation.
	 */
	static async buildEvaluate(rolls, config = {}, message = {}) {
		if (config.evaluate !== false) {
			for (const roll of rolls) await roll.evaluate();
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stage three of the standard rolling workflow, posting a message to chat.
	 * @param {BasicRoll[]} rolls - Rolls to evaluate.
	 * @param {BasicRollProcessConfiguration} config - Configuration for the rolls.
	 * @param {BasicRollMessageConfiguration} message - Configuration for message creation.
	 * @returns {BlackFlagChatMessage|void}
	 */
	static async buildPost(rolls, config, message) {
		message = foundry.utils.expandObject(message ?? {});
		const messageId = config.event?.target.closest("[data-message-id]")?.dataset.messageId;
		if (messageId) foundry.utils.setProperty(message, `data.flags.${game.system.id}.originatingMessage`, messageId);

		if (rolls?.length && config.evaluate !== false && message.create !== false) {
			if (foundry.utils.getType(message.preCreate) === "function") message.preCreate(rolls, config, message);
			message.document = await this.toMessage(rolls, message.data, {
				rollMode: message.rollMode ?? rolls.reduce((mode, r) => mode ?? r.options.rollMode)
			});
		}

		return message.document;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determines whether the roll should be fast forwarded.
	 * @param {BasicRollProcessConfiguration} config - Roll configuration data.
	 * @param {BasicRollDialogConfiguration} dialog - Data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} message - Configuration data that guides roll message creation.
	 */
	static applyKeybindings(config, dialog, message) {
		dialog.configure ??= true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the result of this roll a failure? Returns `undefined` if roll isn't evaluated.
	 * @type {boolean|void}
	 */
	get isFailure() {
		if (!this._evaluated) return undefined;
		if (!Number.isNumeric(this.options.target)) return false;
		return this.total < this.options.target;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the result of this roll a success? Returns `undefined` if roll isn't evaluated.
	 * @type {boolean|void}
	 */
	get isSuccess() {
		if (!this._evaluated) return undefined;
		if (!Number.isNumeric(this.options.target)) return false;
		return this.total >= this.options.target;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Chat Messages            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Transform a Roll instance into a ChatMessage, displaying the roll result.
	 * This function can either create the ChatMessage directly, or return the data object that will be used to create.
	 *
	 * @param {BasicRoll[]} rolls - Rolls to add to the message.
	 * @param {object} messageData - The data object to use when creating the message
	 * @param {options} [options] - Additional options which modify the created message.
	 * @param {string} [options.rollMode] - The template roll mode to use for the message from CONFIG.Dice.rollModes
	 * @param {boolean} [options.create=true] - Whether to automatically create the chat message, or only return the
	 *                                          prepared chatData object.
	 * @returns {Promise<ChatMessage|object>} - A promise which resolves to the created ChatMessage document if create is
	 *                                         true, or the Object of prepared chatData otherwise.
	 */
	static async toMessage(rolls, messageData = {}, { rollMode, create = true } = {}) {
		for (const roll of rolls) {
			if (!roll._evaluated) await roll.evaluate();
		}

		// Prepare chat data
		messageData = foundry.utils.mergeObject(
			{
				user: game.user.id,
				sound: CONFIG.sounds.dice
			},
			messageData
		);
		messageData.rolls = rolls;

		// Either create the message or just return the chat data
		const cls = getDocumentClass("ChatMessage");
		const msg = new cls(messageData);

		// Either create or return the data
		if (create) return cls.create(msg.toObject(), { rollMode });
		else {
			if (rollMode) msg.applyRollMode(rollMode);
			return msg.toObject();
		}
	}
}

/**
 * Primary die used when performing a challenge roll.
 */
class ChallengeDie extends foundry.dice.terms.Die {
	constructor({ number = 1, faces = 20, ...args } = {}) {
		super({ number, faces, ...args });
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Critical success target if no critical failure is set in options.
	 * @type {number}
	 */
	static CRITICAL_SUCCESS_TOTAL = 20;

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Critical failure target if no critical failure is set in options.
	 * @type {number}
	 */
	static CRITICAL_FAILURE_TOTAL = 1;

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Possible advantage modes for this die.
	 * @enum {number}
	 */
	static MODES = {
		NORMAL: 0,
		ADVANTAGE: 1,
		DISADVANTAGE: -1
	};

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Is the result of this roll a critical success? Returns `undefined` if roll isn't evaluated.
	 * @type {boolean|void}
	 */
	get isCriticalSuccess() {
		if (!this.isValid || !this._evaluated) return undefined;
		if (!Number.isNumeric(this.options.criticalSuccess)) return false;
		return this.total >= this.options.criticalSuccess;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Is the result of this roll a critical failure? Returns `undefined` if roll isn't evaluated.
	 * @type {boolean|void}
	 */
	get isCriticalFailure() {
		if (!this.isValid || !this._evaluated) return undefined;
		if (!Number.isNumeric(this.options.criticalFailure)) return false;
		return this.total <= this.options.criticalFailure;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Is this a valid challenge die?
	 * @type {boolean}
	 */
	get isValid() {
		return this.faces === 20;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Apply advantage mode to this die.
	 * @param {number} advantageMode - Advantage mode to apply, defined by {@link ChallengeRoll#MODES}.
	 */
	applyAdvantage(advantageMode) {
		this.options.advantageMode = advantageMode;
		if (advantageMode !== this.constructor.MODES.NORMAL) {
			this.number = 2;
			this.modifiers.push(advantageMode === this.constructor.MODES.ADVANTAGE ? "kh" : "kl");
		} else {
			this.number = 1;
		}
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Apply a minimum value to this die.
	 * @param {number} minimum - Minimum value the die will be able to roll.
	 */
	applyMinimum(minimum) {
		this.options.minimum = minimum;
		this.modifiers.findSplice(m => m.startsWith("min"));
		if (minimum) this.modifiers.push(`min${minimum}`);
	}
}

/**
 * Configuration data for the process of rolling a challenge roll.
 *
 * @typedef {BasicRollProcessConfiguration} ChallengeRollProcessConfiguration
 * @property {ChallengeRollConfiguration[]} rolls - Configuration data for individual rolls.
 * @property {number} target - Default target value for all rolls if none are set individually.
 */

/**
 * Challenge roll configuration data.
 *
 * @typedef {BasicRollConfiguration} ChallengeRollConfiguration
 * @property {string[]} [parts=[]] - Parts used to construct the roll formula, not including the challenge die.
 * @property {ChallengeRollOptions} [options] - Options passed through to the roll.
 */

/**
 * Options that describe a challenge roll.
 *
 * @typedef {BasicRollOptions} ChallengeRollOptions
 * @property {boolean} [advantage] - Is the roll granted advantage?
 * @property {boolean} [disadvantage] - Is the roll granted disadvantage?
 * @property {number} [criticalSuccess] - The value of the challenge die to be considered a critical success.
 * @property {number} [criticalFailure] - The value of the challenge die to be considered a critical failure.
 * @property {number} [minimum] - Minimum number the challenge die can roll.
 */

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Data for the roll configuration dialog.
 *
 * @typedef {BasicRollDialogConfiguration} ChallengeRollDialogConfiguration
 * @property {ChallengeConfigurationDialogOptions} [options] - Configuration options.
 */

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Roll used for challenges and contests, usually using a D20, such as attacks, checks, and saves.
 * @param {string} formula - The formula used to construct the roll.
 * @param {object} data - The roll data used to resolve the formula.
 * @param {ChallengeRollOptions} options - Additional options that describe the challenge roll.
 */
class ChallengeRoll extends BasicRoll {
	constructor(formula, data, options = {}) {
		super(formula, data, options);
		this.#createChallengeDie();
		if (!this.options.configured) this.configureRoll();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static DefaultConfigurationDialog = ChallengeRollConfigurationDialog;

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Static Construction         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @override */
	static fromConfig(config, process = {}) {
		const formula = [new CONFIG.Dice.ChallengeDie().formula].concat(config.parts ?? []).join(" + ");
		config.options ??= {};
		config.options.target ??= process.target;
		return new this(formula, config.data, config.options);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Construct and perform a Challenge Roll through the standard workflow.
	 * @param {ChallengeRollProcessConfiguration} [config={}] - Roll configuration data.
	 * @param {ChallengeRollDialogConfiguration} [dialog={}] - Data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message={}] - Configuration data that guides roll message creation.
	 * @returns {BasicRoll[]} - Any rolls created.
	 */
	static async build(config = {}, dialog = {}, message = {}) {
		for (const roll of config.rolls ?? []) {
			roll.options ??= {};
			roll.options.criticalSuccess ??= CONFIG.Dice.ChallengeDie.CRITICAL_SUCCESS_TOTAL;
			roll.options.criticalFailure ??= CONFIG.Dice.ChallengeDie.CRITICAL_FAILURE_TOTAL;
		}
		return super.build(config, dialog, message);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determines whether the roll should be fast forwarded and what the default advantage mode should be.
	 * @param {ChallengeRollProcessConfiguration} config - Roll configuration data.
	 * @param {ChallengeRollDialogConfiguration} dialog - Data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} message - Configuration data that guides roll message creation.
	 */
	static applyKeybindings(config, dialog, message) {
		const keys = {
			normal: areKeysPressed(config.event, "skipDialogNormal"),
			advantage: areKeysPressed(config.event, "skipDialogAdvantage"),
			disadvantage: areKeysPressed(config.event, "skipDialogDisadvantage")
		};

		// Should the roll configuration dialog be displayed?
		dialog.configure ??= !Object.values(keys).some(k => k);

		// Determine advantage mode
		for (const roll of config.rolls ?? []) {
			roll.options ??= {};
			const advantage = roll.options.advantage || keys.advantage;
			const disadvantage = roll.options.disadvantage || keys.disadvantage;
			if (advantage && !disadvantage) roll.options.advantageMode = CONFIG.Dice.ChallengeDie.MODES.ADVANTAGE;
			else if (!advantage && disadvantage) roll.options.advantageMode = CONFIG.Dice.ChallengeDie.MODES.DISADVANTAGE;
			else roll.options.advantageMode = CONFIG.Dice.ChallengeDie.MODES.NORMAL;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * The primary die used in this challenge.
	 * @type {ChallengeDie|void}
	 */
	get challengeDie() {
		if (!(this.terms[0] instanceof foundry.dice.terms.Die)) return undefined;
		return this.terms[0];
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set the challenge die for this roll.
	 */
	set challengeDie(die) {
		if (!(die instanceof CONFIG.Dice.ChallengeDie))
			throw new Error(
				`Challenge die must be an instance of ${CONFIG.Dice.ChallengeDie.name}, ` +
					`instead a ${die.constructor.name} was provided.`
			);
		this.terms[0] = die;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this challenge roll performed with advantage?
	 * @type {boolean}
	 */
	get hasAdvantage() {
		return this.options.advantageMode === CONFIG.Dice.ChallengeRoll.MODES.ADVANTAGE;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this challenge roll performed with disadvantage?
	 * @type {boolean}
	 */
	get hasDisadvantage() {
		return this.options.advantageMode === CONFIG.Dice.ChallengeRoll.MODES.DISADVANTAGE;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the result of this roll a critical success? Returns `undefined` if roll isn't evaluated.
	 * @type {boolean|void}
	 */
	get isCriticalSuccess() {
		this.#createChallengeDie();
		return this.challengeDie.isCriticalSuccess;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is the result of this roll a critical failure? Returns `undefined` if roll isn't evaluated.
	 * @type {boolean|void}
	 */
	get isCriticalFailure() {
		this.#createChallengeDie();
		return this.challengeDie.isCriticalFailure;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this a valid challenge role?
	 * @type {boolean}
	 */
	get isValidRoll() {
		return this.challengeDie instanceof CONFIG.Dice.ChallengeDie && this.challengeDie.isValid;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*          Roll Configuration         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Modify the damage to take advantage and any other modifiers into account.
	 */
	configureRoll() {
		// Directly modify the challenge die
		this.challengeDie.applyAdvantage(this.options.advantageMode ?? CONFIG.Dice.ChallengeDie.MODES.NORMAL);
		this.challengeDie.applyMinimum(this.options.minimum ?? 0);

		// Critical thresholds & target value
		if (this.options.criticalSuccess) this.challengeDie.options.criticalSuccess = this.options.criticalSuccess;
		if (this.options.criticalFailure) this.challengeDie.options.criticalFailure = this.options.criticalFailure;
		if (this.options.target) this.challengeDie.options.target = this.options.target;

		// Re-compile the underlying formula
		this.resetFormula();

		// Mark configuration as complete
		this.options.configured = true;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Ensure the challenge die for this roll is a proper ChallengeDie, not a regular Die.
	 */
	#createChallengeDie() {
		if (this.challengeDie instanceof CONFIG.Dice.ChallengeDie) return;
		if (!(this.challengeDie instanceof foundry.dice.terms.Die)) return;
		this.challengeDie = new CONFIG.Dice.ChallengeDie({ ...this.challengeDie });
	}
}

/**
 * Configuration data for the process of rolling a damage roll.
 *
 * @typedef {BasicRollProcessConfiguration} DamageRollProcessConfiguration
 * @property {DamageRollConfiguration[]} rolls - Configuration data for individual rolls.
 * @property {CriticalDamageConfiguration} [critical] - Critical configuration for all rolls.
 * @property {number} [scaling=0] - Scale increase above base damage.
 */

/**
 * Damage roll configuration data.
 *
 * @typedef {BasicRollConfiguration} DamageRollConfiguration
 * @property {DamageRollOptions} [options] - Options passed through to the roll.
 */

/**
 * Critical effects configuration data.
 *
 * @typedef {object} CriticalDamageConfiguration
 * @property {boolean} [allow=true] - Should critical damage be allowed?
 * @property {number} [multiplier=2] - Amount by which to multiply critical damage.
 * @property {number} [bonusDice=0] - Additional dice added to first term when calculating critical damage.
 * @property {string} [bonusDamage] - Additional, unmodified, damage formula added when calculating a critical.
 * @property {string} [maximizeDamage] - Maximize result of extra dice added by critical, rather than rolling.
 * @property {boolean} [multiplyDice] - Should dice result be multiplied rather than number of dice rolled increased?
 * @property {boolean} [multiplyNumeric] - Should numeric terms be multiplied along side dice during criticals?
 */

/**
 * Options that describe a damage roll.
 *
 * @typedef {BasicRollOptions} DamageRollOptions
 * @property {boolean} [isCritical] - Should critical damage by calculated for this roll?
 * @property {CriticalDamageConfiguration} [critical] - Critical configuration for this roll.
 * @property {string} [damageType] - Type of damage represented.
 * @property {string[]} [damageTypes] - List of damage types selectable in the configuration app.
 * @property {boolean} [magical] - Is this damage considered magical?
 */

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Roll used for damage with helpers for calculating critical damage.
 * @param {string} formula - The formula used to construct the roll.
 * @param {object} data - The roll data used to resolve the formula.
 * @param {DamageRollOptions} options - Additional options that describe the damage roll.
 */
class DamageRoll extends BasicRoll {
	constructor(formula, data, options = {}) {
		super(formula, data, options);
		if (!this.options.preprocessed) this.#preprocessFormula();
		if (!this.options.configured) this.configureRoll();
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/** @inheritDoc */
	static DefaultConfigurationDialog = DamageRollConfigurationDialog;

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/** @inheritDoc */
	static CHAT_TEMPLATE = "systems/black-flag/templates/dice/damage-roll.hbs";

	/* <><><><> <><><><> <><><><> <><><><> */
	/*         Static Construction         */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static fromConfig(config, process = {}) {
		const roll = super.fromConfig(config, process);
		if (process.critical) roll.configureRoll({ critical: process.critical });
		return roll;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	static async build(config = {}, dialog = {}, message = {}) {
		config.critical ??= {};
		config.critical.maximizeDamage ??= game.settings.get(game.system.id, "criticalMaximizeDamage");
		config.critical.multiplyDice ??= game.settings.get(game.system.id, "criticalMultiplyDice");
		config.critical.multiplyNumeric ??= game.settings.get(game.system.id, "criticalMultiplyNumeric");
		return super.build(config, dialog, message);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determines whether the roll should be fast forwarded and what the default critical mode should be.
	 * @param {DamageRollProcessConfiguration} config - Roll configuration data.
	 * @param {BasicRollDialogConfiguration} dialog - Data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} message - Configuration data that guides roll message creation.
	 */
	static applyKeybindings(config, dialog, message) {
		const keys = {
			normal:
				areKeysPressed(config.event, "skipDialogNormal") || areKeysPressed(config.event, "skipDialogDisadvantage"),
			critical: areKeysPressed(config.event, "skipDialogAdvantage")
		};

		// Should the roll configuration dialog be displayed?
		dialog.configure ??= !Object.values(keys).some(k => k);

		// Determine critical mode
		for (const roll of config.rolls) {
			roll.options ??= {};
			roll.options.isCritical = !!roll.options.isCritical || keys.critical;
		}
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */
	/*  Properties                               */
	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Is this damage critical?
	 * @type {boolean}
	 */
	get isCritical() {
		return this.options.isCritical === true;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */
	/*  Roll Configuration                       */
	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Perform any term-merging required to ensure that criticals can be calculated successfully.
	 */
	#preprocessFormula() {
		for (let [i, term] of this.terms.entries()) {
			const nextTerm = this.terms[i + 1];
			const prevTerm = this.terms[i - 1];

			// Convert shorthand dX terms to 1dX preemptively to allow them to be appropriately doubled for criticals
			if (
				term instanceof foundry.dice.terms.StringTerm &&
				/^d\d+/.test(term.term) &&
				!(prevTerm instanceof foundry.dice.terms.ParentheticalTerm)
			) {
				const formula = `1${term.term}`;
				const newTerm = new Roll(formula).terms[0];
				this.terms.splice(i, 1, newTerm);
				term = newTerm;
			}

			// Merge parenthetical terms that follow string terms to build a dice term (to allow criticals)
			else if (
				term instanceof foundry.dice.terms.ParentheticalTerm &&
				prevTerm instanceof foundry.dice.terms.StringTerm &&
				prevTerm.term.match(/^[0-9]*d$/)
			) {
				if (term.isDeterministic) {
					let newFormula = `${prevTerm.term}${term.evaluate().total}`;
					let deleteCount = 2;

					// Merge in any roll modifiers
					if (nextTerm instanceof foundry.dice.terms.StringTerm) {
						newFormula += nextTerm.term;
						deleteCount += 1;
					}

					const newTerm = new Roll(newFormula).terms[0];
					this.terms.splice(i - 1, deleteCount, newTerm);
					term = newTerm;
				}
			}

			// Merge any parenthetical terms followed by string terms
			else if (
				(term instanceof foundry.dice.terms.ParentheticalTerm || term instanceof foundry.dice.terms.FunctionTerm) &&
				nextTerm instanceof foundry.dice.terms.StringTerm &&
				nextTerm.term.match(/^d[0-9]*$/)
			) {
				if (term.isDeterministic) {
					const newFormula = `${term.evaluate().total}${nextTerm.term}`;
					const newTerm = new Roll(newFormula).terms[0];
					this.terms.splice(i, 2, newTerm);
					term = newTerm;
				}
			}
		}

		// Re-compile the underlying formula
		this.resetFormula();

		// Mark preprocessing as complete
		this.options.preprocessed = true;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/**
	 * Modify the damage to take criticals into account.
	 * @param {object} [options={}]
	 * @param {CriticalDamageConfiguration} [options.critical={}] - Critical configuration to take into account, will be
	 *                                                              superseded by the the roll's configuration.
	 */
	configureRoll({ critical = {} } = {}) {
		critical = foundry.utils.mergeObject(critical, this.options.critical ?? {}, { inplace: false });

		let bonus = 0;
		const multiplier = critical.multiplier ?? 2;

		for (const [i, term] of this.terms.entries()) {
			// Multiply dice terms
			if (term instanceof foundry.dice.terms.DiceTerm) {
				// Handle complex number term
				if (term._number instanceof Roll) {
					if (!term._number.isDeterministic) continue;
					if (!term._number._evaluated) term._number.evaluateSync();
				}

				// Reset to base value & store that value for later if it isn't already set
				term.number = term.options.baseNumber ??= term.number;
				if (this.isCritical) {
					let termMultiplier = multiplier;
					const bonusDice = critical.bonusDice ?? i === 0 ? critical.bonusDice : 0;

					// Maximize Critical - Maximize one die and reduce to the multiplier by one to account for it.
					if (critical.maximizeDamage) {
						bonus += (term.number + bonusDice) * term.faces;
						termMultiplier = Math.max(1, termMultiplier - 1);
					} else {
						term.alter(critical.multiplyDice ? null : termMultiplier, bonusDice);
					}

					term.options.critical = true;

					// Multiply Dice - Add term to multiply dice result (as long as multiply numeric isn't also set)
					if (critical.multiplyDice && !critical.multiplyNumeric)
						this.terms.splice(
							i + 1,
							0,
							new foundry.dice.terms.OperatorTerm({ operator: "*" }),
							new foundry.dice.terms.NumericTerm({ number: termMultiplier })
						);
				}
			}

			// Multiply Numeric - Modify numeric terms (as long as multiply dice isn't also set)
			else if (critical.multiplyNumeric && !critical.multiplyDice && term instanceof foundry.dice.terms.NumericTerm) {
				// Reset to base value & store that value for later if it isn't already set
				term.number = term.options.baseNumber ??= term.number;
				if (this.isCritical) {
					term.number *= multiplier;
					term.options.critical = true;
				}
			}
		}

		// Multiply Dice & Numeric: Wrap whole formula in parenthetical term and multiply
		if (this.isCritical && critical.multiplyDice && critical.multiplyNumeric && multiplier > 1) {
			this.terms = [foundry.dice.terms.ParentheticalTerm.fromTerms(this.terms)];
			this.terms.push(new foundry.dice.terms.OperatorTerm({ operator: "*" }));
			this.terms.push(new foundry.dice.terms.NumericTerm({ number: multiplier }));
		}

		// Add flat bonus back in
		if (bonus > 0) {
			this.terms.push(new foundry.dice.terms.OperatorTerm({ operator: "+" }));
			this.terms.push(
				new foundry.dice.terms.NumericTerm(
					{ number: bonus },
					{ flavor: game.i18n.localize("BF.DAMAGE.Critical.Maximize") }
				)
			);
		}

		// Add extra critical damage
		if (this.isCritical && critical.bonusDamage) {
			const extra = new Roll(critical.bonusDamage, this.data);
			if (!(extra.terms[0] instanceof foundry.dice.terms.OperatorTerm))
				this.terms.push(new foundry.dice.terms.OperatorTerm({ operator: "+" }));
			this.terms.push(...extra.terms);
		}

		// Re-compile the underlying formula
		this.resetFormula();

		// Mark configuration as complete
		this.options.configured = true;
	}

	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */
	/*  Chat Messages                            */
	/* ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~ */

	/** @inheritDoc */
	async render({ flavor, template = this.constructor.CHAT_TEMPLATE, isPrivate = false } = {}) {
		if (!this._evaluated) await this.evaluate();

		const chatData = {
			CONFIG: CONFIG.BlackFlag,
			formula: isPrivate ? "???" : this._formula,
			flavor: isPrivate ? null : flavor,
			user: game.user.id,
			tooltip: isPrivate ? "" : await this.getTooltip(),
			total: isPrivate ? "?" : Math.round(this.total * 100) / 100,
			damageType: isPrivate ? "???" : this.options.damageType
		};
		return renderTemplate(template, chatData);
	}
}

/**
 * Register the various roll types provided by Black Flag during initialization.
 */
function registerDice() {
	log("Registering roll & die types");

	CONFIG.Dice.BasicRoll = BasicRoll;
	CONFIG.Dice.ChallengeDie = ChallengeDie;
	CONFIG.Dice.ChallengeRoll = ChallengeRoll;
	CONFIG.Dice.DamageRoll = DamageRoll;
	CONFIG.Dice.types.push(ChallengeDie);
	CONFIG.Dice.rolls = [BasicRoll, ChallengeRoll, DamageRoll];
}

var dice = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BasicRoll: BasicRoll,
	ChallengeDie: ChallengeDie,
	ChallengeRoll: ChallengeRoll,
	DamageRoll: DamageRoll,
	aggregateDamageRolls: aggregateDamageRolls,
	registerDice: registerDice
});

class BlackFlagActor extends DocumentMixin(Actor) {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * An object that tracks which tracks the changes to the data model which were applied by advancement.
	 * @type {object}
	 */
	advancementOverrides = this.advancementOverrides ?? {};

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Are advancement changes currently being applied?.
	 * @type {boolean}
	 */
	#advancementProcessing = false;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Internal queue of advancement operations to apply.
	 * @type {{advancement: Advancement, functionName: string, parameters: *[]}[]}
	 */
	#advancementQueue = [];

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Is this actor currently preparing embedded documents?
	 * @type {boolean}
	 */
	_embeddedPreparation = false;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Collection of notifications that should be displayed on the actor sheet.
	 */
	notifications = this.notifications;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mapping of item source UUIDs to the items.
	 * @type {Map<string, Set<BlackFlagItem>>}
	 */
	sourcedItems = this.sourcedItems;

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Creatures summoned by this actor.
	 * @type {BlackFlagActor[]}
	 */
	get summonedCreatures() {
		return BlackFlag.registry.summons.creatures(this);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*           Data Preparation          */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareData() {
		this.notifications = new NotificationsCollection();
		super.prepareData();
		this.items.forEach(i => i.system.prepareFinalData?.());
		this.system.prepareNotifications?.();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareEmbeddedDocuments() {
		this.sourcedItems = new Map();
		this._embeddedPreparation = true;
		super.prepareEmbeddedDocuments();
		this._embeddedPreparation = false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		const origin = this.getFlag(game.system.id, "summon.origin");
		if (origin && this.token?.id) BlackFlag.registry.summons.track(origin.split(".Item.")[0], this.uuid);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	*allApplicableEffects() {
		for (const effect of super.allApplicableEffects()) {
			if (effect.type === "enchantment") continue;
			yield effect;
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	applyActiveEffects() {
		this.system.prepareEmbeddedData?.();
		this.applyAdvancementEffects();
		return super.applyActiveEffects();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply any transformations to the Actor which are caused by dynamic Advancement.
	 */
	applyAdvancementEffects() {
		const cls = getDocumentClass("ActiveEffect");
		const applier = new cls({ name: "temp" });
		const overrides = {};

		const levels = [
			{ character: 0, class: 0 },
			...Object.values(this.system.progression?.levels ?? {}).map(l => l.levels)
		];
		const applied = new Map();
		for (const level of levels) {
			for (const advancement of this.advancementForLevel(level.character)) {
				advancement
					.changes(level)
					?.map(change => {
						const c = foundry.utils.deepClone(change);
						c.advancement = advancement;
						c.priority ??= c.mode * 10;
						return c;
					})
					.sort((lhs, rhs) => lhs.priority - rhs.priority)
					.forEach(c => {
						// Special handling of override to avoid issue with scale values
						if (c.mode === CONST.ACTIVE_EFFECT_MODES.OVERRIDE && foundry.utils.getType(c.value) === "Object") {
							foundry.utils.setProperty(this, c.key, c.value);
							overrides[c.key] = c.value;
						} else Object.assign(overrides, applier.apply(this, c));
						if (!applied.has(level)) applied.set(level, []);
						applied.get(level).push(c);
					});
			}
		}
		if (CONFIG.BlackFlag.debug.advancementChanges && applied.size) log("Appling Advancement:", { extras: applied });

		this.advancementOverrides = foundry.utils.expandObject(overrides);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Methods               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Get advancement for the actor.
	 * @param {number} level - Character level for which to get the advancement.
	 * @yields {Advancement}
	 */
	*advancementForLevel(level = 0) {
		const levels = level > 0 ? this.system.progression.levels[level]?.levels : { character: 0, class: 0 };
		if (!levels) return;
		for (const item of this.items) {
			for (const advancement of item.advancementForLevel(levels)) {
				yield advancement;
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Description of a source of damage.
	 *
	 * @typedef {object} DamageDescription
	 * @property {number} value - Amount of damage.
	 * @property {string} type - Type of damage.
	 * @property {boolean} magical - Is the damage magical?
	 * @property {object} [active]
	 * @property {number} [active.multiplier] - Final calculated multiplier.
	 * @property {DamageAffectDescription} [active.all] - How did resistances/etc. to all damage affect the total.
	 * @property {DamageAffectDescription} [active.type] - How did resistances/etc. to this damage type affect the total.
	 * @property {BlackFlagActor|BlackFlagItem} [source] - Source of the damage.
	 */

	/**
	 * @typedef {object} DamageAffectDescription
	 * @property {boolean} [threshold] - Did threshold affect this description?
	 * @property {boolean} [modifications] - Did modification affect this description?
	 * @property {boolean} [resistance] - Did resistance affect this description?
	 * @property {boolean} [vulnerability] - Did vulnerability affect this description?
	 * @property {boolean} [immunity] - Did immunity affect this description?
	 */

	/**
	 * Options for damage application.
	 *
	 * @typedef {object} DamageApplicationOptions
	 * @property {boolean|Set<string>} [downgrade] - Should this actor's resistances and immunities be downgraded by one
	 *                                               step? A set of damage types to be downgraded or `true` to downgrade
	 *                                               all damage types.
	 * @property {number} [multiplier=1] - Amount by which to multiply all damage (before damage resistance, etc).
	 * @property {object|boolean} [ignore] - Set to `true` to ignore all damage modifiers. If set to an object, then
	 *                                       values can either be `true` to indicate that the all modifications of that
	 *                                       type should be ignored, or a set of specific damage types for which it should
	 *                                       be ignored.
	 * @property {boolean|Set<string>} [ignore.immunity] - Should this actor's damage immunity be ignored?
	 * @property {boolean|Set<string>} [ignore.modification] - Should this actor's damage modification be ignored?
	 * @property {boolean|Set<string>} [ignore.resistance] - Should this actor's damage resistance be ignored?
	 * @property {boolean} [ignore.threshold] - Should this actor's damage threshold be ignored?
	 * @property {boolean|Set<string>} [ignore.vulnerability] - Should this actor's damage vulnerability be ignored?
	 * @property {boolean} [invertHealing=true] - Automatically invert healing types to it heals, rather than damages.
	 * @property {"damage"|"healing"} [only] - Apply only damage or healing parts. Untyped rolls will always be applied.
	 */

	/**
	 * Apply damage to the actor.
	 * @param {DamageDescription[]|number} damages - Damages to apply.
	 * @param {DamageApplicationOptions} [options={}]
	 * @returns {Promise<BlackFlagActor>} - The actor after the update has been performed.
	 */
	async applyDamage(damages, options = {}) {
		const hp = this.system.attributes.hp;
		if (!hp?.max) return;

		if (Number.isNumeric(damages)) {
			damages = [{ value: damages }];
			options.ignore ??= true;
		}

		damages = this.calculateDamage(damages, options);
		if (!damages) return this;

		// Round damage towards zero
		let { amount, temp, tempMax } = damages.reduce(
			(acc, d) => {
				if (d.type === "temp") acc.temp += d.value;
				else if (d.type === "max") acc.tempMax += d.rollType === "healing" ? -1 * d.value : d.value;
				else acc.amount += d.value;
				return acc;
			},
			{ amount: 0, temp: 0, tempMax: 0 }
		);
		amount = amount > 0 ? Math.floor(amount) : Math.ceil(amount);
		if (tempMax < 0) amount += tempMax;

		// Subtract from temp HP first & then from normal HP
		const deltaTemp = amount > 0 ? Math.min(hp.temp, amount) : 0;
		const deltaHP = Math.clamp(amount - deltaTemp, -hp.damage + tempMax, hp.value - tempMax);
		const updates = {
			"system.attributes.hp.temp": hp.temp - deltaTemp,
			"system.attributes.hp.tempMax": hp.tempMax - tempMax,
			"system.attributes.hp.value": hp.value - deltaHP,
			"system.attributes.hp.damage": hp.damage + deltaHP
		};
		if (temp > updates["system.attributes.hp.temp"]) updates["system.attributes.hp.temp"] = temp;

		/**
		 * A hook event that fires before damage is applied to an actor.
		 * @param {BlackFlagActor} actor - Actor the damage will be applied to.
		 * @param {number} amount - Amount of damage that will be applied.
		 * @param {object} updates - Distinct updates to be performed on the actor.
		 * @param {DamageApplicationOptions} options - Additional damage application options.
		 * @returns {boolean} - Explicitly return `false` to prevent damage application.
		 * @function blackFlag.preApplyDamage
		 * @memberof hookEvents
		 */
		if (Hooks.call("blackFlag.preApplyDamage", this, amount, updates, options) === false) return this;

		// Call core's hook so anything watching token bar changes can respond
		if (
			Hooks.call(
				"modifyTokenAttribute",
				{
					attribute: "attributes.hp",
					value: amount,
					isDelta: false,
					isBar: true
				},
				updates
			) === false
		)
			return false;

		await this.update(updates);

		/**
		 * A hook event that fires after damage has been applied to an actor.
		 * @param {BlackFlagActor} actor - Actor that has been damaged.
		 * @param {number} amount - Amount of damage that has been applied.
		 * @param {DamageApplicationOptions} options - Additional damage application options.
		 * @function blackFlag.postApplyDamage
		 * @memberof hookEvents
		 */
		Hooks.callAll("blackFlag.postApplyDamage", this, amount, options);

		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Apply temp HP to the actor, but only if it's more than the actor's current temp HP.
	 * @param {number} amount - Amount of temp HP to apply.
	 * @returns {Promise<BlackFlagActor>} - The actor after the update has been performed.
	 */
	async applyTempHP(amount = 0) {
		const hp = this.system.attributes.hp;
		if (!hp) return;
		return amount > hp.temp ? this.update({ "system.attributes.hp.temp": amount }) : this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Calculate the damage that will be applied to this actor.
	 * @param {DamageDescription[]} damages - Damages to calculate.
	 * @param {DamageApplicationOptions} [options={}] - Damage calculation options.
	 * @returns {DamageDescription[]|false} - New damage descriptions with changes applied, or `false` if the calculation
	 *                                        was canceled by a hook.
	 */
	calculateDamage(damages, options = {}) {
		damages = foundry.utils.deepClone(damages);

		/**
		 * A hook event that fires before damage amount is calculated for an actor.
		 * @param {BlackFlagActor} actor - The actor being damaged.
		 * @param {DamageDescription[]} damages - Damage descriptions.
		 * @param {DamageApplicationOptions} options - Additional damage application options.
		 * @returns {boolean} - Explicitly return `false` to prevent damage application.
		 * @function blackFlag.preCalculateDamage
		 * @memberof hookEvents
		 */
		if (Hooks.call("blackFlag.preCalculateDamage", this, damages, options) === false) return false;

		const multiplier = options.multiplier ?? 1;

		const skipped = type => {
			if (options.only === "damage") return type in CONFIG.BlackFlag.healingTypes;
			if (options.only === "healing") return type in CONFIG.BlackFlag.damageTypes;
			return false;
		};

		damages.forEach(d => {
			d.active ??= {};

			// Skip damage types with immunity
			if (skipped(d.type) || this.#changeHasEffect("immunity", d, { options })) {
				d.value = 0;
				d.active.multiplier = 0;
				return;
			}

			// TODO: Apply damage modification

			let damageMultiplier = multiplier;

			// Apply damage resistance
			if (this.#changeHasEffect("resistance", d, { options })) {
				damageMultiplier /= 2;
			}

			// Apply damage vulnerability
			if (this.#changeHasEffect("vulnerability", d, { options })) {
				damageMultiplier *= 2;
			}

			// Negate healing types
			if (options.invertHealing !== false && d.type === "healing") damageMultiplier *= -1;

			d.value = d.value * damageMultiplier;
			d.active.multiplier = (d.active.multiplier ?? 1) * damageMultiplier;
		});

		if (this.system.attributes?.ac?.threshold && options.ignore !== true && options.ignore?.threshold !== true) {
			const total = damages.reduce((t, d) => t + (["temp", "max"].includes(d.type) ? 0 : d.value), 0);
			if (total < this.system.attributes.ac.threshold) {
				for (const damage of damages) {
					if (["temp", "max"].includes(damage.type) || damage.value <= 0) continue;
					damage.value = 0;
					damage.active ??= {};
					damage.active.threshold = true;
				}
			}
		}

		/**
		 * A hook event that fires after damage amount is calculated for an actor.
		 * @param {BlackFlagActor} actor - The actor being damaged.
		 * @param {DamageDescription[]} damages - Damage descriptions.
		 * @param {DamageApplicationOptions} options - Additional damage application options.
		 * @returns {boolean} - Explicitly return `false` to prevent damage application.
		 * @function blackFlag.postCalculateDamage
		 * @memberof hookEvents
		 */
		if (Hooks.call("blackFlag.postCalculateDamage", this, damages, options) === false) return false;

		return damages;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine whether a specific type of change to a damage value will have an effect.
	 * @param {string} category - What type of change should be considered (e.g. resistance, vulnerability, etc.).
	 * @param {DamageDescription|string} damage - Damage description to consider or a specific type.
	 * @param {object} [options={}]
	 * @param {DamageApplicationOptions} [options.options={}] - Damage application options.
	 * @param {boolean} [options.skipDowngrade=false] - Should downgrades be skipped?
	 * @returns {boolean}
	 */
	#changeHasEffect(category, damage, { options = {}, skipDowngrade = false } = {}) {
		const config =
			this.system.traits?.damage?.[
				{
					immunity: "immunities",
					resistance: "resistances",
					vulnerability: "vulnerabilities"
				}[category]
			];
		const downgrade = type => options.downgrade === true || options.downgrade?.has?.(type);
		const setActive = type => {
			if (damage.active) {
				damage.active[type] ??= {};
				damage.active[type][category] = true;
			}
			return true;
		};
		const type = foundry.utils.getType(damage) === "string" ? damage : damage.type;

		// If category is resistance, check for downgraded immunities
		if (category === "resistance") {
			if (downgrade("all") && this.#changeHasEffect("immunity", "all", { skipDowngrade: true })) {
				return setActive("all");
			}
			if (downgrade(type) && this.#changeHasEffect("immunity", type, { skipDowngrade: true })) {
				return setActive("type");
			}
		}

		// If all damage resistance is present and not ignored
		if (
			!this.#changeIsIgnored(category, "all", { options, skipDowngrade }) &&
			(config?.value.has("all") || (config?.nonmagical.has("all") && !damage.magical))
		) {
			return setActive("all");
		}

		// If specific type damage resistance is present and not ignored
		if (
			!this.#changeIsIgnored(category, type, { options, skipDowngrade }) &&
			(config?.value.has(type) || (config?.nonmagical.has(type) && !damage.magical))
		) {
			return setActive("type");
		}

		return false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine whether a specific damage change type should be ignored.
	 * @param {string} category - What type of change should be considered (e.g. resistance, vulnerability, etc.).
	 * @param {string} type - Specific damage type to consider.
	 * @param {object} [options={}]
	 * @param {DamageApplicationOptions} [options.options={}] - Damage application options.
	 * @param {boolean} [options.skipDowngrade=false] - Should downgrades not be taken into account?
	 * @returns {boolean}
	 */
	#changeIsIgnored(category, type, { options = {}, skipDowngrade = false } = {}) {
		const downgrade = type => options.downgrade === true || options.downgrade?.has?.(type);

		// All categories are ignored
		if (options.ignore === true) return true;

		// Specific category is ignored, or specific category has this type in its ignore list
		if (options.ignore?.[category] === true || options.ignore?.[category]?.has?.(type)) return true;

		// When downgrading, always ignore immunities unless `skipDowngrade` option is set
		if (category === "immunity" && downgrade(type) && !skipDowngrade) return true;

		// When downgrading, resistances should be decided by whether immunity is applied
		if (category === "resistance" && downgrade(type) && !this.#changeHasEffect("immunity", type)) return true;

		return false;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add an advancement change to the application queue. Will automatically start processing advancements if
	 * processing is not currently ongoing.
	 * @param {Advancement} advancement - Advancement upon which the function will be called.
	 * @param {string} functionName - Name of the function to call.
	 * @param {*[]} parameters - Parameters that should be called on the function.
	 */
	enqueueAdvancementChange(advancement, functionName, parameters) {
		this.#advancementQueue.push({ advancement, functionName, parameters });
		if (!this.#advancementProcessing) this.#processAdvancementChanges();
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getRollData(options = {}) {
		let rollData;
		if (this.system.getRollData) rollData = this.system.getRollData(options);
		else rollData = { ...super.getRollData() };
		rollData.flags = { ...this.flags };
		rollData.name = this.name;
		return rollData;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async modifyTokenAttribute(attribute, value, isDelta, isBar) {
		if (["attributes.hp", "attributes.hp.value"].includes(attribute)) {
			const hp = this.system.attributes.hp;
			const delta = isDelta ? -1 * value : hp.value + hp.temp - value;
			return this.applyDamage(delta);
		}
		return super.modifyTokenAttribute(attribute, value, isDelta, isBar);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Begin stepping through the advancement queue.
	 */
	async #processAdvancementChanges() {
		if (this.#advancementProcessing) throw new Error("Advancement processing already in progress.");
		if (!this.#advancementQueue.length) return;
		this.#advancementProcessing = true;

		do {
			const op = this.#advancementQueue.shift();
			await op.advancement[op.functionName].bind(op.advancement)(...op.parameters);
		} while (this.#advancementQueue.length);

		this.#advancementProcessing = false;
		this.render();

		game.socket.emit(`system.${game.system.id}`, {
			operation: "advancementChangesComplete",
			actorId: this.id
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Resting               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration options for a rest.
	 *
	 * @typedef {object} RestConfiguration
	 * @property {string} type - Type of rest performed (e.g. "short" or "long").
	 * @property {boolean} dialog - Present a dialog window for any rest configuration.
	 * @property {boolean} chat - Should a chat message be created to summarize the results of the rest?
	 */

	/**
	 * Results from a rest operation.
	 *
	 * @typedef {object} RestResult
	 * @property {string} type - Type of rest performed (e.g. "short" or "long").
	 * @property {BlackFlagActor} clone - Clone of the actor from before the rest began.
	 * @property {object} deltas
	 * @property {number} deltas.hitPoints - Hit points recovered during the rest.
	 * @property {object} deltas.hitDice - Hit dice spent or recovered during the rest, grouped by size.
	 * @property {object} actorUpdates - Updates applied to the actor.
	 * @property {object[]} itemUpdates - Updates applied to the actor's items.
	 * @property {BasicRoll[]} rolls - Any rolls that occurred during the rest process, not including hit dice.
	 */

	/**
	 * Take a short rest, possibly spending hit dice and recovering resources and item uses.
	 * @param {RestConfiguration} [config={}] - Configuration options for a short rest.
	 * @returns {Promise<RestResult|void>} - Final result of the rest operation.
	 */
	async shortRest(config = {}) {
		return this.rest(foundry.utils.mergeObject({ type: "short" }, config));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Take a long rest, possibly recovering hit points, resources, and item uses.
	 * @param {RestConfiguration} [config={}] - Configuration options for a long rest.
	 * @returns {Promise<RestResult|void>} - Final result of the rest operation.
	 */
	async longRest(config = {}) {
		return this.rest(foundry.utils.mergeObject({ type: "long" }, config));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform all of the changes needed when the actor rests.
	 * @param {RestConfiguration} [config={}] - Configuration options for the rest.
	 * @param {object} [deltas={}] - Any changes that have been made earlier in the process.
	 * @returns {Promise<RestResult>} - Final result of the rest operation.
	 */
	async rest(config = {}, deltas = {}) {
		const restConfig = CONFIG.BlackFlag.rest.types[config.type];
		if (!restConfig) return ui.notifications.error(`Rest type ${config.type} was not defined in configuration.`);
		config = foundry.utils.mergeObject({ dialog: true, chat: true }, config);

		const clone = this.clone();
		const initialHitDice = Object.entries(this.system.attributes?.hd?.d ?? {}).reduce((obj, [d, v]) => {
			obj[d] = v.spent;
			return obj;
		}, {});
		const initialHitPoints = this.system.attributes?.hp?.value ?? 0;

		/**
		 * A hook event that fires before the rest dialog is shown.
		 * @function blackFlag.preRestConfiguration
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - The actor that is being rested.
		 * @param {RestConfiguration} config - Configuration options for the rest.
		 * @returns {boolean} - Explicitly return `false` to prevent the rest from being started.
		 */
		if (Hooks.call("blackFlag.preRestConfiguration", this, config) === false) return;

		const RestDialog = config.dialog ? restConfig.dialogClass : null;
		if (RestDialog) {
			try {
				foundry.utils.mergeObject(config, await RestDialog.rest(this, config));
			} catch (err) {
				return;
			}
		}
		const result = {
			clone,
			type: config.type,
			deltas: {},
			actorUpdates: {},
			itemUpdates: [],
			rolls: []
		};

		/**
		 * A hook event that fires after the rest dialog is shown.
		 * @function blackFlag.restConfiguration
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - The actor that is being rested.
		 * @param {RestConfiguration} config - Configuration options for the rest.
		 * @param {RestResult} result - Details on the rest to be completed.
		 * @returns {boolean} - Explicitly return `false` to prevent the rest from being continued.
		 */
		if (Hooks.call("blackFlag.restConfiguration", this, config, result) === false) return;

		if (this.system.attributes?.hd) {
			let totalHD = 0;
			const hd = this.system.attributes.hd;
			result.deltas.hitDice = Object.keys(hd.d).reduce((obj, d) => {
				obj[d] = (result.deltas.hitDice?.[d] ?? 0) + initialHitDice[d] - hd.d[d].spent;
				totalHD += obj[d];
				return obj;
			}, {});
			result.deltas.hitDice.total = totalHD;
		}
		if (this.system.attributes?.hp) {
			result.deltas.hitPoints = (result.deltas.hitPoints ?? 0) + this.system.attributes.hp.value - initialHitPoints;
		}

		this._getRestHitDiceRecovery(config, result);
		this._getRestHitPointRecovery(config, result);
		this._getRestSpellSlotRecovery(config, result);
		await this._getUsesRecovery(config, result);

		/**
		 * A hook event that fires after rest result is calculated, but before any updates are performed.
		 * @function blackFlag.preRestCompleted
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - The actor that is being rested.
		 * @param {RestResult} result - Details on the rest to be completed.
		 * @returns {boolean} - Explicitly return `false` to prevent the rest updates from being performed.
		 */
		if (Hooks.call("blackFlag.preRestCompleted", this, result) === false) return result;

		await this.update(result.actorUpdates);
		await this.updateEmbeddedDocuments("Item", result.itemUpdates);

		if (chat) await this._displayRestResultMessage(result);

		/**
		 * A hook event that fires when the rest process is completed for an actor.
		 * @function blackFlag.restCompleted
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - The actor that just completed resting.
		 * @param {RestResult} result - Details on the rest completed.
		 */
		Hooks.callAll("blackFlag.restCompleted", this, result);

		return result;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any hit dice recover needed for this rest.
	 * @param {RestConfiguration} [config={}] - Configuration options for the rest.
	 * @param {RestResult} [result={}] - Rest result being constructed.
	 * @internal
	 */
	_getRestHitDiceRecovery(config = {}, result = {}) {
		const restConfig = CONFIG.BlackFlag.rest.types[config.type];
		if (!this.system.attributes?.hd || !restConfig.recoverHitDice) return;
		const hd = this.system.attributes.hd;

		// Determine maximum number of hit dice to recover
		let hitDiceToRecover = Math.ceil(this.system.progression.level * CONFIG.BlackFlag.rest.hitDiceRecoveryPercentage);

		const deltas = {};
		const updates = {};
		for (const denomination of Object.keys(hd.d)
			.map(d => Number(d))
			.sort((lhs, rhs) => rhs - lhs)) {
			const spent = hd.d[denomination].spent;
			const delta = Math.min(spent, hitDiceToRecover);
			if (delta > 0) {
				hitDiceToRecover -= delta;
				deltas[denomination] = (result.deltas?.hitDice[denomination] ?? 0) + delta;
				updates[`d.${denomination}.spent`] = spent - delta;
			}
		}

		foundry.utils.mergeObject(result, {
			deltas: { hitDice: deltas },
			actorUpdates: { "system.attributes.hd": updates }
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any hit point recovery needed for this rest.
	 * @param {RestConfiguration} [config={}] - Configuration options for the rest.
	 * @param {RestResult} [result={}] - Rest result being constructed.
	 * @internal
	 */
	_getRestHitPointRecovery(config = {}, result = {}) {
		const restConfig = CONFIG.BlackFlag.rest.types[config.type];
		if (!this.system.attributes?.hp?.max || !restConfig.recoverHitPoints) return;
		const hp = this.system.attributes.hp;
		const percentage = CONFIG.BlackFlag.rest.hitPointsRecoveryPercentage;
		const final = Math.clamp(hp.value + Math.ceil(hp.max * percentage), 0, hp.max);
		foundry.utils.mergeObject(result, {
			deltas: {
				hitPoints: (result.deltas?.hitPoints ?? 0) + final - hp.value
			},
			actorUpdates: {
				"system.attributes.hp.value": final,
				"system.attributes.hp.temp": 0
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any spell slot recovery needed for this rest.
	 * @param {RestConfiguration} [config={}] - Configuration options for the rest.
	 * @param {RestResult} [result={}] - Rest result being constructed.
	 * @internal
	 */
	_getRestSpellSlotRecovery(config = {}, result = {}) {
		if (!this.system.spellcasting?.slots) return;
		const restConfig = CONFIG.BlackFlag.rest.types[config.type];
		for (const type of Object.keys(CONFIG.BlackFlag.spellcastingTypes)) {
			if (!restConfig.recoverSpellSlotTypes?.has(type)) continue;
			this.system.getRestSpellcastingRecovery?.(type, config, result);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Perform any item & activity uses recover needed for this rest.
	 * @param {RestConfiguration} [config={}] - Configuration options for the rest.
	 * @param {RestResult} [result={}] - Rest result being constructed.
	 */
	async _getUsesRecovery(config = {}, result = {}) {
		const restConfig = CONFIG.BlackFlag.rest.types[config.type];
		if (!restConfig.recoverPeriods?.length) return;
		const rollData = this.getRollData();
		result.itemUpdates = [];
		result.rolls ??= [];
		for (const item of this.items) {
			if (foundry.utils.getType(item.system.recoverUses) !== "function") continue;
			const { updates, rolls } = await item.system.recoverUses(restConfig.recoverPeriods, rollData);
			if (foundry.utils.isEmpty(updates)) continue;
			const updateTarget = result.itemUpdates.find(i => i._id === item.id);
			if (updateTarget) foundry.utils.mergeObject(updateTarget, updates);
			else result.itemUpdates.push({ _id: item.id, ...updates });
			result.rolls.push(...rolls);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the result of a rest operation in chat.
	 * @param {RestResult} result - Results of the rest.
	 * @returns {Promise<ChatMessage>}
	 * @internal
	 */
	async _displayRestResultMessage(result) {
		const restConfig = CONFIG.BlackFlag.rest.types[result.type];

		const totalHD = Object.keys(this.system.attributes?.hd?.d ?? {}).reduce((t, d) => t + result.deltas.hitDice[d], 0);

		// Determine what localization string should be used for the message content
		let resultType = "Basic";
		if (result.deltas.hitPoints && totalHD) resultType = "Full";
		else if (result.type === "long" && result.deltas.hitPoints) resultType = "HitPoints";
		else if (result.type === "long" && totalHD) resultType = "HitDice";
		const localizationString = `${restConfig.resultMessages}.${resultType}`;

		// Prepare localization data
		const pluralRules = getPluralRules();
		const localizationData = {
			name: this.name,
			hitDice: numberFormat(result.type === "long" ? totalHD : -totalHD),
			hitDiceLabel: game.i18n.localize(`BF.HitDie.Label[${pluralRules.select(totalHD)}]`).toLowerCase(),
			hitPoints: numberFormat(result.deltas.hitPoints),
			hitPointsLabel: game.i18n
				.localize(`BF.HitPoint.Label[${pluralRules.select(result.deltas.hitPoints)}]`)
				.toLowerCase()
		};

		const chatData = {
			content: game.i18n.format(localizationString, localizationData),
			flavor: game.i18n.localize(restConfig.label),
			rolls: result.rolls,
			speaker: ChatMessage.getSpeaker({ actor: this, alias: this.name }),
			system: {
				activations: ActivationsField.getActivations(this, restConfig.activationPeriods ?? []),
				deltas: ActorDeltasField.getDeltas(result.clone, { actor: result.actorUpdates, item: result.itemUpdates }),
				type: result.type
			},
			type: "rest"
		};
		ChatMessage.applyRollMode(chatData, game.settings.get("core", "rollMode"));
		return ChatMessage.create(chatData);
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Rolling               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a roll event and pass it on to the indicated rolling method.
	 * @param {string} type - Type of roll to perform.
	 * @param {object} [config] - Additional configuration options.
	 * @param {object} [message] - Configuration data that guides roll message creation.
	 * @param {object} [dialog] - Presentation data for the roll configuration dialog.
	 * @returns {Promise}
	 */
	async roll(type, config, message, dialog) {
		switch (type) {
			case "ability-check":
				return this.rollAbilityCheck(config, message, dialog);
			case "ability-save":
				return this.rollAbilitySave(config, message, dialog);
			case "death-save":
				return this.rollDeathSave(config, message, dialog);
			case "hit-die":
				return this.rollHitDie(config, message, dialog);
			case "initiative":
				return this.configureInitiativeRoll(config, message, dialog);
			case "skill":
				return this.rollSkill(config, message, dialog);
			case "tool":
				return this.rollTool(config, message, dialog);
			case "vehicle":
				return this.rollVehicle(config, message, dialog);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration information for an ability roll.
	 *
	 * @typedef {ChallengeRollProcessConfiguration} AbilityRollProcessConfiguration
	 * @property {string} ability - The ability to be rolled.
	 */

	/**
	 * Roll an ability check.
	 * @param {AbilityRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {ChallengeRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollAbilityCheck(config = {}, dialog = {}, message = {}) {
		const ability = this.system.abilities?.[config.ability];
		const rollData = this.getRollData();

		const rollConfig = foundry.utils.deepClone(config);
		rollConfig.subject = this;
		rollConfig.rolls = [
			{
				...buildRoll(
					{
						mod: ability?.mod,
						prof: ability?.check.proficiency.hasProficiency ? ability?.check.proficiency.term : null,
						bonus: this.system.buildBonus?.(ability?.check.modifiers.bonus, { rollData })
					},
					rollData
				),
				options: {
					minimum: this.system.buildMinimum?.(ability?.check.modifiers.minimum, { rollData })
				}
			}
		].concat(config.rolls ?? []);

		const type = game.i18n.format("BF.Ability.Action.CheckSpecific", {
			ability: CONFIG.BlackFlag.abilities.localized[config.ability] ?? ""
		});
		const dialogConfig = foundry.utils.mergeObject(
			{
				options: {
					rollNotes: this.system.getModifiers?.(ability?.check.modifiers._data, "note"),
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor: type,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								ability: config.ability,
								type: "ability-check"
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before an ability check is rolled.
		 * @function blackFlag.preRollAbilityCheck
		 * @memberof hookEvents
		 * @param {AbilityRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {ChallengeRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollAbilityCheck", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires after an ability check has been rolled.
		 * @function blackFlag.postRollAbilityCheck
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {string} data.ability - ID of the ability that was rolled as defined in `CONFIG.BlackFlag.abilities`.
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 */
		if (rolls?.length)
			Hooks.callAll("blackFlag.postRollAbilityCheck", rolls, { ability: config.ability, subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Roll an ability saving throw.
	 * @param {AbilityRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {ChallengeRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollAbilitySave(config = {}, dialog = {}, message = {}) {
		const ability = this.system.abilities?.[config.ability];
		const rollData = this.getRollData();

		const rollConfig = foundry.utils.deepClone(config);
		rollConfig.subject = this;
		rollConfig.rolls = [
			{
				...buildRoll(
					{
						mod: ability?.mod,
						prof: ability?.save.proficiency.hasProficiency ? ability?.save.proficiency.term : null,
						bonus: this.system.buildBonus?.(ability?.save.modifiers.bonus, { rollData })
					},
					rollData
				),
				options: {
					minimum: this.system.buildMinimum?.(ability?.save.modifiers.minimum, { rollData }),
					target: config.target
				}
			}
		].concat(config.rolls ?? []);

		const type = game.i18n.format("BF.Ability.Action.SaveSpecificLong", {
			ability: CONFIG.BlackFlag.abilities.localized[config.ability] ?? ""
		});
		const dialogConfig = foundry.utils.mergeObject(
			{
				options: {
					rollNotes: this.system.getModifiers?.(ability?.save.modifiers._data, "note"),
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor: type,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								ability: config.ability,
								type: "ability-save"
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before an save check is rolled.
		 * @function blackFlag.preRollAbilitySave
		 * @memberof hookEvents
		 * @param {AbilityRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {ChallengeRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollAbilitySave", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires after an ability save has been rolled.
		 * @function blackFlag.postRollAbilitySave
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {string} data.ability - ID of the ability that was rolled as defined in `CONFIG.BlackFlag.abilities`.
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 */
		if (rolls?.length)
			Hooks.callAll("blackFlag.postRollAbilitySave", rolls, { ability: config.ability, subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration data for death saving throw rolls.
	 *
	 * @typedef {ChallengeRollProcessConfiguration} DeathSaveRollProcessConfiguration
	 * @property {number} [successThreshold] - Number of successes required to stabilize.
	 * @property {number} [failureThreshold] - Number of failures required to die.
	 */

	/**
	 * Roll a death saving throw.
	 * @param {DeathSaveRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {ChallengeRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollDeathSave(config = {}, dialog = {}, message = {}) {
		const death = this.system.attributes.death;
		if (!death) return;

		const modifierData = { type: "death-save" };
		const rollData = this.getRollData();

		const rollConfig = foundry.utils.mergeObject(
			{
				successThreshold: death.overrides.success
					? death.overrides.success
					: CONFIG.BlackFlag.deathSave.successThreshold,
				failureThreshold: death.overrides.failure
					? death.overrides.failure
					: CONFIG.BlackFlag.deathSave.failureThreshold
			},
			config
		);
		rollConfig.subject = this;
		rollConfig.rolls = [
			{
				...buildRoll(
					{
						bonus: this.system.buildBonus?.(this.system.getModifiers?.(modifierData), { rollData })
					},
					rollData
				),
				options: {
					minimum: this.system.buildMinimum?.(this.system.getModifiers?.(modifierData, "min"), { rollData }),
					target: config.target ?? death.overrides.target ? death.overrides.target : CONFIG.BlackFlag.deathSave.target
				}
			}
		].concat(config.rolls ?? []);

		const type = game.i18n.localize("BF.Death.Label[one]");
		const dialogConfig = foundry.utils.mergeObject(
			{
				options: {
					rollNotes: this.system.getModifiers?.(modifierData, "note"),
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								type: "death-save"
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before an death save is rolled for an Actor.
		 * @function blackFlag.preRollDeathSave
		 * @memberof hookEvents
		 * @param {DeathSaveRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {ChallengeRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent death save from being rolled.
		 */
		if (Hooks.call("blackFlag.preRollDeathSave", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);
		if (!rolls?.length) return;
		const roll = rolls[0];

		const details = { subject: this };

		// Save success
		if (roll.total >= (roll.options.target ?? CONFIG.BlackFlag.deathSave.target)) {
			let successes = (death.success || 0) + 1;

			// Critical success, you're back up!
			if (roll.isCriticalSuccess) {
				details.updates = {
					"system.attributes.death.status": "alive",
					"system.attributes.death.success": 0,
					"system.attributes.death.failure": 0,
					"system.attributes.hp.value": 1
				};
				details.chatString = "BF.Death.Message.CriticalSuccess";
			}

			// Three successes, you're stabilized
			else if (successes >= rollConfig.successThreshold) {
				details.updates = {
					"system.attributes.death.status": "stable",
					"system.attributes.death.success": rollConfig.successThreshold
				};
				details.chatString = "BF.Death.Message.Success";
				details.count = rollConfig.successThreshold;
			}

			// Increment successes
			else
				details.updates = {
					"system.attributes.death.success": Math.clamp(successes, 0, rollConfig.successThreshold)
				};
		}

		// Save failure
		else {
			let failures = (death.failure || 0) + (roll.isCriticalFailure ? 2 : 1);
			details.updates = {
				"system.attributes.death.failure": Math.clamp(failures, 0, rollConfig.failureThreshold)
			};
			// Three failures, you're dead
			if (failures >= rollConfig.failureThreshold) {
				details.updates["system.attributes.death.status"] = "dead";
				details.chatString = "BF.Death.Message.Failure";
				details.count = rollConfig.failureThreshold;
			}
		}

		/**
		 * A hook event that fires after a death saving throw has been rolled for an Actor, but before
		 * updates have been performed.
		 * @function blackFlag.rollDeathSave
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {string} data.chatString - Localizable string displayed in the create chat message. If not set,
		 *                                      then no chat message will be displayed.
		 * @param {number} data.count - Number of rolls succeeded or failed to result in this message.
		 * @param {object} data.updates - Updates that will be applied to the actor as a result of this save.
		 * @param {BlackFlagActor} data.subject - Actor for which the death saving throw has been rolled.
		 * @returns {boolean} - Explicitly return `false` to prevent updates from being performed.
		 */
		if (Hooks.call("blackFlag.rollDeathSave", this, rolls, details) === false) return roll;

		if (!foundry.utils.isEmpty(details.updates)) await this.update(details.updates);

		// Display success/failure chat message
		if (details.chatString) {
			const pluralRule = new Intl.PluralRules(game.i18n.lang).select(details.count);
			const numberFormatter = new Intl.NumberFormat(game.i18n.lang);
			const counted = game.i18n.format("BF.Death.Message.Counted", {
				count: numberFormatter.format(details.count),
				label: game.i18n.localize(`BF.Death.Message.Label[${pluralRule}]`)
			});
			let chatData = {
				content: game.i18n.format(details.chatString, { name: this.name, counted }),
				speaker: messageConfig.data.speaker
			};
			ChatMessage.applyRollMode(chatData, roll.options.rollMode);
			await ChatMessage.create(chatData);
		}

		/**
		 * A hook event that fires after a death saving throw has been rolled and the actor has been updated.
		 * @function blackFlag.postRollDeathSave
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {BlackFlagActor} data.subject - Actor for which the death saving throw has been rolled.
		 */
		Hooks.callAll("blackFlag.postRollDeathSave", rolls, { subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration data for a hit die roll.
	 *
	 * @typedef {BasicRollProcessConfiguration} HitDieRollProcessConfiguration
	 * @property {number} [denomination] - Denomination of hit dice to roll.
	 * @property {boolean} [modifySpentHitDie=true] - Should the actor's spent hit die count be updated?
	 * @property {boolean} [modifyHitPoints=true] - Should the actor's hit points be updated after the roll?
	 */

	/**
	 * Roll one of the actor's hit die and add its value to their health.
	 * @param {HitDieRollConfiguration} [config] - Configuration information for the roll.
	 * @param {BasicRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<BasicRoll[]|void>}
	 */
	async rollHitDie(config = {}, dialog = {}, message = {}) {
		if (!this.system.attributes?.hd) return;

		// If no denomination is chosen, use the highest HD that is available
		if (!config.denomination) {
			config.denomination = Object.entries(this.system.attributes.hd.d)
				.filter(([k, v]) => v.available > 0)
				.sort((lhs, rhs) => rhs[1].available - lhs[1].available)[0]?.[0];
			if (!config.denomination) {
				return ui.notifications.warn("BF.HitDie.Warning.NoneAvailableGeneric", { localize: true });
			}
		}

		// Ensure there is a hit die to spend
		else if (!this.system.attributes.hd.d[config.denomination]?.available) {
			return ui.notifications.warn(
				game.i18n.format("BF.HitDie.Warning.NoneAvailableSpecific", {
					denomination: config.denomination
				})
			);
		}

		const rollData = this.getRollData();
		const modifierData = { type: "hit-die", denomination: config.denomination };
		const minimum = this.system.buildMinimum?.(this.system.getModifiers?.(modifierData, "min"), { rollData });

		let die = `1d${config.denomination}`;
		if (minimum) die = `${die}min${minimum}`;
		config.denomination = Number(config.denomination);
		const rollConfig = foundry.utils.deepClone(config);
		rollConfig.rolls = [
			{
				...buildRoll(
					{
						base: `max(0, ${die} + @abilities.${CONFIG.BlackFlag.defaultAbilities.hitPoints}.mod)`,
						bonus: this.system.buildBonus?.(this.system.getModifiers?.(modifierData), { rollData })
					},
					rollData
				)
			}
		].concat(config.rolls ?? []);

		const type = game.i18n.localize("BF.HitDie.Label[one]");
		const dialogConfig = foundry.utils.mergeObject(
			{
				configure: false,
				options: {
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Type.Label", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor: flavor,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								denomination: config.denomination,
								type: "hit-die"
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before a hit die is rolled.
		 * @function blackFlag.preRollHitDie
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - Actor for which the roll is being performed.
		 * @param {HitDieRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {BasicRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollHitDie", this, rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.BasicRoll.build(rollConfig, dialogConfig, messageConfig);

		const updates = {};
		if (rollConfig.modifySpentHitDie !== false) {
			const hd = this.system.attributes.hd.d[config.denomination];
			updates[`system.attributes.hd.d.${config.denomination}.spent`] = hd.spent + 1;
		}
		if (rollConfig.modifyHitPoints !== false) {
			const hp = this.system.attributes.hp;
			updates["system.attributes.hp.value"] = Math.min(hp.max, hp.value + (rolls[0]?.total ?? 0));
		}

		/**
		 * A hook event that fires after a hit die has been rolled for an Actor, but before updates have been performed.
		 * @function blackFlag.rollHitDie
		 * @memberof hookEvents
		 * @param {BasicRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 * @param {object} data.updates - Updates that will be applied to the actor.
		 * @returns {boolean} - Explicitly return `false` to prevent updates from being performed.
		 */
		if (Hooks.call("blackFlag.rollHitDie", rolls, { subject: this, updates }) === false) return rolls;

		if (!foundry.utils.isEmpty(updates)) await this.update(updates);

		/**
		 * A hook event that fires after a hit die has been rolled for an Actor and updates have been performed.
		 * @function blackFlag.postRollHitDie
		 * @memberof hookEvents
		 * @param {BasicRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 */
		Hooks.callAll("blackFlag.postRollHitDie", rolls, { subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {ChallengeRollProcessConfiguration} InitiativeRollProcessConfiguration
	 * @property {number} [fixed] - Fixed initiative value, will bypass any rolling.
	 */

	/**
	 * Construct an initiative roll.
	 * @param {ChallengeRollOptions} [options] - Options for the roll.
	 * @returns {InitiativeRollProcessConfiguration}
	 */
	getInitiativeRollConfig(options = {}) {
		const rollConfig = this.system.getInitiativeRollConfig?.(options) ?? {};

		/**
		 * A hook event that fires when initiative roll configuration is being prepared.
		 * @function blackFlag.initiativeConfig
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - Actor for which the initiative is being configured.
		 * @param {InitiativeRollProcessConfiguration} config - Configuration data for the pending roll.
		 */
		Hooks.callAll("blackFlag.initiativeConfig", this, rollConfig);

		return rollConfig;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Present the initiative roll configuration dialog and then roll initiative.
	 * @param {InitiativeRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {ChallengeRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @returns {Promise<Combat|void>}
	 */
	async configureInitiativeRoll(config = {}, dialog = {}) {
		const init = this.system.attributes?.initiative ?? {};
		const rollConfig = foundry.utils.mergeObject(this.getInitiativeRollConfig(config.options), config);

		if (rollConfig.fixed) {
			return await this.rollInitiative({
				createCombatants: true,
				initiativeOptions: { formula: `${rollConfig.fixed}` }
			});
		}

		const dialogConfig = foundry.utils.mergeObject(
			{
				options: {
					rollNotes: this.system.getModifiers?.(init.modifiers?._data, "note"),
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", {
						type: game.i18n.localize("BF.Initiative.Label")
					})
				}
			},
			dialog
		);

		const Roll = CONFIG.Dice.ChallengeRoll;
		Roll.applyKeybindings(rollConfig, dialogConfig);

		let rolls;
		if (dialogConfig.configure) {
			let DialogClass = dialogConfig.applicationClass ?? Roll.DefaultConfigurationDialog;
			try {
				rolls = await DialogClass.configure(rollConfig, dialogConfig);
			} catch (err) {
				if (!err) return;
				throw err;
			}
		} else {
			rolls = Roll.create(rollConfig);
		}

		if (!rolls?.length) return;
		this._cachedInitiativeRolls = rolls;
		await this.rollInitiative({ createCombatants: true });
		delete this._cachedInitiativeRolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async rollInitiative(options = {}) {
		/**
		 * A hook event that fires before initiative is rolled for an Actor.
		 * @function blackFlag.preRollInitiative
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - Actor for which the initiative is being rolled.
		 * @param {ChallengeRoll[]} roll - The initiative rolls.
		 * @returns {boolean} - Explicitly return `false` to prevent initiative from being rolled.
		 */
		if (Hooks.call("blackFlag.preRollInitiative", this, this._cachedInitiativeRolls) === false) return;

		const combat = await super.rollInitiative(options);
		const combatants = this.isToken
			? this.getActiveTokens(false, true).filter(t => game.combat.getCombatantByToken(t.id))
			: [game.combat.getCombatantByActor(this.id)];

		/**
		 * A hook event that fires after an Actor has rolled for initiative.
		 * @function blackFlag.rollInitiative
		 * @memberof hookEvents
		 * @param {BlackFlagActor} actor - The Actor that has rolled initiative.
		 * @param {CombatantEH[]} combatants - The associated Combatants in the Combat.
		 */
		Hooks.callAll("blackFlag.rollInitiative", this, combatants);

		return combat;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * @typedef {ChallengeRollProcessConfiguration} SkillRollProcessConfiguration
	 * @property {string} skill - The skill to roll.
	 * @property {string} [ability] - The ability to be rolled with the skill.
	 */

	/**
	 * @typedef {ChallengeRollDialogConfiguration} SkillRollDialogConfiguration
	 * @property {SkillRollConfigurationDialogOptions} [options] - Configuration options.
	 */

	/**
	 * Roll a skill check.
	 * @param {Partial<SkillRollProcessConfiguration>} [config] - Configuration information for the roll.
	 * @param {Partial<SkillRollDialogConfiguration>} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {Partial<BasicRollMessageConfiguration>} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollSkill(config = {}, dialog = {}, message = {}) {
		const skill = this.system.proficiencies?.skills?.[config.skill];
		if (!skill) return this.rollAbilityCheck(config, dialog, message);
		const rollData = this.getRollData();

		const prepareSkillConfig = (baseConfig, rollConfig, formData, index) => {
			const abilityId = formData?.get("ability") ?? baseConfig.ability ?? skill.ability;
			const ability = this.system.abilities[abilityId];

			const modifierData = [
				{ type: "ability-check", ability: abilityId, proficiency: skill.proficiency.multiplier },
				{ type: "skill-check", ability: abilityId, skill: config.skill, proficiency: skill.proficiency.multiplier }
			];

			rollConfig = foundry.utils.mergeObject(rollConfig, {
				...buildRoll(
					{
						mod: ability?.mod,
						prof: skill.proficiency.hasProficiency ? skill.proficiency.term : null,
						bonus: this.system.buildBonus?.(this.system.getModifiers?.(modifierData), { rollData }),
						situational: rollConfig.data?.situational
					},
					{ ...rollData }
				),
				options: {
					minimum: this.system.buildMinimum?.(this.system.getModifiers?.(modifierData, "min"), { rollData }),
					target: rollConfig.target ?? config.target
				}
			});
			rollConfig.data.abilityId = abilityId;

			return { rollConfig, rollNotes: this.system.getModifiers?.(modifierData, "note") };
		};

		const rollConfig = foundry.utils.deepClone(config);
		const { rollConfig: roll, rollNotes } = prepareSkillConfig(rollConfig, {});
		rollConfig.subject = this;
		rollConfig.rolls = [roll].concat(config.rolls ?? []);

		const type = game.i18n.format("BF.Skill.Action.CheckSpecific", {
			skill: game.i18n.localize(CONFIG.BlackFlag.skills[config.skill].label)
		});
		const dialogConfig = foundry.utils.mergeObject(
			{
				applicationClass: SkillRollConfigurationDialog,
				options: {
					buildConfig: prepareSkillConfig,
					chooseAbility: true,
					rollNotes,
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor: type,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								skill: rollConfig.skill,
								type: "skill"
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before a skill check is rolled.
		 * @function blackFlag.preRollSkill
		 * @memberof hookEvents
		 * @param {SkillRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {SkillRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollSkill", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires after a skill check has been rolled.
		 * @function blackFlag.postRollSkill
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {string} data.skill - ID of the skill that was rolled as defined in `CONFIG.BlackFlag.skills`.
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 */
		if (rolls?.length) Hooks.callAll("blackFlag.postRollSkill", rolls, { skill: config.skill, subject: this });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration information for a tool roll.
	 *
	 * @typedef {ChallengeRollProcessConfiguration} ToolRollProcessConfiguration
	 * @property {string} tool - The tool to roll.
	 * @property {string} [ability] - The ability to be rolled with the tool.
	 */

	/**
	 * Roll a Tool check.
	 * @param {ToolRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {ChallengeRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollTool(config = {}, dialog = {}, message = {}) {
		let tool = this.system.proficiencies?.tools?.[config.tool];
		if (!tool) {
			const toolConfig = configForKey(config.tool, { trait: "tools" });
			if (!toolConfig) return;
			tool = {
				label: toolConfig.label,
				proficiency: new Proficiency(this.system.attributes.proficiency, 0)
			};
		}
		const rollData = this.getRollData();

		const prepareToolConfig = (baseConfig, rollConfig, formData, index) => {
			const abilityId = formData?.get("ability") ?? baseConfig.ability ?? tool.ability ?? "intelligence";
			const ability = this.system.abilities[abilityId];

			const modifierData = [
				{ type: "ability-check", ability: abilityId, proficiency: tool.proficiency.multiplier },
				{ type: "tool-check", ability: abilityId, tool: config.tool, proficiency: tool.proficiency.multiplier }
			];

			rollConfig = foundry.utils.mergeObject(rollConfig, {
				...buildRoll(
					{
						mod: ability?.mod,
						prof: tool.proficiency.hasProficiency ? tool.proficiency.term : null,
						bonus: this.system.buildBonus?.(this.system.getModifiers?.(modifierData), { rollData }),
						situational: rollConfig.data?.situational
					},
					{ ...rollData }
				),
				options: {
					minimum: this.system.buildMinimum?.(this.system.getModifiers?.(modifierData, "min"), { rollData }),
					target: rollConfig.target ?? config.target
				}
			});
			rollConfig.data.abilityId = abilityId;

			return { rollConfig, rollNotes: this.system.getModifiers?.(modifierData, "note") };
		};

		const rollConfig = foundry.utils.deepClone(config);
		const { rollConfig: roll, rollNotes } = prepareToolConfig(rollConfig, {});
		rollConfig.subject = this;
		rollConfig.rolls = [roll].concat(config.rolls ?? []);

		const type = game.i18n.format("BF.Tool.Action.CheckSpecific", {
			tool: game.i18n.localize(tool.label)
		});
		const dialogConfig = foundry.utils.mergeObject(
			{
				applicationClass: SkillRollConfigurationDialog,
				options: {
					buildConfig: prepareToolConfig,
					chooseAbility: true,
					rollNotes,
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor: type,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								tool: rollConfig.tool,
								type: "tool"
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before a tool check is rolled.
		 * @function blackFlag.preRollTool
		 * @memberof hookEvents
		 * @param {ToolRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {ChallengeRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollTool", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires after a tool check has been rolled.
		 * @function blackFlag.postRollTool
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {object} data
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 * @param {string} data.tool - ID of the tool that was rolled as defined in `CONFIG.BlackFlag.tools`.
		 */
		if (rolls?.length) Hooks.callAll("blackFlag.postRollTool", rolls, { subject: this, tool: config.tool });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Configuration information for a vehicle roll.
	 *
	 * @typedef {ChallengeRollProcessConfiguration} VehicleRollProcessConfiguration
	 * @property {string} vehicle - The vehicle type to roll.
	 * @property {string} [ability] - The ability to be rolled with the vehicle.
	 */

	/**
	 * Roll a Vehicle check.
	 * @param {VehicleRollProcessConfiguration} [config] - Configuration information for the roll.
	 * @param {ChallengeRollDialogConfiguration} [dialog] - Presentation data for the roll configuration dialog.
	 * @param {BasicRollMessageConfiguration} [message] - Configuration data that guides roll message creation.
	 * @returns {Promise<ChallengeRoll[]|void>}
	 */
	async rollVehicle(config = {}, dialog = {}, message = {}) {
		let vehicle = this.system.proficiencies?.vehicles?.[config.vehicle];
		if (!vehicle) {
			const vehicleConfig = configForKey(config.vehicle, { trait: "vehicles" });
			if (!vehicleConfig) return;
			vehicle = {
				label: vehicleConfig.label,
				proficiency: new Proficiency(this.system.attributes.proficiency, 0)
			};
		}
		const rollData = this.getRollData();

		const prepareVehicleConfig = (baseConfig, rollConfig, formData, index) => {
			const abilityId = formData?.get("ability") ?? baseConfig.ability ?? vehicle.ability ?? "dexterity";
			const ability = this.system.abilities[abilityId];

			const modifierData = [
				{ type: "ability-check", ability: abilityId, proficiency: vehicle.proficiency.multiplier },
				{
					type: "vehicle-check",
					ability: abilityId,
					vehicle: config.vehicle,
					proficiency: vehicle.proficiency.multiplier
				}
			];

			rollConfig = foundry.utils.mergeObject(rollConfig, {
				...buildRoll(
					{
						mod: ability?.mod,
						prof: vehicle.proficiency.hasProficiency ? vehicle.proficiency.term : null,
						bonus: this.system.buildBonus?.(this.system.getModifiers?.(modifierData), { rollData }),
						situational: rollConfig.data?.situational
					},
					{ ...rollData }
				),
				options: {
					minimum: this.system.buildMinimum?.(this.system.getModifiers?.(modifierData, "min"), { rollData }),
					target: rollConfig.target ?? config.target
				}
			});
			rollConfig.data.abilityId = abilityId;

			return { rollConfig, rollNotes: this.system.getModifiers?.(modifierData, "note") };
		};

		const rollConfig = foundry.utils.deepClone(config);
		const { rollConfig: roll, rollNotes } = prepareVehicleConfig(rollConfig, {});
		rollConfig.subject = this;
		rollConfig.rolls = [roll].concat(config.rolls ?? []);

		const type = game.i18n.format("BF.VEHICLE.Action.CheckSpecific", {
			vehicle: game.i18n.localize(vehicle.label)
		});
		const dialogConfig = foundry.utils.mergeObject(
			{
				applicationClass: SkillRollConfigurationDialog,
				options: {
					buildConfig: prepareVehicleConfig,
					chooseAbility: true,
					rollNotes,
					title: game.i18n.format("BF.Roll.Configuration.LabelSpecific", { type })
				}
			},
			dialog
		);

		const flavor = game.i18n.format("BF.Roll.Action.RollSpecific", { type });
		const messageConfig = foundry.utils.mergeObject(
			{
				data: {
					title: `${flavor}: ${this.name}`,
					flavor: type,
					speaker: ChatMessage.getSpeaker({ actor: this }),
					flags: {
						[game.system.id]: {
							messageType: "roll",
							roll: {
								type: "vehicle",
								vehicle: rollConfig.vehicle
							}
						}
					}
				}
			},
			message
		);

		/**
		 * A hook event that fires before a vehicle check is rolled.
		 * @function blackFlag.preRollVehicle
		 * @memberof hookEvents
		 * @param {VehicleRollProcessConfiguration} config - Configuration data for the pending roll.
		 * @param {ChallengeRollDialogConfiguration} dialog - Presentation data for the roll configuration dialog.
		 * @param {BasicRollMessageConfiguration} message - Configuration data for the roll's message.
		 * @returns {boolean} - Explicitly return `false` to prevent the roll.
		 */
		if (Hooks.call("blackFlag.preRollVehicle", rollConfig, dialogConfig, messageConfig) === false) return;

		const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);

		/**
		 * A hook event that fires after a vehicle check has been rolled.
		 * @function blackFlag.postRollVehicle
		 * @memberof hookEvents
		 * @param {ChallengeRoll[]} rolls - The resulting rolls.
		 * @param {BlackFlagActor} data.subject - Actor for which the roll has been performed.
		 * @param {string} data.vehicle - ID of the vehicle type that was rolled as defined in `CONFIG.BlackFlag.vehicles`.
		 */
		if (rolls?.length) Hooks.callAll("blackFlag.postRollVehicle", rolls, { subject: this, vehicle: config.vehicle });

		return rolls;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*            Context Menus            */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Set up any hooks relevant to actor rendering.
	 */
	static setupHooks() {
		Hooks.on("getActorDirectoryEntryContext", this.getActorDirectoryEntryContext);
		Hooks.on("getUserContextOptions", this.getUserContextOptions);
		game.socket.on(`system.${game.system.id}`, data => {
			if (data?.operation === "advancementChangesComplete") game.actors.get(data.actorId)?.render();
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the "Grant Luck" context option for GMs on PC actors in sidebar.
	 * @param {jQuery} jQuery - The Application's rendered HTML.
	 * @param {ContextMenuEntry[]} menuItems - The array of menu items being rendered.
	 */
	static getActorDirectoryEntryContext(jQuery, menuItems) {
		const ownershipIndex = menuItems.findIndex(o => o.icon.includes("fa-lock"));
		menuItems.splice(ownershipIndex + 1, 0, {
			name: "BF.Luck.Action.Grant",
			icon: '<i class="fa-solid fa-clover"></i>',
			condition: li => {
				if (!game.user.isGM) return false;
				const actor = game.actors.get(li[0].dataset.documentId);
				return actor?.type === "pc";
			},
			callback: li => {
				const actor = game.actors.get(li[0].dataset.documentId);
				actor.system.addLuck();
			},
			group: "system"
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Display the "Grant Luck" context option for GMs on players.
	 * @param {jQuery} jQuery - The Application's rendered HTML.
	 * @param {ContextMenuEntry[]} menuItems - The array of menu items being rendered.
	 */
	static getUserContextOptions(jQuery, menuItems) {
		const viewAvatarIndex = menuItems.findIndex(o => o.icon.includes("fa-image"));
		menuItems.splice(viewAvatarIndex + 1, 0, {
			name: "BF.Luck.Action.Grant",
			icon: '<i class="fa-solid fa-clover"></i>',
			condition: li => {
				if (!game.user.isGM) return false;
				const user = game.users.get(li[0].dataset.userId);
				return user.character?.type === "pc";
			},
			callback: li => {
				const actor = game.users.get(li[0].dataset.userId).character;
				actor.system.addLuck();
			}
		});
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onCreateDescendantDocuments(parent, collection, documents, data, options, userId) {
		if (userId === game.userId && collection === "items") {
			await this.system.updateEncumbrance?.(options);
			if (!options.keepRelationship) {
				const updates = documents.map(d => ({ _id: d.id, [`flags.${game.system.id}.relationship.enabled`]: true }));
				await this.updateEmbeddedDocuments("Item", updates);
			}
		}
		super._onCreateDescendantDocuments(parent, collection, documents, data, options, userId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId) {
		if (userId === game.userId && collection === "items") await this.system.updateEncumbrance?.(options);
		super._onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		const origin = this.getFlag(game.system.id, "summon.origin");
		if (origin) BlackFlag.registry.summons.untrack(origin.split(".Item.")[0], this.uuid);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId) {
		if (userId === game.userId && collection === "items") await this.system.updateEncumbrance?.(options);
		super._onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId);
	}
}

/**
 * Extended version of Combat with support for uses recovery.
 */
class BlackFlagCombat extends Combat {
	/** @inheritDoc */
	async startCombat() {
		await super.startCombat();
		this._recoverUses({ encounter: true });
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async endCombat() {
		await super.endCombat();
		this._recoverUses({ turn: true, roundEnd: true, roundStart: true });
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async rollInitiative(ids, options = {}) {
		await super.rollInitiative(ids, options);
		for (const id of ids) await this._recoverUses({ initiative: this.combatants.get(id) });
		return this;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onEndTurn(combatant) {
		await super._onEndTurn(combatant);
		this._recoverUses({ roundEnd: combatant });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	async _onStartTurn(combatant) {
		await super._onStartTurn(combatant);
		this._recoverUses({ turn: true, roundStart: combatant });
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Reset combat specific uses for certain combatants.
	 * @param {Record<string, boolean|BFCombatant>} types - Which types of recovery to handle, and whether they should be
	 *                                                      performed on all combatants or only the combatant specified.
	 */
	async _recoverUses(types) {
		for (const combatant of this.combatants) {
			const periods = Object.entries(types)
				.filter(([, v]) => v === true || v === combatant)
				.map(([k]) => k);
			if (periods.length) await combatant.recoverCombatUses(periods);
		}
	}
}

/**
 * @import { ActorDeltasData } from "../data/chat-message/fields/deltas-field.mjs";
 */

/**
 * @typedef CombatRecoveryResults
 * @property {object} actor - Updates to be applied to the actor.
 * @property {object[]} item - Updates to be applied to the actor's items.
 * @property {BasicRoll[]} rolls - Any recovery rolls performed.
 */

/**
 * Extended version of `Combatant` class to support initiative rolls.
 */
class BlackFlagCombatant extends Combatant {
	/**
	 * Create a chat message representing actor changes and displaying possible actions for this turn.
	 * @param {object} [data={}]
	 * @param {ActorDeltasData} [data.deltas]
	 * @param {string[]} [data.periods]
	 * @param {BasicRoll[]} [data.rolls]
	 * @returns {BlackFlagChatMessage|void}
	 */
	async createTurnMessage({ deltas, periods, rolls } = {}) {
		const messageConfig = {
			create: false,
			data: {
				rolls,
				speaker: ChatMessage.getSpeaker({ actor: this.actor, token: this.token }),
				system: {
					deltas,
					periods,
					activations: ActivationsField.getActivations(this.actor, periods),
					origin: {
						combat: this.combat.id,
						combatant: this.id
					}
				},
				type: "turn",
				whisper: game.users.filter(u => this.actor.testUserPermission(u, "OWNER"))
			}
		};

		if (
			!foundry.utils.isEmpty(messageConfig.data.system.deltas?.actor) ||
			!foundry.utils.isEmpty(messageConfig.data.system.deltas?.item) ||
			!foundry.utils.isEmpty(messageConfig.data.system.activations)
		)
			messageConfig.create = true;

		/**
		 * A hook event that fires before a combat state change chat message is created.
		 * @function blackFlag.preCreateCombatMessage
		 * @memberof hookEvents
		 * @param {BlackFlagCombatant} combatant - Combatant for which the message will be created.
		 * @param {object} messageConfig
		 * @param {boolean} messageConfig.create - Should the chat message be posted?
		 * @param {object} messageConfig.data - Data for the created chat message.
		 */
		Hooks.callAll("blackFlag.preCreateCombatMessage", this, messageConfig);

		if (messageConfig.create) return ChatMessage.implementation.create(messageConfig.data);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	getInitiativeRoll(formula) {
		if (formula) return super.getInitiativeRoll(formula);
		if (this.actor?._cachedInitiativeRolls?.[0]) return this.actor._cachedInitiativeRolls[0].clone();
		const config = this.actor?.getInitiativeRollConfig() ?? {};
		if (config.fixed !== undefined) return new CONFIG.Dice.BasicRoll(`${config.fixed}`);
		return CONFIG.Dice.ChallengeRoll.fromConfig(config.rolls[0]);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Reset combat-related uses.
	 * @param {string[]} periods - Which recovery periods should be considered.
	 * @returns {Promise<BlackFlagCombatant>}
	 */
	async recoverCombatUses(periods) {
		/**
		 * A hook event that fires before combat-related recovery changes.
		 * @function blackFlag.preCombatRecovery
		 * @memberof hookEvents
		 * @param {BlackFlagCombatant} combatant - Combatant that is being recovered.
		 * @param {string[]} periods - Periods to be recovered.
		 * @returns {boolean} - Explicitly return `false` to prevent recovery from being performed.
		 */
		if (Hooks.call("blackFlag.preCombatRecovery", this, periods) === false) return;

		const results = { actor: {}, item: [], rolls: [] };
		await this.actor?.system.recoverCombatUses?.(periods, results);

		for (const item of this.actor?.items ?? []) {
			if (foundry.utils.getType(item.system.recoverUses) !== "function") continue;
			const rollData = item.getRollData();
			const { updates, rolls } = await item.system.recoverUses(periods, rollData);
			if (!foundry.utils.isEmpty(updates)) {
				const updateTarget = results.item.find(i => i._id === item.id);
				if (updateTarget) foundry.utils.mergeObject(updateTarget, updates);
				else results.item.push({ _id: item.id, ...updates });
			}
			results.rolls.push(...rolls);
		}

		/**
		 * A hook event that fires after combat-related recovery changes have been prepared, but before they have been
		 * applied to the actor.
		 * @function blackFlag.combatRecovery
		 * @memberof hookEvents
		 * @param {BlackFlagCombatant} combatant - Combatant that is being recovered.
		 * @param {string[]} periods - Periods that were recovered.
		 * @param {CombatRecoveryResults} results - Update that will be applied to the actor and its items.
		 * @returns {boolean} - Explicitly return `false` to prevent updates from being performed.
		 */
		if (Hooks.call("blackFlag.combatRecovery", this, periods, results) === false) return;

		const deltas = ActorDeltasField.getDeltas(this.actor, results);

		if (!foundry.utils.isEmpty(results.actor)) await this.actor.update(results.actor);
		if (results.item.length) await this.actor.updateEmbeddedDocuments("Item", results.item);

		const message = await this.createTurnMessage({ deltas, periods, rolls: results.rolls });

		/**
		 * A hook event that fires after combat-related recovery changes have been applied.
		 * @function blackFlag.postCombatRecovery
		 * @memberof hookEvents
		 * @param {BlackFlagCombatant} combatant - Combatant that is being recovered.
		 * @param {string[]} periods - Periods that were recovered.
		 * @param {ChatMessage5e|void} message - Chat message created, if any.
		 */
		Hooks.callAll("blackFlag.postCombatRecovery", this, periods, message);
	}
}

class BlackFlagJournalEntryPage extends EmbedMixin(JournalEntryPage) {}

/**
 * Extended version of `TokenDocument` class to support some system-specific functionality.
 */
class BlackFlagTokenDocument extends TokenDocument {
	async toggleActiveEffect(effectData, { overlay = false, active } = {}) {
		if (!this.actor || !effectData.id) return false;
		const id = staticID(`bf${effectData.id}`);

		// Remove existing effects matching this effect's static ID
		const existing = this.actor.effects.get(id);
		const state = active ?? !existing;
		if (!state && existing) await this.actor.deleteEmbeddedDocuments("ActiveEffect", [id]);
		// Add a new effect
		else if (state) {
			const cls = getDocumentClass("ActiveEffect");
			const effect = cls.fromStatusEffect(effectData);
			if (overlay) effect.updateSource({ "flags.core.overlay": true });
			await cls.create(effect, { parent: this.actor, keepId: true });
		}

		return state;
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*        Socket Event Handlers        */
	/* <><><><> <><><><> <><><><> <><><><> */

	/** @inheritDoc */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		const origin = this.actor?.getFlag(game.system.id, "summon.origin");
		if (origin) BlackFlag.registry.summons.untrack(origin.split(".Item.")[0], this.actor.uuid);
	}
}

var _module = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DocumentMixin: DocumentMixin,
	PseudoDocumentMixin: PseudoDocumentMixin
});

/**
 * Register the various documents & type labels provided by the system during initialization.
 */
function registerDocumentClasses() {
	log("Registering document classes");

	CONFIG.ActiveEffect.documentClass = BlackFlagActiveEffect;
	CONFIG.Actor.documentClass = BlackFlagActor;
	CONFIG.ChatMessage.documentClass = BlackFlagChatMessage;
	CONFIG.Combat.documentClass = BlackFlagCombat;
	CONFIG.Combatant.documentClass = BlackFlagCombatant;
	CONFIG.Item.documentClass = BlackFlagItem;
	CONFIG.JournalEntryPage.documentClass = BlackFlagJournalEntryPage;
	CONFIG.Token.documentClass = BlackFlagTokenDocument;

	CONFIG.Activity = {
		documentClass: Activity,
		types: CONFIG.BlackFlag._activityTypes
	};

	CONFIG.Advancement = {
		documentClass: Advancement,
		types: CONFIG.BlackFlag._advancementTypes
	};
}

var documents = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BlackFlagActiveEffect: BlackFlagActiveEffect,
	BlackFlagActor: BlackFlagActor,
	BlackFlagChatMessage: BlackFlagChatMessage,
	BlackFlagCombatant: BlackFlagCombatant,
	BlackFlagItem: BlackFlagItem,
	BlackFlagJournalEntryPage: BlackFlagJournalEntryPage,
	BlackFlagTokenDocument: BlackFlagTokenDocument,
	NotificationsCollection: NotificationsCollection,
	Proficiency: Proficiency,
	Scaling: Scaling,
	SelectChoices: SelectChoices,
	activity: _module$f,
	advancement: _module$c,
	mixins: _module,
	registerDocumentClasses: registerDocumentClasses
});

const slugify = value => value?.slugify().replaceAll("-", "").replaceAll("(", "").replaceAll(")", "");

/**
 * Set up system-specific enrichers.
 */
function registerCustomEnrichers() {
	log("Registering custom enrichers");
	const stringNames = ["attack", "check", "damage", "heal", "healing", "save", "skill", "tool", "vehicle"];
	CONFIG.TextEditor.enrichers.push(
		{
			pattern: new RegExp(
				`\\[\\[/(?<type>${stringNames.join("|")})(?<config> .*?)?]](?!])(?:{(?<label>[^}]+)})?`,
				"gi"
			),
			enricher: enrichString
		},
		{
			pattern: /\[\[(?<type>calc|lookup) (?<config>[^\]]+)]](?:{(?<label>[^}]+)})?/gi,
			enricher: enrichString
		},
		{
			pattern: /&(?<type>reference)\[(?<config>[^\]]+)](?:{(?<label>[^}]+)})?/gi,
			enricher: enrichString
		},
		{
			pattern: /~def\[([^\]]+)]/gi,
			enricher: (match, options) => {
				const dnf = document.createElement("dfn");
				dnf.innerText = match[1];
				return dnf;
			}
		}
	);

	document.body.addEventListener("click", handleActivation);
	document.body.addEventListener("click", handleApply);
	document.body.addEventListener("click", handleRollAction);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Parse config data from the provided string and call the appropriate enricher method.
 * @param {RegExpMatchArray} match - The regular expression match result.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {Promise<HTMLElement|null>}
 */
async function enrichString(match, options) {
	let { type, config, label } = match.groups;
	config = parseConfig(config, { multiple: ["damage", "healing"].includes(type) });
	config._input = match[0];
	switch (type.toLowerCase()) {
		case "attack":
			return enrichAttack(config, label, options);
		case "calc":
			return enrichCalculation(config, label, options);
		case "check":
		case "skill":
		case "tool":
		case "vehicle":
			return enrichCheck(config, label, options);
		case "lookup":
			return enrichLookup(config, label, options);
		case "save":
			return enrichSave(config, label, options);
		case "heal":
		case "healing":
			config._isHealing = true;
		case "damage":
			return enrichDamage(config, label, options);
		case "reference":
			return enrichReference(config, label);
	}
	return null;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Parse a string into a configuration object.
 * @param {string} match - Matched configuration string.
 * @param {object} [options={}]
 * @param {boolean} [options.multiple=false] - Support splitting the configuration by "&". If `true` then an array of
 *                                             configs will be returned rather than a single object.
 * @returns {object|object[]}
 */
function parseConfig(match = "", { multiple = false } = {}) {
	if (multiple) return match.split("&").map(s => parseConfig(s));
	const config = { values: [] };
	for (const part of match.match(/(?:[^\s"]+|"[^"]*")+/g) ?? []) {
		if (!part) continue;
		const [key, value] = part.split("=");
		const valueLower = value?.toLowerCase();
		if (value === undefined) config.values.push(key.replace(/(^"|"$)/g, ""));
		else if (["true", "false"].includes(valueLower)) config[key] = valueLower === "true";
		else if (Number.isNumeric(value)) config[key] = Number(value);
		else config[key] = value.replace(/(^"|"$)/g, "");
	}
	return config;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                    Element Creation                   */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a passive skill tag.
 * @param {string} label - Label to display.
 * @param {object} dataset - Data that will be added to the tag.
 * @returns {HTMLElement}
 */
function createPassiveTag(label, dataset) {
	const span = document.createElement("span");
	span.classList.add("passive-check");
	_addDataset(span, dataset);
	span.innerText = label;
	return span;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a rollable link with a request section for GMs.
 * @param {HTMLElement|string} label - Label to display
 * @param {object} dataset - Data that will be added to the link for the rolling method.
 * @returns {HTMLElement}
 */
function createRequestLink(label, dataset) {
	const span = document.createElement("span");
	span.classList.add("roll-link-group");
	_addDataset(span, dataset);
	if (label instanceof HTMLTemplateElement) span.append(label.content);
	else if (label instanceof HTMLElement) span.append(label);
	else span.append(label);

	// Add chat request link for GMs
	if (game.user.isGM) {
		const gmLink = document.createElement("a");
		gmLink.classList.add("extra-link");
		gmLink.dataset.request = true;
		gmLink.dataset.tooltip = "BF.Enricher.Request.Action";
		gmLink.setAttribute("aria-label", game.i18n.localize(gmLink.dataset.tooltip));
		gmLink.innerHTML = '<i class="fa-solid fa-comment-dots" inert></i>';
		span.insertAdjacentElement("beforeend", gmLink);
	}

	return span;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a rollable link.
 * @param {string} label - Label to display.
 * @param {object} [dataset={}] - Data that will be added to the link for the rolling method.
 * @param {object} [options={}]
 * @param {string} [options.classes="roll-link"] - Class to add to the link.
 * @param {string} [options.tag="a"] - Tag to use for the link.
 * @returns {HTMLElement}
 */
function createRollLink(label, dataset = {}, { classes = "roll-link", tag = "a" } = {}) {
	const link = document.createElement(tag);
	link.className = classes;
	_addDataset(link, dataset);
	link.innerHTML = '<i class="fa-solid fa-dice-d20" inert></i>';
	link.append(label);
	return link;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Add a dataset object to the provided element.
 * @param {HTMLElement} element - Element to modify.
 * @param {object} dataset - Data properties to add.
 * @private
 */
function _addDataset(element, dataset) {
	for (const [key, value] of Object.entries(dataset)) {
		if (key.startsWith("_") || key === "values" || !value) continue;
		if (["Array", "Object"].includes(foundry.utils.getType(value))) element.dataset[key] = JSON.stringify(value);
		else element.dataset[key] = value;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                     Event Handling                    */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Activate an activity.
 * @param {Event} event - The click event triggering the action.
 */
async function handleActivation(event) {
	const activity = await fromUuid(event.target.closest("[data-activity-uuid]")?.dataset.activityUuid);
	if (activity && !event.target.closest("[data-roll-action]")) {
		event.stopPropagation();
		activity.activate();
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Apply a status effect.
 * @param {Event} event - The click event triggering the action.
 */
async function handleApply(event) {
	const status = event.target.closest('[data-action="apply"][data-status]')?.dataset.status;
	const effect = CONFIG.statusEffects.find(e => e.id === status);
	if (!effect) return;
	event.stopPropagation();
	for (const token of getSelectedTokens()) await token.actor?.toggleStatusEffect(status);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform the provided roll action.
 * @param {Event} event - The click event triggering the action.
 * @returns {Promise|void}
 */
function handleRollAction(event) {
	const target = event.target.closest(".roll-link-group, [data-roll-action]");
	if (!target) return;
	event.stopPropagation();

	if (event.target.closest('[data-request="true"]')) return requestCheckSave(event);

	switch (target.dataset.rollAction) {
		case "ability-check":
		case "ability-save":
		case "skill":
		case "tool":
		case "vehicle":
			return rollCheckSave(event);
		case "attack":
			return rollAttack(event);
		case "damage":
			return rollDamage(event);
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                    Attack Enricher                    */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich an attack link, using a pre-set to hit value or determining it from the enriching item or activity.
 * @param {object} config - Configuration data.
 * @param {string} [label] - Optional label to replace default text.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML link if the save could be built, otherwise null.}
 *
 * @example Create an attack link using a fixed to hit:
 * ```[[/attack +5]]``` or ```[[/attack formula=5]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="attack" data-formula="+5">
 *   <i class="fa-solid fa-dice-d20" inert></i> +5
 * </a> to hit
 * ```
 *
 * @example Create an attack link using the attack from the item:
 * ```[[/attack]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="attack" data-activity="...uuid...">
 *   <i class="fa-solid fa-dice-d20" inert></i> +8
 * </a> to hit
 * ```
 */
async function enrichAttack(config, label, options) {
	if (config.activity && config.formula) {
		log(`Activity ID and formula found while enriching ${config._input}, only one is supported.`, { level: "warn" });
		return null;
	}

	const formulaParts = [];
	if (config.formula) formulaParts.push(config.formula);
	for (const value of config.values) {
		if (value in CONFIG.BlackFlag.attackModes) config.attackMode = value;
		else formulaParts.push(value);
	}
	config.formula = Roll.defaultImplementation.replaceFormulaData(formulaParts.join(" "), options.rollData ?? {});

	const activity = config.activity
		? options.relativeTo?.system?.activities?.get(config.activity)
		: !config.formula
			? options.relativeTo instanceof Activity
				? options.relativeTo
				: options.relativeTo?.system?.activities?.getByType("attack")[0] ?? null
			: null;

	if (activity) {
		config.activityUuid = activity.uuid;
		const attackConfig = activity.getAttackDetails?.(config) ?? {};
		config.formula = Roll.defaultImplementation.replaceFormulaData(attackConfig.parts.join(" + "), attackConfig.data);
		delete config.activity;
	}

	if (!config.activityUuid && !config.formula) {
		log(`No formula or linked activity found while enriching ${config._input}.`, { level: "warn" });
		return null;
	}

	config.rollAction = "attack";

	if (label) return createRollLink(label, config);

	let displayFormula = simplifyFormula(config.formula) || "+0";
	if (!displayFormula.startsWith("+") && !displayFormula.startsWith("-")) displayFormula = `+${displayFormula}`;

	const span = document.createElement("span");
	span.innerHTML = game.i18n.format("BF.Enricher.Attack.Long", {
		formula: createRollLink(displayFormula, config).outerHTML
	});
	return span;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform an attack roll.
 * @param {Event} event - The click event triggering the action.
 * @returns {Promise|void}
 */
async function rollAttack(event) {
	const target = event.target.closest("[data-roll-action]");
	const { activityUuid, attackMode, formula } = target.dataset;

	if (activityUuid) {
		const activity = await fromUuid(activityUuid);
		if (activity) return activity.rollAttack({ attackMode, event });
	}

	const targets = getTargetDescriptors();
	const rollConfig = {
		attackMode,
		event,
		rolls: [
			{
				parts: [formula.replace(/^\s*\+\s*/, "")],
				options: {
					target: targets.length === 1 ? targets[0].ac : undefined
				}
			}
		]
	};

	const dialogConfig = {
		applicationClass: AttackRollConfigurationDialog
	};

	const messageConfig = {
		data: {
			flags: {
				[game.system.id]: {
					messageType: "roll",
					roll: {
						type: "attack"
					},
					targets: getTargetDescriptors()
				}
			},
			flavor: game.i18n.format("BF.Roll.Type.Label", { type: game.i18n.localize("BF.ATTACK.Label") }),
			speaker: ChatMessage.implementation.getSpeaker()
		}
	};

	if (Hooks.call("blackFlag.preRollAttack", rollConfig, dialogConfig, messageConfig) === false) return;
	const rolls = await CONFIG.Dice.ChallengeRoll.build(rollConfig, dialogConfig, messageConfig);
	if (rolls?.length) {
		Hooks.callAll("blackFlag.rollAttack", rolls, { ammoUpdate: null, subject: null });
		Hooks.callAll("blackFlag.postRollAttack", rolls, { subject: null });
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                  Calculation Enricher                 */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich a pre-resolved deterministic calculation
 * @param {object} config - Configuration data.
 * @param {string} [fallback] - Optional fallback if the value couldn't be found.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML element if the calculation could be built, otherwise null.
 *
 * @example Include a NPC's modified perception value:
 * ```The creature's perception is [[calc @attributes.perception + 5]] while perceiving with hearing or smell.``
 * becomes
 * ```html
 * The creature's perception is <span class="calculated-value">17</span> while perceiving with hearing or smell.
 * ```
 */
function enrichCalculation(config, fallback, options) {
	const formulaParts = [];
	if (config.formula) formulaParts.push(config.formula);
	formulaParts.push(...config.values);
	const roll = new Roll(
		formulaParts.join(" "),
		options.rollData ?? options.relativeTo?.getRollData?.({ deterministic: true })
	);

	if (!roll.isDeterministic) {
		log(`Non-deterministic formula found while enriching ${config._input}.`, { level: "warn" });
		return null;
	}

	roll.evaluateSync();

	const span = document.createElement("span");
	span.classList.add("calculation-value");
	span.innerText = roll.total;
	return span;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                 Check & Save Enrichers                */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a roll label for a check or save.
 * @param {object} config - Enricher configuration data.
 * @returns {string}
 */
function createRollLabel(config) {
	const ability = CONFIG.BlackFlag.enrichment.lookup.abilities[slugify(config.ability)]?.label;
	const skill = CONFIG.BlackFlag.enrichment.lookup.skills[slugify(config.skill)]?.label;
	const tool = CONFIG.BlackFlag.enrichment.lookup.tools[slugify(config.tool)]?.label;
	const vehicle = CONFIG.BlackFlag.enrichment.lookup.vehicles[slugify(config.vehicle)]?.label;
	const longSuffix = config.format === "long" ? "Long" : "Short";
	const showDC = config.dc && !config.hideDC;

	let label;
	switch (config.rollAction) {
		case "ability-check":
		case "skill":
		case "tool":
		case "vehicle":
			if (ability && (skill || tool || vehicle)) {
				label = game.i18n.format("BF.Enricher.Check.Specific", { ability, type: skill ?? tool ?? vehicle });
			} else {
				label = ability;
			}
			if (config.passive) {
				label = game.i18n.format(`BF.Enricher.${showDC ? "DC." : ""}Passive.${longSuffix}`, {
					dc: config.dc,
					check: label
				});
			} else {
				if (showDC) label = game.i18n.format("BF.Enricher.DC.Phrase", { dc: config.dc, check: label });
				label = game.i18n.format(`BF.Enricher.Check.${longSuffix}`, { check: label });
			}
			break;
		case "ability-save":
			label = ability || config.ability?.toUpperCase() || "";
			if (showDC) label = game.i18n.format("BF.Enricher.DC.Phrase", { dc: config.dc, check: label });
			label = game.i18n.format(`BF.Enricher.Save.${longSuffix}`, { save: label });
			break;
		default:
			return "";
	}

	// TODO: Icon

	return label;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich an ability check link to perform a specific ability or skill check. If an ability is provided
 * along with a skill, then the skill check will always use the provided ability. Otherwise it will use
 * the character's default ability for that skill.
 * @param {object} config - Configuration data.
 * @param {string} [label] - Optional label to replace default text.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML link if the check could be built, otherwise null.
 *
 * @example Create a dexterity check:
 * ```[[/check ability=dex]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="check" data-ability="dex">
 *   <i class="fa-solid fa-dice-d20" inert></i> DEX
 * </a>
 * ```
 *
 * @example Create an acrobatics check with a DC and default ability:
 * ```[[/check skill=acrobatics dc=20]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="check" data-ability="dexterity" data-skill="acrobatics" data-dc="20">
 *   <i class="fa-solid fa-dice-d20" inert></i> DC 20 DEX (Acrobatics)
 * </a>
 * ```
 *
 * @example Create an acrobatics check using strength:
 * ```[[/check ability=strength skill=acrobatics]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="check" data-ability="strength" data-skill="acrobatics">
 *   <i class="fa-solid fa-dice-d20" inert></i> STR (Acrobatics)
 * </a>
 * ```
 *
 * @example Create a tool check:
 * ```[[/check tool=thieves ability=intelligence]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="check" data-ability="intelligence" data-tool="thievesTools">
 *   <i class="fa-solid fa-dice-d20" inert></i> INT (Thieves' Tools)
 * </a>
 * ```
 *
 * @example Formulas used for DCs will be resolved using data provided to the description (not the roller):
 * ```[[/check ability=charisma dc=@abilities.int.dc]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="check" data-ability="charisma" data-dc="15">
 *   <i class="fa-solid fa-dice-d20" inert></i> DC 15 CHA
 * </a>
 * ```
 *
 * @example Use multiple skills in a check using default abilities:
 * ```[[/check skill=acrobatics/athletics dc=15]]```
 * ```[[/check acrobatics athletics 15]]```
 * becomes
 * ```html
 * <span class="roll-link-group" data-type="check" data-skill="acrobatics|athletics" data-dc="15">
 *   DC 15
 *   <a class="roll-action" data-ability="dexterity" data-skill="acrobatics">
 *     <i class="fa-solid fa-dice-d20" inert></i> DEX (Acrobatics)
 *   </a> or
 *   <a class="roll-action" data-ability="strength" data-skill="athletics">
 *     <i class="fa-solid fa-dice-d20" inert></i> STR (Athletics)
 *   </a>
 *   <a class="enricher-action" data-action="request" ...><!-- request link --></a>
 * </span>
 * ```
 *
 * @example Use multiple skills with a fixed ability:
 * ```[[/check ability=str skill=deception/persuasion dc=15]]```
 * ```[[/check strength deception persuasion 15]]```
 * becomes
 * ```html
 * <span class="roll-link-group" data-type="check" data-ability="str" data-skill="deception|persuasion" data-dc="15">
 *   DC 15 STR
 *   (<a class="roll-action" data-skill="deception"><i class="fa-solid fa-dice-d20" inert></i> Deception</a> or
 *   <a class="roll-action" data-ability="persuasion"><i class="fa-solid fa-dice-d20" inert></i> Persuasion</a>)
 *   <a class="enricher-action" data-action="request" ...><!-- request link --></a>
 * </span>
 * ```
 *
 * @example Link an enricher to an check activity, either explicitly or automatically
 * ```[[/check activity=RLQlsLo5InKHZadn]]``` or ```[[/check]]```
 * becomes
 * ```html
 * <span class="roll-link-group" data-roll-action="ability-check" data-ability="dexterity" data-dc="20"
 *       data-activity-uuid="...">
 *   <a class="roll-action"><i class="fa-solid fa-dice-d20" inert></i> DC 20 DEX</a>
 *   <a class="enricher-action" data-action="request" ...><!-- request link --></a>
 * </span>
 * ```
 */
async function enrichCheck(config, label, options) {
	config.skill = config.skill?.replaceAll("/", "|").split("|") ?? [];
	config.tool = config.tool?.replaceAll("/", "|").split("|") ?? [];
	config.vehicle = config.vehicle?.replaceAll("/", "|").split("|") ?? [];
	const LOOKUP = CONFIG.BlackFlag.enrichment.lookup;
	for (const value of config.values) {
		const slug = foundry.utils.getType(value) === "string" ? slugify(value) : value;
		if (slug in LOOKUP.abilities) config.ability = LOOKUP.abilities[slug].key;
		else if (slug in LOOKUP.skills) config.skill.push(LOOKUP.skills[slug].key);
		else if (slug in LOOKUP.tools) config.tool.push(slug);
		else if (slug in LOOKUP.vehicles) config.vehicle.push(slug);
		else if (Number.isNumeric(value)) config.dc = Number(value);
		else config[value] = true;
	}
	delete config.values;

	const groups = new DefaultMap([], () => []);
	let invalid = false;

	const anything = config.ability || config.skill.length || config.tool.length || config.vehicle.length;
	const activity = config.activity
		? options.relativeTo?.system?.activities?.get(config.activity)
		: !anything
			? options.relativeTo?.system?.activities?.getByType("check")[0]
			: null;

	if (activity) {
		if (activity.type !== "check") {
			log(`Check enricher linked to non-check activity when enriching ${config._input}.`, { level: "warn" });
			return null;
		}

		if (activity.system.check.ability) config.ability = activity.system.check.ability;
		config.activityUuid = activity.uuid;
		config.dc = activity.system.check.dc.value;
		config.skill = [];
		config.tool = [];
		config.vehicle = [];
		for (const associated of activity.system.check.associated) {
			if (associated in CONFIG.BlackFlag.skills) config.skill.push(associated);
			else if (associated in CONFIG.BlackFlag.tools) config.tool.push(associated);
			else if (associated in CONFIG.BlackFlag.vehicles) config.vehicle.push(associated);
		}
		delete config.activity;
	}

	let abilityConfig = LOOKUP.abilities[slugify(config.ability)];
	if (config.ability && !abilityConfig) {
		log(`Ability ${config.ability} not found while enriching ${config._input}.`, { level: "warn" });
		invalid = true;
	} else if (abilityConfig?.key) config.ability = abilityConfig.key;

	for (let [index, skill] of config.skill.entries()) {
		const skillConfig = LOOKUP.skills[slugify(skill)];
		if (skillConfig) {
			if (skillConfig.key) skill = config.skill[index] = skillConfig.key;
			const ability = config.ability || skillConfig.ability;
			groups.get(ability).push({ key: skill, type: "skill", label: skillConfig.label });
		} else {
			log(`Skill ${skill} not found while enriching ${config._input}.`, { level: "warn" });
			invalid = true;
		}
	}

	for (const tool of config.tool) {
		const toolConfig = LOOKUP.tools[slugify(tool)];
		if (toolConfig) {
			if (config.ability) {
				groups.get(config.ability).push({ key: tool, type: "tool", label: toolConfig.label });
			} else {
				log(`Tool "${tool}" found without specified ability while enriching ${config._input}.`, { level: "warn" });
				invalid = true;
			}
		} else {
			log(`Tool ${tool} not found while enriching ${config._input}.`, { level: "warn" });
			invalid = true;
		}
	}

	for (const vehicle of config.vehicle) {
		const vehicleConfig = LOOKUP.vehicles[slugify(vehicle)];
		if (vehicleConfig) {
			if (config.ability) {
				groups.get(config.ability).push({ key: vehicle, type: "vehicle", label: vehicleConfig.label });
			} else {
				log(`Vehicle "${vehicle}" found without specified ability while enriching ${config._input}.`, {
					level: "warn"
				});
				invalid = true;
			}
		} else {
			log(`Vehicle ${vehicle} not found while enriching ${config._input}.`, { level: "warn" });
			invalid = true;
		}
	}

	if (!abilityConfig && !groups.size) {
		log(`No ability, skill, tool, vehicle or linked activity provided while enriching ${config._input}.`, {
			level: "warn"
		});
		invalid = true;
	}

	const complex = config.skill.length + config.tool.length + config.vehicle.length > 1;
	if (config.passive && complex) {
		log(
			`Multiple proficiencies and passive flag found while enriching ${config._input}, which aren't supported together.`,
			{ level: "warn" }
		);
		invalid = true;
	}
	if (label && complex) {
		log(
			`Multiple proficiencies and a custom label found while enriching ${config._input}, which aren't supported together.`,
			{ level: "warn" }
		);
		invalid = true;
	}

	if (config.dc && !Number.isNumeric(config.dc)) config.dc = simplifyBonus(config.dc, options.rollData ?? {});

	if (invalid) return null;

	if (complex) {
		const formatter = game.i18n.getListFormatter({ type: "disjunction" });
		const parts = [];
		for (const [ability, associated] of groups.entries()) {
			const makeConfig = ({ key, type }) => ({
				rollAction: type,
				[type]: key,
				ability: groups.size > 1 ? ability : undefined
			});

			// Multiple associated proficiencies, link each individually
			if (associated.length > 1)
				parts.push(
					game.i18n.format("BF.Enricher.Check.Specific", {
						ability: LOOKUP.abilities[ability].label,
						type: formatter.format(associated.map(a => createRollLink(a.label, makeConfig(a)).outerHTML))
					})
				);
			// Only single associated proficiency, wrap whole thing in roll link
			else {
				const associatedConfig = makeConfig(associated[0]);
				parts.push(createRollLink(createRollLabel({ ...associatedConfig, ability }), associatedConfig).outerHTML);
			}
		}

		label = formatter.format(parts);
		if (config.dc && !config.hideDC) {
			label = game.i18n.format("BF.Enricher.DC.Phrase", { dc: config.dc, check: label });
		}
		label = game.i18n.format(`BF.Enricher.Check.${config.format === "long" ? "Long" : "Short"}`, { check: label });
		const template = document.createElement("template");
		template.innerHTML = label;
		return createRequestLink(template, {
			rollAction: "ability-check",
			...config,
			skill: config.skill.join("|"),
			tool: config.tool.join("|"),
			vehicle: config.vehicle.join("|")
		});
	}

	config = {
		rollAction: config.skill ? "skill" : config.tool ? "tool" : config.vehicle ? "vehicle" : "ability-check",
		ability: Array.from(groups.keys())[0],
		...config,
		skill: config.skill[0],
		tool: config.tool[0],
		vehicle: config.vehicle[0]
	};
	label ??= createRollLabel(config);
	if (config.passive) return createPassiveTag(label, config);
	return createRequestLink(createRollLink(label), config);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create the buttons for a check requested in chat.
 * @param {object} dataset
 * @returns {object[]}
 */
function createCheckRequestButtons(dataset) {
	const skills = dataset.skill?.split("|") ?? [];
	const tools = dataset.tool?.split("|") ?? [];
	const vehicles = dataset.vehicle?.split("|") ?? [];
	if (skills.length + tools.length + vehicles.length <= 1) return [createRequestButton(dataset)];
	const baseDataset = { ...dataset };
	delete baseDataset.skill;
	delete baseDataset.tool;
	delete baseDataset.vehicle;
	return [
		...skills.map(skill =>
			createRequestButton({
				ability: CONFIG.BlackFlag.skills[skill].ability,
				...baseDataset,
				format: "long",
				skill,
				rollAction: "skill"
			})
		),
		...tools.map(tool => createRequestButton({ ...baseDataset, format: "long", tool, rollAction: "tool" })),
		...vehicles.map(skill => createRequestButton({ ...baseDataset, format: "long", vehicle, rollAction: "vehicle" }))
	];
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich a saving throw link.
 * @param {object} config - Configuration data.
 * @param {string} [label] - Optional label to replace default text.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML link if the save could be built, otherwise null.
 *
 * @example Create a dexterity saving throw:
 * ```[[/save ability=dexterity]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="save" data-key="dexterity">
 *   <i class="fa-solid fa-dice-d20" inert></i> DEX
 * </a>
 * ```
 *
 * @example Add a DC to the save:
 * ```[[/save ability=dexterity dc=20]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="save" data-key="dexterity" data-dc="20">
 *   <i class="fa-solid fa-dice-d20" inert></i> DC 20 DEX
 * </a>
 * ```
 *
 * @example Empty enricher fetches details from item or activity.
 * ```[[/save]]```
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="save" data-key="dexterity" data-dc="20" data-activity="...uuid...">
 *   <i class="fa-solid fa-dice-d20" inert></i> DC 20 DEX
 * </a>
 * ```
 */
async function enrichSave(config, label, options) {
	if (config.activity && config.ability) {
		log(`Activity ID and ability found while enriching ${config._input}, only one is supported.`, { level: "warn" });
		return null;
	}

	const blankAbility = config.ability === false;
	config.ability = blankAbility ? [] : config.ability?.replace("/", "|").split("|") ?? [];
	const LOOKUP = CONFIG.BlackFlag.enrichment.lookup;
	for (const value of config.values) {
		const slug = slugify(value);
		if (slug in LOOKUP.abilities) config.ability.push(LOOKUP.abilities[slug].key);
		else if (Number.isNumeric(value)) config.dc = Number(value);
		else config[value] = true;
	}
	config.ability = config.ability
		.map(a => slugify(a))
		.filter(a => a in LOOKUP.abilities)
		.map(a => LOOKUP.abilities[a].key ?? a);

	const activity = config.activity
		? options.relativeTo?.system?.activities?.get(config.activity)
		: !config.ability.length && !blankAbility
			? options.relativeTo instanceof Activity
				? options.relativeTo
				: options.relativeTo?.system?.activities?.getByType("save")[0] ?? null
			: null;

	if (activity) {
		config.activityUuid = activity.uuid;
		const saveConfig = activity.getSaveDetails?.(config) ?? {};
		config.ability =
			foundry.utils.getType(saveConfig.ability) === "Set" ? Array.from(saveConfig.ability) : [saveConfig.ability];
		config.dc = saveConfig.dc;
		delete config.activity;
	}

	if (!config.activityUuid && !config.ability.length && !blankAbility) {
		log(`No ability or linked activity found while enriching ${config._input}.`, { level: "warn" });
		return null;
	}

	if (!config.ability.length) config.ability.push("");

	if (config.dc && !Number.isNumeric(config.dc)) config.dc = simplifyBonus(config.dc, options.rollData ?? {});

	if (config.ability.length > 1 && label) {
		log(
			`Multiple abilities and custom label found while enriching ${config._input}, which aren't supported together.`,
			{ level: "warn" }
		);
		return null;
	}

	config.rollAction = "ability-save";
	if (label) label = createRollLink(label);
	else if (config.ability?.length <= 1) {
		label = createRollLink(createRollLabel({ ...config, ability: config.ability[0] }));
	} else {
		const abilities = config.ability.map(ability => {
			const linkConfig = { ...config, ability };
			delete linkConfig.rollAction;
			return createRollLink(LOOKUP.abilities[ability].label, linkConfig).outerHTML;
		});
		label = game.i18n.getListFormatter({ type: "disjunction" }).format(abilities);
		const showDC = config.dc && !config.hideDC;
		if (showDC) label = game.i18n.format("BF.Enricher.DC.Phrase", { dc: config.dc, check: label });
		label = game.i18n.format(`BF.Enricher.Save.${config.format === "long" ? "Long" : "Short"}`, { save: label });
		const template = document.createElement("template");
		template.innerHTML = label;
		label = template;
	}

	return createRequestLink(label, { ...config, ability: config.ability.join("|") });
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create the buttons for a save requested in chat.
 * @param {object} dataset
 * @returns {object[]}
 */
function createSaveRequestButtons(dataset) {
	const abilities = dataset.ability ? dataset.ability.split("|") : [""];
	return abilities.map(ability => createRequestButton({ ...dataset, format: "long", ability }));
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a roll request chat message for a check or save roll.
 * @param {Event} event - The click event triggering the action.
 * @returns {Promise|void}
 */
async function requestCheckSave(event) {
	const dataset = {
		...(event.target.closest(".roll-link-group")?.dataset ?? {}),
		...(event.target.closest(".roll-link")?.dataset ?? {})
	};
	let buttons;
	switch (dataset.rollAction) {
		case "ability-check":
		case "skill":
		case "tool":
		case "vehicle":
			buttons = createCheckRequestButtons(dataset);
			break;
		case "ability-save":
			buttons = createSaveRequestButtons(dataset);
			break;
		default:
			buttons = [createRequestButton({ ...dataset, format: "short" })];
	}

	const MessageClass = getDocumentClass("ChatMessage");
	const chatData = {
		user: game.user.id,
		content: await renderTemplate("systems/black-flag/templates/chat/request-card.hbs", { buttons }),
		flavor: game.i18n.localize("BF.Enricher.Request.Title"),
		speaker: MessageClass.getSpeaker({ user: game.user })
	};
	return MessageClass.create(chatData);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Create a button for a chat request.
 * @param {object} dataset
 * @returns {object}
 */
function createRequestButton(dataset) {
	return {
		visibleLabel: createRollLabel({ ...dataset, icon: true }),
		hiddenLabel: createRollLabel({ ...dataset, icon: true, hideDC: true }),
		dataset: { ...dataset, action: "rollRequest", visibility: "all" }
	};
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform a check or save roll.
 * @param {Event} event - The click event triggering the action.
 * @returns {Promise|void}
 */
async function rollCheckSave(event) {
	const target = event.target.closest("[data-roll-action]");
	const dataset = {
		...(event.target.closest("[data-roll-action]")?.dataset ?? {}),
		...(event.target.closest(".roll-link")?.dataset ?? {})
	};

	target.disabled = true;
	try {
		const actors = new Set(getSelectedTokens().map(t => t.actor));
		if (!actors.size) {
			ui.notifications.warn(game.i18n.localize("BF.Enricher.Warning.NoActor"));
			return;
		}

		for (const actor of actors) {
			const { rollAction, dc, ...data } = dataset;
			const rollConfig = { event, ...data };
			if (rollConfig.ability === "spellcasting") rollConfig.ability = actor.system.spellcasting?.ability;
			if (dc) rollConfig.target = Number(dc);
			await actor.roll(rollAction, rollConfig);
		}
	} finally {
		target.disabled = false;
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                    Damage Enricher                    */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich a damage link.
 * @param {object[]} configs - Configuration data.
 * @param {string} [label] - Optional label to replace default text.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML link if the save could be built, otherwise null.
 *
 * @example Create a damage link:
 * ```[[/damage 2d6 type=bludgeoning]]``
 * becomes
 * ```html
 * <a class="roll-action" data-roll-action="damage" data-formulas="["2d6"]" data-types="["bludgeoning"]">
 *   <i class="fa-solid fa-dice-d20" inert></i> 2d6
 * </a> bludgeoning
 * ````
 *
 * @example Display the average:
 * ```[[/damage 2d6 type=bludgeoning average=true]]``
 * becomes
 * ```html
 * 7 (<a class="roll-action" data-roll-action="damage" data-formulas="["2d6"]" data-types="["bludgeoning"]">
 *   <i class="fa-solid fa-dice-d20" inert></i> 2d6
 * </a>) bludgeoning
 * ````
 *
 * @example Manually set the average & don't prefix the type:
 * ```[[/damage 8d4dl force average=666]]``
 * becomes
 * ```html
 * 666 (<a class="roll-action" data-roll-action="damage" data-formulas="["8d4dl"]" data-types="["force"]">
 *   <i class="fa-solid fa-dice-d20" inert></i> 8d4dl
 * </a> force
 * ````
 *
 * @example Use two different damage types:
 * ```[[/damage 1d6 + 5 slashing & 2d6 fire average]]```
 * becomes
 * ```html
 * <a class="unlink" data-roll-action="damage" data-formulas="["1d6","2d6"]" data-types="["bludgeoning","fire"]"
 *    data-average="true">
 *   3 (<span class="roll-link"><i class="fa-solid fa-dice-d20" inert></i> 1d6 + 5</span>) bludgeoning plus
 *   7 (<span class="roll-link"><i class="fa-solid fa-dice-d20" inert></i> 2d6</span>) fire
 * </a>
 * ```
 *
 * @example Create a healing link:
 * ```[[/heal 2d6]]``` or ```[[/damage 2d6 healing]]```
 * becomes
 * ```html
 * <a class="unlink" data-roll-action="damage" data-formulas="["2d6"]" data-types="["healing"]">
 *   <i class="fa-solid fa-dice-d20" inert></i> 2d6
 * </a> healing
 * ```
 */
async function enrichDamage(configs, label, options) {
	const config = { rollAction: "damage", formulas: [], types: [], rollType: configs._isHealing ? "healing" : "damage" };
	for (const c of configs) {
		const formulaParts = [];
		if (c.activity) config.activity = c.activity;
		if (c.average) config.average = c.average;
		if (c.magical) config.magical = true;
		if (c.mode) config.attackMode = c.mode;
		if (c.formula) formulaParts.push(c.formula);
		c.type = c.type?.replaceAll("/", "|").split("|") ?? [];
		for (const value of c.values) {
			if (value in CONFIG.BlackFlag.damageTypes) c.type.push(value);
			else if (value in CONFIG.BlackFlag.healingTypes) c.type.push(value);
			else if (value === "average") config.average = true;
			else if (value === "magical") config.magical = true;
			else if (value === "versatile") config.attackMode ??= "twoHanded";
			else formulaParts.push(value);
		}
		c.formula = Roll.defaultImplementation.replaceFormulaData(formulaParts.join(" "), options.rollData ?? {});
		c.type = c.type ?? (configs._isHealing ? "healing" : null);
		if (c.formula) {
			config.formulas.push(c.formula);
			config.types.push(c.type.join("|"));
		}
	}

	if (config.activity && config.formulas.length) {
		log(`Activity ID and formulas found while enriching ${config._input}, only one is supported.`, { level: "warn" });
		return null;
	}

	let activity =
		options.relativeTo instanceof Activity
			? options.relativeTo
			: options.relativeTo?.system?.activities?.get(config.activity);
	if (!activity && !config.formulas.length) {
		const types = configs._isHealing ? ["heal"] : ["attack", "damage", "save"];
		for (const a of options.relativeTo?.system?.activities?.getByTypes(...types) ?? []) {
			if (a.system.damage?.parts.length || a.system.healing?.formula) {
				activity = a;
				break;
			}
		}
	}

	if (activity) {
		config.activityUuid = activity.uuid;
		configs.rollType = activity.type === "heal" ? "healing" : "damage";
		const damageConfig = activity.getDamageDetails(config);
		for (const r of damageConfig?.rolls ?? []) {
			const formula = Roll.defaultImplementation.replaceFormulaData(r.parts.join(" + "), r.data, { missing: "0" });
			if (formula) {
				config.formulas.push(formula);
				if (r.options.damageTypes?.size) config.types.push(Array.from(r.options.damageTypes).join("|"));
				else config.types.push(r.options.damageType);
			}
		}
		delete config.activity;
	}

	if (!config.activityUuid && !config.formulas.length) {
		log(`No formula or linked activity found while enriching ${config._input}.`, { level: "warn" });
		return null;
	}

	if (label) return createRollLink(label, config);

	const parts = [];
	for (const [idx, formula] of config.formulas.entries()) {
		const type = config.types[idx];
		const types = type
			?.split("|")
			.map(t => CONFIG.BlackFlag.damageTypes.localized[t] ?? CONFIG.BlackFlag.healingTypes.localized[t])
			.filter(_ => _);
		const localizationData = {
			formula: createRollLink(formula, {}, { tag: "span" }).outerHTML,
			type: game.i18n.getListFormatter({ type: "disjunction" }).format(types).toLowerCase()
		};

		let localizationType = "Short";
		if (config.average) {
			localizationType = "Long";
			if (config.average === true) {
				const minRoll = Roll.create(formula).evaluate({ minimize: true });
				const maxRoll = Roll.create(formula).evaluate({ maximize: true });
				localizationData.average = Math.floor(((await minRoll).total + (await maxRoll).total) / 2);
			} else if (Number.isNumeric(config.average)) {
				localizationData.average = config.average;
			} else {
				localizationType = "Short";
			}
		}

		parts.push(game.i18n.format(`BF.Enricher.Damage.${localizationType}`, localizationData));
	}

	const link = document.createElement("a");
	link.className = "unlink";
	_addDataset(link, config);
	if (config.average && parts.length === 2) {
		link.innerHTML = game.i18n.format("BF.Enricher.Damage.Double", { first: parts[0], second: parts[1] });
	} else {
		link.innerHTML = game.i18n.getListFormatter().format(parts);
	}
	return link;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Perform a damage roll.
 * @param {Event} event - The click event triggering the action.
 * @returns {Promise|void}
 */
async function rollDamage(event) {
	const target = event.target.closest("[data-roll-action]");
	let { formulas, types, activity: activityUuid, attackMode, magical, rollType } = target.dataset;
	formulas = JSON.parse(formulas);
	magical = magical === "true";
	types = JSON.parse(types);

	if (activityUuid) {
		const activity = await fromUuid(activityUuid);
		if (activity) return activity.rollDamage({ attackMode, event });
	}

	const rollConfig = {
		attackMode,
		event,
		rolls: formulas.map((formula, idx) => {
			const damageTypes = new Set(types[idx]?.split("|") ?? []);
			return {
				parts: [formula],
				options: { damageType: damageTypes?.first(), damageTypes, magical }
			};
		})
	};

	const dialogConfig = {};

	const title = game.i18n.format("BF.Roll.Type.Label", {
		type: game.i18n.localize(rollType === "healing" ? "BF.Healing.Label" : "BF.DAMAGE.Label")
	});
	const messageConfig = {
		data: {
			flavor: title,
			title,
			speaker: ChatMessage.implementation.getSpeaker(),
			flags: {
				[game.system.id]: {
					messageType: "roll",
					roll: {
						type: rollType ?? "damage"
					},
					targets: getTargetDescriptors()
				}
			}
		}
	};

	if (Hooks.call("blackFlag.preRollDamage", rollConfig, dialogConfig, messageConfig) === false) return;
	const rolls = await CONFIG.Dice.DamageRoll.build(rollConfig, dialogConfig, messageConfig);
	if (rolls?.length) Hooks.callAll("blackFlag.postRollDamage", rolls);
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                    Lookup Enricher                    */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich a property lookup.
 * @param {object} config - Configuration data.
 * @param {string} [fallback] - Optional fallback if the value couldn't be found.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML element if the lookup could be built, otherwise null.
 *
 * @example Include a creature's name in its description:
 * ```[[lookup @name]]```
 * becomes
 * ```html
 * <span class="lookup-value">Adult Black Dragon</span>
 * ```
 *
 * @example Lookup a property within an activity:
 * ```[[lookup @target.template.size activity=Osjqpi5MJiML9pYs]]```
 * becomes
 * ```html
 * <span class="lookup-value">120</span>
 * ```
 */
function enrichLookup(config, fallback, options) {
	let keyPath = config.path;
	let style = config.style;
	for (const value of config.values) {
		if (value === "capitalize") style ??= "capitalize";
		else if (value === "lowercase") style ??= "lowercase";
		else if (value === "uppercase") style ??= "uppercase";
		else if (value.startsWith("@")) keyPath ??= value;
	}

	let activity = options.relativeTo?.system?.activities?.get(config.activity);
	if (config.activity && !activity) {
		log(`Activity not found when enriching ${config._input}.`, { level: "warn" });
		return null;
	}

	if (!keyPath) {
		log(`Lookup path must be defined to enrich ${config._input}.`, { level: "warn" });
		return null;
	}

	const data = activity
		? activity.getRollData().activity
		: options.rollData ?? options.relativeTo?.getRollData?.() ?? {};
	let value = foundry.utils.getProperty(data, keyPath.substring(1)) ?? fallback;
	if (value && style) {
		if (style === "capitalize") value = value.capitalize();
		else if (style === "lowercase") value = value.toLowerCase();
		else if (style === "uppercase") value = value.toUpperCase();
	}

	const span = document.createElement("span");
	span.classList.add("lookup-value");
	if (!value && options.documents === false) return null;
	if (!value) span.classList.add("not-found");
	span.innerText = value ?? keyPath;
	return span;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                   Reference Enricher                  */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Enrich a reference link.
 * @param {object} config - Configuration data.
 * @param {string} label - Optional label to replace default text.
 * @param {EnrichmentOptions} options - Options provided to customize text enrichment.
 * @returns {HTMLElement|null} - An HTML link to the Journal Entry Page for the given reference.
 */
async function enrichReference(config, label, options) {
	let key;
	let source;
	let type = Object.keys(config).find(k => k in CONFIG.BlackFlag.ruleTypes);
	if (type) {
		key = slugify(config[type]);
		source = foundry.utils.getProperty(CONFIG.BlackFlag, CONFIG.BlackFlag.ruleTypes[type].references)?.[key];
	} else if (config.values.length) {
		key = slugify(config.values.join(""));
		for (const [t, { references }] of Object.entries(CONFIG.BlackFlag.ruleTypes)) {
			source = foundry.utils.getProperty(CONFIG.BlackFlag, references)?.[key];
			if (source) {
				type = t;
				break;
			}
		}
	}

	if (!source) {
		log(`No valid rule foundry while enriching ${config._input}.`, { level: "warn" });
		return null;
	}

	const uuid = foundry.utils.getType(source) === "Object" ? source.reference : source;
	if (!uuid) return null;

	const journalPage = await fromUuid(uuid);
	const span = document.createElement("span");
	span.classList.add("reference-link", "roll-link-group");
	span.append(journalPage.toAnchor({ name: label || journalPage.name }));

	if (type === "condition" && config.apply !== false) {
		const apply = document.createElement("a");
		apply.classList.add("extra-link");
		apply.dataset.action = "apply";
		apply.dataset.status = key;
		apply.dataset.tooltip = "BF.Enricher.Apply.Label";
		apply.setAttribute("aria-label", game.i18n.localize(apply.dataset.tooltip));
		apply.innerHTML = '<i class="fa-solid fa-fw fa-reply-all fa-flip-horizonal" inert></i>';
		span.append(apply);
	}

	return span;
}

var enrichers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	registerCustomEnrichers: registerCustomEnrichers
});

/**
 * Scan module manifests for any data that should be integrated into the system configuration.
 */
function registerModuleData() {
	log("Registering Module Data", { level: "groupCollapsed" });
	for (const manifest of [game.system, ...game.modules.filter(m => m.active), game.world]) {
		try {
			const complete = methods.map(m => m(manifest)).filter(r => r);
			if (complete.length) {
				log(`Registered ${manifest.title} data: ${complete.join(", ")}`);
			}
		} catch (err) {
			console.error(
				`%cBlack Flag | %cError registering ${manifest.title}\n`,
				"color: #1874B3; font-variant: small-caps",
				"color: #1874B3",
				err.message
			);
		}
	}
	console.groupEnd();
}

const methods = [registerSourceBooks, registerRequiredRules];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register package source books from `flags.black-flag.sourceBooks`.
 * @param {Module|System|World} manifest - Manifest from which to register data.
 * @returns {string|void} - Description of the data registered.
 */
function registerSourceBooks(manifest) {
	if (!manifest.flags[game.system.id]?.sourceBooks) return;
	Object.assign(CONFIG.BlackFlag.sourceBooks, manifest.flags[game.system.id].sourceBooks);
	return "source books";
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register optional rules required by a module from `flags.black-flag.requireRules`.
 * @param {Module|System|World} manifest - Manifest from which to register data.
 * @returns {string|void} - Description of the data registered.
 */
function registerRequiredRules(manifest) {
	if (!manifest.flags[game.system.id]?.requiredRules?.length) return;
	for (const rule of manifest.flags[game.system.id].requiredRules) {
		RulesSetting.addRequiredRule(rule, manifest);
	}
	return "required rules";
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                    Compendium Packs                   */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Apply any changes to compendium packs during the setup hook.
 */
function setupModulePacks() {
	log("Setting Up Compendium Packs", { level: "groupCollapsed" });
	for (const pack of game.packs) {
		if (pack.metadata.type === "Item") pack.applicationClass = BlackFlagItemCompendium;
		try {
			const complete = setupMethods.map(m => m(pack)).filter(r => r);
			if (complete.length) log(`Finished setting up ${pack.metadata.label}: ${complete.join(", ")}`);
		} catch (err) {
			log(`Error setting up ${pack.metadata.label}\n`, { extras: [err.message], level: "error" });
		}
	}
	console.groupEnd();
}

const setupMethods = [setupPackDisplay, setupPackSorting];

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Set application based on `flags.black-flag.display`.
 * @param {Compendium} pack - Pack to set up.
 * @returns {string|void} - Description of the step.
 */
function setupPackDisplay(pack) {
	const display = pack.metadata.flags[game.system.id]?.display ?? pack.metadata.flags.display;
	if (display !== "table-of-contents") return;
	pack.applicationClass = TableOfContentsCompendium;
	return "table of contents";
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

let sortingChanges;
const debouncedUpdateSorting = foundry.utils.debounce(
	() => game.settings.set("core", "collectionSortingModes", sortingChanges),
	250
);

/**
 * Set default sorting order based on `flags.black-flag.sorting`.
 * @param {Compendium} pack - Pack to set up.
 * @returns {string|void} - Description of the step.
 */
function setupPackSorting(pack) {
	sortingChanges ??= game.settings.get("core", "collectionSortingModes") ?? {};
	if (!pack.metadata.flags[game.system.id]?.sorting || sortingChanges[pack.metadata.id]) return;
	sortingChanges[pack.metadata.id] = pack.metadata.flags[game.system.id].sorting;
	debouncedUpdateSorting();
	return "default sorting";
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                     Message Rolls                     */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

class MessageRegistry {
	/**
	 * Registration of roll chat messages that originated at a specific message. The map is keyed by the ID of
	 * the originating message and contains sets of IDs for each roll type.
	 * @type {Map<string, Map<string, Set<string>>}
	 */
	static #messages = new Map();

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch roll messages for an origin message, in chronological order.
	 * @param {string} origin - ID of the origin message.
	 * @param {string} [type] - Type of roll messages to fetch.
	 * @returns {BlackFlagChatMessage[]}
	 */
	static get(origin, type) {
		const originMap = MessageRegistry.#messages.get(origin);
		if (!originMap) return [];
		let ids;
		if (type) ids = Array.from(originMap.get(type) ?? []);
		else
			ids = Array.from(originMap.values())
				.map(v => Array.from(v))
				.flat();
		return ids
			.map(id => game.messages.get(id))
			.filter(m => m)
			.sort((lhs, rhs) => lhs.timestamp - rhs.timestamp);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add a new roll message to the registry.
	 * @param {BlackFlagChatMessage} message - Message to add to the registry.
	 */
	static track(message) {
		const origin = message.getFlag(game.system.id, "originatingMessage");
		const type = message.getFlag(game.system.id, "roll.type");
		if (!origin || !type) return;
		if (!MessageRegistry.#messages.has(origin)) MessageRegistry.#messages.set(origin, new Map());
		const originMap = MessageRegistry.#messages.get(origin);
		if (!originMap.has(type)) originMap.set(type, new Set());
		originMap.get(type).add(message.id);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Remove a roll message to the registry.
	 * @param {BlackFlagChatMessage} message - Message to remove from the registry.
	 */
	static untrack(message) {
		const origin = message.getFlag(game.system.id, "originatingMessage");
		const type = message.getFlag(game.system.id, "roll.type");
		MessageRegistry.#messages.get(origin)?.get(type)?.delete(message.id);
	}
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */
/*                        Summons                        */
/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

class SummonRegistry {
	/**
	 * Registration of summoned creatures mapped to a specific summoner. The map is keyed by the UUID of
	 * summoner while the set contains UUID of actors that have been summoned.
	 * @type {Map<string, Set<string>>}
	 */
	static #creatures = new Map();

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Fetch creatures summoned by an actor.
	 * @param {BlackFlagActor} actor - Actor for which to find the summoned creatures.
	 * @returns {BlackFlagActor[]}
	 */
	static creatures(actor) {
		return Array.from(SummonRegistry.#creatures.get(actor.uuid) ?? []).map(uuid => fromUuidSync(uuid));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Add a new summoned creature to the list of summoned creatures.
	 * @param {string} summoner - UUID of the actor who performed the summoning.
	 * @param {string} summoned - UUID of the summoned creature to track.
	 */
	static track(summoner, summoned) {
		if (summoned.startsWith("Compendium.")) return;
		if (!SummonRegistry.#creatures.has(summoner)) SummonRegistry.#creatures.set(summoner, new Set());
		SummonRegistry.#creatures.get(summoner).add(summoned);
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Stop tracking a summoned creature.
	 * @param {string} summoner - UUID of the actor who performed the summoning.
	 * @param {string} summoned - UUID of the summoned creature to stop tracking.
	 */
	static untrack(summoner, summoned) {
		SummonRegistry.#creatures.get(summoner)?.delete(summoned);
	}
}

var registry = {
	messages: MessageRegistry,
	summons: SummonRegistry
};

/**
 * Register custom keybindings offered by Everyday Heroes.
 */
function registerKeybindings() {
	log("Registering keybindings");

	game.keybindings.register(game.system.id, "skipDialogNormal", {
		name: "BF.Keybinding.SkipDialog.Normal",
		editable: [{ key: "ShiftLeft" }, { key: "ShiftRight" }]
	});

	game.keybindings.register(game.system.id, "skipDialogAdvantage", {
		name: "BF.Keybinding.SkipDialog.Advantage",
		editable: [{ key: "AltLeft" }, { key: "AltRight" }]
	});

	game.keybindings.register(game.system.id, "skipDialogDisadvantage", {
		name: "BF.Keybinding.SkipDialog.Disadvantage",
		editable: [{ key: "CtrlLeft" }, { key: "CtrlRight" }, { key: "OsLeft" }, { key: "OsRight" }]
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Register the system's settings.
 */
function registerSettings() {
	log("Registering system settings");

	// Optional rules
	game.settings.registerMenu(game.system.id, "rulesConfiguration", {
		name: "BF.Settings.Rules.Name",
		label: "BF.Settings.Rules.Label",
		hint: "BF.Settings.Rules.Hint",
		icon: "fas fa-chess-rook",
		type: RulesSettingsConfig,
		restricted: true
	});

	game.settings.register(game.system.id, "rulesConfiguration", {
		scope: "world",
		config: false,
		type: RulesSetting,
		default: {
			firearms: false
		},
		requiresReload: true
	});

	game.settings.register(game.system.id, "attackVisibility", {
		name: "BF.Settings.AttackVisibility.Label",
		hint: "BF.Settings.AttackVisibility.Hint",
		scope: "world",
		config: true,
		default: "hideAC",
		type: String,
		choices: {
			all: "BF.Settings.AttackVisibility.All",
			hideAC: "BF.Settings.AttackVisibility.HideAC",
			none: "BF.Settings.AttackVisibility.None"
		}
	});

	game.settings.register(game.system.id, "challengeVisibility", {
		name: "BF.Settings.ChallengeVisibility.Label",
		hint: "BF.Settings.ChallengeVisibility.Hint",
		scope: "world",
		config: true,
		default: "player",
		type: String,
		choices: {
			all: "BF.Settings.ChallengeVisibility.All",
			player: "BF.Settings.ChallengeVisibility.Player",
			none: "BF.Settings.ChallengeVisibility.None"
		}
	});

	game.settings.register(game.system.id, "collapseChatTrays", {
		name: "BF.Settings.CollapseTrays.Label",
		hint: "BF.Settings.CollapseTrays.Hint",
		scope: "client",
		config: true,
		default: "older",
		type: String,
		choices: {
			never: "BF.Settings.CollapseTrays.Never",
			older: "BF.Settings.CollapseTrays.Older",
			always: "BF.Settings.CollapseTrays.Always"
		}
	});

	game.settings.register(game.system.id, "encumbrance", {
		name: "BF.Settings.Encumbrance.Label",
		hint: "BF.Settings.Encumbrance.Hint",
		scope: "world",
		config: true,
		default: "none",
		type: String,
		choices: {
			none: "BF.Settings.Encumbrance.None",
			normal: "BF.Settings.Encumbrance.Normal",
			variant: "BF.Settings.Encumbrance.Variant"
		}
	});

	game.settings.register(game.system.id, "levelingMode", {
		name: "BF.Settings.LevelingMode.Label",
		hint: "BF.Settings.LevelingMode.Hint",
		scope: "world",
		config: true,
		default: "xp",
		type: String,
		choices: {
			xp: "BF.Settings.LevelingMode.XP",
			milestone: "BF.Settings.LevelingMode.Milestone"
		}
	});

	game.settings.register(game.system.id, "proficiencyMode", {
		name: "BF.Settings.ProficiencyMode.Label",
		hint: "BF.Settings.ProficiencyMode.Hint",
		scope: "world",
		config: false,
		default: "bonus",
		type: String,
		choices: {
			bonus: "BF.Settings.ProficiencyMode.Bonus",
			dice: "BF.Settings.ProficiencyMode.Dice"
		}
	});

	game.settings.register(game.system.id, "initiativeTiebreaker", {
		name: "BF.Settings.InitiativeTiebreaker.Label",
		hint: "BF.Settings.InitiativeTiebreaker.Hint",
		scope: "world",
		config: true,
		default: false,
		type: Boolean
	});

	game.settings.register(game.system.id, "abilitySelectionManual", {
		name: "BF.Settings.AbilitySelectionManual.Label",
		hint: "BF.Settings.AbilitySelectionManual.Hint",
		scope: "world",
		config: true,
		default: false,
		type: Boolean
	});

	game.settings.register(game.system.id, "abilitySelectionReroll", {
		name: "BF.Settings.AbilitySelectionReroll.Label",
		hint: "BF.Settings.AbilitySelectionReroll.Hint",
		scope: "world",
		config: true,
		default: false,
		type: Boolean
	});

	game.settings.register(game.system.id, "allowMulticlassing", {
		name: "BF.Settings.Multiclassing.Label",
		hint: "BF.Settings.Multiclassing.Hint",
		scope: "world",
		config: true,
		default: true,
		type: Boolean
	});

	game.settings.register(game.system.id, "allowSummoning", {
		name: "BF.Settings.Summoning.Label",
		hint: "BF.Settings.Summoning.Hint",
		scope: "world",
		config: true,
		default: true,
		type: Boolean
	});

	game.settings.register(game.system.id, "criticalMaximizeDamage", {
		name: "BF.Settings.CriticalMaximizeDamage.Label",
		hint: "BF.Settings.CriticalMaximizeDamage.Hint",
		scope: "world",
		config: true,
		default: false,
		type: Boolean
	});

	game.settings.register(game.system.id, "criticalMultiplyDice", {
		name: "BF.Settings.CriticalMultiplyDice.Label",
		hint: "BF.Settings.CriticalMultiplyDice.Hint",
		scope: "world",
		config: true,
		default: false,
		type: Boolean
	});

	game.settings.register(game.system.id, "criticalMultiplyNumeric", {
		name: "BF.Settings.CriticalMultiplyNumeric.Label",
		hint: "BF.Settings.CriticalMultiplyNumeric.Hint",
		scope: "world",
		config: true,
		default: false,
		type: Boolean
	});

	game.settings.register(game.system.id, "_firstRun", {
		scope: "world",
		config: false,
		default: true,
		type: Boolean
	});
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Add the Black Flag badge into the sidebar.
 * @param {HTMLElement} html - Rendered sidebar content.
 * @returns {void}
 */
function renderSettingsSidebar(html) {
	if (game.release.generation < 13) return _renderLegacy(html[0]);

	const details = html.querySelector(".info .system");
	const pip = details.querySelector(".notification-pip");
	details.remove();

	const section = document.createElement("section");
	section.classList.add("black-flag", "sidebar-info", "flexcol");
	section.innerHTML = `
		<h4 class="divider">${game.i18n.localize("WORLD.GameSystem")}</h4>
		<figure class="black-flag sidebar-badge">
			<img src="systems/black-flag/artwork/branding/badge.webp" height="64" width="154"
			     data-tooltip="${game.system.title}" alt="${game.system.title}">
			<span class="system-info">${systemVersion()}</span>
		</figure>
	`;
	section.querySelector(".divider").after(_settingsLinks());

	const welcomeLink = document.createElement("button");
	welcomeLink.dataset.action = "welcome";
	welcomeLink.innerHTML = `<i class="fa-solid fa-flag-checkered"></i> ${game.i18n.localize("BF.WELCOME.Button")}`;
	welcomeLink.addEventListener("click", () => new WelcomeDialog().render({ force: true }));
	section.append(welcomeLink);

	if (pip) section.querySelector(".system-info").append(pip);
	html.querySelector(".info").after(section);
}

/**
 * Add the Black Flag badge into the sidebar.
 * @param {HTMLElement} html - Rendered sidebar content.
 */
function _renderLegacy(html) {
	const details = html.querySelector("#game-details");
	const pip = details.querySelector(".system-info .update");
	details.querySelector(".system")?.remove();

	const heading = document.createElement("div");
	heading.classList.add("black-flag", "sidebar-heading");
	heading.innerHTML = `<h2>${game.i18n.localize("WORLD.GameSystem")}</h2>`;
	heading.append(_settingsLinks());
	details.insertAdjacentElement("afterend", heading);

	const badge = document.createElement("figure");
	badge.classList.add("black-flag", "sidebar-badge");
	badge.innerHTML = `
		<img src="systems/black-flag/artwork/branding/badge.webp" height="64" width="154"
		     data-tooltip="${game.system.title}" alt="${game.system.title}">
		<span class="system-info">${systemVersion()}</span>
	`;
	if (pip) badge.querySelector(".system-info").insertAdjacentElement("beforeend", pip);
	heading.insertAdjacentElement("afterend", badge);

	const welcomeLink = document.createElement("button");
	welcomeLink.dataset.action = "welcome";
	welcomeLink.innerHTML = `<i class="fa-solid fa-flag-checkered"></i> ${game.i18n.localize("BF.WELCOME.Button")}`;
	welcomeLink.addEventListener("click", () => new WelcomeDialog().render({ force: true }));
	const div = document.createElement("div");
	div.append(welcomeLink);
	badge.insertAdjacentElement("afterend", div);
}

/**
 * Create the links for the sidebar.
 * @returns {HTMLULElement}
 */
function _settingsLinks() {
	const links = document.createElement("ul");
	links.classList.add("links");
	links.innerHTML = `
		<li>
			<a href="https://koboldpress.github.io/black-flag-docs/" target="_blank">
				${game.i18n.localize("BF.Link.Notes")}
			</a>
		</li>
		<li>
			<a href="https://github.com/koboldpress/black-flag/issues" target="_blank">
				${game.i18n.localize("BF.Link.Issues")}
			</a>
		</li>
		<li>
			<a href="https://discord.com/channels/170995199584108546/1083522450148577290" target="_blank">
				${game.i18n.localize("BF.Link.Discord")}
			</a>
		</li>
	`;
	return links;
}

/* <><><><> <><><><> <><><><> <><><><> <><><><> <><><><> */

/**
 * Make adjustments to configuration data based on selected optional rules.
 */
function _configureOptionalRules() {
	const rules = game.settings.get(game.system.id, "rulesConfiguration");
	const adjustNested = obj => {
		for (const [key, value] of Object.entries(obj)) {
			if ("rules" in value && rules[value.rules] !== true && !rules.required[value.rules]) delete obj[key];
			else if ("children" in value) adjustNested(value.children);
		}
	};
	["ammunition", "itemProperties", "weaponOptions", "weapons"].forEach(c => adjustNested(CONFIG.BlackFlag[c]));
}

var settings = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_configureOptionalRules: _configureOptionalRules,
	registerKeybindings: registerKeybindings,
	registerSettings: registerSettings,
	renderSettingsSidebar: renderSettingsSidebar
});

/**
 * System for presenting custom tooltips.
 */
class TooltipConductor {
	/* <><><><> <><><><> <><><><> <><><><> */
	/*              Properties             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Mutation observer that monitors for changes.
	 * @type {MutationObserver}
	 */
	#observer;

	/**
	 * The current ephemeral tooltip.
	 * @type {HTMLElement}
	 */
	get tooltip() {
		return document.getElementById("tooltip");
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Observation             */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Initialize the observer.
	 */
	observe() {
		this.#observer?.disconnect();
		this.#observer = new MutationObserver(this.#handleMutation.bind(this));
		this.#observer.observe(this.tooltip, { attributeFilter: ["class"], attributeOldValue: true });
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle a mutation event.
	 * @param {MutationRecord[]} mutationList - List of changes.
	 */
	#handleMutation(mutationList) {
		const tooltip = this.tooltip;
		for (const { type, attributeName, oldValue } of mutationList) {
			if (type === "attributes" && attributeName === "class") {
				const difference = new Set(tooltip.classList).difference(new Set(oldValue?.split(" ")));
				if (difference.has("active")) {
					this._onTooltipActivate();
					return;
				}
			}
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*             Activation              */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Determine what to present when tooltip if activated.
	 * @returns {Promise}
	 * @protected
	 */
	async _onTooltipActivate() {
		// Content Links
		if (game.tooltip.element?.classList.contains("content-link")) {
			const doc = await fromUuid(game.tooltip.element.dataset.uuid);
			return this._onHoverContentLink(doc);
		}

		const loading = this.tooltip.querySelector(".loading");

		if (loading?.dataset.uuid) {
			const doc = await fromUuid(loading.dataset.uuid);
			// TODO: Custom actor hovers
			return this._onHoverContentLink(doc);
		}

		// TODO: Passive checks
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Handle hovering over a content link and showing rich tooltips if available.
	 * @param {Document} doc - The linked document being hovered.
	 * @protected
	 */
	async _onHoverContentLink(doc) {
		const { content, classes } = (await (doc.richTooltip?.() ?? doc.system?.richTooltip?.())) ?? {};
		if (!content) return;
		this.tooltip.innerHTML = content;
		if (classes?.length) this.tooltip.classList.add(...classes);
		const { tooltipDirection } = game.tooltip.element.dataset;
		requestAnimationFrame(() => this._positionTooltip(tooltipDirection));
	}

	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Re-position a tooltip after rendering.
	 * @param {string} [direction] - The direction to position the tooltip, if there is enough space.
	 * @protected
	 */
	_positionTooltip(direction) {
		const dirs = TooltipManager.TOOLTIP_DIRECTIONS;
		if (!direction) {
			direction = dirs.LEFT;
			game.tooltip._setAnchor(direction);
		}

		const position = this.tooltip.getBoundingClientRect();
		switch (direction) {
			case dirs.UP:
				if (position.y - TooltipManager.TOOLTIP_MARGIN_PX <= 0) direction = dirs.DOWN;
				break;
			case dirs.DOWN:
				if (position.y + this.tooltip.offsetHeight > window.innerHeight) direction = dirs.UP;
				break;
			case dirs.LEFT:
				if (position.x - TooltipManager.TOOLTIP_MARGIN_PX <= 0) direction = dirs.RIGHT;
				break;
			case dirs.RIGHT:
				if (position.x + this.tooltip.offsetWidth > window.innerWith) direction = dirs.LEFT;
				break;
		}

		game.tooltip._setAnchor(direction);

		// Detect whether the item description is overflowing
		if (tooltip.classList.contains("item-tooltip")) {
			const description = tooltip.querySelector(".description");
			description?.classList.toggle("overflowing", description.clientHeight < description.scrollHeight);
		}
	}

	/* <><><><> <><><><> <><><><> <><><><> */
	/*               Helpers               */
	/* <><><><> <><><><> <><><><> <><><><> */

	/**
	 * Prevent middle mouse button from triggering scrolling when attempting to lock within another locked tooltip.
	 */
	static activateListeners() {
		document.addEventListener(
			"pointerdown",
			event => {
				if (event.button === 1 && event.target.closest(".locked-tooltip")) event.preventDefault();
			},
			{ capture: true }
		);
	}
}

/**
 * The Black Flag Roleplaying game system for Foundry Virtual Tabletop.
 * Software License: MIT
 * Repository: https://github.com/koboldpress/black-flag
 * Issue Tracker: https://github.com/koboldpress/black-flag/issues
 */


globalThis.BlackFlag = {
	applications,
	config: config$1,
	data,
	dice,
	documents,
	enrichers,
	modules: {},
	registry,
	settings,
	utils
};

Hooks.once("init", function () {
	log(`Initializing the Black Flag Roleplaying system - Version ${game.system.version}`);

	CONFIG.compatibility.excludePatterns.push(
		/V1 Application framework/,
		/Set#isSubset/,
		/ChatMessage#getHTML/,
		/renderChatMessage/
	);

	game.blackFlag = globalThis.BlackFlag;
	CONFIG.BlackFlag = config$1;
	CONFIG.ActiveEffect.legacyTransferral = false;
	CONFIG.Item.collection = BlackFlagItems;
	CONFIG.Item.compendiumIndexFields.push("system.container");
	CONFIG.Note.objectClass = BlackFlagNote;
	CONFIG.ui.chat = BlackFlagChatLog;
	CONFIG.ui.combat = BlackFlagCombatTracker;
	CONFIG.ui.items = BlackFlagItemDirectory;
	CONFIG.time.roundTime = 6;
	registerCustomElements();
	config$1._configureFonts();
	config$1._configureRedirects();
	config$1._configureStatusEffects();
	config$1.registration.setupHooks();
	applyEffectApplicationPatches();
	registerDataModels(ActiveEffect, { enchantment: EchantmentData });
	registerDataModels(Actor);
	registerDataModels(Item);
	CONFIG.ChatMessage.dataModels = config;
	registerDataModels(JournalEntryPage);
	registerDice();
	BlackFlagActiveEffect.registerHUDListeners();
	BlackFlagActor.setupHooks();
	registerDocumentClasses();
	registerCustomEnrichers();
	registerKeybindings();
	registerSettings();
	registerHandlebarsHelpers();
	registerHandlebarsPartials();

	registerModuleData();

	game.blackFlag.tooltipConductor = new TooltipConductor();
});

Hooks.once("setup", function () {
	// Register Sheets
	registerSheets(Actor);
	registerSheets(Item);
	registerSheets(JournalEntryPage);
	(foundry.applications?.apps?.DocumentSheetConfig ?? DocumentSheetConfig).registerSheet(
		JournalEntry,
		"black-flag",
		BlackFlagJournalSheet,
		{
			makeDefault: true,
			label: "BF.Sheet.Default.Journal"
		}
	);

	config$1._configureConsumableAttributes();
	config$1._configureTrackableAttributes();
	_configureOptionalRules();
	setupModulePacks();

	// Handle rich tooltips
	TooltipConductor.activateListeners();
	game.blackFlag.tooltipConductor.observe();
});

Hooks.once("i18nInit", function () {
	Object.values(CONFIG.Activity.types).forEach(c => c.documentClass.localize());
	Object.values(CONFIG.Advancement.types).forEach(c => c.documentClass.localize());
});

Hooks.once("ready", function () {
	NotificationTooltip.activateListeners();
	config$1.registration.registerItemTypes();

	if (game.user.isGM && game.settings.get(game.system.id, "_firstRun")) {
		const welcome = new WelcomeDialog();
		welcome.render({ force: true });
	}
});

Hooks.on("hotReload", file => {
	// TODO: Temporary patch until https://github.com/foundryvtt/foundryvtt/issues/11939 is fixed
	if (file.extension !== "css") return;
	for (const style of document.querySelectorAll("head style")) {
		if (style.textContent.includes(file.path)) {
			setTimeout(() => (style.textContent = `@import "${file.path}?${Date.now()}" layer(system);`), 100);
		}
	}
});

Hooks.on("renderSettings", (app, jQuery, options) => renderSettingsSidebar(jQuery));
Hooks.on("renderJournalPageSheet", BlackFlagJournalSheet.onRenderJournalPageSheet);

export { applications, config$1 as config, data, dice, documents, enrichers, registry, settings, utils };
//# sourceMappingURL=black-flag.mjs.map
